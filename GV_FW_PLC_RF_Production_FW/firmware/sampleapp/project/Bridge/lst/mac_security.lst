C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_SECURITY
OBJECT MODULE PLACED IN .\obj\mac_security.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_security.c LARGE OBJECTADVANCED OPTIMIZE
                    -(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\
                    -..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src
                    -\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\
                    -firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zig
                    -bee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\
                    -inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp
                    -\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_suppor
                    -t;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drive
                    -rs\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;
                    -..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\.
                    -.\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drive
                    -rs\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilit
                    -ies;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers
                    -\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\
                    -..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBR
                    -II_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SY
                    -NC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_D
                    -ETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERR
                    -UPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,R
                    -EGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_security.lst) T
                    -ABS(2) OBJECT(.\obj\mac_security.obj)

line level    source

   1          /**
   2           * @file mac_security.c
   3           *
   4           * Handles MAC security
   5           *
   6           * $Id: mac_security.c,v 1.3 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          #ifdef HYBRII_802154
  12          
  13          /* === Includes ============================================================ */
  14          
  15          #include <string.h>
  16          #include "papdef.h"
  17          #include "return_val.h"
  18          #include "bmm.h"
  19          #include "qmm.h"
  20          #include "mac_const.h"
  21          #include "mac_msgs.h"
  22          #include "mac_data_structures.h"
  23          #include "mac_hal.h"
  24          #include "mac_internal.h"
  25          #include "mac_security.h"
  26          #include "utils_fw.h"
  27          
  28          /* === Macros =============================================================== */
  29          
  30          /* Security Control Field: Security Level mask */
  31          #define SEC_CTRL_SEC_LVL_MASK           (0x07)
  32          
  33          /* Security Control Field: Key Identifier mask */
  34          #define SEC_CTRL_KEY_ID_MASK            (0x03)
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 2   

  35          
  36          /* Security Control Field: Key Identifier Field position */
  37          #define SEC_CTRL_KEY_ID_FIELD_POS       (3)
  38          
  39          uint8_t aes_test_key[] = {0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
  40          0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF};
  41          uint8_t aes_test_ext_addr[8];
  42          
  43          /* === Globals ============================================================= */
  44          #ifdef ZBMAC_DIAG
              uint64_t dst_ext_addr;  // mac_security.c uses this for AES testing
              #endif
  47          
  48          /* === Prototypes ========================================================== */
  49          
  50          /* === Implementation ====================================================== */
  51          
  52          
  53          
  54          /* --- Helper Functions ---------------------------------------------------- */
  55          
  56          /*
  57           * Gets the length of the Key Identifier field
  58           *
  59           * This function returns the length of the Key Identifier field
  60           * within the Auxiliary Security Header of a secured frame based
  61           * on the Key Identifier Mode.
  62           *
  63           * key_id_mode Key Identifier Mode
  64           *
  65           * Length of Key Identifier field in octets.
  66           */
  67          static uint8_t get_key_id_field_len (uint8_t key_id_mode)
  68          {
  69   1          uint8_t len_field = 0;
  70   1      
  71   1          switch (key_id_mode) {
  72   2          case 1:
  73   2              len_field = 1;
  74   2              break;
  75   2          case 2:
  76   2              len_field = 5;
  77   2              break;
  78   2          case 3:
  79   2              len_field = 9;
  80   2              break;
  81   2          case 0:
  82   2          default:
  83   2              break;
  84   2          }
  85   1      
  86   1          return (len_field);
  87   1      }
  88          
  89          /**
  90           * Calculates the length of the MIC
  91           *
  92           * This function returns the length of the MIC depending on the given 
  93           * security level
  94           *
  95           * security_level Security Level of current frame
  96           *
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 3   

  97           * Length of MIC in octets.
  98           */
  99          uint8_t get_mic_length (uint8_t sec_level)
 100          {
 101   1          uint8_t mic_len = 0;
 102   1      
 103   1          if (sec_level & 3) {
 104   2              mic_len = 1 << ((sec_level & 3) + 1);
 105   2          } else {
 106   2              mic_len = 0;
 107   2          }
 108   1      
 109   1          return (mic_len);
 110   1      }
 111          
 112          uint8_t sec_additional_len (security_info_t *sec_info_p)
 113          {
 114   1          uint8_t len;
 115   1      
 116   1          /* Auxiliary security header length */
 117   1          len  = 1 +    /* security ctrl field */
 118   1                 4 +    /* frame counter length */
 119   1                 get_key_id_field_len(sec_info_p->KeyIdMode);
 120   1      
 121   1          return (len);
 122   1      }
 123          
 124          retval_t mac_security_search_key (uint8_t *key_lookup_data, 
 125                                            uint8_t key_lookup_size,
 126                                            uint8_t **key, uint8_t **addr)
 127          {
 128   1          uint8_t i, k;
 129   1      
 130   1      #if 1
 131   1          /*Compiler warning suppression*/
 132   1          key_lookup_data = key_lookup_data;
 133   1          key_lookup_size = key_lookup_size;
 134   1          i = i;
 135   1          k = k;
 136   1        
 137   1          // FIXME - Use test key for now
 138   1          *key = aes_test_key;
 139   1          if (addr) {
 140   2              *addr = aes_test_ext_addr;
 141   2          }
 142   1          return (MAC_SUCCESS);
 143   1          // FIXME - End of test code
 144   1          /*Compiler warning suppression*/
 145   1      #else    
              
                  // Get key from KeyDescriptor as 7.5.8.2.5
                  for (i = 0; i < mac_sec_pib.KeyTableEntries; i++) {
                      for (k = 0; k < mac_sec_pib.KeyTable[i].KeyIdLookupListEntries; k++) {
                          if (mac_sec_pib.KeyTable[i].KeyIdLookupList[k].LookupDataSize ==
                              key_lookup_size) {
                              uint16_t compare;
                              uint8_t len;
              
                              if (0 == key_lookup_size) {
                                  len = 5;
                              } else if (1 == key_lookup_size) {
                                  len = 9;
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 4   

                              } else {
                                  return (MAC_UNSUPPORTED_SECURITY);
                              } 
                              compare =
                                 memcmp(mac_sec_pib.KeyTable[i].KeyIdLookupList[k].LookupData,
                                        key_lookup_data, len);
                              if (compare == 0) {
                                  *key = mac_sec_pib.KeyTable[i].Key;
                                  if (addr) {
                                      *addr = (uint8_t *)
                                              &mac_sec_pib.DeviceTable[i].\
                                              DeviceDescriptor[i].ExtAddress;
                                  }
                                  return (MAC_SUCCESS);
                              }
                          }
                      }
                  }
              
                  return (MAC_UNAVAILABLE_KEY);
              #endif  
 180   1      }
 181          
 182          /* --- Security Features ------------------------------------------ */
 183          
 184          /*
 185           * Generates Auxiliary Security Header fields
 186           *
 187           * This function generates the required fields of the
 188           * Auxiliary Security Header of a secured frame based
 189           * on the actual security parameter.
 190           *
 191           * Status of extraction of Auxiliary Security Header fields
 192           */
 193          retval_t mac_build_aux_sec_header (uint8_t **frame_ptr,
 194                                             security_info_t *sec_info_p,
 195                                             uint8_t *frame_len)
 196          {
 197   1          uint8_t sec_info_len = sec_additional_len(sec_info_p);
 198   1          uint8_t *sec_msdu_ptr;
 199   1      
 200   1          *frame_ptr = *frame_ptr - sec_info_len;
 201   1          /* Add security field length to original frame length */
 202   1          *frame_len += sec_info_len;
 203   1        sec_msdu_ptr = *frame_ptr;   /* Create Auxiliary security header. */
 204   1      
 205   1          /* Fill in Security Control Field. */
 206   1          *sec_msdu_ptr = (sec_info_p->SecurityLevel & SEC_CTRL_SEC_LVL_MASK) |
 207   1                          ((sec_info_p->KeyIdMode & SEC_CTRL_KEY_ID_MASK) <<
 208   1                            SEC_CTRL_KEY_ID_FIELD_POS);
 209   1          sec_msdu_ptr++;
 210   1      
 211   1          /* Fill in Frame Counter. */
 212   1          if (mac_sec_pib.FrameCounter == 0xFFFFFFFF) {
 213   2              return (MAC_COUNTER_ERROR);
 214   2          } else {
 215   2              mac_utils_32_bit_to_byte_array(mac_sec_pib.FrameCounter, sec_msdu_ptr);
 216   2              sec_msdu_ptr += 4;
 217   2          }
 218   1      
 219   1          /*
 220   1           * Format the Key Identifier according to 802.15.4-2006
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 5   

 221   1           * section 7.5.8.2.1 h) 4) and 7.6.2.4
 222   1           * Key Identifier contains Key Source (when KeyIdMode is > 1) and
 223   1           * Key Index subfields
 224   1           * Key Identifier is only present when KeyIdMode is not zero.
 225   1           */
 226   1          if (sec_info_p->KeyIdMode == 1) {
 227   2              *sec_msdu_ptr = sec_info_p->KeyIndex;
 228   2          } else if (sec_info_p->KeyIdMode > 1) {
 229   2              uint8_t i;
 230   2              uint8_t key_src_size;
 231   2      
 232   2              if (sec_info_p->KeyIdMode == 2) {
 233   3                  key_src_size = 4;
 234   3              } else if (sec_info_p->KeyIdMode == 3) {
 235   3                  key_src_size = 8;
 236   3              } else {
 237   3                  return (MAC_UNSUPPORTED_SECURITY);
 238   3              }
 239   2              for (i = 0; i < key_src_size; i++) {
 240   3                  *sec_msdu_ptr++ = sec_info_p->KeySource[i];
 241   3              }
 242   2              *sec_msdu_ptr = sec_info_p->KeyIndex;
 243   2          }
 244   1      
 245   1          return (MAC_SUCCESS);
 246   1      }
 247          
 248          /*
 249           * Outgoing frame security material retrieval procedure as described in
 250           * 7.5.8.2.2
 251           */
 252          static retval_t outgoing_key_retrieval (security_info_t *sec_info_p,
 253                                                  wpan_addr_spec_t *dst_addr_spec_p,
 254                                                  uint8_t **key)
 255          {
 256   1          uint8_t key_lookup_size;
 257   1          uint8_t i;
 258   1          uint8_t lookup_data[9];
 259   1      
 260   1          switch (sec_info_p->KeyIdMode) {
 261   2          case 0x00:    // implicit key identification
 262   2              if (FCF_SHORT_ADDR == dst_addr_spec_p->AddrMode) {
 263   3                  /* 
 264   3                   * lookup_data:
 265   3                   * 2-octet Dest PANId right-concatenated
 266   3                   * 2-octet dest short addr right-concatenated
 267   3                   * 1-octet of 0x00
 268   3                   */
 269   3                  lookup_data[0] = (uint8_t)(dst_addr_spec_p->PANId >> 8);
 270   3                  lookup_data[1] = (uint8_t)dst_addr_spec_p->PANId;
 271   3                  lookup_data[2] = (uint8_t)
 272   3                                   (dst_addr_spec_p->Addr.short_address >> 8);
 273   3                  lookup_data[3] = (uint8_t)dst_addr_spec_p->Addr.short_address;
 274   3                  lookup_data[4] = 0x00;
 275   3                  key_lookup_size = 0; /* 0 means 5 bytes (See IEEE spec) */
 276   3              } else if (FCF_LONG_ADDR == dst_addr_spec_p->AddrMode) {
 277   3                  /*
 278   3                   * lookup_data:
 279   3                   * 8-octet dest addr right-concatenated
 280   3                   * 1-octet of 0x00
 281   3                   */
 282   3                   memcpy(&lookup_data[0], &dst_addr_spec_p->Addr, 8);
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 6   

 283   3                   lookup_data[8] = 0x00;
 284   3                   key_lookup_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 285   3              } else if (FCF_NO_ADDR == dst_addr_spec_p->AddrMode) {
 286   3                   if (mac_pib_macCoordShortAddress < MAC_NO_SHORT_ADDR_VALUE) {
 287   4                       /*
 288   4                        * Use Short Address:
 289   4                        * lookup_data:
 290   4                        * 2-octet Src PANId right-concatenated
 291   4                        * 2-octet PAN Coord Short Address right-concatenated
 292   4                        * 1-octet of 0x00
 293   4                        */
 294   4                       lookup_data[0] = (uint8_t)(hal_pib_PANId >> 8);
 295   4                       lookup_data[1] = (uint8_t) hal_pib_PANId;
 296   4                       lookup_data[2] = (uint8_t) (mac_pib_macCoordShortAddress >> 8);
 297   4                       lookup_data[3] = (uint8_t) (mac_pib_macCoordShortAddress);
 298   4                       lookup_data[4] = 0;
 299   4                       key_lookup_size = 0; /* 0 means 5 bytes (See IEEE spec) */
 300   4                   } else {
 301   4                       /*
 302   4                        * Use Ext Address:
 303   4                        * lookup_data:
 304   4                        * 8-octet PAN Coord Ext Address
 305   4                        * 1-octet of 0x00
 306   4                        */
 307   4                       memcpy(&lookup_data[0], &mac_pib_macCoordExtendedAddress, 8);
 308   4                       lookup_data[8] = 0x00;
 309   4                       key_lookup_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 310   4                   }
 311   3              } else {
 312   3                   return (MAC_UNSUPPORTED_SECURITY);
 313   3              }
 314   2              break;
 315   2      
 316   2          case 0x01:    // explicit key identification
 317   2              /*
 318   2               * lookup_data:
 319   2               * 8-octet of macDefaultKeySource right-concatenated with
 320   2               * 1-octet of Key Index
 321   2               */
 322   2              for (i = 0; i < 8; i++) {
 323   3                  lookup_data[i] = mac_sec_pib.DefaultKeySource[i];
 324   3              }
 325   2              lookup_data[8] = sec_info_p->KeyIndex;
 326   2              key_lookup_size = 1; // 1 means 9 bytes (See IEEE spec)
 327   2              break;
 328   2      
 329   2          case 0x02:
 330   2              /*
 331   2               * lookup_data: 4-octet of KeySource right-concatenated with
 332   2               * 1-octet of Key Index
 333   2               */
 334   2              for (i = 0; i < 4; i++) {
 335   3                  lookup_data[i] = sec_info_p->KeySource[i];
 336   3              }
 337   2              lookup_data[5] = sec_info_p->KeyIndex;
 338   2              key_lookup_size = 0; // 0 means 5 bytes (See IEEE spec)
 339   2              break;
 340   2      
 341   2          case 0x03:
 342   2              /*
 343   2               * lookup_data: 8-octet of KeySource right-concatenated with
 344   2               * 1-octet of Key Index
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 7   

 345   2               */
 346   2              for (i = 0; i < 8; i++) {
 347   3                  lookup_data[i] = sec_info_p->KeySource[i];
 348   3              }
 349   2              lookup_data[9] = sec_info_p->KeyIndex;
 350   2              key_lookup_size = 1; // 1 means 9 bytes (See IEEE spec)
 351   2              break;
 352   2      
 353   2          default:
 354   2              return (MAC_UNSUPPORTED_SECURITY);
 355   2              break;
 356   2          }
 357   1      
 358   1          return (mac_security_search_key(lookup_data, key_lookup_size, key, NULL));
 359   1      }
 360          
 361          /*
 362           * This function secures the given MAC frame.
 363           *
 364           * tx_frame Frame information structure of current frame
 365           * security_level Security Level of current frame
 366           * key_id_mode Key Identifier Mode
 367           *
 368           * return retval_t MAC_SUCCESS or MAC_UNSUPPORTED_SECURITY
 369           */
 370          retval_t mac_secure (security_info_t *sec_info_p,
 371                               wpan_addr_spec_t *dst_addr_spec_p)
 372          {
 373   1          uint8_t *key;
 374   1          retval_t status;
 375   1      
 376   1          status = outgoing_key_retrieval(sec_info_p, dst_addr_spec_p, &key);
 377   1      
 378   1          if (status != MAC_SUCCESS) {
 379   2              return (status);
 380   2          }
 381   1      
 382   1          /*
 383   1           * For encryption the extended address is the extended address of the 
 384   1           * source so just provide the dummy extended address
 385   1           */
 386   1          status = mac_hal_aes_key_config(HAL_AES_ENCRYPT, key, NULL); 
 387   1      
 388   1          return (status);
 389   1      }
 390          
 391          
 392          /* --- Incoming Security --------------------------------------------------- */
 393          
 394          /*
 395           *
 396           * This function extracts the actual security parameters
 397           * from the Auxiliary Security Header of a received secured frame.
 398           *
 399           * Return the Status of generation of Auxiliary Security Header fields
 400           */
 401          static retval_t parse_aux_sec_header (parse_t *mac_parse_data,
 402                                                uint8_t *mac_payload)
 403          {
 404   1          memcpy(&mac_parse_data->sec_ctrl, &mac_payload[0], 1);
 405   1          memcpy(&mac_parse_data->frame_cnt, &mac_payload[1], 4);
 406   1          mac_parse_data->key_id_len =
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 8   

 407   1                      get_key_id_field_len(mac_parse_data->sec_ctrl.key_id_mode);
 408   1      
 409   1          if (mac_parse_data->sec_ctrl.key_id_mode != 0) {
 410   2              memcpy(mac_parse_data->key_id, &mac_payload[5], 
 411   2                     mac_parse_data->key_id_len);
 412   2          }
 413   1      
 414   1          /* See 802.15.4-2006 section 7.5.8.2.3 b) */
 415   1          if ((mac_parse_data->fcf & FCF_SECURITY_ENABLED) &&
 416   1              !(mac_parse_data->fcf & FCF_FRAME_VERSION_2006)) {
 417   2              return (MAC_UNSUPPORTED_LEGACY);
 418   2          }
 419   1      
 420   1          return (MAC_SUCCESS);
 421   1      }
 422          
 423          /*
 424           * Incoming frame security material retrieval procedure as described in
 425           * 7.5.8.2.4
 426           */
 427          static retval_t incoming_sec_material_retrieval (parse_t *mac_parse_data,
 428                                                           uint8_t **key, uint8_t **addr)
 429          {
 430   1          uint8_t lookup_data_size;
 431   1          uint8_t lookup_data[9];
 432   1          uint8_t i;
 433   1          retval_t status;
 434   1      
 435   1          switch (mac_parse_data->sec_ctrl.key_id_mode) {
 436   2          case 0x00: // Implicit
 437   2              if (FCF_SHORT_ADDR == mac_parse_data->src_addr_mode) {
 438   3                  /*
 439   3                   * Key look up:
 440   3                   * 2-octet of Src PAN Id or Dest PAN Id right-concatenated
 441   3                   * 2-octet dest addr right-concatenated
 442   3                   * 1-octet of 0x00
 443   3                   */
 444   3                  if (mac_parse_data->fcf & FCF_PAN_ID_COMPRESSION) {
 445   4                      lookup_data[0] = (uint8_t)(mac_parse_data->dest_panid >> 8);
 446   4                      lookup_data[1] = (uint8_t)mac_parse_data->dest_panid;
 447   4                  } else {
 448   4                      lookup_data[0] = (uint8_t)(mac_parse_data->src_panid >> 8);
 449   4                      lookup_data[1] = (uint8_t)mac_parse_data->src_panid;
 450   4                  }
 451   3                  lookup_data[2] = (uint8_t)
 452   3                                   (mac_parse_data->src_addr.short_address >> 8);
 453   3                  lookup_data[3] = (uint8_t)mac_parse_data->src_addr.short_address;
 454   3                  lookup_data[4] = 0x00;
 455   3                  lookup_data_size = 0; /* 0 means 5 bytes (See IEEE spec) */
 456   3              } else if (FCF_LONG_ADDR == mac_parse_data->src_addr_mode) {
 457   3                  /*
 458   3                   * Key look up:
 459   3                   * 8-octet of Src Extended Addr right-concatenated
 460   3                   * 1-octet of 0x00
 461   3                   */
 462   3                   memcpy(&lookup_data[0], &mac_parse_data->src_addr.long_address, 8);
 463   3                   lookup_data[8] = 0x00;
 464   3                   lookup_data_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 465   3              } else if (FCF_NO_ADDR == mac_parse_data->src_addr_mode) {
 466   3                   if (mac_pib_macCoordShortAddress < MAC_NO_SHORT_ADDR_VALUE) {
 467   4                       /*
 468   4                        * Use Short Address:
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 9   

 469   4                        * lookup_data:
 470   4                        * 2-octet Dest PANId right-concatenated
 471   4                        * 2-octet PAN Coord Short Address right-concatenated
 472   4                        * 1-octet of 0x00
 473   4                        */
 474   4                       lookup_data[0] = (uint8_t)(mac_parse_data->dest_panid >> 8);
 475   4                       lookup_data[1] = (uint8_t) mac_parse_data->dest_panid;
 476   4                       lookup_data[2] = (uint8_t)(mac_pib_macCoordShortAddress >> 8);
 477   4                       lookup_data[3] = (uint8_t)(mac_pib_macCoordShortAddress);
 478   4                       lookup_data[4] = 0;
 479   4                       lookup_data_size = 0; /* 0 means 5 bytes (See IEEE spec) */
 480   4                   } else {
 481   4                       /*
 482   4                        * Use Ext Address:
 483   4                        * lookup_data:
 484   4                        * 8-octet PAN Coord Ext Address
 485   4                        * 1-octet of 0x00
 486   4                        */
 487   4                       memcpy(&lookup_data[0], &mac_pib_macCoordExtendedAddress, 8);
 488   4                       lookup_data[8] = 0x00;
 489   4                       lookup_data_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 490   4                   }
 491   3              } else {
 492   3                  return (MAC_UNSUPPORTED_SECURITY);
 493   3              }
 494   2              break;
 495   2      
 496   2          case 0x01: // Explicit
 497   2              /*
 498   2               * Key look up:
 499   2               * 8-octet of Src Extended Addr right-concatenated
 500   2               * 1-octet of 0x00
 501   2               */
 502   2              for (i = 0; i < 8; i++) {
 503   3                  lookup_data[i] = mac_sec_pib.DefaultKeySource[i];
 504   3              }
 505   2              lookup_data[8] = mac_parse_data->key_id[0];
 506   2              lookup_data_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 507   2              break;
 508   2          case 0x02: // Explicit
 509   2              /*
 510   2               * Key look up:
 511   2               * 4-octet of Key Source right-concatenated
 512   2               * 1-octet of Key Index 
 513   2               */
 514   2              memcpy(lookup_data, mac_parse_data->key_id, mac_parse_data->key_id_len);
 515   2              lookup_data_size = 0; /* 0 means 5 bytes (See IEEE spec) */
 516   2              break;
 517   2      
 518   2          case 0x03: // Explicit
 519   2              /*
 520   2               * Key look up:
 521   2               * 8-octet of Key Source right-concatenated
 522   2               * 1-octet of Key Index 
 523   2               */
 524   2              memcpy(lookup_data, mac_parse_data->key_id, mac_parse_data->key_id_len);
 525   2              lookup_data_size = 1; /* 1 means 9 bytes (See IEEE spec) */
 526   2              break;
 527   2          }
 528   1      
 529   1          // FIXME - For Test Only - Set the aes_test_ext_addr
 530   1          if (FCF_SHORT_ADDR == mac_parse_data->src_addr_mode) {
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 10  

 531   2              mac_parse_data->src_addr.long_address.lo_u32 = 
 532   2                                  mac_parse_data->src_addr.short_address;
 533   2              mac_parse_data->src_addr.long_address.hi_u32 = 0xACDE4800;
 534   2          }
 535   1          if (FCF_NO_ADDR != mac_parse_data->src_addr_mode) {
 536   2              mac_utils_64_bit_to_byte_array(mac_parse_data->src_addr.long_address,
 537   2                                             aes_test_ext_addr);
 538   2          } else {
 539   2      #ifdef ZBMAC_DIAG    
                      mac_utils_64_bit_to_byte_array(dst_ext_addr, aes_test_ext_addr);
              #endif
 542   2          }
 543   1          // FIXME - End of test code
 544   1      
 545   1          status = mac_security_search_key(lookup_data, lookup_data_size, key, addr);
 546   1      
 547   1          return (status);
 548   1      }
 549          
 550          /**
 551           * @brief Unsecures MAC frame
 552           *
 553           * This function unsecures the given MAC frame.
 554           *
 555           * @param mac_parse_data Frame information structure of current frame
 556           * @param security_level Security Level of current frame
 557           *
 558           * @return retval_t MAC_SUCCESS, MAC_UNSUPPORTED_SECURITY or MAC_SECURITY_ERROR
 559           */
 560          static retval_t unsecure_frame (parse_t *mac_parse_data_p, uint8_t *mpdu_p,
 561                                          uint8_t *mac_payload_p,
 562                                          uint8_t *payload_index_p)
 563          {
 564   1          uint8_t *src_ieee_addr;
 565   1          uint8_t *key;
 566   1          retval_t status;
 567   1      
 568   1          status = incoming_sec_material_retrieval(mac_parse_data_p, &key,
 569   1                                                   &src_ieee_addr);
 570   1      
 571   1          if (MAC_SUCCESS == status) {
 572   2              status = mac_hal_aes_key_config(HAL_AES_DECRYPT, key, src_ieee_addr);
 573   2              if (MAC_SUCCESS == status) {
 574   3                  /*
 575   3                   * Write the encrypted frame to TX (AES) FIFO
 576   3                   * Don't write the len in mpdu_p[0] and FCS bytes
 577   3                   */                   
 578   3                  status = mac_hal_write_frame_to_fifo(&mpdu_p[1],
 579   3                                         mac_parse_data_p->mpdu_length - FCS_LEN,
 580   3                                         AES_DECRYPT, FALSE);
 581   3                  if (MAC_SUCCESS == status) {
 582   4                      /*
 583   4                       * Read the decrypted frame from RX (AES) FIFO
 584   4                       * mpdu_p[0] is the length of the decrypted packet
 585   4                       */
 586   4                      status = mac_hal_rx_decrypted_data_to_buffer(mpdu_p);
 587   4                      if (MAC_SUCCESS == status) {
 588   5                          uint8_t sec_hdr_len;
 589   5                          uint8_t mhr_len;
 590   5                          uint8_t mic_len;
 591   5      
 592   5                          /*
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 11  

 593   5                           * sec ctrl (1-octet) + frame counter (4-octet) = 5
 594   5                           */
 595   5                          sec_hdr_len = 5 + mac_parse_data_p->key_id_len;
 596   5                          /*
 597   5                           * mpdu_p + 1 to skip the length byte
 598   5                           */ 
 599   5                          mhr_len = mac_payload_p - (mpdu_p + 1) + sec_hdr_len;
 600   5                          mic_len =
 601   5                              get_mic_length(mac_parse_data_p->sec_ctrl.sec_level);
 602   5                          *payload_index_p = sec_hdr_len;
 603   5      
 604   5                          /*
 605   5                           * Get the mac command type for MAC Command packet
 606   5                           * which is the 1st byte of the payload
 607   5                           */
 608   5                          if (FCF_FRAMETYPE_MAC_CMD == 
 609   5                              mac_parse_data_p->frame_type) {
 610   6                              mac_parse_data_p->mac_command = 
 611   6                                               mac_payload_p[*payload_index_p];
 612   6                          }
 613   5                          /*
 614   5                           * Compute the mac payload length of the decrypted packet.
 615   5                           * The mpdu_length is the length of the original
 616   5                           * encrypted packet which included FCS_LEN
 617   5                           */
 618   5                          mac_parse_data_p->mac_payload_length =
 619   5                              mac_parse_data_p->mpdu_length - FCS_LEN - mhr_len -
 620   5                              mic_len;
 621   5                          /*
 622   5                           * mpdu_p[0] contains the length of the new decrypted
 623   5                           * packet that does not including FCS_LEN.
 624   5                           * Note: The FCS bytes of the decrypted packet is not
 625   5                           * valid but we don't care
 626   5                           */
 627   5                          mac_parse_data_p->mpdu_length = mpdu_p[0] + FCS_LEN; 
 628   5                          mac_stats_g.decrypt_ok++;                 
 629   5                      } else {
 630   5                          mac_stats_g.decrypt_error++;
 631   5                      }
 632   4                  }
 633   3              }
 634   2          }
 635   1      
 636   1          return (status);
 637   1      }
 638          
 639          /**
 640           *
 641           * This function handles the complete unsecuring of a MAC frame.
 642           * This includes the extraction of the Auxiliary Security Header and
 643           * the actual frame decryption.
 644           *
 645           */
 646          retval_t mac_unsecure (parse_t *mac_parse_data_p, uint8_t *mpdu_p,
 647                                 uint8_t *mac_payload_p, uint8_t *payload_index_p)
 648          {
 649   1          retval_t status;
 650   1      
 651   1          status = parse_aux_sec_header(mac_parse_data_p, mac_payload_p);
 652   1          if (status != MAC_SUCCESS) {
 653   2              return (status);
 654   2          }
C51 COMPILER V9.53.0.0   MAC_SECURITY                                                      11/04/2015 20:09:50 PAGE 12  

 655   1      
 656   1          // 7.5.8.2.3 d)
 657   1          if (mac_pib_macSecurityEnabled == FALSE) {
 658   2              if (0 == mac_parse_data_p->sec_ctrl.sec_level) {
 659   3                  return (MAC_SUCCESS);
 660   3              } else {
 661   3                  return (MAC_UNSUPPORTED_SECURITY);
 662   3              }
 663   2          }
 664   1      
 665   1          // 7.5.8.2.3 c)
 666   1          if (0 == mac_parse_data_p->sec_ctrl.sec_level) {
 667   2              return (MAC_UNSUPPORTED_SECURITY);
 668   2          }
 669   1      
 670   1          status = unsecure_frame(mac_parse_data_p, mpdu_p, mac_payload_p,
 671   1                                  payload_index_p);
 672   1      
 673   1          return (status);
 674   1      }
 675          
 676          #endif //HYBRII_802154
 677          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2426    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24     112
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
