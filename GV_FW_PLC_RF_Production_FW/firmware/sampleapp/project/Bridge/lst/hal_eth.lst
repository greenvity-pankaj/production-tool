C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE HAL_ETH
OBJECT MODULE PLACED IN .\obj\hal_eth.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hal\hal_eth.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE)
                    - BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\fi
                    -rmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\
                    -..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware
                    -\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\.
                    -.\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\.
                    -.\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\
                    -..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\
                    -..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\
                    -inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..
                    -\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compon
                    -ents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash
                    -\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\.
                    -.\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc
                    -;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\co
                    -mponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,
                    -HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HY
                    -BRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HY
                    -BRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO
                    -,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_
                    -APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\hal_eth.lst) TABS(2) OBJECT
                    -(.\obj\hal_eth.obj)

line level    source

   1          /*
   2          * $Id: hal_eth.c,v 1.10 2014/11/11 14:52:57 ranjan Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_eth.c,v $
   5          *
   6          * Description : ETH HAL module.
   7          *
   8          * Copyright (c) 2010-2011 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines Ethernet PHY/MAC register read/write , fields set/reset, Init, Tx/Rx functions.
  13          *
  14          *
  15          */
  16          
  17          #ifdef RTX51_TINY_OS
  18          #include <rtx51tny.h>
  19          #endif
  20          #include <stdio.h>
  21          #include <stdlib.h>
  22          #include <string.h>
  23          #include "papdef.h"
  24          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  27          #include "list.h"
  28          #include "event.h"
  29          #include "nma.h"
  30          #include "nma_fw.h"
  31          #ifndef HPGP_HAL_TEST
  32          #include "hal.h"
  33          #include "linkl.h"
  34          #include "hpgpapi.h"
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 2   

  35          #include "nma.h"
  36          #endif
  37          #include "hal_reg.h"
  38          #ifdef UM
  39          #include "timer.h"
  40          #include "stm.h"
  41          #endif
  42          
  43          #include "hal_common.h"
  44          #include "hal_hpgp.h"
  45          #include "hal_cfg.h"
  46          #include "hal_eth.h"
  47          #include "hal_tst.h"
  48          #include "fm.h"
  49          #include "gv701x_gpiodriver.h"
  50          
  51          #if 0
              #define printf(x)
              #define FM_Printf(x, z)
              
              #endif
  56          extern sHpgpHalCB gHpgpHalCB;
  57          #ifdef ETH_BRDG_DEBUG
              extern u8 myDebugFlag;
              extern u8 myDebugFlag1;
              extern u32 numPlcPendingRet;
              extern u32 numForcePlcTxDone; 
              extern u32 numEthTxDoneInts;
              extern u32 numEthTxCpReleased;
              extern u32 numPlcTxCp;
              extern u32 plcTxWriteFail;
              extern u32 plcTxFrameCnt;
              
              extern u32 ethTxFrameCnt;
              extern u32 numEthTxCp;
              
              extern u32 ethRxFrameCnt;
              #endif
  73          
  74          #ifdef HPGP_HAL_TEST   
              extern sHalCB gHalCB;
              #endif
  77          
  78          sEthHalCB gEthHalCB;
  79          u8 ethTxDone = 1;
  80          //#define MAX_ETH_BUFF 1600
  81                     
  82          #ifdef DEBUG_DATAPATH
  83          extern u8 pktDbg;
  84          extern u8 sigDbg;
  85          #endif
  86          
  87          
  88          #ifdef HYBRII_ETH
              void EHAL_Clear_ethHWStat()
              {
                  WriteU8Reg(ETHMAC_STATCLR_REG, 1);
                  printf("ETH TX and RX HW Stats are cleared:\n");
              
              }
              
              void EHAL_Print_ethHWStat()
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 3   

              {
                  u8 i;
              
                  printf("ETH RX HW Stats:\n");
                  for (i = 0; i < 0x15; i++)
                  {
                      printf("    RegRd:  [0x%02bX] --> %08lu\n", i, rtocl(EHAL_ReadEthStatReg(i)));     
                  }
                  printf("ETH TX HW Stats:\n");
                  for (i = 0x80; i < 0x96; i++)
                  {
                      printf("    RegRd:  [0x%02bX] --> %08lu\n", i, rtocl(EHAL_ReadEthStatReg(i)));     
                  }
              }
              #endif
 112          
 113          void EHAL_EthSendPause()
 114          {
 115   1          u8 pause_Flag = 1;
 116   1      
 117   1          WriteU8Reg(ETHMAC_PAUSQNT_REG, 0xFF);
 118   1          WriteU8Reg(ETHMAC_PAUSQNT_REG+1, 0x10);
 119   1          WriteU8Reg(ETHMAC_SENDPAUSE_REG, pause_Flag);
 120   1      }
 121          
 122          #ifdef HYBRII_ETH
              void EHAL_DoRelEthTxCP()
              {
                  uEthTxFreeCPCntReg  ethTxFreeCPCnt;
                  uEthTxRelCPQReg     ethTxRelCPQ;
                  u8 i;
              
                // keep releasing free CPs until there's no more in Free CP register
                while (TRUE)
                {
                    ethTxFreeCPCnt.reg = ReadU32Reg(ETHMAC_TXFREECPCNT_REG);
                  if (ethTxFreeCPCnt.s.freeCPCnt == 0)
                    break;
              #ifdef ETH_BRDG_DEBUG
                  numEthTxCpReleased += ethTxFreeCPCnt.s.freeCPCnt;
              #endif
                    for( i=0 ; i<ethTxFreeCPCnt.s.freeCPCnt ; i++)
                    {
                        ethTxRelCPQ.reg = ReadU32Reg(ETHMAC_TXRELEASECPQ_REG);
                        CHAL_DecrementReleaseCPCnt((u8)ethTxRelCPQ.s.cp);
                    }
                }
              }
              #endif
 146          
 147          #ifdef HYBRII_ETH
              
              //=============================================================================
              // Procedure:   EHAL_PHYReg
              //
              // Description: This function Read/Write PHY Registers.
              //
              // Arguments:
              //      u8   sddr
              //      u8   *pData
              //      eRegOp  regOp
              //
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 4   

              // Returns:
              //      0 - Success , 1 - Failure
              //=============================================================================
              eStatus EHAL_EthPhyRegOp(u8 phyAddr, u8 addr, u16 *pData, eRegOp regOp)
              {
                  eStatus status = STATUS_FAILURE;
              #ifdef HYBRII_ETH
                  uEthMacMdioCmdReg       ethMacMdioCmd;
                  uEthMacMdioStatReg      ethMacMdioStat;
              //    unsigned long dwTmp;
                  int i;
              
                  status = STATUS_SUCCESS;
                 // MDIO GO ?
              
                  i=2000;
                  while(i--)
                  {
                     ethMacMdioCmd.s2.MDIOCmd4    = ReadU8Reg(ETHMAC_MDIOCMD4_REG);
                     if(ethMacMdioCmd.s1.Go == 0)
                     break;
                  }
                  if(ethMacMdioCmd.s1.Go != 0)
                  {
                      return STATUS_FAILURE;
                   }
                  /*Read Ethernet PHY Register*/
              
                   ethMacMdioCmd.reg = 0;
                  /* set the Phy reg address in MDIO Cmd register
                   * with MDIOWrite bit set to 0 */
                   ethMacMdioCmd.s1.PHYReg   = addr;
                   ethMacMdioCmd.s1.PHYAddr1 = phyAddr & 0x7;
                   ethMacMdioCmd.s1.PHYAddr2 = (phyAddr >> 3)& 0x3;
              
                   if(regOp ==  RD)
                   {
                        ethMacMdioCmd.s1.MDIOWrite  = 0;
                   }else
                   {
                        ethMacMdioCmd.s1.MDIOWrite    = 1;
                        ethMacMdioCmd.s1.WriteData1  = * ((u8*)pData);
                        ethMacMdioCmd.s1.WriteData2  = * ((u8*)pData + 1);
                   }
                   ethMacMdioCmd.s1.Go       = 1;
              
                   WriteU8Reg(ETHMAC_MDIOCMD1_REG, ethMacMdioCmd.s2.MDIOCmd1);
                   WriteU8Reg(ETHMAC_MDIOCMD2_REG, ethMacMdioCmd.s2.MDIOCmd2);
                   WriteU8Reg(ETHMAC_MDIOCMD3_REG, ethMacMdioCmd.s2.MDIOCmd3);
                   WriteU8Reg(ETHMAC_MDIOCMD4_REG, ethMacMdioCmd.s2.MDIOCmd4);
              
                   i = 2000;
                   while(i--)
                   {
                       /*  check the busy bit to see if
                        *  HW has completed the register operation*/
                        ethMacMdioCmd.s2.MDIOCmd4    = ReadU8Reg(ETHMAC_MDIOCMD4_REG);
                        if(ethMacMdioCmd.s1.Go == 0)
                        {
                            break;
                        }
                   }
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 5   

                   if(i < 1)
                   {
                      //FM_Printf(FM_ERROR, "Failed to complete Ethernet PHY Register Read\n");
                     // printf("PHYAddr = %bu, RegAddr = %bu\n", (ethMacMdioCmd.s1.PHYAddr2 << 3)| ethMacMdioCmd.s1.PHYA
             -ddr1, addr);
                      return STATUS_FAILURE;
                   }
              
              
                    if(regOp ==  RD)
                    {
              
                    /*  Read back the Status and value */
                    ethMacMdioStat.reg = 0;
                    ethMacMdioStat.s2.MDIOStat1    = ReadU8Reg(ETHMAC_MDIOSTAT1_REG);
                    ethMacMdioStat.s2.MDIOStat2    = ReadU8Reg(ETHMAC_MDIOSTAT2_REG);
                    ethMacMdioStat.s2.MDIOStat3    = ReadU8Reg(ETHMAC_MDIOSTAT3_REG);
                    ethMacMdioStat.s2.MDIOStat4    = ReadU8Reg(ETHMAC_MDIOSTAT4_REG);
              
                    if(ethMacMdioStat.s1.RdErr)
                    {
                        //FM_Printf(FM_ERROR, "Error reading Ethernet PHY Register\n");
                        return STATUS_FAILURE ;
                    }
                        * ((u8*)pData)     = ethMacMdioStat.s1.ReadData1 ;
                        * ((u8*)pData + 1) = ethMacMdioStat.s1.ReadData2 ;
                    }
                  // printf("data is: %X",*pData);
              #endif
                   return status;
              }
              
              
              void EHAL_Init()
              {
              
              #ifdef HYBRII_ETH
                  uEthPhyStatReg          ethPhyStat;
              //    uEthMacModeReg          ethMacMode;
                  uEthMacTxCtl1Reg        ethMacTxCtl1;
              //    uEthMacTxCtl2Reg        ethMacTxCtl2;
                  uEthMacRxCtlReg         ethMacRxCtl;
                  uEthRxEndianReg         ethRxEnd;
                  sEthMacPrtEmtThresReg   ethMacPrtEmtThres;
                  sEthMacPrtFulThresReg   ethMacPrtFulThres;
                  sEthMacTxBufSzReg       ethMacTxBufSz;
                  u8                      i;
                  eStatus status;
                  u8 ethMacAddr[MAC_ADDR_LEN] = {0x00,0x11,0x22,0x33,0x44,0x55};
                  u8 seedVal = (u8) gHalCB.timerIntCnt;
              
                  //printf("====> EHAL_InitETH\n");
              
                  // Write to Ethernet Unicast Address and Source Address registers
                  for(i=0;i< MAC_ADDR_LEN;i++)
                  ethMacAddr[i] = gEthHalCB.macAddrDef[i];
              
                  // Write the Threshold registers and Buffer size
                  ethMacPrtEmtThres.PartEmpty  = 0x04;//0x80;
                  WriteU8Reg(ETHMAC_PRTEMTTH_REG, ethMacPrtEmtThres.PartEmpty);
              
                  ethMacPrtFulThres.PartFull   = 0xC0; //0x80;
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 6   

                  WriteU8Reg(ETHMAC_PRTFULTH_REG, ethMacPrtFulThres.PartFull);
              
                  ethMacTxBufSz.TxBufSz        = 5; // 0x80, 0x40;
                  WriteU8Reg(ETHMAC_TXBUFSZ_REG, ethMacTxBufSz.TxBufSz);
                  WriteU8Reg( ETHMAC_SEED_REG, seedVal );
                  WriteU8Reg( ETHMAC_SLOTTM_REG, 128 );   // 10Mbps/100Mbps: slot time = 128, Gigabit: 512
                  WriteU8Reg( ETHMAC_TXCTL2_REG, 0x0a);   // # of  tx retry
              
                  // PC - don't change
                for(i=0 ; i<32 ; i++) 
                  {
                     status = EHAL_EthPhyRegOp(i,ETHPHY_STAT,&ethPhyStat.reg,RD);
                     if(status == STATUS_SUCCESS)
                     {
                        FM_Printf(FM_MINFO, "ETH Phy Addr = %bX, regAddr = %bX, data = %04X\n", i, ETHPHY_STAT,ethPhySta
             -t.reg);
                        gEthHalCB.phyChipAddr = i;
                        break;
                     }
                  }
              
                  if(status == STATUS_FAILURE)
                  {
                      FM_Printf(FM_ERROR, "ETH Phy not present\n");
              
                  }
                  if(ethPhyStat.s.ANComp)
                  {
                      // Enable Ethernet MAC TX and RX  - Any other parameters ?
                      ethMacRxCtl.reg         = 0;
                      ethMacRxCtl.s.RxEn      = 1;
                      ethMacRxCtl.s.SendCRC   = 0;
                      WriteU8Reg( ETHMAC_RXCTL_REG, ethMacRxCtl.reg );
              
                      ethMacTxCtl1.reg        = 0;
                      ethMacTxCtl1.s.TxEn     = 1;
                      ethMacTxCtl1.s.RetryEn  = 1;
                      ethMacTxCtl1.s.PadEn    = 1;
                      ethMacTxCtl1.s.FCSAppnd = 1;
                      WriteU8Reg( ETHMAC_TXCTL1_REG, ethMacTxCtl1.reg );
                  }
                  else
                  {
                  //FM_Printf(FM_MINFO, "InitETH : Auto Neg not complete");
                  }
              
                  ethRxEnd.reg = 0;
                  ethRxEnd.s.rxLittleEnd = 1;
                  WriteU32Reg( ETHMAC_RXENDIAN_REG, ethRxEnd.reg );
                  EHAL_ResetStat();
                  memset(&ConnState, 0, sizeof(sConnState)*MAX_NUM_STATIONS); // for ETH tests
              #endif
              }
              
              u32 EHAL_ReadEthStatReg(u8 reg_addr)
              {
              #ifdef HYBRII_ETH
                  u32 stat;
                  char*   pStat = &stat;
                  // Read ETH MAC Status
                  WriteU8Reg(ETHMAC_STATIDX_REG,reg_addr);
              
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 7   

                  pStat[0]     = ReadU8Reg(ETHMAC_STATDAT1_REG);
                  pStat[1]     = ReadU8Reg(ETHMAC_STATDAT2_REG);
                  pStat[2]     = ReadU8Reg(ETHMAC_STATDAT3_REG);
                  pStat[3]     = ReadU8Reg(ETHMAC_STATDAT4_REG);
              
                  return stat;
              #endif
              }
              
              u8 EHAL_GetEthTxQFreeDescCnt()
              {
              #ifdef HYBRII_ETH
                  uEthTxQDescCntReg ethTxQDescCnt;
                  u8 freeDescCnt;
              
                  ethTxQDescCnt.reg = ReadU32Reg(ETHMAC_TXQDESCCNT_REG);
                  freeDescCnt = ETH_TXQ_DEPTH - ethTxQDescCnt.s.descCnt;
                  //printf("PLCTxQStatusReg = 0x%08lX, PLCTxQ[%bu].freeDescCnt = %bu\n", RTOCL(capTxQStat.reg),plid, fre
             -eDescCnt);
                  return  freeDescCnt;
              #endif
              }
              
              eStatus EHAL_EthTxQWrite(sSwFrmDesc * pEthTxFrmSwDesc)
              {
                u16 mycnt=0;
              #ifdef HYBRII_ETH
                  u8 frmDescCnt;
              //    u8 ethTxFreeDescCnt;
                  eStatus status=STATUS_SUCCESS;
              
                  frmDescCnt = 1 + pEthTxFrmSwDesc->cpCount;
                  ethTxDone = 0;
              //  FM_Printf(FM_USER,"etx\n");
              
                  // Check if the respective CAP queue has enough space to hold the descritpors.
                  if(EHAL_GetEthTxQFreeDescCnt() >= frmDescCnt)
                  {
                      uEthTxPktQDesc1       pktQDesc1;
                      uEthTxPktQCPDesc      pktQDescCP;
                      u8                    i;
              #ifdef ETH_BRDG_DEBUG
                  u16           frame_len, tmp_frame_len=0; //cur_oversize_frames, tmp_oversize_frames;
              #endif
              
                      //1.Create header/first descriptor
                      pktQDesc1.reg        = 0;
              
                      //1.1 Write Frame Length
                      pktQDesc1.s.frmLenLo =  pEthTxFrmSwDesc->frmLen & PKTQDESC1_FRMLENLO_MASK;
                      pktQDesc1.s.frmLenHi = (pEthTxFrmSwDesc->frmLen & PKTQDESC1_FRMLENHI_MASK) >> PKTQDESC1_FRMLENHI_P
             -OS;
              #ifdef ETH_BRDG_DEBUG
                  frame_len = (pktQDesc1.s.frmLenHi << PKTQDESC1_FRMLENHI_POS) + pktQDesc1.s.frmLenLo;
              //    cur_oversize_frames = rtocl(EHAL_ReadEthStatReg(0x88));
                  if (frame_len > 1518)
                    printf("EHAL_EthTxQWrite: ERROR - frame len exceeds maximum len: frame_len=%d\n", frame_len);
                    
                  if (myDebugFlag1)
                  {
                    printf("EHAL_EthTxQWrite: frame_len=%d, pEthTxFrmSwDesc->frmLen\n", frame_len, pEthTxFrmSwDesc->frmLen)
             -;
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 8   

                  }
              #endif
              
                      // 1.6 Set First Descriptor Flag
                      pktQDesc1.s.bFirstDesc   = 1;
              
                      // Set Little Endian flag
                      pktQDesc1.s.litEndian = 1;
                  
              #ifdef DEBUG_DATAPATH
              
                      FM_Printf(FM_HINFO,"\nEthTxQfreeDescCnt = %bu , FreeCPCnt = %bu\n",
                                  EHAL_GetEthTxQFreeDescCnt(),
                                  CHAL_GetFreeCPCnt());
                      FM_Printf(FM_HINFO,"EHAL_EthTxQWrite: HdrDesc    = 0x%08lX, frmLen = %u\n", 
                              RTOCL(pktQDesc1.reg), pEthTxFrmSwDesc->frmLen);
              #endif
              
              // 1.7 Write first descriptor to the queue
                  WriteU32Reg(ETHMAC_QUEUEDATA_REG, pktQDesc1.reg);
              
              #ifdef DEBUG_DATAPATH
                      
                      if (pktDbg)
                      {
                          FM_Printf(FM_ERROR, "\neth tx\n");
                      }
              
              #endif
                      // 6. Create CP Descriptors are write one by one
                      for( i=0 ; i<pEthTxFrmSwDesc->cpCount ; i++)
                      {
                          pktQDescCP.reg          = 0;
                          pktQDescCP.s.cp         = pEthTxFrmSwDesc->cpArr[i].cp;
                          pktQDescCP.s.descLenLo  = pEthTxFrmSwDesc->cpArr[i].len & PKTQDESCCP_DESCLENLO_MASK;
                          pktQDescCP.s.descLenHi  = (pEthTxFrmSwDesc->cpArr[i].len & 
                                      PKTQDESCCP_DESCLENHI_MASK)>> PKTQDESCCP_DESCLENHI_POS;
              #ifdef ETH_BRDG_DEBUG
                    tmp_frame_len += (pktQDescCP.s.descLenHi << PKTQDESCCP_DESCLENHI_POS) + pktQDescCP.s.descLenLo;
              #endif
                          if( i == pEthTxFrmSwDesc->cpCount-1 )
                          {
                              pktQDescCP.s.lastDesc = 1;
                          }
                          pktQDescCP.s.offset     = pEthTxFrmSwDesc->cpArr[i].offsetU32;
              
                          // Write CP descriptor to the queue
                          // SwapWriteU32Reg(PLC_CAP_REG, pPlcTxFrmSwDesc->capValue);
                          WriteU32Reg(ETHMAC_QUEUEDATA_REG, pktQDescCP.reg);
              
              //            FM_Printf(FM_LINFO,"EHAL_EthTxQWrite: CPDesc%Bu    = 0x%08lX, Offset = %bu, descLen = %bu,cp
             - = %bu\n",
              //                                i+1,RTOCL(pktQDescCP.reg), pktQDescCP.s.offset, pEthTxFrmSwDesc->cpArr[i
             -].len, pktQDescCP.s.cp );
              #if defined(ETH_DEBUG_PACKET) || defined(DEBUG_DATAPATH)
                          
              #ifdef DEBUG_DATAPATH
              
                     if (pktDbg)
              #endif        
                      
                          {
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 9   

                              u8 j;
                              u8 byteOffset = (u8)pEthTxFrmSwDesc->cpArr[i].offsetU32 << 2;
              
                              volatile u8 xdata * cellAddr = CHAL_GetAccessToCP(pEthTxFrmSwDesc->cpArr[i].cp);
                              FM_Printf(FM_USER,"PktBuf%bu, addr %lu :\n", i+1, (cellAddr+byteOffset));
                              FM_Printf(FM_USER, "eth offset 0x%02x \n", byteOffset);
                              for( j = byteOffset ;  j < (byteOffset + pEthTxFrmSwDesc->cpArr[i].len ); j++)
                              {
                                  FM_Printf(FM_USER,"0x%02bX ", cellAddr[j]);
                              }
                              FM_Printf(FM_USER,"\n\n");
                          }
              #endif             
                      }    
              #ifdef ETH_BRDG_DEBUG
                  if (frame_len != tmp_frame_len)
                  {
                    printf("EHAL_EthTxQWrite: ERROR - frame lens don't match: frame_len=%d, tmp_frame_len=%d\n", frame_len,
             - tmp_frame_len);
                  }
                  /*
                  tmp_oversize_frames = rtocl(EHAL_ReadEthStatReg(0x88));
                  if (cur_oversize_frames != tmp_oversize_frames)
                  {
                    printf("EHAL_EthTxQWrite: frame_len %d produces an oversize frame: %d\n", tmp_oversize_frames);
                  }
              */
              #endif
                      // update statistics
                      gEthHalCB.TotalTxFrmCnt++;
                      gEthHalCB.TotalTxBytesCnt+=pEthTxFrmSwDesc->frmLen;
              
              #ifdef ETH_BRDG_DEBUG
                  ethTxFrameCnt++;
                  numEthTxCp += pEthTxFrmSwDesc->cpCount;
              #endif
                  }
                  else
                  {
              
                    ethTxDone = 1;
                      status =  STATUS_FAILURE;
                    printf("EHAL_EthTxQWrite(): Failed 1: EHAL_GetEthTxQFreeDescCnt()=%bu, frmDescCnt=bu\n", EHAL_GetEthTxQ
             -FreeDescCnt(), frmDescCnt);
              #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag1)
                    printf("EHAL_EthTxQWrite(): Failed 1: EHAL_GetEthTxQFreeDescCnt()=%bu, frmDescCnt=bu\n", EHAL_GetEthTxQ
             -FreeDescCnt(), frmDescCnt);
              #endif
                  }
                  return status;
              #endif
              }
              
              
              bool EHAL_IsTxReady()
              {
              
                if(ethTxDone != 1)
                {
              
                  return FALSE;
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 10  

                }
              
                return TRUE;
              }
              
              void EHAL_ResetStat()
              {
              #ifdef HYBRII_ETH
                  // Rx Statistics counters
                  gEthHalCB.TotalRxFrmCnt     = 0;
                  gEthHalCB.TotalRxBytesCnt   = 0;
              
                  // Tx Statistics counters
                  gEthHalCB.TotalTxFrmCnt     = 0;
                  gEthHalCB.TotalTxBytesCnt   = 0;
              
                  // Test Statistics
                  gEthHalCB.CurTxTestFrmCnt   = 0;
                  gEthHalCB.CurTxTestBytesCnt = 0;
              #endif
              }
              
              void EHAL_DisplayEthStat()
              {
              #ifdef HYBRII_ETH
                  u16 outStandingDescCnt;
              
                  outStandingDescCnt = ETH_TXQ_DEPTH - EHAL_GetEthTxQFreeDescCnt();
              
                  if(gEthHalCB.TotalRxBytesCnt)
                  {
                      printf("\n============ HOST Rx Statistics ==============\n");
                      printf("TotalRxFrmCnt     = %lu\n",gEthHalCB.TotalRxFrmCnt);
                      printf("TotalRxBytesCnt   = %lu\n\n",gEthHalCB.TotalRxBytesCnt);
                  }
              
                  if(gEthHalCB.TotalTxFrmCnt)
                  {
                      printf("\n============ HOST Tx Statistics ==============\n");
                      printf("TotalTxFrmCnt     = %lu\n",gEthHalCB.TotalTxFrmCnt);
                      printf("TotalTxBytesCnt   = %lu\n\n",gEthHalCB.TotalTxBytesCnt);
                  }
                  printf("TimerIntCnt       = %lu\n",gHalCB.timerIntCnt);
                  printf("FreeCPCnt         = %bu\n\n",CHAL_GetFreeCPCnt());
              #endif
              }
              
              // ConnExistSlave is called from a slave station. It returns:
              //      - TRUE if there is already an Open connection for this station. 
              //        It also returns the index to that station.
              //      - FALSE otherwise. In this case, it returns the index to the first 
              //        available station
              //
              u8  ConnExistSlave(u8 *MACaddr, u8 *StationId)
              {
                  u8  firstFreeConn = 0xff;
                  u8  i;
              
                  for (i = 0; i < MAX_NUM_STATIONS; i++)
                  {
                      if (!memcmp(ConnState[i].myMACaddr, MACaddr, MAC_ADDR_LEN) 
                          && (ConnState[i].state == GCI_STATE_OPEN))
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 11  

                      {
                          *StationId = i;
                          return(TRUE);
                      } else
                      {
                          if (firstFreeConn == 0xff)
                              firstFreeConn = i;
                      }
                  }
                  *StationId = firstFreeConn;
                  return(FALSE);
              }
              
              // ConnExistMaster is called from a master station. It returns:
              //      - TRUE if there is already an Open connection for this station.
              //        It also returns the index to that station
              //      - FALSE otherwise. In this case, it returns the index to the first available station
              //
              u8  ConnExistMaster(u8 *masterMACaddr, u8 *slaveMACaddr,u8 *StationId)
              {
                  u8  firstFreeConn = 0xff;
                  u8  i;
              
                  for (i = 0; i < MAX_NUM_STATIONS; i++)
                  {
                      if (!memcmp(ConnState[i].myMACaddr, masterMACaddr, MAC_ADDR_LEN)
                          && !memcmp(ConnState[i].slaveMACaddr, slaveMACaddr, MAC_ADDR_LEN))
                      {
                          *StationId = i;
                          return(TRUE);
                      } else
                      {
                          if (firstFreeConn == 0xff)
                              firstFreeConn = i;
                      }
                  }
                  *StationId = firstFreeConn;
                  return(FALSE);
              }
              #endif // HYBRII_ETH
 623          
 624          
 625          void EHAL_ReleaseEthTxCPIntHandler()
 626          {
 627   1      #ifdef HYBRII_ETH
                  EHAL_DoRelEthTxCP();
                  ethTxDone = 1;
              #ifdef ETH_BRDG_DEBUG
                numEthTxDoneInts++;
              #endif
              #endif
 634   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     19    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     32    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.53.0.0   HAL_ETH                                                           11/04/2015 20:09:42 PAGE 12  

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
