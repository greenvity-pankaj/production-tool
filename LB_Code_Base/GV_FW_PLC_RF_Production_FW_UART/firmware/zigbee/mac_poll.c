/**
 * @file 
 *
 * Handle MLME-POLL.request
 *
 * $Id: mac_poll.c,v 1.6 2014/11/26 13:19:41 ranjan Exp $
 *
 * Copyright (c) 2012, Greenvity Communication
 *
 */
#ifdef HYBRII_802154

/* === Includes ============================================================ */

#include "papdef.h"
#include "timer.h"
#include "return_val.h"
#include "bmm.h"
#include "qmm.h"
#include "mac_const.h"
#include "mac_msgs.h"
#include "mac_data_structures.h"
#include "mac_hal.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_security.h"
#include "utils_fw.h"


/* === Macros ============================================================== */


/* === Globals ============================================================= */ 

/* === Prototypes ========================================================== */

/* === Implementation ====================================================== */

/*
 * Initiate mlme poll confirm message.
 *
 * buf_ptr - Buffer to send poll confirmation to NHLE.
 * status  - MLME Poll request status.
 */
static void mac_poll_gen_mlme_poll_conf (buffer_t *buf_ptr, uint8_t status)
{
    mlme_poll_conf_t *mpc = (mlme_poll_conf_t *)BMM_BUFFER_POINTER(buf_ptr);

    mpc->cmdcode = MLME_POLL_CONFIRM;
    mpc->status = status;

    /*
     * Only go to sleep if poll is not successful,
     * otherwise stay awake until subsequent evaluation of data frame
     */
    if (MAC_SUCCESS != status) {
        /* Set radio to sleep if allowed */
        mac_trx_sleep();
    }

#if (defined UM) && (!defined ZBMAC_DIAG)
	mlme_send_to_host(buf_ptr);
#else
	mlme_poll_conf(buf_ptr);
#endif		
}



/*
 * This function handles an MLME-POLL.request primitive.
 * The MLME-POLL.request primitive is generated by the next
 * higher layer and issued to its MLME when data are to be
 * requested from a coordinator.
 *
 * m_p - Pointer to the message from next higher layer
 */
void mlme_poll_request (buffer_t *buf_p)
{
    /*
     * Polling for data is only allowed, if the node
     * 1) is not a PAN coordinator,
     * 2) is not polling already, and
     * 3) is not scanning.
     */
    if ((MAC_POLL_IDLE         == mac_poll_state) &&
        (MAC_PAN_COORD_STARTED != mac_state     ) &&
        (MAC_SCAN_IDLE         == mac_scan_state)) {
        bool            status;
        address_field_t coord_addr;
        uint8_t         data_req_addr_mode;
        mlme_poll_req_t *poll_req_p = (mlme_poll_req_t *)buf_p;

        /* Wake up radio first */
        mac_trx_wakeup();

        /*
         * Extract the Coordinator address information from the Poll request.
         * This is required later for building the proper destination address
         * information in the data request frame.
         */

        if (poll_req_p->CoordAddrMode == FCF_SHORT_ADDR) {
            data_req_addr_mode = FCF_SHORT_ADDR;
            ADDR_COPY_DST_SRC_16(coord_addr.short_address, 
                                 poll_req_p->CoordAddress.short_address);
        } else {
            data_req_addr_mode = FCF_LONG_ADDR;
            ADDR_COPY_DST_SRC_64(coord_addr.long_address, 
                                 poll_req_p->CoordAddress.long_address);
        }

        /* Build and transmit data request frame due to explicit poll request */
        status = mac_data_build_and_tx_data_req(true,
                                                false,
                                                data_req_addr_mode,
                                                &coord_addr,
                                                poll_req_p->CoordPANId);

        if (status) {
            /* Store the poll request buffer to give poll confirm */
            mac_conf_buf_ptr = (uint8_t *)buf_p;
        } else {
            mac_poll_gen_mlme_poll_conf(buf_p, MAC_CHANNEL_ACCESS_FAILURE);
        }
    } else {
        mac_poll_gen_mlme_poll_conf(buf_p, MAC_CHANNEL_ACCESS_FAILURE);
    }
}



/*
 * This function implements the POLL_WAIT_TIMER callback.
 * If a poll request is pending, a mlme-poll-confirm is generated.
 *
 * callback_parameter - Callback parameter
 */
void mac_poll_wait_time_cb (void *callback_parameter)
{
    if (MAC_POLL_EXPLICIT == mac_poll_state) {
        /*
         * Data is not received on time for the poll request, hence generate
         * the poll confirm using the poll request buffer which was stored in
         * mac_conf_buf_ptr.
         */
        mac_poll_gen_mlme_poll_conf((buffer_t *)mac_conf_buf_ptr, MAC_NO_DATA);
    }

    mac_poll_state = MAC_POLL_IDLE;

    /* MAC was busy during poll. */
    MAC_NOT_BUSY();

    callback_parameter = callback_parameter;  /* Keep compiler happy. */
}

/*
 * This function processes a data response to an MLME-POLL.request.
 * Our coordinator has responded with a data frame. It is checked
 * whether any data has been received, and the appropriate
 * MLME-POLL.confirm message is constructed.
 */
void mac_poll_process_data_response (void)
{
    uint8_t status;

    if (FCF_FRAMETYPE_BEACON == mac_parse_data.frame_type) {
        /*
         * Node is currently in polling state, so only command or data frames
         * are of interest.
         * This is an unexpected frame type, do nothing.
         * Note. Ack frames are not uploaded to this point.
         * All subsequent actions are not to be done now.
         * Instead the timer will expire and initiate the proper stuff.
         */
         return;
    } else {
        /* Stop the FrameResponseTime timer */
        STM_StopTimer(poll_wait_timer);

        /*
         * For received command frames (Association response or
         * disassociation notification) and for data frames with zero
         * payload length the potential status for the poll.confirm message
         * is supposed to be "No data".
         */
        status = MAC_NO_DATA;

        if ((FCF_FRAMETYPE_DATA == mac_parse_data.frame_type) &&
            (mac_parse_data.mac_payload_length > 0)) {
            /*
             * For received data frames with non-zero payload length
             * the potential status for the poll.confirm message is
             * supposed to be "Success".
             */
             status = MAC_SUCCESS;
        }
    }

    if (MAC_POLL_EXPLICIT == mac_poll_state) {
        /*
         * Data is received on explicit poll request, hence generate 
         * the poll confirm using the buffer which was stored in
         * mac_conf_buf_ptr.
         */
        mac_poll_gen_mlme_poll_conf((buffer_t *)mac_conf_buf_ptr, status);
    }

    /* MAC was busy during poll. */
    MAC_NOT_BUSY();

    mac_poll_state = MAC_POLL_IDLE;
}
#endif //HYBRII_802154
