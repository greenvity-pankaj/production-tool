C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_START
OBJECT MODULE PLACED IN .\obj\mac_start.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_start.c LARGE OBJECTADVANCED OPTIMIZE(9,
                    -SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\
                    -..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\ha
                    -l;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\fir
                    -mware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee
                    -;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc
                    -;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\in
                    -c;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;.
                    -.\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\
                    -hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\
                    -..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\c
                    -omponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\
                    -flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities
                    -;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nw
                    -k\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\
                    -..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_
                    -8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,
                    -UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETE
                    -CT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT
                    -,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGI
                    -STER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_start.lst) TABS(2)
                    - OBJECT(.\obj\mac_start.obj)

line level    source

   1          /**
   2           * @file mac_start.c
   3           *
   4           * This file implements the MLME-START.request
   5           *
   6           * $Id: mac_start.c,v 1.3 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          #ifdef HYBRII_802154
  12          
  13          /* === Includes ============================================================ */
  14          
  15          #include <string.h>
  16          #include "papdef.h"
  17          #include "timer.h"
  18          #include "return_val.h"
  19          #include "bmm.h"
  20          #include "qmm.h"
  21          #include "mac_msgs.h"
  22          #include "mac_hal.h"
  23          #include "mac_const.h"
  24          #include "mac_api.h"
  25          #include "mac_data_structures.h"
  26          #include "mac_internal.h"
  27          #include "mac.h"
  28          #include "utils_fw.h"
  29          
  30          /* === Macros =============================================================== */
  31          /*
  32           * Coordinator realignment payload length
  33           */
  34          /*
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 2   

  35           * In 802.15.4-2006 the channel page may be added, if the new channel page is
  36           * different than the original value. In order to simplify the code, it
  37           * is always added.
  38           */
  39          #define COORD_REALIGN_PAYLOAD_LEN       (9)
  40          
  41          /* === Globals ============================================================== */
  42          
  43          static mlme_start_req_t msr_params;    /* Intermediate start parameters */
  44          
  45          /* === Prototypes =========================================================== */
  46          
  47          
  48          /* === Implementation ======================================================= */
  49          
  50          /*
  51           * Generate confirmation for MLME_START.request
  52           *
  53           * buf_p            - Pointer to MLME_START.request
  54           * start_req_status - Status of the MLME_START.request
  55           */
  56          static void gen_mlme_start_conf (buffer_t *buf_p,
  57                                           uint8_t start_req_status)
  58          {
  59   1      
  60   1          /* Use the same start request buffer for start confirm */
  61   1          mlme_start_conf_t *msc_p = (mlme_start_conf_t *)BMM_BUFFER_POINTER(buf_p);
  62   1      
  63   1          msc_p->cmdcode = MLME_START_CONFIRM;
  64   1          msc_p->status = start_req_status;
  65   1      
  66   1      #if (defined UM) && (!defined ZBMAC_DIAG)
  67   1         mlme_send_to_host(buf_p);
  68   1      #else
                 mlme_start_conf(buf_p);
              #endif  
  71   1      }
  72          
  73          
  74          
  75          /*
  76           * Checks the parameters of a MLME_START.request
  77           *
  78           * This function validates the parameters of the MLME_START.request.
  79           *
  80           * msg_p - Pointer to the MLME_START.request message which holds the
  81           * start parameters
  82           *
  83           * return true if parameters are valid, false otherwise
  84           */
  85          static bool check_start_parameter (mlme_start_req_t *msg_p)
  86          {
  87   1          bool param_validation_status = false;
  88   1      
  89   1          /*
  90   1           * Value of BO has to be less than or equal to 15 (Non beacon
  91   1           * Network). The value of SO has to be either greater than or equal to
  92   1           * BO.
  93   1           */
  94   1          if ((msg_p->BeaconOrder <= NON_BEACON_NWK) &&
  95   1              ((msg_p->SuperframeOrder <= msg_p->BeaconOrder) ||
  96   1               (NON_BEACON_NWK == msg_p->SuperframeOrder))) {
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 3   

  97   2              /*
  98   2               * Coordinator realignment command can only be given by a
  99   2               * PAN coordinator or cordinator (which is associated to a
 100   2               * PAN coordinator).
 101   2               */
 102   2              if ((msg_p->CoordRealignment) &&
 103   2                  ((MAC_ASSOCIATED == mac_state) || (MAC_IDLE == mac_state))) {
 104   3                  /*
 105   3                   * We are neigher the requested to be the PAN Coordinator,
 106   3                   * nor are we associated, so Realignment is not allowed at
 107   3                   * this stage.
 108   3                   */
 109   3                  param_validation_status = false;
 110   3              } else {
 111   3                  param_validation_status = true;
 112   3              }
 113   2          }
 114   1      
 115   1          return (param_validation_status);
 116   1      }
 117          
 118          /**
 119           *
 120           * This function is called either in response to the reception of an orphan
 121           * notification command from a device (cmd_type = ORPHANREALIGNMENT),
 122           * or gratuitously whenever the PAN parameters are about to be changed
 123           * (cmd_type = COORDINATORREALIGNMENT). In the former case, the
 124           * paramater contains a pointer to the respective MLME_ORPHAN.response message,
 125           * while in the latter case this parameter is unused, and can be passed as NULL.
 126           *
 127           * cmd_type    - Determines directed or broadcast mode
 128           * buf_p       - Pointer to the buffer, using which coord_realignment_command
 129           *               to be sent
 130           * new_panid   - Contains the new PAN-ID in case there is a network realignment
 131           * new_channel - Contains the new channel in case there is a network
 132           *               realignment
 133           * new_page    - Contains the new channel page in case there is a network
 134           *               realignment
 135           *
 136           * return true if coord_realignment_command is sent successfully,
 137           *        false otherwise
 138           */
 139          bool mac_tx_coord_realignment_command (frame_msgtype_t cmd_type,
 140                                                 buffer_t *buf_p,
 141                                                 uint16_t new_panid,
 142                                                 uint8_t new_channel,
 143                                                 uint8_t new_page)
 144          {
 145   1          retval_t           tx_status;
 146   1          uint8_t            frame_len;
 147   1          uint8_t            *frame_ptr;
 148   1          uint8_t            *temp_frame_ptr;
 149   1          uint16_t           fcf;
 150   1          uint16_t           bc_addr = BROADCAST;
 151   1          mlme_orphan_resp_t orphan_resp;
 152   1          frame_info_t       *coord_realignment_frame_p;
 153   1      
 154   1          /*
 155   1           * Orphan request is reused to send coordinator realignment
 156   1           * command frame and finally to send comm-status-indication
 157   1           */
 158   1          memcpy(&orphan_resp,
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 4   

 159   1                 (mlme_orphan_resp_t *)BMM_BUFFER_POINTER(buf_p),
 160   1                 sizeof(mlme_orphan_resp_t));
 161   1      
 162   1          coord_realignment_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
 163   1      
 164   1          coord_realignment_frame_p->msg_type = cmd_type;
 165   1          coord_realignment_frame_p->buffer_header_p = buf_p;
 166   1      
 167   1          /* Get the payload pointer. */
 168   1          frame_ptr = temp_frame_ptr =
 169   1                      (uint8_t *)coord_realignment_frame_p +
 170   1                      BUFFER_SIZE -
 171   1                      COORD_REALIGN_PAYLOAD_LEN;
 172   1      
 173   1          /* Update the payload field. */
 174   1          *frame_ptr++ = COORDINATORREALIGNMENT;
 175   1      
 176   1          /*
 177   1           * The payload of the frame has the parameters of the new PAN
 178   1           * configuration
 179   1           */
 180   1          mac_utils_16_bit_to_byte_array(new_panid, frame_ptr);
 181   1          frame_ptr += PAN_ID_LEN;
 182   1          mac_utils_16_bit_to_byte_array(hal_pib_ShortAddress, frame_ptr);
 183   1          frame_ptr += SHORT_ADDR_LEN;
 184   1      
 185   1          *frame_ptr++ = new_channel;
 186   1      
 187   1          /*
 188   1           * Insert the device's short address, or 0xFFFF if this is a
 189   1           * gratuitous realigment.
 190   1           */
 191   1          if (ORPHANREALIGNMENT == cmd_type) {
 192   2              mac_utils_16_bit_to_byte_array(orphan_resp.ShortAddress, frame_ptr);
 193   2          } else {
 194   2              mac_utils_16_bit_to_byte_array(BROADCAST, frame_ptr);
 195   2          }
 196   1          frame_ptr += SHORT_ADDR_LEN;
 197   1      
 198   1          /* Add channel page no matter if it changes or not. */
 199   1          *frame_ptr++ = new_page;
 200   1      
 201   1          /* Get the payload pointer again to add the MHR. */
 202   1          frame_ptr = temp_frame_ptr;
 203   1      
 204   1          /* Update the length. */
 205   1          frame_len = COORD_REALIGN_PAYLOAD_LEN +
 206   1                      FCF_LEN                   +
 207   1                      PAN_ID_LEN                + // Destination PAN-ID
 208   1                      SHORT_ADDR_LEN            +
 209   1                      PAN_ID_LEN                + // Source PAN-ID
 210   1                      EXT_ADDR_LEN              + // Long Source Address
 211   1                      SEQ_NUM_LEN               +
 212   1                      FCF_LEN;
 213   1      
 214   1      
 215   1          /* Source address */
 216   1          frame_ptr -= EXT_ADDR_LEN;
 217   1          mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 218   1      
 219   1          /* Source PAN-Id */
 220   1          frame_ptr -= PAN_ID_LEN;
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 5   

 221   1          mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 222   1      
 223   1      
 224   1          /* Destination Address and FCF */
 225   1          if (ORPHANREALIGNMENT == cmd_type) {
 226   2              /*
 227   2               * Coordinator realignment in response to an orphan
 228   2               * notification command received from a device. This is always
 229   2               * sent to a 64-bit device address, and the device is
 230   2               * requested to acknowledge the reception.
 231   2               */
 232   2              fcf = FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
 233   2                    FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR)    |
 234   2                    FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
 235   2                    FCF_ACK_REQUEST                          |
 236   2                    FCF_FRAME_VERSION_2006;
 237   2      
 238   2              frame_ptr -= EXT_ADDR_LEN;
 239   2              frame_len += 6; // Add further 6 octets for long Destination Address
 240   2              mac_utils_64_bit_to_byte_array(orphan_resp.OrphanAddress,
 241   2                                                 frame_ptr);
 242   2          } else {
 243   2              /*
 244   2               * Coordinator realignment gratuitously sent when the PAN
 245   2               * configuration changes. This is sent to the (16-bit)
 246   2               * broadcast address.
 247   2               */
 248   2              fcf = FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
 249   2                    FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR)   |
 250   2                    FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
 251   2                    FCF_FRAME_VERSION_2006;
 252   2              /*
 253   2               * Since the channel page is always added at the end of the
 254   2               * coordinator realignment command frame, the frame version subfield
 255   2               * needs to indicate a 802.15.4-2006 compatible frame.
 256   2               */
 257   2      
 258   2              frame_ptr -= SHORT_ADDR_LEN;  /* BC Addr is short */
 259   2              mac_utils_16_bit_to_byte_array(bc_addr, frame_ptr);
 260   2          }
 261   1      
 262   1          /* Destination PAN-Id */
 263   1          frame_ptr -= PAN_ID_LEN;
 264   1          mac_utils_16_bit_to_byte_array(bc_addr, frame_ptr);
 265   1      
 266   1      
 267   1          /* Set DSN. */
 268   1          frame_ptr -= SEQ_NUM_LEN;
 269   1          *frame_ptr = mac_pib_macDSN++;
 270   1      
 271   1      
 272   1          /* Set the FCF. */
 273   1          frame_ptr -= FCF_LEN;
 274   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
 275   1      
 276   1      
 277   1          /* First element shall be length of PHY frame. */
 278   1          frame_ptr -= LENGTH_FIELD_LEN;
 279   1          *frame_ptr = frame_len;
 280   1      
 281   1          /* Finished building of frame. */
 282   1          coord_realignment_frame_p->mpdu_p = frame_ptr;
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 6   

 283   1      
 284   1          if (NON_BEACON_NWK == hal_pib_BeaconOrder) {
 285   2              /* In Nonbeacon network the frame is sent with unslotted CSMA-CA. */
 286   2              tx_status = mac_hal_tx_frame(coord_realignment_frame_p,
 287   2                                           CSMA_UNSLOTTED, FALSE);
 288   2          } else {
 289   2              /* Beacon-enabled network */
 290   2              if (ORPHANREALIGNMENT == cmd_type) {
 291   3                  /* 
 292   3                   * In Beacon network the Orphan Realignment frame is sent 
 293   3                   * with slotted CSMA-CA.
 294   3                   */
 295   3                  tx_status = mac_hal_tx_frame(coord_realignment_frame_p,
 296   3                                               CSMA_SLOTTED, FALSE);
 297   3              } else {
 298   3                  /*
 299   3                   * Coordinator Realignment frame is sent to broadcast address,
 300   3                   * so it needs to be appended at the end of the broadcast queue.
 301   3                   */
 302   3                  if (FALSE == qmm_queue_append(&broadcast_q, buf_p)) {
 303   4                      return (false);
 304   4                  }
 305   3                  return (true);
 306   3              }
 307   2          }
 308   1      
 309   1          if (MAC_SUCCESS == tx_status) {
 310   2              MAC_BUSY();
 311   2              return (true);
 312   2          } else {
 313   2              return (false);
 314   2          }
 315   1      }
 316          
 317          /**
 318           * The MLME-START.request primitive makes a request for the device to
 319           * start using a new superframe configuration
 320           *
 321           * buf_p - Pointer to MLME_START.request message issued by the NHLE
 322           */
 323          void mlme_start_request (buffer_t *buf_p)
 324          {
 325   1          mlme_start_req_t *msg_p = (mlme_start_req_t *)BMM_BUFFER_POINTER(buf_p);
 326   1       
 327   1          /*
 328   1           * The MLME_START.request parameters are copied into a global variable
 329   1           * structure, which is used by check_start_parameter() function.
 330   1           */
 331   1          memcpy(&msr_params, msg_p, sizeof(msr_params));
 332   1      
 333   1          if (BROADCAST == hal_pib_ShortAddress) {
 334   2              /*
 335   2               * This device does not have a valid short address to
 336   2               * start a network.
 337   2               */
 338   2              gen_mlme_start_conf(buf_p, MAC_NO_SHORT_ADDRESS);
 339   2              return;
 340   2          }
 341   1      
 342   1          if (check_start_parameter(msg_p) == false) {
 343   2              /*
 344   2               * The MLME_START.request parameters are invalid, hence confirmation
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 7   

 345   2               * is given to NHLE.
 346   2               */
 347   2              gen_mlme_start_conf(buf_p, MAC_INVALID_PARAMETER);
 348   2          } else {
 349   2              /*
 350   2               * All the start parameters are valid, hence MLME_START.request can
 351   2               * proceed.
 352   2               */
 353   2              mac_hal_pib_set(I_AM_PAN_COORDINATOR, (void *)&(msg_p->PANCoordinator));
 354   2      
 355   2              if (msr_params.CoordRealignment) {
 356   3                  /* First inform our devices of the configuration change */
 357   3                  if (!mac_tx_coord_realignment_command(COORDINATORREALIGNMENT,
 358   3                                                        buf_p,
 359   3                                                        msr_params.PANId,
 360   3                                                        msr_params.LogicalChannel,
 361   3                                                        msr_params.ChannelPage)) {
 362   4                      /*
 363   4                       * The coordinator realignment command was unsuccessful,
 364   4                       * hence the confiramtion is given to NHLE.
 365   4                       */
 366   4                      gen_mlme_start_conf(buf_p, MAC_INVALID_PARAMETER);
 367   4                  }
 368   3              } else {
 369   3                  /* This is a normal MLME_START.request. */
 370   3                  retval_t channel_set_status, channel_page_set_status;
 371   3      
 372   3                  mac_hal_pib_set(macBeaconOrder, (void *)&(msg_p->BeaconOrder));
 373   3      
 374   3                  /*
 375   3                   * If macBeaconOrder is equal to 15, set also 
 376   3                   * macSuperframeOrder to 15
 377   3                   */
 378   3                  if (msg_p->BeaconOrder == NON_BEACON_NWK) {
 379   4                      msg_p->SuperframeOrder = NON_BEACON_NWK;
 380   4                  }
 381   3      
 382   3                  mac_hal_pib_set(macSuperframeOrder,
 383   3                                     (void *)&(msg_p->SuperframeOrder));
 384   3      
 385   3                  /*
 386   3                   * Symbol times are calculated according to the new BO and SO
 387   3                   * values.
 388   3                   */
 389   3                  if (hal_pib_BeaconOrder < NON_BEACON_NWK) {
 390   4                      mac_hal_pib_set(macBattLifeExt,
 391   4                                      (void *)&(msr_params.BatteryLifeExtension));
 392   4                  }
 393   3      
 394   3                  /* Wake up radio first */
 395   3                  mac_trx_wakeup();
 396   3      
 397   3                  mac_hal_pib_set(macPANId, (void *)&(msr_params.PANId));
 398   3      
 399   3                  channel_page_set_status =
 400   3                      mac_hal_pib_set(phyCurrentPage,
 401   3                                      (void *)&(msr_params.ChannelPage));
 402   3      
 403   3                  channel_set_status =
 404   3                      mac_hal_pib_set(phyCurrentChannel,
 405   3                                      (void *)&(msr_params.LogicalChannel));
 406   3      
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 8   

 407   3                  if ((MAC_SUCCESS == channel_page_set_status) &&
 408   3                      (MAC_SUCCESS == channel_set_status) &&
 409   3                      (PHY_RX_ON == mac_hal_hw_control(PHY_RX_ON))) {
 410   4                      if (msr_params.PANCoordinator) {
 411   5                          mac_state = MAC_PAN_COORD_STARTED;
 412   5                      } else {
 413   5                          mac_state = MAC_COORDINATOR;
 414   5                      }
 415   4      
 416   4                      gen_mlme_start_conf(buf_p, MAC_SUCCESS);
 417   4      
 418   4                      /*
 419   4                       * In case we have a beaconing network, the beacon timer needs
 420   4                       * to be started now.
 421   4                       */
 422   4                      if (hal_pib_BeaconOrder != NON_BEACON_NWK) {
 423   5                          mac_start_beacon_timer();
 424   5                      }
 425   4                  } else {
 426   4                      /* Start of network failed. */
 427   4                      gen_mlme_start_conf(buf_p, MAC_INVALID_PARAMETER);
 428   4                  }
 429   3      
 430   3                  /* Set radio to sleep if allowed */
 431   3                  mac_trx_sleep();
 432   3              }
 433   2          }
 434   1      }
 435          
 436          
 437          
 438          /**
 439           * Continues handling of MLME_START.request (Coordinator realignment)
 440           * command
 441           *
 442           * This function is called once the coordinator realignment command is
 443           * sent out to continue the handling of the MLME_START.request command.
 444           *
 445           * tx_status - Status of the coordinator realignment command transmission
 446           * buf_ptr   - Buffer for start confirmation
 447           */
 448          void mac_coord_realignment_command_tx_success (uint8_t tx_status,
 449                                                         buffer_t *buf_p)
 450          {
 451   1          uint8_t conf_status = MAC_INVALID_PARAMETER;
 452   1          uint8_t cur_beacon_order;
 453   1          retval_t channel_set_status, channel_page_set_status;
 454   1      
 455   1          if (MAC_SUCCESS == tx_status) {
 456   2              /* The parameters of the existing PAN are updated. */
 457   2              channel_page_set_status =
 458   2                  mac_hal_pib_set(phyCurrentPage, (void *)&msr_params.ChannelPage);
 459   2      
 460   2              channel_set_status =
 461   2                  mac_hal_pib_set(phyCurrentChannel,
 462   2                                  (void *)&msr_params.LogicalChannel);
 463   2      
 464   2              if ((MAC_SUCCESS == channel_set_status) &&
 465   2                   (MAC_SUCCESS == channel_page_set_status)) {
 466   3                  conf_status = MAC_SUCCESS;
 467   3      
 468   3                  mac_hal_pib_set(macPANId,
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 9   

 469   3                                     (void *)&(msr_params.PANId));
 470   3      
 471   3                  /*
 472   3                   * Store current beacon order in order to be able to detect
 473   3                   * switching from nonbeacon to beacon network.
 474   3                   */
 475   3                  cur_beacon_order = hal_pib_BeaconOrder;
 476   3      
 477   3                  mac_hal_pib_set(macBeaconOrder, (void *)&msr_params.BeaconOrder);
 478   3                  mac_hal_pib_set(macSuperframeOrder,
 479   3                                  (void *)&msr_params.SuperframeOrder);
 480   3      
 481   3                  /*
 482   3                   * New symbol times for beacon time (in sysbols) and inactive 
 483   3                   * time are calculated according to the new superframe
 484   3                   * configuration.
 485   3                   */
 486   3                  if (msr_params.BeaconOrder < NON_BEACON_NWK) {
 487   4                      mac_hal_pib_set(macBattLifeExt,
 488   4                                      (void *)&msr_params.BatteryLifeExtension);
 489   4                  }
 490   3      
 491   3                  if ((NON_BEACON_NWK < cur_beacon_order) &&
 492   3                      (msr_params.BeaconOrder == NON_BEACON_NWK)) {
 493   4                      /*
 494   4                       * This is a transition from a beacon enabled network to
 495   4                       * a nonbeacon enabled network.
 496   4                       * In this case the broadcast data queue will never be served.
 497   4                       *
 498   4                       * Therefore the broadcast queue needs to be emptied.
 499   4                       * The standard does not define what to do now.
 500   4                       * The current implementation will try to send all 
 501   4                       * pending broadcast data frames immediately, thus giving
 502   4                       * the receiving nodes a chance receive them.
 503   4                       */
 504   4                      while (broadcast_q.size > 0) {
 505   5                          mac_tx_pending_bc_data();
 506   5                      }
 507   4                  }
 508   3      
 509   3                  if ((NON_BEACON_NWK == cur_beacon_order) &&
 510   3                      (msr_params.BeaconOrder < NON_BEACON_NWK)) {
 511   4                      /*
 512   4                       * This is a transition from a nonbeacon enabled network to
 513   4                       * a beacon enabled network, hence the beacon timer will be
 514   4                       * started.
 515   4                       */
 516   4                      mac_start_beacon_timer();
 517   4                  }
 518   3              }
 519   2          }
 520   1      
 521   1          gen_mlme_start_conf(buf_p, conf_status);
 522   1      
 523   1          /* Set radio to sleep if allowed */
 524   1          mac_trx_sleep();
 525   1      }
 526          #endif //HYBRII_802154


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1438    ----
C51 COMPILER V9.53.0.0   MAC_START                                                         11/04/2015 20:09:51 PAGE 10  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     36      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
