C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HAL_HPGP
OBJECT MODULE PLACED IN .\obj\hal_hpgp.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\..\hal\hal_hpgp.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100
                    -) INCDIR(..\..\..\common\datapath;..\..\..\common\include;..\..\..\hal;..\..\src\crypto;..\..\src\ctrl;..\..\src\hal;..\
                    -..\src\link;..\..\src\mux;..\..\src\nma;..\..\src\route;..\..\src\sap;..\..\src\test;..\..\..\project\hal\src;..\..\..\z
                    -igbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\even
                    -t\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\sampleapp\src
                    -;..\..\..\..\sampleapp\inc;..\..\..\common;..\..\..\hpgp;..\..\src;..\..\..\..\components\hpgp\inc;..\..\..\app_support;
                    -..\..\..\HybriiB_configuration_rw\src) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUN
                    -C,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HYBRII_ETH,HPGP_MAC_SAP,NMA,HYBRII_SPI,NEW_SYNC,UM,HYBRII_B
                    -,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,AUTH_AES,PLC_TEST,B_ASICPLC,UART_HOST_INTF_,UART_RAW,MPER_,FREQ_DETECT,SW_RECOVERY
                    -,PROD_TEST) DEBUG PRINT(.\lst\hal_hpgp.lst) TABS(2) OBJECT(.\obj\hal_hpgp.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgp.c,v 1.63 2014/09/05 09:28:18 ranjan Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgp.c,v $
   5          *
   6          * Description : HPGP Hardware Abstraction Layer implementation
   7          *
   8          * Copyright (c) 2010-2013 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines API interface for accessing HPGP memory mapped registers.
  13          *                           for writing tx descritpors to plc tx queues
  14          *                           for writing beacons to beacon tx fifos
  15          *                           for reading beacons from beacon rx fifos
  16          */
  17          
  18          
  19          #include <stdio.h>
  20          #include <string.h>
  21          #include <intrins.h>
  22          #include "papdef.h"
  23          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  26          #include "hal_common.h"
  27          #include "hal.h"
  28          #include "fm.h"
  29          #include "hal_hpgp.h"
  30          #include "hal_eth.h"
  31          #include "hal_tst.h"
  32          #include "hal_reg.h"
  33          #include "hpgpevt.h"
  34          #include "timer.h"
  35          #include "stm.h"
  36          #include "hybrii_tasks.h"
  37          #ifndef HPGP_HAL_TEST
  38          #include "hpgpapi.h"
  39          #endif  //HPGP_HAL_TEST
  40          
  41          
  42          #include "fm.h"
  43          
  44          #ifdef HPGP_HAL_TEST
              #include "hal_cfg.h"
              #else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 2   

  47          #include "hal.h"
  48          #endif  //HPGP_HAL_TEST
  49          
  50          #include "hal_regs_def.h"
  51          
  52          #include "uart.h"
  53          #ifdef UM
  54          #include "mac_intf_common.h"
  55          #endif
  56          
  57          #ifdef HPGP_MAC_SAP 
  58          #ifdef LINK_STATUS
              #define MAX_LINK_TEST_TX_TIMEOUT 450
              #define LINK_RETRY            1
              #endif  //LINK_STATUS
  62          #endif  //HPGP_MAC_SAP
  63          
  64          #ifdef FREQ_DETECT
  65              u32 AC_MIN_THRESHOLD;
  66              u32 PLC_DC_LINE_CYCLE_FREQENCY  =  0x7A120;
  67          #endif
  68          u32 gBPSTdelta;
  69          u8 gNegativeflag = 0;
  70          u8 gPositiveflag = 0;
  71          u8 firsttime = 0;
  72          u32 goldbpst;
  73          u32 gavg;
  74          u8 zctrack = 0;
  75          u8 zcFlag;
  76          u32 gbpst = 0;
  77          u8 gRollOver;
  78          u32 zcCCONTBold;
  79          u32 gCCO_BTS;
  80          u32 zcCCONTB_OLD;
  81          
  82          u8 avgdone = 0;
  83          u32 avg;
  84          u8 avgcount =0;
  85          
  86          extern u32 misscnt;
  87          //extern sysConfig_t sysConfig;
  88          //extern Load_Config_Data (u8, u8 *);
  89          //extern Program_Config_Data();
  90          
  91          void sendSingleFrame(u8 mcstMode);  //1 = multicast, 0 unicast
  92          extern void datapath_init();
  93          
  94          extern u16 var1;
  95          //u32 missarr[1000];
  96          u8 testflag = 1;
  97          
  98          extern u8 opMode;
  99          #ifdef PLC_TEST
 100          u8 gSTA_TEI;
 101          u8 gCount;
 102          u8 gNumOfSTAAssignedTEI = 1;
 103          u8 gCCOTest = 0;
 104          extern u16 gBcnSent;
 105          eHpgpRoboMod gRoboMode;
 106          eHpgpRoboModLens gCurrRobomode;
 107          #define TOTAL_NUM_OF_TX_FRAME  1000
 108          
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 3   

 109            u16 gRobomodeAllLenTest[5][2]= {
 110          
 111              {HPGP_ROBOMD_MINI_100, 100},   
 112              {HPGP_ROBOMD_MINI_250, 250}, 
 113              //{HPGP_ROBOMD_HS_800, 800}, 
 114             // {HPGP_ROBOMD_HS_1000, 1000},
 115              {HPGP_ROBOMD_STD_500, 500}, 
 116              {HPGP_ROBOMD_HS_800, 800}, 
 117              {HPGP_ROBOMD_HS_1000, 1000}, 
 118          
 119          
 120          };   
 121          #endif
 122          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
 123          
 124          u16 gAltRoboLenArr[]={101,401,801,1201};
 125          u8 gAltEksTstArr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15}; // 7 NEKs, 2 PPEKs, Unenc
 126          #endif
 127          
 128          #ifdef FREQ_DETECT
 129          u32 PLC_DC_BP_LEN     =           PLC_DC_BP_LEN_60HZ;
 130          u32 PLC_AC_BP_LEN     =           PLC_AC_BP_LEN_60HZ;//0xCB735      //these are for 60 hz AC
 131          u32 PLC_MIN_AC_BPLEN  =           0xCB300;
 132          u32 PLC_MAX_AC_BPLEN  =           0xCBA00; 
 133          #endif
 134          
 135          u32 cnt5 = 0;
 136          u32 oldRetrievedBTS;
 137          u32 oldss1;
 138          u32 OldCCOBpst;
 139          
 140          u32 gBcnPer;
 141          extern u32 gtimer2, gtimer1;
 142          u8 gsyncTimeout;
 143          u8 gBcnMissingRescanCnt;
 144          extern u8 gflag;
 145          sHpgpHalCB gHpgpHalCB;
 146          #ifdef HPGP_HAL_TEST
              extern sHalCB gHalCB;
              sHpgpHalCB *gpHhalCb;
              #endif  //HPGP_HAL_TEST
 150          
 151          #ifdef DEBUG_DATAPATH
              extern u8 sigDbg;
              #endif
 154          
 155          u32 gbpst1;
 156          u32 gOldBTS;
 157          #ifdef ETH_BRDG_DEBUG
              extern u32 numTxDoneInts;
              extern u8 myDebugFlag;
              extern u8 myDebugFlag1;
              #endif
 162          
 163          /*u32 TX_RXLatency_TCC[8] = {
 164                             
 165                              0x321e0417,  //TCC =1
 166                             // 0x336F0417,
 167                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
 168                              0x34ca0417,
 169                              0x361F0417,
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 4   

 170                              0x37750417,
 171                              0x38c20417,
 172                              0x3a180417,
 173                              0x3b740417,  //TCC= 8
 174          
 175          };*/
 176          
 177          //phy image gpphy_3S150_08032013- and onwards uses phy tx latency as 0x04e5 and older phy image uses phy t
             -x latency as 0x0417 
 178          #ifdef B_ASICPLC
 179          //following is for ASIC
 180          u32 TX_RXLatency_TCC[8] = {
 181                          0x30C104DD,   //TCC =1
 182                          0x319304DD,
 183                          0x325504DD,  //TCC =3   326204dd  3255
 184                          0x332604DD,
 185                          0x33F304DD,
 186                          0x34C004DD,
 187                          0x358C04DD,
 188                          0x365A04DD, //TCC= 8
 189          
 190          };
 191          #else
              u32 TX_RXLatency_TCC[8] = {
                                 
                                  0x321e04E5,  //TCC =1
                                 // 0x336F0417,   old phy tx latency 0x0417
                                  0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
                                  0x34ca04E5,
                                  0x361F04E5,
                                  0x377504E5,
                                  0x38c204E5,
                                  0x3a1804E5,
                                  0x3b7404E5,  //TCC= 8
              
              };
              #endif
 206          u8 TCC_REG_485_486_val[8][2] = {
 207                                          {0x40,0x80},
 208                                          {0x80,0x80},
 209                                          {0xc0,0x80},
 210                                          {0x0,0x81},
 211                                          {0x40,0x81},
 212                                          {0x80,0x81},
 213                                          {0xc0,0x81},
 214                                          {0x0,0x82},
 215          
 216          };
 217          u8 gDefNID[NID_LEN] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
 218          #define PLC_MaxPeran                    0x1B
 219          #define PLC_MinPeran                    0x1C
 220          u16  prevCsmaRgns[HYBRII_MAXSMAREGION_CNT] = {0};
 221          #ifdef FREQ_DETECT
 222          #ifdef UM
 223          extern eStatus CNSM_InitRegion(sCnsm *cnsm, sLinkLayer *linkl);
 224          #endif
 225          #endif
 226          
 227          #ifdef PLC_TEST
 228          void printmsg(u8* buff, u8 len)
 229          {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 5   

 230   1         u8 i;
 231   1         for(i = 0; i < len; i++)
 232   1         {
 233   2             printf("%bx\t", buff[i]);
 234   2         }
 235   1         printf("\n");
 236   1      }
 237          
 238          void HHT_ProcessPlcFrame(sSwFrmDesc* plcRxFrmSwDesc)
 239          {
 240   1          
 241   1          u8 HeaderOffset = sizeof(gHeaderBytes);
 242   1          u8 TestID;
 243   1          u8 NumOFSTAAssignTEI;
 244   1          u8 offset;
 245   1          volatile u8  RxDataBuff[500];
 246   1          volatile u8 TxdataBuff[500];
 247   1          u8 STA_TEI;
 248   1          u8 i;
 249   1          u16 totalDesc ;
 250   1          u16 freeDescCnt ;
 251   1          u32 per;
 252   1          
 253   1                              
 254   1          
 255   1          sHpgpHalCB HpgpHalCB;
 256   1          plcHalStatus plc_halstatus_t;
 257   1          volatile u8 xdata * cellAddr;
 258   1          
 259   1          //printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
 260   1        
 261   1        
 262   1      
 263   1          //  /?! frames should not be considered in statistic so doing minus 1
 264   1          //gHpgpHalCB.halStats.TotalRxGoodFrmCnt--;
 265   1          //gHpgpHalCB.halStats.RxGoodDataCnt--;
 266   1          
 267   1           
 268   1           //WE assume that received data will never be more then 500 bytes since rxdabuff size is 500  and txda
             -tabuff is also 500
 269   1          
 270   1          cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[0].cp);
 271   1          TestID = cellAddr[HeaderOffset + 0];//because first three bytes will be /, ?, !       HeaderOffset = 3
 272   1          strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
 273   1          
 274   1          
 275   1          for(i = 0; i < plcRxFrmSwDesc->cpCount; i++ )
 276   1          {
 277   2               cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[i].cp);
 278   2               
 279   2               if(i == 0)//if first cp then we have /?! and test ID
 280   2               {
 281   3                   offset = HeaderOffset + 1;//since we have stored 
 282   3               }
 283   2               else
 284   2                   offset = 0;
 285   2               
 286   2               
 287   2               memcpy(&RxDataBuff[i* HYBRII_CELLBUF_SIZE] ,&cellAddr[offset], HYBRII_CELLBUF_SIZE);
 288   2          }
 289   1          
 290   1       
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 6   

 291   1          
 292   1         // if(plcRxFrmSwDesc->frmInfo.plc.stei == DEFAULT_CCO_TEI )//source is CCO so STA is Rx
 293   1          {
 294   2              
 295   2              //printf("\nSTA : \n");
 296   2              switch(TestID)
 297   2              {
 298   3                  case  BROADCAST_CCO_TEI_TESTID:
 299   3                  
 300   3            //send STA TEI to CCO
 301   3          //  printf("BROADCAST_CCO_TEI_TESTID\n");
 302   3                      NumOFSTAAssignTEI = RxDataBuff[0];
 303   3                      STA_TEI = (NumOFSTAAssignTEI + 1);
 304   3                      TxdataBuff[HeaderOffset] = ASSIGN_STA_TEI_TESTID;
 305   3                      TxdataBuff[HeaderOffset + 1] = STA_TEI;
 306   3                      
 307   3                      //printf("\n Rx:\n");
 308   3                      //printmsg(&cellAddr[0],5);
 309   3                      
 310   3                      //printf("\n Tx:\n");
 311   3                      //printmsg((u8*)&TxdataBuff[0],5);
 312   3                      
 313   3                      Send_SinglePLCFrame(5, &TxdataBuff[0], STA_TEI, DEFAULT_CCO_TEI);//this frame is sent from
             - sta to cco saying that tei is assign to sta
 314   3                      break;
 315   3                  
 316   3                  case ACK_FOR_STA_TEI_TESTID://3
 317   3                      //set robo mode to mini robo
 318   3                      //send start PLC data rate test ID
 319   3                      
 320   3                   //    printf("\n ACK_FOR_STA_TEI_TESTID\n");
 321   3                       gSTA_TEI = RxDataBuff[0];
 322   3                       HHAL_SetTei(gSTA_TEI);
 323   3                       gHpgpHalCB.remoteTei = DEFAULT_CCO_TEI;
 324   3                       gHpgpHalCB.selfTei = gSTA_TEI;
 325   3                       TxdataBuff[HeaderOffset] = START_PLC_DATA_RATE_TESTID;
 326   3                       //printf("\n Tx:\n"); 
 327   3                       //printmsg(&TxdataBuff[0],4);
 328   3                       
 329   3                       CHAL_DelayTicks(400);
 330   3                       Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);   //this frmae is sent
             - from cco to sta saying start test to test hardware
 331   3                       HHAL_ResetPlcStat();
 332   3                      
 333   3                      
 334   3                  break;
 335   3       
 336   3                  case DATARATE_TEST_TESTID://5 
 337   3                   //   printf("DATARATE_TEST_TESTID\n");
 338   3                      //send pstat 
 339   3                      //after send clear the p stat
 340   3                      //printf("\nHeaderOffset = %bu\n", HeaderOffset);
 341   3                      
 342   3                      // printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
 343   3                      //printf("\n>>>nSTA received ROBO mode frame.\n");
 344   3                      TxdataBuff[HeaderOffset] = PSTAT_TESTID;
 345   3                      memcpy(&TxdataBuff[HeaderOffset + 1],(char*)&gHpgpHalCB.halStats,sizeof(gHpgpHalCB.halStat
             -s));
 346   3                      
 347   3      
 348   3                    
 349   3      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 7   

 350   3                      totalDesc      = PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH;
 351   3                      freeDescCnt    =  (u16)(HHAL_GetPlcTxQFreeDescCnt(0) + HHAL_GetPlcTxQFreeDescCnt(1) + \
 352   3                                           HHAL_GetPlcTxQFreeDescCnt(2) + HHAL_GetPlcTxQFreeDescCnt(3));  
 353   3      
 354   3                       
 355   3      
 356   3                      plc_halstatus_t.AddrFilterErrCnt = hal_common_reg_32_read(PLC_ADDRFILTERERRCNT_REG);
 357   3                      plc_halstatus_t.FrameCtrlErrCnt = hal_common_reg_32_read(PLC_FCCSERRCNT_REG);
 358   3                      plc_halstatus_t.ICVErrCnt = hal_common_reg_32_read(PLC_ICVERRCNT_REG);
 359   3                      plc_halstatus_t.PBCSRxErrCnt = hal_common_reg_32_read(PLC_PBCSRXERRCNT_REG);
 360   3                      plc_halstatus_t.PBCSTxErrCnt = hal_common_reg_32_read(PLC_PBCSTXERRCNT_REG);
 361   3                      plc_halstatus_t.PLCMpduDropCnt = hal_common_reg_32_read(PLC_MPDUDROPCNT_REG);
 362   3                      plc_halstatus_t.outStandingDescCnt = totalDesc - freeDescCnt;
 363   3                      plc_halstatus_t.FreeCPcount = CHAL_GetFreeCPCnt();
 364   3                      plc_halstatus_t.timerIntCnt = gHalCB.timerIntCnt;
 365   3                      plc_halstatus_t.bpIntGap = gHpgpHalCB.bpIntGap;
 366   3                      plc_halstatus_t.lastNtbB4 = gHpgpHalCB.lastNtbB4;
 367   3                      plc_halstatus_t.lastNtbAft = gHpgpHalCB.lastNtbAft;
 368   3                      plc_halstatus_t.lastBpst = gHpgpHalCB.lastBpst;
 369   3                      
 370   3                      
 371   3                      memcpy(&TxdataBuff[HeaderOffset + 1 + sizeof(gHpgpHalCB.halStats)],(char*)&plc_halstatus_t
             -,sizeof(plc_halstatus_t)); 
 372   3                      
 373   3             
 374   3                      
 375   3                      
 376   3                      //printmsg(&TxdataBuff[0],(sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t))); 
 377   3                      //clear the stat
 378   3                      HHAL_ResetPlcStat();
 379   3                     // printf("\nsize = %x\n", (sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)));
 380   3                      
 381   3                      //printf("\n >>>STA transmitting its Statistic to CCO...\n");
 382   3                      Send_SinglePLCFrame((sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)), &TxdataBu
             -ff[0], gSTA_TEI, DEFAULT_CCO_TEI);
 383   3                      
 384   3                      
 385   3                  break;
 386   3                  
 387   3                  /*case SEND_SYNC_DATA:
 388   3                      //compare and display
 389   3                      //send pxmittest dataID DATA_DURING_BCNS_TESTID
 390   3                      printf("\nRxGoodBcnCnt = %lu", gHpgpHalCB.halStats.RxGoodBcnCnt);
 391   3                      if(gHpgpHalCB.halStats.RxGoodBcnCnt >= NUM_OF_BCNS_FOR_CCO_TEST)
 392   3                      {
 393   3                          eth_plc_bridge = 1;
 394   3                          printf("\n\t\t\t\t\t BEACONS RECEIVED SUCCESSFULLY\n");
 395   3                          printf("\n>>>STA Transmitting MINI_ROBO frames to CCO...\n\n");
 396   3                          sendRobomodeFrames(100,1000);
 397   3                          
 398   3                           
 399   3                          TxdataBuff[3] = SEND_SYNC_DATA;
 400   3                          printmsg(&TxdataBuff[0],4);
 401   3                          Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);//broadcast CCO TEI
 402   3      
 403   3                      }
 404   3                      
 405   3                  break;
 406   3                  
 407   3                  case ENABLE_BRIDGE:
 408   3                      break;
 409   3                  
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 8   

 410   3                */
 411   3      
 412   3                      
 413   3                      
 414   3              }
 415   2          } 
 416   1        //  else//CCO is Rx
 417   1          {
 418   2              //printf("\nCCo : \n");
 419   2              switch(TestID)
 420   2              {
 421   3                  case ASSIGN_STA_TEI_TESTID://2
 422   3                      
 423   3                      //send Ack for STA TEI to STA
 424   3                    //  printf("ASSIGN_STA_TEI_TESTID\n");
 425   3                      HHAL_SetTei(DEFAULT_CCO_TEI);
 426   3                      gHpgpHalCB.selfTei = DEFAULT_CCO_TEI;
 427   3                      gSTA_TEI = RxDataBuff[0];
 428   3                      gRoboMode = HPGP_ROBOMD_MINI;
 429   3                      gHpgpHalCB.remoteTei = gSTA_TEI;
 430   3                      TxdataBuff[HeaderOffset] =  ACK_FOR_STA_TEI_TESTID;
 431   3                      TxdataBuff[HeaderOffset + 1]  = gSTA_TEI;
 432   3                      Send_SinglePLCFrame(5, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
 433   3                      
 434   3                      
 435   3                  break;
 436   3                  case START_PLC_DATA_RATE_TESTID://4  tx pxmitttest data    //this is rec from sta that cco has
             - to start test by sending 1000 minirobo frames followed by std robo and hs mode
 437   3                    //  printf("START_PLC_DATA_RATE_TESTID\n");
 438   3                    label1:  
 439   3                    HHAL_ResetPlcStat();
 440   3                    gRoboMode = gRobomodeAllLenTest[gCount][0];
 441   3                    sendRobomodeFrames(gRobomodeAllLenTest[gCount][1],TOTAL_NUM_OF_TX_FRAME);
 442   3                    
 443   3                    switch(gRoboMode)
 444   3                    {
 445   4                      case HPGP_ROBOMD_MINI_100:
 446   4                           // printf("\n>>>CCO Transmitting MINI_ROBO frames to STA...\n");
 447   4                            gCurrRobomode = HPGP_ROBOMD_MINI_100;
 448   4                      break;
 449   4                      case  HPGP_ROBOMD_MINI_250:
 450   4                           // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");
 451   4                            gCurrRobomode = HPGP_ROBOMD_MINI_250;
 452   4                      break;
 453   4                      case HPGP_ROBOMD_STD_500:
 454   4                          // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");  
 455   4                           gCurrRobomode = HPGP_ROBOMD_STD_500;
 456   4                      break;
 457   4                     
 458   4                      case  HPGP_ROBOMD_HS_800:
 459   4                           //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
 460   4                           gCurrRobomode = HPGP_ROBOMD_HS_800;
 461   4                      break;
 462   4                      case HPGP_ROBOMD_HS_1000:
 463   4                           //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
 464   4                           gCurrRobomode = HPGP_ROBOMD_HS_1000;
 465   4                           //gCount = 0;
 466   4                      break;
 467   4                       
 468   4                    
 469   4                  }
 470   3                  strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 9   

 471   3                  HeaderOffset = 3; 
 472   3                  TxdataBuff[HeaderOffset] =  DATARATE_TEST_TESTID;
 473   3                  //printmsg(&TxdataBuff[0], 4);
 474   3                  Send_SinglePLCFrame(4, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
 475   3                
 476   3                      
 477   3                      
 478   3                      
 479   3                  break;
 480   3                  case PSTAT_TESTID://6 compare and display it rec all robo mode pstat
 481   3                      
 482   3                      //compare and display 
 483   3                      
 484   3                    //  printmsg(&RxDataBuff[0], 20); 
 485   3                      //printf("\n>>>CCO Received Statistcs from STA");
 486   3                      memcpy((char*)&HpgpHalCB.halStats, &RxDataBuff[0], sizeof(HpgpHalCB.halStats));
 487   3                      memcpy((char*)&plc_halstatus_t, &RxDataBuff[(sizeof(gHpgpHalCB.halStats) + 4)], sizeof(plc
             -_halstatus_t)); 
 488   3                     // printf("\nSTA Statistic\n\n\n");
 489   3                      //HHAL_DisplayPlcStatFromRAM(&HpgpHalCB.halStats, &plc_halstatus_t);
 490   3                   
 491   3                      
 492   3                     // if(HpgpHalCB.halStats.RxGoodDataCnt ==  gHpgpHalCB.halStats.TxDataCnt)
 493   3                      //{
 494   3                         
 495   3                          printf("\n\t\t\t\t\t RxGoodDataCnt = %lu\n", HpgpHalCB.halStats.RxGoodDataCnt);
 496   3                           per = TOTAL_NUM_OF_TX_FRAME - HpgpHalCB.halStats.RxGoodDataCnt;
 497   3                          
 498   3                           per = ((per * 100)/TOTAL_NUM_OF_TX_FRAME);
 499   3                         
 500   3                           /*if(per <= 1)
 501   3                              printf("\n\t\t\t\t\tPER is Less athen 1%");
 502   3                           else
 503   3                              printf("\nPER :  %u",per);
 504   3                                                          */
 505   3                          
 506   3                          if(gCurrRobomode == HPGP_ROBOMD_MINI_100 )
 507   3                          {
 508   4                              printf("\n\t\t\t\t\t MINI ROBO MODE PER = %lu",per);
 509   4                          }
 510   3                         
 511   3                          else  if((gCurrRobomode == HPGP_ROBOMD_MINI_250) || (gCurrRobomode == HPGP_ROBOMD_STD_
             -500) )
 512   3                          {
 513   4                              printf("\n\t\t\t\t\t STD ROBO MODE PER = %lu",per);
 514   4                          }
 515   3                          else if((gCurrRobomode == HPGP_ROBOMD_HS_800) || (gCurrRobomode == HPGP_ROBOMD_HS_1000
             -) )
 516   3                          {
 517   4                              printf("\n\t\t\t\t\t HS PB ROBO MODE PER = %lu",per);
 518   4                             
 519   4                          }
 520   3                           
 521   3                           printf("%c\n\n",'%');
 522   3                           printf("-----------------------------------------------------------------\n\n");
 523   3                          // printf("\nFrmLen = %d\n\n ", gRobomodeAllLenTest[gCount++][1]);
 524   3                          
 525   3                           HHAL_ResetPlcStat();
 526   3                           
 527   3                    //  }
 528   3      
 529   3                      gCount++;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 10  

 530   3                      if(gCount == 5)   //since this is last frame test
 531   3                      {
 532   4                          gCount = 0;
 533   4                          //oldssn = 0;
 534   4                          printf("\n\t\t\t\t TEST FINISHED, PRESS ENTER");
 535   4                          break;
 536   4                          
 537   4                          
 538   4                       }
 539   3                     goto label1; 
 540   3                      break;
 541   3                    
 542   3              }       //end of switch
 543   2          }//end of else
 544   1          
 545   1         
 546   1          for( i=0 ; i< plcRxFrmSwDesc->cpCount ; i++ )
 547   1          {
 548   2                  CHAL_DecrementReleaseCPCnt(plcRxFrmSwDesc->cpArr[i].cp);
 549   2          }
 550   1          
 551   1      }  
 552          #endif
 553          
 554          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
 555          
 556          void HHT_GetMinMaxLen ( sPlcSimTxTestParams* pTestParams, u8* stdModeSel, u8* minFrmLen, u8* maxFrmLen )
 557          {
 558   1          if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
 559   1          {
 560   2              if(pTestParams->roboTestMode == MINI_ROBO_TEST)
 561   2              {
 562   3                  *minFrmLen =  1 ;
 563   3                  *maxFrmLen = pTestParams->frmType?HYBRII_MINIROBO_DATALEN_MAX:HYBRII_MINIROBO_MGMTLEN_MAX;
 564   3              } 
 565   2              else if(pTestParams->roboTestMode == STD_ROBO_TEST) 
 566   2              {
 567   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 568   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
 569   3                  *stdModeSel = 1;
 570   3              } 
 571   2              else if(pTestParams->roboTestMode == HS1PB_ROBO_TEST)
 572   2              {
 573   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 574   3                  *maxFrmLen = pTestParams->frmType ?( HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
 575   3                  *stdModeSel = 0;
 576   3              }
 577   2              else if(pTestParams->roboTestMode == HS2PB_ROBO_TEST)
 578   2              {
 579   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX+1):(HYBRII_STD1PBHSROBO_M
             -GMTLEN_MAX+1);
 580   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX):(HYBRII_2PBHSROBO_MGMTLEN_M
             -AX);
 581   3              }
 582   2              else if(pTestParams->roboTestMode == HS3PB_ROBO_TEST)
 583   2              {
 584   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX+1):(HYBRII_2PBHSROBO_MGMTLEN
             -_MAX+1);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 11  

 585   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
             -AX);
 586   3              }
 587   2              else if(pTestParams->roboTestMode == HSALLPB_ROBO_TEST)
 588   2              {
 589   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 590   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
             -AX);
 591   3              }
 592   2          }
 593   1          else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
 594   1          {
 595   2              *stdModeSel = 1;
 596   2              *minFrmLen  = 1;
 597   2              *maxFrmLen  =  pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_MAX
             -);
 598   2          }
 599   1          else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
 600   1          {
 601   2              *stdModeSel = 1;
 602   2              *minFrmLen  = gAltRoboLenArr[0];
 603   2          }
 604   1      }
 605          
 606          void HHT_SimulateTx(sPlcSimTxTestParams* pTestParams)
 607          {
 608   1      //  sPlcTxFrmSwDesc plcTxFrmSwDesc;
 609   1      //#ifdef Packet_grouping
 610   1          u32             Sw_command_queue[8];
 611   1          u8              cmd_num;
 612   1      //#endif  
 613   1      //    uPlcTxPktQCAP_Write   cap_write;
 614   1      //    uTxCMDQueueWrite      txCmdQueueWrtie;
 615   1          sTxFrmSwDesc    plcTxFrmSwDesc;
 616   1          u8              stdModeSel;
 617   1          u16             stdRoboFrmLenMax;
 618   1          u8              minFrmLen;
 619   1          u8              maxFrmLen;
 620   1          u16             curFrmLen;     
 621   1          eFrmMcstMode    mcstMode;
 622   1          eHpgpHwFrmType  frmType;
 623   1          // mixed mode variables
 624   1          u16             tmpFrmLen;
 625   1          u8              curOffsetDW;
 626   1          u8              curDescLen;
 627   1          u8              eksArrIdx;
 628   1          uAltPlid        altPlid;
 629   1          uAltRoboLenIdx  altRoboLenIdx;        
 630   1          eStatus         status;
 631   1          u8              i, c;
 632   1          u8              j;
 633   1          u8              quit; 
 634   1          u16             tmpPayloadLen;
 635   1        u8        cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
 636   1          u8              dbc_pktchange;
 637   1      #ifndef HPGP_HAL_TEST
 638   1          sHaLayer        *hal = HOMEPLUG_GetHal();
 639   1      #endif
 640   1      
 641   1        dbc_pktchange     = 0;
 642   1          quit              = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 12  

 643   1          altPlid.val       = 0;
 644   1          altRoboLenIdx.val = 0;
 645   1          eksArrIdx         = 0;
 646   1      //#ifdef Packet_grouping0 
 647   1        cmd_num           = 0;     
 648   1      //#endif
 649   1      
 650   1          memset((u8*)&plcTxFrmSwDesc, 0x00, sizeof(plcTxFrmSwDesc));
 651   1          
 652   1          plcTxFrmSwDesc.frmInfo.plc.eks            = pTestParams->eks;       
 653   1          plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
 654   1          plcTxFrmSwDesc.frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_RSV;//HPGP_CONVLYRSAPTYPE_ETH; 
 655   1          plcTxFrmSwDesc.frmInfo.plc.snid = HYBRII_DEFAULT_SNID;
 656   1      
 657   1          if(pTestParams->frmType == 0)     
 658   1          {
 659   2                  plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_MGMT;
 660   2                  frmType                = HPGP_HW_FRMTYPE_MGMT;
 661   2          }
 662   1          else if(pTestParams->frmType == 1)
 663   1          {
 664   2              plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;
 665   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;
 666   2          }
 667   1          else if (pTestParams->frmType == 2) // frmType = 2
 668   1          {
 669   2              plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_SOUND;
 670   2              frmType                = HPGP_HW_FRMTYPE_SOUND;
 671   2              plcTxFrmSwDesc.frmInfo.plc.src     = pTestParams->src;
 672   2              plcTxFrmSwDesc.frmInfo.plc.saf     = pTestParams->saf;
 673   2              plcTxFrmSwDesc.frmInfo.plc.scf     = pTestParams->scf;
 674   2          }
 675   1        else if (pTestParams->frmType == HPGP_HW_FRMTYPE_RTS)
 676   1        {
 677   2            plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
 678   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
 679   2              plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
 680   2        }
 681   1        else if  (pTestParams->frmType == HPGP_HW_FRMTYPE_CTS)
 682   1          {
 683   2            plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
 684   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
 685   2              plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
 686   2        }
 687   1          
 688   1          mcstMode           = pTestParams->mcstMode;
 689   1          if(pTestParams->mcstMode == 0)   
 690   1          {
 691   2              plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;       
 692   2          }
 693   1          else
 694   1          {
 695   2              plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;
 696   2          }
 697   1      
 698   1          if(pTestParams->altPlidTest)
 699   1          {
 700   2              plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->plid; //0;
 701   2          }
 702   1          else
 703   1          {
 704   2              plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;   
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 13  

 705   2          }                                
 706   1        //printf("plid = %d\n",plcTxFrmSwDesc.frmInfo.plc.plid);  //[YM] debug Hybrii_B data pkt Tx
 707   1        
 708   1          plcTxFrmSwDesc.frmInfo.plc.stei           = gHpgpHalCB.selfTei;//HYBRII_DEFAULT_TEISTA;
 709   1      
 710   1      
 711   1          stdModeSel                    = pTestParams->stdModeSel;
 712   1      
 713   1          // Incremental/alternating length modes
 714   1          if(pTestParams->frmLen == 0)   //Continuous Tx mode
 715   1          {
 716   2              HHT_GetMinMaxLen(pTestParams, &stdModeSel, &minFrmLen, &maxFrmLen);
 717   2              
 718   2              stdRoboFrmLenMax = plcTxFrmSwDesc.frmType==HPGP_HW_FRMTYPE_MSDU?(HYBRII_STD1PBHSROBO_DATALEN_MAX):
             -(HYBRII_STD1PBHSROBO_MGMTLEN_MAX);               
 719   2              curFrmLen = minFrmLen;
 720   2              FM_Printf(FM_LINFO,"\nStarting from len = %u\n",curFrmLen);
 721   2          }
 722   1          else
 723   1          {
 724   2              // fixed length test
 725   2              curFrmLen = pTestParams->frmLen;
 726   2          }
 727   1          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = stdModeSel;
 728   1          curOffsetDW  = pTestParams->offsetDW;
 729   1          curDescLen   = pTestParams->descLen; 
 730   1          gHpgpHalCB.halStats.CurTxTestFrmCnt = 0;
 731   1        
 732   1          //for each frame
 733   1          while(1)
 734   1          {
 735   2              u8  frmData = 0;
 736   2              tmpFrmLen   = 0;
 737   2              tmpPayloadLen = 0;
 738   2      
 739   2              if (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
 740   2              {
 741   3                  if(pTestParams->frmLen <= 136)
 742   3                      plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //136;
 743   3                  else
 744   3                      plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //520;
 745   3              }
 746   2              else
 747   2              {
 748   3                  // check for mgmt frm max len, in case this is inclen & altfrmtype test
 749   3                  plcTxFrmSwDesc.frmLen         =  (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT && curFrmLen 
             -> HYBRII_3PBHSROBO_MGMTLEN_MAX) ? \
 750   3                                                    HYBRII_3PBHSROBO_MGMTLEN_MAX : curFrmLen ;  
 751   3              }   
 752   2          
 753   2              //[YM] Add DBC Code
 754   2            if (pTestParams->dbc)
 755   2            {
 756   3                if (pTestParams->pattern == 1)  // One RoBo + One Mini RoBo
 757   3                {
 758   4                      if (dbc_pktchange > 1)
 759   4                dbc_pktchange = 0;
 760   4              if (dbc_pktchange == 0)
 761   4                    {
 762   5                        plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 763   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  //Std RoBo
 764   5                    }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 14  

 765   4              else if (dbc_pktchange == 1)
 766   4              {
 767   5                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 768   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 769   5              }
 770   4                }
 771   3            else if (pTestParams->pattern == 2)  // Three Mini RoBo
 772   3            {
 773   4                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 774   4                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 775   4            }
 776   3            else if (pTestParams->pattern == 3)  //Two MiniRoBo + One HS RoBo 1 PB
 777   3            {
 778   4              if ((dbc_pktchange == 0)|(dbc_pktchange == 1))
 779   4                    {
 780   5                        plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 781   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 782   5                    }
 783   4              else
 784   4              {
 785   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 786   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 787   5              }
 788   4            }
 789   3            else if (pTestParams->pattern == 4)  //One MiniRoBo + One HS RoBo 2PB
 790   3            {
 791   4              if (dbc_pktchange == 0)
 792   4                    {
 793   5                        plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 794   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 795   5                    }
 796   4              else
 797   4              {
 798   5                  plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
 799   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 800   5              }
 801   4            }
 802   3            else if (pTestParams->pattern == 5)  //Two HS RoBo with 1 PB
 803   3            {
 804   4                    plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 805   4                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 806   4            }
 807   3            else if (pTestParams->pattern == 6)  //One Mini RoBo + One HS RoBo with 3 PB
 808   3            {
 809   4      
 810   4              if (dbc_pktchange == 0)
 811   4              {
 812   5                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 813   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 814   5              }
 815   4              else
 816   4              {
 817   5                plcTxFrmSwDesc.frmLen =  HYBRII_3PBHSROBO_DATALEN_MAX;
 818   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 819   5              } 
 820   4            }
 821   3            else if (pTestParams->pattern == 7)  //One RoBo + One HS RoBo with 1 PB
 822   3            {
 823   4              if (dbc_pktchange == 0)
 824   4              {
 825   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 826   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 15  

 827   5              }
 828   4              else
 829   4              {
 830   5                plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 831   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 832   5              } 
 833   4            }
 834   3            else if (pTestParams->pattern == 8)  //One HSRoBo with 1 PB + One HSRoBo with 2 PB
 835   3            {
 836   4              if (dbc_pktchange == 0)
 837   4              {
 838   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 839   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 840   5              }
 841   4              else
 842   4              {
 843   5                plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
 844   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 845   5              }
 846   4            }
 847   3              }
 848   2      
 849   2                  plcTxFrmSwDesc.cpCount        = 0; 
 850   2            plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = pTestParams->plid>0 ? HPGP_PPB_CAP123 : HPGP_PPB_CAP0;
 851   2                  plcTxFrmSwDesc.frmInfo.plc.mcstMode       = mcstMode;       
 852   2          
 853   2              if (mcstMode > 0)
 854   2                  plcTxFrmSwDesc.frmInfo.plc.phyPendBlks = HPGP_PPB_MCFRPT;
 855   2                else
 856   2                    plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = (pTestParams->plid > 0) ? HPGP_PPB_CAP123 : HPGP_
             -PPB_CAP0;             
 857   2      
 858   2          
 859   2              if(pTestParams->altPlidTest)
 860   2              {
 861   3                  pTestParams->plid = (gHpgpHalCB.halStats.CurTxTestFrmCnt & 0x3) ; //plid value will be changed
             - in sequence;
 862   3                  plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;    
 863   3              }
 864   2          else
 865   2            plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;
 866   2                          
 867   2              // create cp descriptors
 868   2              while(tmpFrmLen < plcTxFrmSwDesc.frmLen)
 869   2              {       
 870   3                  u8        cp;
 871   3                  u8        tmpOffsetDW;
 872   3                  u8        tmpOffsetByte;
 873   3                  u8        tmpDescLen;
 874   3                  u8        remDescLen;
 875   3                  u8        actualDescLen;
 876   3                  volatile u8 xdata *       cellAddr;
 877   3      
 878   3                  tmpOffsetDW =      curOffsetDW;
 879   3                  tmpDescLen  =      curDescLen; 
 880   3                  // Fetch CP
 881   3            //printf("(C)\n");
 882   3                  do
 883   3                  {
 884   4                      status = CHAL_RequestCP(&cp);
 885   4      #ifdef _FIXME_
              #ifdef HPGP_HAL_TEST
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 16  

                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')
                              {
                                  // Realease CPs fetched so far for current frame -- tbd
                                  quit = 1;
                                  break;
                              }
              
              #endif
 899   4                  }while (status != STATUS_SUCCESS);
 900   3                  // check for user initiated exit task
 901   3                  if(quit)
 902   3                  {
 903   4                      break;
 904   4                  }
 905   3            
 906   3                  i = plcTxFrmSwDesc.cpCount;
 907   3                  // test offset and desc len - only for first CPs
 908   3                  if((i==0 || i==1) && (pTestParams->frmType != 2))
 909   3                  //if(i==0 || i==1)
 910   3                  { 
 911   4                      if(pTestParams->altOffsetDescLenTest)
 912   4                      {
 913   5                          curOffsetDW--;
 914   5                          curDescLen+=4;    
 915   5                          tmpOffsetDW =      curOffsetDW;  
 916   5                          tmpDescLen  =      curDescLen;  
 917   5                          if( curOffsetDW==0 )
 918   5                          {
 919   6                              curOffsetDW  = pTestParams->offsetDW; // 0
 920   6                              curDescLen   = pTestParams->descLen;  //HYBRII_DEFAULT_SNID;
 921   6      //                        FM_Printf(FM_LINFO,"OffsetDW & DescLen resetting to %bu & %bu respectively\n", c
             -urOffsetDW, curDescLen);
 922   6                          }
 923   5                      } //printf("curOffsetDW = %bu, tempDescLen=%bu\n", tmpOffsetDW, tmpDescLen);              
             -              
 924   4                  }
 925   3                  else if(pTestParams->frmType == 2)
 926   3                  {
 927   4                        tmpOffsetDW =      0;  
 928   4                        tmpDescLen  =      curDescLen;  
 929   4                  }
 930   3                  else
 931   3                  {
 932   4                      tmpOffsetDW = 0;
 933   4                      tmpDescLen  = HYBRII_CELLBUF_SIZE;
 934   4                  }
 935   3      
 936   3                  tmpOffsetByte = tmpOffsetDW << 2;
 937   3                  actualDescLen =  (plcTxFrmSwDesc.frmLen-tmpFrmLen)>tmpDescLen ? tmpDescLen : (plcTxFrmSwDesc.f
             -rmLen-tmpFrmLen);
 938   3                  remDescLen    =  actualDescLen;
 939   3      
 940   3                  if(( i==0 || i==1 ) && tmpOffsetDW != 0)
 941   3                  {
 942   4                      FM_Printf(FM_LINFO,"curFrmLen = %u, curOffsetDW = %bu, curDescLen=%bu, free CPCnt = %bu\n"
             -, 
 943   4                                                   plcTxFrmSwDesc.frmLen, tmpOffsetDW, actualDescLen, CHAL_GetFr
             -eeCPCnt());
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 17  

 944   4                  }
 945   3                  //FM_Printf(FM_LINFO,"curOffsetByte = %bu, curDescLen=%bu\n", tmpOffsetByte, actualDescLen);
 946   3                  
 947   3                  // Fill Buffer with pattern
 948   3      #ifdef MEM_PROTECTION
                    // Get local CP buffer
                    cellAddr = &cp_localBuf[0];
              #else
 952   3                  cellAddr = CHAL_GetAccessToCP(cp);
 953   3      #endif
 954   3            memset(&cp_localBuf[0], 0, HYBRII_CELLBUF_SIZE);  // clear read buf for every new test
 955   3                  FM_Printf(FM_LINFO,"cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.halSt
             -ats.TxSeqNum);
 956   3                  //printf("cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.halStats.TxSeqN
             -um);
 957   3            
 958   3                  // Add Seq Num as first byte of first CP
 959   3                  if ( i==0 )
 960   3                  {
 961   4                      if (pTestParams->frmType != 2)
 962   4                      {
 963   5      #if  PLC_BCNDATA_FIXED_PATTERN
                              cellAddr[tmpOffsetByte] = 0xBB;
                              // Start frame data from seq num.
                              frmData   = (u8)(gHpgpHalCB.halStats.TxSeqNum+1);   
              
              #elif PLC_DATA_FIXED_PATTERN
 969   5      
 970   5                      cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
 971   5                      // Alternatig frame bytes
 972   5                      frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0xAA : 0x55 ;
 973   5      #endif        
 974   5                      tmpOffsetByte +=1;
 975   5                      remDescLen    -=1; 
 976   5                      }
 977   4                      else 
 978   4                      {                     
 979   5                          //cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
 980   5                          // Alternatig frame bytes
 981   5                          frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0x00 : 0x00 ;
 982   5       
 983   5                          //tmpOffsetByte +=1;
 984   5                          //remDescLen    -=1; 
 985   5                      }
 986   4                  }
 987   3      
 988   3                  if (pTestParams->frmType == 2) // Sound packet 
 989   3                  {
 990   4                      for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
 991   4                      {    
 992   5                          cellAddr[j] = 0x0;
 993   5                      }
 994   4                  }
 995   3                  else
 996   3                  {
 997   4                      for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
 998   4                      {
 999   5          #if  PLC_BCNDATA_FIXED_PATTERN
                                  cellAddr[j] = 0xBB;
                  #elif PLC_DATA_FIXED_PATTERN                    
1002   5                          cellAddr[j] = frmData;
1003   5                          frmData     = _cror_(frmData, 1);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 18  

1004   5          #else
                                  cellAddr[j] = frmData++;
                  #endif
1007   5                      }
1008   4                  }
1009   3      #if 0       
                          // [YM] debug message
                    printf("CP len: %bu, offset=%bu\n", remDescLen, tmpOffsetByte);                         
                    
                          for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
                          {
                              printf("0X%bx ", cellAddr[j]);
                      if ((j>0) && ((j % 20) == 0))
                        printf("\n");
                          } 
              #endif                              
1020   3            //printf("\n");
1021   3                  plcTxFrmSwDesc.cpArr[i].offsetU32 = tmpOffsetDW;
1022   3                  plcTxFrmSwDesc.cpArr[i].len       = actualDescLen; 
1023   3                  tmpFrmLen                        += plcTxFrmSwDesc.cpArr[i].len; 
1024   3                  plcTxFrmSwDesc.cpArr[i].cp        = cp;
1025   3                  plcTxFrmSwDesc.cpCount++;
1026   3                  tmpPayloadLen += (plcTxFrmSwDesc.cpArr[i].len - tmpOffsetByte);
1027   3      
1028   3                  // Alternate Encryption Test Mode
1029   3                  if(pTestParams->secTestMode == ALT_UNENC_NEK)
1030   3                  {
1031   4                      plcTxFrmSwDesc.frmInfo.plc.eks = (plcTxFrmSwDesc.frmInfo.plc.eks  >= HPGP_MAX_NEKS) ? 0  :
             - (plcTxFrmSwDesc.frmInfo.plc.eks + 1);
1032   4                  }
1033   3                  else if(pTestParams->secTestMode == ALT_UNENC_NEK_PPEK)
1034   3                  {
1035   4                      plcTxFrmSwDesc.frmInfo.plc.eks  = gAltEksTstArr[eksArrIdx++];
1036   4                      plcTxFrmSwDesc.frmInfo.plc.dtei = gHpgpHalCB.remoteTei;
1037   4                  }
1038   3      
1039   3      #ifdef MEM_PROTECTION
                    // now copy the CP local buf to the actual CP memory
                    if (HHAL_CP_Put_Copy(cp, cellAddr, HYBRII_CELLBUF_SIZE) == STATUS_FAILURE)
                    {
                      printf("HHT_SimulateTx: Failed to put a copy of CP %bu. Continue with nex CP\n", cp);
                      continue;
                    }
              #endif
1047   3              } 
1048   2            
1049   2          
1050   2      #ifdef Packet_grouping0
                      //[YM] Check multiple packet queueing is requested or not
                      if (gHpgpHalCB.plcMultiPktTest > 1 )
                      {
                              cmd_num++;
              
                      //printf("1-0. cmd_num = %bu \n", cmd_num);
                              /*  Write PLC Command Queue Write Register to trigger HW Tx */
                              txCmdQueueWrtie.reg = 0;
                              txCmdQueueWrtie.s.txQ = pTestParams->plid;
                            txCmdQueueWrtie.s.txCap = pTestParams->plid;
                            txCmdQueueWrtie.s.txRobo = pTestParams->stdModeSel;
              #ifdef ETH_BRDG_DEBUG
                      if (myDebugFlag)
                      {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 19  

                        //printf("txCmdQueueWrtie.reg = %lx\n",txCmdQueueWrtie.reg);
                      //printf("txCmdQueueWrtie.s.txQ = %bu\n", txCmdQueueWrtie.s.txQ);
                      printf("txCmdQueueWrtie.s.txCap = %bu\n", txCmdQueueWrtie.s.txCap);
                      //printf("txCmdQueueWrtie.s.txRobo = %bu\n", txCmdQueueWrtie.s.txRobo);
                      }
              #endif  //ETH_BRDG_DEBUG
                      //WriteU32Reg(PLC_CMDQ_REG, txCmdQueueWrtie.reg);
                      //[YM] store command queue setting value to a software queue, will write all stored command queue sett
             -ing value to 
                      //command queue later
                      Sw_command_queue[cmd_num - 1] = txCmdQueueWrtie.reg;
                      if (cmd_num > (gHpgpHalCB.plcMultiPktTest - 1))
                        {
                                     u8 p;
                           
                           // Write all the store command settings in sw command queue [64] to HW command queue register
                           for (p = 0; p < gHpgpHalCB.plcMultiPktTest; p++)
                            {
                               WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
              #ifndef MPER               
                             printf("Write PLC_CMDQ_REQ = %u\n", Sw_command_queue[p]);
              #endif  //MPER
                            }
                           if (cmd_num > 0)
              #ifndef MPER              
                               printf("1. Write PLC_CMDQ_REG %bu times\n", cmd_num);
              #endif  //MPER
                           cmd_num = 0;
                           gHpgpHalCB.plcMultiPktTest = 0;
                        }
                      }
              #endif  //Packet_grouping0  
1096   2              // check for user initiated exit task
1097   2              if(status == STATUS_SUCCESS)
1098   2              {
1099   3                         u16 pkt_retry = 0;
1100   3                  do
1101   3                  {
1102   4                      // Transmit the frame;
1103   4                      //printf("(D)\n");
1104   4      #ifdef HPGP_HAL_TEST
                              status = HHAL_PlcTxQWrite(&plcTxFrmSwDesc);
              #else
1107   4                      status = HHAL_PlcTxQWrite(hal, &plcTxFrmSwDesc);
1108   4      #endif
1109   4              if (status == STATUS_FAILURE)
1110   4              {
1111   5                pkt_retry++;
1112   5                //printf("Write PLC Tx Q failed, %bu times, cp = %bu\n", pkt_retry, plcTxFrmSwDesc.cpCount);
1113   5                // [YM] - retry the packet transmission until it failed too many times
1114   5      
1115   5                          CHAL_DelayTicks(64);
1116   5                if (pkt_retry > 2000)   //[YM] extended delay loop, high PER condition will make Tx stop too quick
1117   5                {
1118   6      #ifndef MPER          
1119   6                              printf("\nWrite PLC Tx Q failed, cp = %bu, Quit!!\n", plcTxFrmSwDesc.cpCount);
1120   6      #endif
1121   6                    quit = 1;
1122   6                    break;
1123   6                }
1124   5              }
1125   4                      // check for user initiated exit task from infinite loop
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 20  

1126   4      #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
1129   4                      c = poll_key();
1130   4      #endif
1131   4                      if( c == 'q')              
1132   4                      {
1133   5                          // if TxQWrite failed, release CPs for current frame -- tbd
1134   5                          quit = 1;
1135   5                          break;
1136   5                      }
1137   4                  } while(status == STATUS_FAILURE);
1138   3                    pkt_retry = 0;
1139   3              }
1140   2      
1141   2           
1142   2              if(status == STATUS_SUCCESS)
1143   2              {
1144   3                  gHpgpHalCB.halStats.CurTxTestFrmCnt++;
1145   3                  gHpgpHalCB.halStats.TxSeqNum++;
1146   3      
1147   3                  // check for alternating plid
1148   3                  plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->altPlidTest ? altPlid.s.plid++ : pTestParams->p
             -lid;
1149   3      
1150   3                  // check for alternating frametype
1151   3                  if(pTestParams->altFrmTypeTest)
1152   3                  {
1153   4                      plcTxFrmSwDesc.frmType = (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MSDU) ? HPGP_HW_FRMTYP
             -E_MGMT : HPGP_HW_FRMTYPE_MSDU;
1154   4                  }
1155   3                  else
1156   3                  {
1157   4                      plcTxFrmSwDesc.frmType = frmType;
1158   4                  }
1159   3      
1160   3                  // check for alternating mcstMode
1161   3                  if(pTestParams->altMcstTest)
1162   3                  {
1163   4                      if(mcstMode == 2)
1164   4                      {
1165   5                          mcstMode = 0;
1166   5                          plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;         
1167   5                      }
1168   4                      else
1169   4                      {
1170   5                          mcstMode++;
1171   5                          plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;       
1172   5                      }
1173   4                  }
1174   3      
1175   3            if (!pTestParams->dbc)
1176   3            {
1177   4                  // check for incremental length single robo
1178   4                  if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
1179   4                  {
1180   5                      curFrmLen++;
1181   5                      if(curFrmLen > maxFrmLen)
1182   5                      {
1183   6                          FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
1184   6                          curFrmLen = minFrmLen;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 21  

1185   6                      }
1186   5                  }             
1187   4                  // check for incremental length all robo
1188   4                  else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
1189   4                  {
1190   5                      curFrmLen++;            
1191   5                      if(curFrmLen > stdRoboFrmLenMax && plcTxFrmSwDesc.frmInfo.plc.stdModeSel)
1192   5                      {
1193   6                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
1194   6                          curFrmLen                 = HYBRII_MINIROBO_DATALEN_MAX+1;
1195   6                          FM_Printf(FM_LINFO,"Switching to HS Mode; len = %u\n",curFrmLen);
1196   6                          
1197   6                      }
1198   5                      // restart inc len test
1199   5                      if(curFrmLen > maxFrmLen)
1200   5                      {
1201   6                          FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
1202   6                          curFrmLen                 = minFrmLen;
1203   6                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;                  
1204   6                      }
1205   5                  } 
1206   4                  // check for fixed length alternating robo
1207   4                  else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
1208   4                  {
1209   5                      curFrmLen  = gAltRoboLenArr[altRoboLenIdx.s.idx++];
1210   5                  }
1211   4            }
1212   3            else  //DBC Test
1213   3            {
1214   4                if (dbc_pktchange == 0)
1215   4                dbc_pktchange = 1;
1216   4              else if (dbc_pktchange == 1)
1217   4                dbc_pktchange = 2;
1218   4              else
1219   4                dbc_pktchange = 0;
1220   4            }
1221   3              
1222   3              }
1223   2          
1224   2              if((gHpgpHalCB.halStats.CurTxTestFrmCnt & (u32)(0xFF)) == 0)
1225   2              {  
1226   3                  printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b
             -\b\b\b");
1227   3                  printf("Sent %ld, Received %ld HPGP frames.", gHpgpHalCB.halStats.CurTxTestFrmCnt, gHpgpHalCB.
             -halStats.TotalRxGoodFrmCnt - gHpgpHalCB.halStats.RxGoodBcnCnt);
1228   3              }
1229   2      
1230   2          
1231   2              if(!pTestParams->contMode)
1232   2              {
1233   3                  pTestParams->numFrames--;
1234   3      //      printf(" Remaining Tx packet number = %ld\n",pTestParams->numFrames);
1235   3                  if(!pTestParams->numFrames)
1236   3                  {
1237   4                      quit = 1;
1238   4                  }
1239   3              }
1240   2      
1241   2          
1242   2              if(!quit && pTestParams->delay != 0xFF)
1243   2              {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 22  

1244   3                  u32 delay64ticks = pTestParams->delay;
1245   3                  if(delay64ticks == 0)
1246   3                  {
1247   4                      printf("press c to continue\n");
1248   4                      while(1)
1249   4                      {
1250   5      #ifdef HPGP_HAL_TEST
                                  u8 userInput = CHT_Poll();
              #else
1253   5                          u8 userInput = poll_key();
1254   5      #endif
1255   5                          if( userInput == 'c' || userInput == 'C')
1256   5                          {
1257   6                              // exit delay loop and resume transmission
1258   6                              break;                      
1259   6                          }
1260   5                          else if( userInput == 'q' || userInput == 'Q')
1261   5                          {
1262   6                              // exit delay loop and quite transmission
1263   6                              quit = 1;
1264   6                              break;
1265   6                          }
1266   5                      }
1267   4                  }
1268   3                  else
1269   3                  while(delay64ticks--)
1270   3                  {
1271   4                      CHAL_DelayTicks(64);
1272   4                      // check for user initiated exit task from infinite loop
1273   4                      
1274   4      #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
1277   4                      c = poll_key();
1278   4      #endif
1279   4                      if( c == 'q')              
1280   4                      {
1281   5                          quit = 1;
1282   5                          break;
1283   5                      }
1284   4                  }  
1285   3              }
1286   2          
1287   2              if(quit )//|| CHAL_GetFreeCPCnt() < 100 || HHAL_GetPlcTxQFreeDescCnt(plcTxFrmSwDesc.plid) < 32 )
1288   2              {
1289   3      //#ifdef Packet_grouping0
1290   3              //[YM] write sw command queue setting values to HW command queue
1291   3              //printf("2. Write PLC_CMDQ_REG %bu times\n", cmd_num);
1292   3          while (cmd_num > 0)
1293   3          {
1294   4                             u8 p;
1295   4                   
1296   4                   //printf("(F)\n");
1297   4                   // Write all the store command settings in sw command queue [64] to HW command queue register
1298   4                   for (p = 0; p < cmd_num; p++)
1299   4                       WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
1300   4                   cmd_num--;
1301   4          }
1302   3      //#endif
1303   3      
1304   3      
1305   3                 // printf("Sent %ld HPGP frames.\n", gHpgpHalCB.halStats.CurTxTestFrmCnt);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 23  

1306   3                 // printf("Quit Tx: Free CP Cnt = %bu, curFrmLen = %u\n", CHAL_GetFreeCPCnt(), curFrmLen);
1307   3                  break;
1308   3              }       
1309   2          } // while(1)   
1310   1      }
1311          
1312          #endif
1313          /*u32 TX_RXLatency_TCC[8] = {
1314                             
1315                              0x321e0417,  //TCC =1
1316                             // 0x336F0417,
1317                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
1318                              0x34ca0417,
1319                              0x361F0417,
1320                              0x37750417,
1321                              0x38c20417,
1322                              0x3a180417,
1323                              0x3b740417,  //TCC= 8
1324          
1325          };*/
1326          
1327          
1328          
1329          
1330          #ifdef POWER_SAVE
              extern u16 psNoTxFrm;
              
              void HHAL_SetTxRxEn(u8 mode)
              {
                  uPlcStatusReg         plcStatus;
              
                  if (mode == TxRxEnState.state)
                  {
                      plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                    IRQ_DISABLE_INTERRUPT();  // this function can also be called from timer interrupt
                      // mode = 0: enable, 1: disable
                  if (mode == 1)
                  {
                    // disable TxRxEn
                        plcStatus.s.nTxEn  = 1;
                        plcStatus.s.nRxEn = 1;
                        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Disabled\n");
                        if (gHpgpHalCB.devMode == DEV_MODE_STA)
                    {
                            // STA: we just disabled TxRxEn, set a timer to wake
                            // up and enable them again so we can receive
                            // next beacon. Only do this for STA, CCO uses the BCN Tx
                      // interrupt and BCN Sent interrupt to wake up
                            TxRxEnState.StarttimerIntCnt = gHalCB.timerIntCnt;
                            TxRxEnState.StartRxGoodBcnCnt = gHpgpHalCB.halStats.RxGoodBcnCnt;
                        }
                  }
                  else
                  {
                    // enable TxRxEn
                      plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                        plcStatus.s.nTxEn  = 0;
                    //plcStatus.s.randomBackoff = 1;  //added by YM 
                    // below is sequence to re-enable RxEn
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 24  

                      plcStatus.s.rxSoftReset = 1;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                      CHAL_DelayTicks(10);
                      plcStatus.s.rxSoftReset = 0;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Enabled\n");
                  }
                      TxRxEnState.state = !mode;    // State =  0: Disabled, 1: Enabled
                      IRQ_DISABLE_INTERRUPT();
                }
              }
              
              // HHAL_DisTxRxEn is called by the HW timer interrupt every 4 ms
              void HHAL_DisTxRxEn()
              {
                 if (!plc_powersave || TxRxEnState.state ||
                    (gHpgpHalCB.devMode == DEV_MODE_CCO))
                  // this timer ISR is only used in STA
                     return;
                  
                  if(gHalCB.timerIntCnt >= (TxRxEnState.StarttimerIntCnt + 18))
                  {
                      // STA should receive a central beacon every 33 ms 
                      // (50 Mhz) or 44 ms (60 Mhz). gHalCB.timerIntCnt is
                      // incremented every timer interrupt cycle, ie. 4ms.
                      // Enable TxRxEn so it can receive the next beacon 
                  if (ethDebugON)
                  {
                     printf("Timer INT: ON TxRxEn\n");
                     printf("Timer INT: gHalCB.timerIntCnt=%lu, TxRxEnState.StarttimerIntCnt=%lu\n", gHalCB.timerIntCnt, T
             -xRxEnState.StarttimerIntCnt);
                  } 
                      HHAL_SetTxRxEn(0);
                  }
              }
              #endif     //POWER_SAVE
1403          
1404          // this is specific to Hybrii B
1405          void set_plc_paramter(u8 sel, u32 u32Val)
1406          {
1407   1          union {
1408   1              u8  chval[4];
1409   1              u32 reg;
1410   1          }  val;
1411   1      
1412   1          val.reg = 0;
1413   1          val.chval[0] = sel;
1414   1      
1415   1          WriteU32Reg(PLC_PLCPARASEL_REG, val.reg);
1416   1          WriteU32Reg(PLC_PARA_DATAWR_REG, ctorl(u32Val));
1417   1      }
1418          
1419          
1420          /*******************************************************************
1421          * NAME :            HHAL_mpiRxReset
1422          *
1423          * DESCRIPTION :     Reset mpi Rx MAC block
1424          *
1425          * INPUTS :
1426          *       PARAMETERS:
1427          *      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 25  

1428          *
1429          * OUTPUTS :
1430          *       None
1431          *
1432          */
1433          /*  Hybrii A only
1434          void HHAL_mpiRxReset(void)
1435          {
1436              uPlcResetReg plcReset;
1437          
1438              plcReset.reg = 0;
1439              plcReset.s.mpiRxReset = 1;
1440              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1441              CHAL_DelayTicks(2);
1442              plcReset.reg = 0;
1443              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1444          }*/
1445          
1446          
1447          /*******************************************************************
1448          * NAME :            HHAL_PhyPgmRoboMd
1449          *
1450          * DESCRIPTION :     Programs Rx to a particular Robo Md.
1451          *
1452          * INPUTS :
1453          *       PARAMETERS:
1454          *           eHpgpRpoboMod roboMd
1455          *
1456          * OUTPUTS :
1457          *       None
1458          *
1459          */
1460          void HHAL_PhyPgmRoboMd(eRegFlag enbRoboMdPgm, ePlcPhyRxRoboMod roboMd, ePlcNumPBs numPBs)
1461          {
1462   1          uPhyRxEnbRoboReg  phyRxEnbRobo;
1463   1          uPhyRxRoboMdReg   phyRxRoboMd;
1464   1          uPhyNumPBReg      phyNumPBs;
1465   1      
1466   1          // Write Rx Robo Mode override bit.
1467   1          phyRxEnbRobo.reg         = ReadU8Reg(PLC_RXROBOENB_REG);
1468   1          phyRxEnbRobo.s.enbRobo   = enbRoboMdPgm;
1469   1          WriteU8Reg(PLC_RXROBOENB_REG, phyRxEnbRobo.reg);
1470   1      
1471   1          // Write Rx Robo Mode.
1472   1          if(enbRoboMdPgm)
1473   1          {
1474   2              phyRxRoboMd.reg          = ReadU8Reg(PLC_RXROBOMD_REG);
1475   2              phyRxRoboMd.s.roboMd     = roboMd;
1476   2              WriteU8Reg(PLC_RXROBOMD_REG, phyRxRoboMd.reg);
1477   2      
1478   2              // Write Number of PBs
1479   2              if( roboMd == PLCPHY_ROBOMD_HS )
1480   2              {
1481   3                  phyNumPBs.reg          = ReadU8Reg(PLC_RXNUMPB_REG);
1482   3                  phyNumPBs.s.enbNumPBs  = 1; 
1483   3                  phyNumPBs.s.numPBs     = numPBs;
1484   3                  WriteU8Reg(PLC_RXNUMPB_REG, phyNumPBs.reg);
1485   3              }
1486   2          }        
1487   1      }
1488          
1489          /*******************************************************************
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 26  

1490          * NAME :            HHAL_SetACLine50HzFlag
1491          *
1492          * DESCRIPTION :     Sets or Clears CpuSwStatus.acLine50Hz flag.
1493          *
1494          * INPUTS :
1495          *       PARAMETERS:
1496          *           eRegFlag acLin50Hz
1497          *
1498          * OUTPUTS :
1499          *       None
1500          *
1501          */
1502          /*void HHAL_SetACLine50HzFlag(eRegFlag acLin50Hz)
1503          {
1504              uPlcLineControlReg plcLineCtrl;
1505          
1506              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1507              plcLineCtrl.s.acCycle50Hz = acLin50Hz;
1508              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
1509          } */
1510          
1511          /*******************************************************************
1512          * NAME :            HHAL_SetPlcDevMode()
1513          *
1514          * DESCRIPTION :     Sets PLC Device Mode.
1515          *
1516          * INPUTS :
1517          *       PARAMETERS:
1518          *           eRegFlag regFlag
1519          *
1520          * OUTPUTS :
1521          *       None
1522          *
1523          */
1524          void HHAL_SetPlcDevMode(ePlcDevMode plcDevMode)
1525          {
1526   1          uPlcDevCtrlReg PlcDevCtrl;
1527   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1528   1          PlcDevCtrl.s.plcDevMode = plcDevMode;
1529   1          WriteU32Reg(PLC_DEVCTRL_REG,PlcDevCtrl.reg);
1530   1      }
1531          
1532          
1533          #ifdef FREQ_DETECT
1534          void FREQDET_FreqSetting(u8 frequency)
1535          {
1536   1          
1537   1                     
1538   1          if(frequency == FREQUENCY_50HZ)
1539   1          {                
1540   2              gHpgpHalCB.lineFreq = FREQUENCY_50HZ;
1541   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1542   2              {
1543   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_50HZ;
1544   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_50HZ;                    
1545   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1546   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
1547   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1548   3              }
1549   2              else
1550   2              {
1551   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_50HZ; 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 27  

1552   3                  //WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1553   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1554   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer)); 
1555   3                  PLC_MIN_AC_BPLEN  =           0xF3000;
1556   3                  PLC_MAX_AC_BPLEN  =           0xF6000; 
1557   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_50Hz;
1558   3              }
1559   2             // printf("\n50 HZ detected\n");
1560   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_SET);
1561   2              
1562   2              //WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1563   2          }
1564   1          else // 60 hz
1565   1          {                
1566   2              gHpgpHalCB.lineFreq = FREQUENCY_60HZ;
1567   2             // printf("\n60 HZ detected\n");
1568   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1569   2              {
1570   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_60HZ;   
1571   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_60HZ;                    
1572   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1573   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;                    
1574   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1575   3              }
1576   2              else
1577   2              {
1578   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_60HZ; 
1579   3      //            WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1580   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1581   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer)); 
1582   3                  PLC_MIN_AC_BPLEN  =           0xCB300;
1583   3                  PLC_MAX_AC_BPLEN  =           0xCBA00; 
1584   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_60Hz;//this is done just to avoid noise or spike while det
             -ecting zero cross
1585   3              }
1586   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_CLR);                
1587   2          }
1588   1      /*#ifndef HPGP_HAL_TEST
1589   1          CTRLL_SendFreqDetectedEvent();
1590   1      #endif*/
1591   1      }
1592          
1593          #endif
1594          /*******************************************************************
1595          * NAME :            HHAL_GetPlcDevMode
1596          *
1597          * DESCRIPTION :     Returns PLC Device Mode.
1598          *
1599          * INPUTS :
1600          *       None
1601          *
1602          * OUTPUTS :
1603          *       None
1604          *
1605          */
1606          ePlcDevMode HHAL_GetPlcDevMode()
1607          {
1608   1          uPlcDevCtrlReg PlcDevCtrl;
1609   1      
1610   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1611   1      
1612   1          return((ePlcDevMode)PlcDevCtrl.s.plcDevMode);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 28  

1613   1      }
1614          
1615          
1616          /*******************************************************************
1617          * NAME :            HHAL_SetSWStatReqScanFlag
1618          *
1619          * DESCRIPTION :     Sets or clears PLC Scan Mode.
1620          *
1621          * INPUTS :
1622          *       PARAMETERS:
1623          *           eRegFlag scanEnb
1624          *
1625          * OUTPUTS :
1626          *       None
1627          *
1628          */
1629          void HHAL_SetSWStatReqScanFlag(eRegFlag scanEnb)
1630          {
1631   1          uPlcLineControlReg plcLineCtrl;
1632   1          uPlcDevCtrlReg  plcDevCtrl;
1633   1      
1634   1          plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1635   1          plcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1636   1          plcLineCtrl.s.reqScanning = scanEnb;
1637   1          //gHpgpHalCB.scanEnb    = scanEnb;   
1638   1          if(scanEnb && !gHpgpHalCB.scanEnb)
1639   1          {
1640   2              plcDevCtrl.s.snidValid    = 1;  // ask TRI
1641   2              gHpgpHalCB.syncComplete   = 0;
1642   2              gHpgpHalCB.halStats.RxGoodBcnCnt   = 0;
1643   2              gHpgpHalCB.halStats.syncTestValIdx = 0;
1644   2              gHpgpHalCB.nwSelected     = 0;
1645   2      
1646   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Enable\n");
1647   2      
1648   2          }
1649   1          if(!scanEnb)
1650   1          {
1651   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Disable\n");
1652   2      
1653   2          }
1654   1          gHpgpHalCB.scanEnb    = scanEnb;   
1655   1          WriteU32Reg(PLC_LINECTRL_REG,plcLineCtrl.reg);
1656   1          WriteU32Reg(PLC_DEVCTRL_REG,plcDevCtrl.reg);
1657   1      }
1658          
1659          
1660          /*******************************************************************
1661          * NAME :            HHAL_GetTei
1662          *
1663          * DESCRIPTION :     Sets local TEI.
1664          *
1665          * INPUTS :
1666          *       PARAMETERS:
1667          *           None
1668          *
1669          * OUTPUTS :
1670          *       u8 tei
1671          *
1672          */
1673          u8 HHAL_GetTei()
1674          {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 29  

1675   1          uPlcDevCtrlReg PlcDevCtrl;
1676   1          u8             stei;
1677   1          
1678   1          PlcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1679   1          stei = PlcDevCtrl.s.stei;
1680   1      
1681   1          return stei;         
1682   1      }
1683          
1684          /*******************************************************************
1685          * NAME :            HHAL_SetTei
1686          *
1687          * DESCRIPTION :     Sets local TEI.
1688          *
1689          * INPUTS :
1690          *       PARAMETERS:
1691          *           u8 tei
1692          *
1693          * OUTPUTS :
1694          *       None
1695          *
1696          */
1697          void HHAL_SetTei(u8 stei)
1698          {
1699   1          uPlcDevCtrlReg PlcDevCtrlReg;
1700   1      #ifdef HPGP_HAL_TEST
                  gHpgpHalCB.selfTei  = stei;
              #else
1703   1          gHpgpHalCB.tei  = stei;
1704   1      #endif   //HPGP_HAL_TEST
1705   1          PlcDevCtrlReg.reg   = ReadU32Reg(PLC_DEVCTRL_REG);
1706   1          PlcDevCtrlReg.s.stei = stei;
1707   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1708   1      }
1709          
1710          /*******************************************************************
1711          * NAME :            HHAL_GetSnid
1712          *
1713          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1714          *
1715          * INPUTS :
1716          *       PARAMETERS:
1717          *           eRegFlag regFlag
1718          *
1719          * OUTPUTS :
1720          *       None
1721          *
1722          */
1723          u8 HHAL_GetSnid()
1724          {
1725   1          uPlcDevCtrlReg PlcDevCtrlReg;
1726   1          u8             snid;
1727   1      
1728   1          PlcDevCtrlReg.reg       = ReadU32Reg(PLC_DEVCTRL_REG);
1729   1          snid                 = PlcDevCtrlReg.s.snid;
1730   1      
1731   1          return snid;
1732   1      }
1733          
1734          /*******************************************************************
1735          * NAME :            HHAL_SetSnid
1736          *
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 30  

1737          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1738          *
1739          * INPUTS :
1740          *       PARAMETERS:
1741          *           u8 snid
1742          *
1743          * OUTPUTS :
1744          *       None
1745          *
1746          */
1747          void HHAL_SetSnid(u8 snid)
1748          {
1749   1          uPlcDevCtrlReg PlcDevCtrlReg;
1750   1      
1751   1          gHpgpHalCB.snid      = snid;
1752   1          PlcDevCtrlReg.reg    = ReadU32Reg(PLC_DEVCTRL_REG);
1753   1          PlcDevCtrlReg.s.snid = snid;
1754   1          if(gHpgpHalCB.devMode == DEV_MODE_CCO || !gHpgpHalCB.scanEnb)
1755   1          {
1756   2              PlcDevCtrlReg.s.snidValid = 1;
1757   2              FM_Printf(FM_MINFO, "SetSnid:%bu\n", snid);
1758   2      
1759   2          }
1760   1          else
1761   1          {
1762   2              /*// FIXME : -- sync with HMAC on the use of Set SNID for STA side
1763   2              if(gHpgpHalCB.halStats.RxGoodBcnCnt >= PLC_BCNTST_SYNCTHRES)
1764   2              {
1765   2                  gHpgpHalCB.nwSelected  = 1;
1766   2                  FM_Printf(FM_MINFO, "HHAL_SetSnid: network Selected, snid = %bu\n", snid);      
1767   2              }
1768   2              else
1769   2              {
1770   2              PlcDevCtrlReg.s.snidValid = 0;
1771   2              }
1772   2                    */
1773   2      
1774   2                    gHpgpHalCB.nwSelected  = 1;
1775   2                    PlcDevCtrlReg.s.snidValid = 1;
1776   2          }
1777   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1778   1      }
1779          
1780          void HHAL_DisableLMBcnBuf(u8 bcnType)
1781          {
1782   1         gHpgpHalCB.lmBcn.txBitmap &= ~((1 << bcnType));
1783   1      }
1784          
1785          void HHAL_SetLMBcnBuf(u8 *buff, u8 bcnType, u8 bpstoOffset)
1786          {
1787   1          if (bcnType == BEACON_TYPE_CENTRAL)
1788   1          {
1789   2              memcpy(&gHpgpHalCB.lmBcn.cBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.cBcn.bcnBuff));
1790   2              gHpgpHalCB.lmBcn.cBcn.bpstoOffset = bpstoOffset;
1791   2      
1792   2      
1793   2          }
1794   1      #if 0 
                  else
                  if (bcnType == BEACON_TYPE_DISCOVER)
                  {
                      memcpy(&gHpgpHalCB.lmBcn.dBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.dBcn.bcnBuff));
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 31  

                      gHpgpHalCB.lmBcn.dBcn.bpstoOffset = bpstoOffset;
                  }
              #endif
1802   1      
1803   1          gHpgpHalCB.lmBcn.txBitmap |= (1 << bcnType);
1804   1      }   
1805          
1806          /*******************************************************************
1807          * NAME :            HHAL_SetCsmaRegions
1808          *
1809          * DESCRIPTION :     Sets CSMA Regions - takes effect only next BPST.
1810          *                   Startime,EndTime,Duration in units of ATU = 10.24uS
1811          *                   Starttime is number of ATUs from EndTime of prev region.
1812          *
1813          * INPUTS :
1814          *       PARAMETERS:
1815          *           eRegFlag regFlag
1816          *
1817          * OUTPUTS :
1818          *       None
1819          *
1820          */
1821          void HHAL_SetCsmaRegions(sCsmaRegion* regionArr, u8 regionCnt)
1822          {
1823   1          uCSMARegionReg  csmaRegion;
1824   1          u8 i;
1825   1          u8 csmaRegionCnt;
1826   1      
1827   1          csmaRegionCnt = HYBRII_MAXSMAREGION_CNT < regionCnt ? HYBRII_MAXSMAREGION_CNT: regionCnt;
1828   1          //for (j=0; j<csmaRegionCnt; j++) {
1829   1         //     FM_Printf(FM_USER, "region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n", 
1830   1          //        j, regionArr[j].startTime, regionArr[j].endTime, regionArr[j].rxOnly);
1831   1         // }
1832   1          for( i=0 ; i<csmaRegionCnt ; i++ )
1833   1          {
1834   2              csmaRegion.s.csma_start_time_lo = 0;//regionArr[i].startTime & CSMAREG_STARTTMLO_MASK;
1835   2              csmaRegion.s.csma_start_time_hi = 0;//(regionArr[i].startTime & CSMAREG_STARTTMHI_MASK) >> CSMAREG
             -_STARTTMHI_POS ;
1836   2              csmaRegion.s.csma_rxOnly      = regionArr[i].rxOnly;
1837   2              csmaRegion.s.csma_endtime_lo  = regionArr[i].endTime & CSMAREG_DURATIONLO_MASK;
1838   2              csmaRegion.s.csma_endtime_hi  = (regionArr[i].endTime & CSMAREG_DURATIONHI_MASK) >> CSMAREG_DURATI
             -ONHI_POS ;
1839   2              csmaRegion.s.csma_hybrid    = regionArr[i].hybridMd;
1840   2              switch(i)
1841   2              {
1842   3                  case 0:
1843   3                      WriteU32Reg(PLC_CSMAREGION0_REG, csmaRegion.reg);
1844   3                      break;
1845   3                  case 1:
1846   3                      WriteU32Reg(PLC_CSMAREGION1_REG , csmaRegion.reg);
1847   3                      break;
1848   3                  case 2:
1849   3                      WriteU32Reg(PLC_CSMAREGION2_REG, csmaRegion.reg);
1850   3                      break;
1851   3                  case 3:
1852   3                      WriteU32Reg(PLC_CSMAREGION3_REG, csmaRegion.reg);
1853   3                      break;
1854   3                  case 4:
1855   3                      WriteU32Reg(PLC_CSMAREGION4_REG, csmaRegion.reg);
1856   3                      break;
1857   3                  case 5:
1858   3                      WriteU32Reg(PLC_CSMAREGION5_REG, csmaRegion.reg);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 32  

1859   3                      break;
1860   3                  default:
1861   3                      {
1862   4      
1863   4                      }
1864   3      
1865   3              }
1866   2          }
1867   1      }
1868          
1869          
1870          /*******************************************************************
1871          * NAME :            HHAL_SetDiagMode
1872          *
1873          * DESCRIPTION :     Sets or clears PLC Tx/Rx Diagnostic mode operation.
1874          *
1875          * INPUTS :
1876          *       PARAMETERS:
1877          *           eRegFlag regFlag
1878          *
1879          * OUTPUTS :
1880          *       None
1881          *
1882          */
1883          void HHAL_SetDiagMode(eRegFlag regFlag)
1884          {
1885   1          uPlcStatusReg plcStatus;
1886   1      
1887   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1888   1          if(regFlag)
1889   1          {
1890   2              gHpgpHalCB.diagModeEnb = 1;
1891   2          }
1892   1          else
1893   1          {
1894   2              gHpgpHalCB.diagModeEnb = 0;
1895   2          }
1896   1          plcStatus.s.contTxDiag = regFlag;
1897   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1898   1      }
1899          
1900          /*******************************************************************
1901          * NAME :            HHAL_SetDiagModeNoSack
1902          *
1903          * DESCRIPTION :     Enables or Disables ACK during Diagnostic mode operation.
1904          *
1905          * INPUTS :
1906          *       PARAMETERS:
1907          *           eRegFlag regFlag
1908          *
1909          * OUTPUTS :
1910          *       None
1911          *
1912          */
1913          void HHAL_SetDiagModeNoSack(eRegFlag regFlag)
1914          {
1915   1          uPlcStatusReg plcStatus;
1916   1      
1917   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1918   1          plcStatus.s.noSackDiag = regFlag;
1919   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1920   1      }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 33  

1921          
1922          
1923          /*******************************************************************
1924          * NAME :            HHAL_GetPlcTxQFreeDescCnt
1925          *
1926          * DESCRIPTION :     Returns no: of dwords available in a given PLC CAP Tx Q.
1927          *
1928          * INPUTS :
1929          *       PARAMETERS:
1930          *           eRegFlag regFlag
1931          *
1932          * OUTPUTS :
1933          *       None
1934          *
1935          */
1936          u8 HHAL_GetPlcTxQFreeDescCnt(eHpgpPlidValue plid)
1937          {
1938   1          uCapTxQStatusReg capTxQStat;
1939   1          u8 freeDescCnt;
1940   1          u8* descCntArr;
1941   1      
1942   1          capTxQStat.reg = ReadU32Reg(PLC_QDSTATUS_REG);
1943   1      
1944   1          descCntArr = (u8*)&capTxQStat.reg;
1945   1          freeDescCnt = PLC_TXQ_DEPTH - descCntArr[plid];
1946   1          //printf("PLCTxQStatusReg = 0x%08lX, PLCTxQ[%bu].freeDescCnt = %bu\n", SwapU32(capTxQStat.reg),plid, f
             -reeDescCnt);
1947   1          return  freeDescCnt;
1948   1      }
1949          
1950          
1951          // txBcn starts with 16 bytes avFC & has to be zero padded
1952          // bcnLen is always 136
1953          // Always give a non-zero valid bpstoValueOffset: minimum is 16 byte AVFC + 12 byte BcnHdr + 1 byte NBE + 
             -2 bytes BEHDR,BELEN of BPSTO BENTRY
1954          //                                                            = 33 (ie., 34thth byte)
1955          eStatus HHAL_AddNEK(u8 eks, u8 nek[PLC_AES_KEYLEN] )
1956          {
1957   1          uAesLutAddrReg      aesLutAddr;
1958   1          uAesLutDataReg      aesLutData;
1959   1          uAesKeyLutAddrReg   aesKeyLutAddr;
1960   1          uAesKeyLutDataReg   aesKeyLutData;
1961   1          uAesCpuCmdStatReg   aesCpuCmd;
1962   1      
1963   1          u8                  i,j;
1964   1          u8                  arrIdx;
1965   1      
1966   1          arrIdx          = 0;
1967   1      
1968   1          // Wait for Cpu Aes Lut access grant.
1969   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
1970   1          aesCpuCmd.s.cpuTblReq = 1;
1971   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
1972   1      /*
1973   1          CHAL_DelayTicks(100);
1974   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
1975   1          if(!aesCpuCmd.s.cpuTblGnt)
1976   1          {
1977   1              printf("Add NEK failed\n");  //[YM] Add debug message of set NEK failure
1978   1              return STATUS_FAILURE;
1979   1          }
1980   1      */
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 34  

1981   1          // Write Key to the Key LUT.
1982   1          for(i=0; i<4; i++)
1983   1          {
1984   2              aesKeyLutAddr.reg     = 0;
1985   2              aesKeyLutAddr.sNek.isNek = 1;
1986   2              aesKeyLutAddr.sNek.idx   = i;
1987   2              aesKeyLutAddr.sNek.eks   = (eks & 0x7);
1988   2              WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
1989   2              FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.reg), (PLC_
             -AESKEYLUTADDR_REG));
1990   2              for(j=0 ; j<4 ; j++)
1991   2              {
1992   3                  aesKeyLutData.s.key[j] = nek[arrIdx++];       
1993   3              }
1994   2              WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
1995   2              FM_Printf(FM_LINFO,"Wrote key dw        0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.reg), (PLC_
             -AESKEYLUTDATA_REG));
1996   2          }
1997   1      
1998   1          // Write Aes LUT Addr corres. to NEK.
1999   1          aesLutAddr.reg        = 0;
2000   1          aesLutAddr.sNek.eks   = eks;
2001   1          aesLutAddr.sNek.isNek = 1;
2002   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2003   1          FM_Printf(FM_LINFO,"Wrote AesLutAddr dw 0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (PLC_AESLUTA
             -DDR_REG));
2004   1      
2005   1          // Set the NEK as valid.
2006   1          aesLutData.reg        = 0;
2007   1          aesLutData.sNek.valid = 0xFF;
2008   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2009   1          FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n\n", rtocl(aesLutData.reg), (PLC_AESLU
             -TDATA_REG));
2010   1      
2011   1          // Release CPU Lock on AES LUT
2012   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2013   1          aesCpuCmd.s.cpuTblGnt = 0;
2014   1          aesCpuCmd.s.cpuTblReq = 0;
2015   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
2016   1      
2017   1          return STATUS_SUCCESS;
2018   1      }
2019           
2020          eStatus HHAL_RemoveNEK(u8 eks)
2021          {
2022   1      
2023   1          uAesLutAddrReg      aesLutAddr;
2024   1          uAesLutDataReg      aesLutData;
2025   1          uAesCpuCmdStatReg   aesCpuCmd;
2026   1          eStatus             status;
2027   1      
2028   1          // Wait for Cpu Aes Lut access grant.
2029   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2030   1          aesCpuCmd.s.cpuTblReq = 1;
2031   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2032   1      /*
2033   1          CHAL_DelayTicks(100);
2034   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2035   1          if(!aesCpuCmd.s.cpuTblGnt || eks > 7)
2036   1          {
2037   1              return STATUS_FAILURE;
2038   1          }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 35  

2039   1      */
2040   1          // Write Aes LUT Addr corres. to NEK.
2041   1          aesLutAddr.reg     = 0;
2042   1          aesLutAddr.sNek.eks   = eks;
2043   1          aesLutAddr.sNek.isNek = 1;
2044   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2045   1      
2046   1          // Set the NEK as invalid.
2047   1          aesLutData.reg        = 0;
2048   1          aesLutData.sNek.valid = 0x0;
2049   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg); 
2050   1      
2051   1          // Release CPU Lock on AES LUT
2052   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2053   1          aesCpuCmd.s.cpuTblGnt = 0;
2054   1          aesCpuCmd.s.cpuTblReq = 0;
2055   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2056   1      
2057   1          return status;
2058   1      }
2059           
2060          eStatus HHAL_AddPPEK(u8 eks, u8 ppek[PLC_AES_KEYLEN], u8 tei)
2061          {
2062   1          uAesLutAddrReg      aesLutAddr;
2063   1          uAesLutDataReg      aesLutData;
2064   1          uAesKeyLutAddrReg   aesKeyLutAddr;
2065   1          uAesKeyLutDataReg   aesKeyLutData;
2066   1          uAesCpuCmdStatReg   aesCpuCmd;
2067   1          eStatus             status;
2068   1          u8                  i,j;
2069   1          u8                  arrIdx;
2070   1          u8                  keyNum;
2071   1          u8                  region;
2072   1      
2073   1          arrIdx          = 0;
2074   1      
2075   1          status  = STATUS_SUCCESS;
2076   1          // Wait for Cpu Aes Lut access grant.
2077   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2078   1          aesCpuCmd.s.cpuTblReq = 1;
2079   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2080   1      /*
2081   1          CHAL_DelayTicks(100);
2082   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2083   1          if(!aesCpuCmd.s.cpuTblGnt)
2084   1          {
2085   1              return STATUS_FAILURE;
2086   1          }
2087   1      */
2088   1          if(eks != 8 && eks != 9 )  // EKS = 0b1000 or 0b1001
2089   1          {
2090   2              status = STATUS_FAILURE;
2091   2          }
2092   1          else
2093   1          {
2094   2               region                  = eks & 0x01;
2095   2      
2096   2              // Write AesLutAddr corres to the tei.
2097   2              aesLutAddr.reg          = 0;
2098   2              aesLutAddr.sPpek.tei    = tei;
2099   2              aesLutAddr.sPpek.isNek  = 0;
2100   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 36  

2101   2              FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to   reg#0x%08lX\n", rtocl(aesLutAddr.reg), (P
             -LC_AESLUTADDR_REG));
2102   2      
2103   2              // Read back AesLutData corres to the tei.
2104   2              aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2105   2              FM_Printf(FM_MINFO, "Readback AesLutData dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (P
             -LC_AESLUTDATA_REG));
2106   2      
2107   2              if(aesLutData.sPpek.valid)
2108   2              {
2109   3                   // Overwrite the current Key. So retrive Index of current key.
2110   3                   keyNum = aesLutData.sPpek.keyNum;
2111   3              }
2112   2              else
2113   2              {
2114   3                  // Find an available Key Index to add the new PPEK.
2115   3                  for(i=0 ; i<32 ; i++)
2116   3                  {
2117   4                      if( (gHpgpHalCB.ppekValidReg & BIT(i)) == 0)
2118   4                      {
2119   5                          keyNum = i;
2120   5                          gHpgpHalCB.ppekValidReg |= BIT(i);
2121   5                          break;
2122   5                      }                    
2123   4                  }
2124   3                  if(i == 32)
2125   3                  {
2126   4                      // All 32 KeyEntries in selected PPEK Region are currently in use.
2127   4                      // PPEK Table full.
2128   4                      status = STATUS_FAILURE;
2129   4                  }
2130   3              }
2131   2          }
2132   1      
2133   1          if(status == STATUS_SUCCESS)
2134   1          {
2135   2              // Write Key to the Key LUT.
2136   2              for(i=0; i<4; i++)
2137   2              {
2138   3                  aesKeyLutAddr.reg          = 0;
2139   3                  aesKeyLutAddr.sPpek.isNek  = 0;
2140   3                  aesKeyLutAddr.sPpek.idx    = i;
2141   3                  aesKeyLutAddr.sPpek.keyNum = keyNum;
2142   3                  aesKeyLutAddr.sPpek.region = region;
2143   3                  WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
2144   3                  FM_Printf(FM_MINFO, "Wrote keyAddr dw       0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.reg
             -), (PLC_AESKEYLUTADDR_REG));
2145   3                  for(j=0 ; j<4 ; j++)
2146   3                  {
2147   4                      aesKeyLutData.s.key[j] = ppek[arrIdx++];       
2148   4                  }
2149   3                  WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
2150   3                  FM_Printf(FM_MINFO, "Wrote key dw           0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.reg
             -), (PLC_AESKEYLUTDATA_REG));
2151   3              }
2152   2      
2153   2              // Write Aes LUT Addr corres to PPEK.
2154   2              aesLutAddr.reg          = 0;
2155   2              aesLutAddr.sPpek.tei    = tei;
2156   2              aesLutAddr.sPpek.isNek  = 0;
2157   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2158   2              FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (PLC
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 37  

             -_AESLUTADDR_REG));
2159   2          
2160   2              // Set the PPEK valid.
2161   2              //aesLutData.reg           = 0;
2162   2              aesLutData.sPpek.keyNum  = keyNum;
2163   2              aesLutData.sPpek.valid   = 1;
2164   2              if(region == 0)
2165   2              {
2166   3                  aesLutData.sPpek.region0 = 1;
2167   3              }
2168   2              else
2169   2              {
2170   3                  aesLutData.sPpek.region1 = 1;
2171   3              }
2172   2      
2173   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2174   2              FM_Printf(FM_MINFO, "Wrote AesLutData dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutData.reg), (PLC
             -_AESLUTDATA_REG));
2175   2          }
2176   1      
2177   1          // Release CPU Lock on AES LUT
2178   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2179   1          aesCpuCmd.s.cpuTblGnt = 0;
2180   1          aesCpuCmd.s.cpuTblReq = 0;
2181   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2182   1      
2183   1          return status;
2184   1      }
2185          
2186          
2187          eStatus HHAL_RemovePPEK(u8 eks, u8 tei)
2188          {
2189   1          uAesLutAddrReg      aesLutAddr;
2190   1          uAesLutDataReg      aesLutData;
2191   1          uAesCpuCmdStatReg   aesCpuCmd;
2192   1          eStatus             status;
2193   1          u8                  region;
2194   1      
2195   1          // Wait for Cpu Aes Lut access grant.
2196   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2197   1          aesCpuCmd.s.cpuTblReq = 1;
2198   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2199   1      
2200   1          CHAL_DelayTicks(100);
2201   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2202   1          if(eks < 8 || eks > 9)
2203   1          {
2204   2              return STATUS_FAILURE;
2205   2          }
2206   1          region                  = eks & 0x01;
2207   1      
2208   1          // Write Aes LUT Addr corres. to PPEK.
2209   1          aesLutAddr.reg         = 0;
2210   1          aesLutAddr.sPpek.tei   = tei;
2211   1          aesLutAddr.sPpek.isNek = 0;
2212   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2213   1      
2214   1          // Read back AesLutData corres to the tei.
2215   1          aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2216   1          FM_Printf(FM_MINFO,"Read back dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (PLC_AESLUTDATA_R
             -EG));
2217   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 38  

2218   1          if(aesLutData.sPpek.valid)
2219   1          {
2220   2              if(region == 0)
2221   2              {
2222   3                  aesLutData.sPpek.region0 = 0;
2223   3              }
2224   2              else
2225   2              {
2226   3                  aesLutData.sPpek.region1 = 0;
2227   3              }
2228   2              if(aesLutData.sPpek.region0 == 0 && aesLutData.sPpek.region1 == 0)
2229   2              {
2230   3                   // Set the PPEK as invalid.
2231   3                  aesLutData.reg         = 0;
2232   3                  aesLutData.sPpek.valid = 0x0;
2233   3                  
2234   3              }
2235   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutAddr.reg); 
2236   2          }
2237   1          else
2238   1          {
2239   2              status = STATUS_FAILURE;
2240   2          }
2241   1      
2242   1          // Release CPU Lock on AES LUT
2243   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2244   1          aesCpuCmd.s.cpuTblGnt = 0;
2245   1          aesCpuCmd.s.cpuTblReq = 0;
2246   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2247   1      
2248   1          return status;
2249   1      }
2250          
2251          #ifdef HPGP_HAL_TEST
              void HHAL_SetDefAddrConfig()
              {
              #if defined(Flash_Config) && defined(Z_P_BRIDGE)    
              
                      gHpgpHalCB.selfTei   = sysConfig.defaultSTEI;
                      gHpgpHalCB.remoteTei = sysConfig.defaultDTEI;
                  gHpgpHalCB.snid      = sysConfig.defaultNID[0];
              
              #else 
                if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                  {
                      gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
                      gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
                  }else
                  {
                      gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
                      gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
                  }
                  gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
              #endif  //Flash_Config && Z_P_BRIDGE
              #ifndef QCA
                
                  HHAL_SetTei(gHpgpHalCB.selfTei);
              
                  HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other chip
             - snid should be set once we receive bcn from cco and should not get set at power on because 
              #endif
              }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 39  

              #endif  //HPGP_HAL_TEST
2280          
2281          void HHAL_ClearBcnInit()
2282          {
2283   1          gHpgpHalCB.bcnInitDone = 0;
2284   1          //FM_Printf(FM_MINFO, "HHAL_ClearBcnInit\n");
2285   1      
2286   1      }
2287          
2288          void HHAL_SetBcnInit()
2289          {
2290   1          gHpgpHalCB.bcnInitDone = 1;
2291   1          FM_Printf(FM_MINFO, "HHAL_SetBcnInit\n");
2292   1      
2293   1      }
2294          
2295          void HHAL_PowerSaveConfig()
2296          {
2297   1          uPlcLineControlReg plcLineCtrl;
2298   1        
2299   1        plcLineCtrl.reg = ReadU32Reg(PLC_POWERSAVE_REG);
2300   1        
2301   1      }
2302          
2303          /*******************************************************************
2304          * NAME :            HHAL_SetDevMode
2305          *
2306          * DESCRIPTION :     Sets Default PLC Device configuration.
2307          *
2308          * INPUTS :
2309          *       PARAMETERS:
2310          *           eRegFlag regFlag
2311          *
2312          * OUTPUTS :
2313          *       None
2314          *
2315          */
2316          #ifdef HPGP_HAL_TEST
              void HHAL_SetDevMode(eDevMode devMode, eLineMode lineMode )
              #else
2319          void HHAL_SetDevMode(sHaLayer *hal, eDevMode devMode, eLineMode lineMode)
2320          #endif   //HPGP_HAL_TEST
2321          {
2322   1      
2323   1      
2324   1          sCsmaRegion      csmaRegArr[5]; 
2325   1          uPlcLineControlReg plcLineCtrl;
2326   1          
2327   1         
2328   1        
2329   1          memset(csmaRegArr, 0, 5*sizeof(sCsmaRegion));
2330   1          // Added by Varsha
2331   1          if(lineMode == LINE_MODE_DC)
2332   1          {
2333   2              gHpgpHalCB.lineMode = LINE_MODE_DC;
2334   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
2335   2              //gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2336   2              WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
2337   2          WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_DC_BP_LEN >> 1)));
2338   2              WriteU32Reg(PLC_HWBCNPERCUR_REG, ctorl(PLC_DC_BP_LEN));
2339   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2340   2              plcLineCtrl.s.dcmode = 1;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 40  

2341   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2342   2               gsyncTimeout = DC_SYNC_TIMEOUT;
2343   2               gBcnMissingRescanCnt = DC_BCN_MISSING_RESCAN_CNT;  //60*4= 240= 240/40= 6 bcn missing
2344   2              //gHpgpHalCB.bPerAvgInitDone = 1;
2345   2          }
2346   1          else
2347   1          {
2348   2              gHpgpHalCB.lineMode = LINE_MODE_AC;
2349   2      
2350   2              gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2351   2            
2352   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2353   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2354   2              
2355   2              set_plc_paramter(PLC_MaxPeran,PLC_MAX_AC_BPLEN);
2356   2              set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2357   2              
2358   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2359   2              plcLineCtrl.s.dcmode = 0;
2360   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2361   2               gsyncTimeout = AC_SYNC_TIMEOUT;
2362   2               gBcnMissingRescanCnt = AC_BCN_MISSING_RESCAN_CNT;  //30*4= 120= 120/33.33= 3 bcn missing
2363   2            set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2364   2          }
2365   1      
2366   1          if(devMode == DEV_MODE_CCO)
2367   1          {
2368   2              gHpgpHalCB.devMode   = DEV_MODE_CCO;
2369   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode CCo\n");
2370   2      
2371   2              // Write PLC Devmode register.
2372   2              //cpuSwStatus.reg = ReadU32Reg(CPU_SWSTATUS_REG);
2373   2              if(lineMode == LINE_MODE_AC)
2374   2              {
2375   3                  //cpuSwStatus.s.plcDevMode = CCO_ACLINE;            
2376   3                  HHAL_SetPlcDevMode(CCO_ACLINE);
2377   3                  // Set AC cycle frequency
2378   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2379   3      /*#ifdef AC_LINECYCLE_50HZ
2380   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2381   3      #else                   
2382   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2383   3      #endif   */ //AC_LINECYCLE_50HZ         
2384   3                  gHpgpHalCB.perSumCnt       = 0;
2385   3                  gHpgpHalCB.bPerAvgInitDone = 0;
2386   3              }
2387   2              else
2388   2              {
2389   3                  
2390   3                  HHAL_SetPlcDevMode(CCO_DCLINE);
2391   3                  //HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2392   3              }
2393   2      #ifdef HPGP_HAL_TEST
                      setCSMA_onCCO();                                          
              #endif
2396   2          }
2397   1          else
2398   1          {
2399   2              gHpgpHalCB.devMode   = DEV_MODE_STA;
2400   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode Sta\n");
2401   2      
2402   2      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 41  

2403   2              // Write PLC Devmode register.
2404   2              if(lineMode == LINE_MODE_AC)
2405   2              {
2406   3                  HHAL_SetPlcDevMode(STA_CSMANW);
2407   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2408   3      /*#ifdef AC_LINECYCLE_50HZ
2409   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2410   3      #else                   
2411   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2412   3      #endif   */ //AC_LINECYCLE_50HZ       
2413   3             
2414   3              }
2415   2              else
2416   2              {
2417   3                  HHAL_SetPlcDevMode(STA_DCLINE);
2418   3                  gHpgpHalCB.lineMode = LINE_MODE_DC;
2419   3              }     
2420   2      #ifdef HPGP_HAL_TEST    
                   setCSMA_onSTA();
              #endif
2423   2      
2424   2                
2425   2          }
2426   1        
2427   1         /* csmaRegArr[0].startTime  = 0;
2428   1          csmaRegArr[0].bcnRegion  = (devMode == DEV_MODE_STA) ? 1 : 0;
2429   1          csmaRegArr[0].duration   = 0x2FF;
2430   1          csmaRegArr[0].hybridMd   = 1;    
2431   1          
2432   1          csmaRegArr[2].startTime  = 0;
2433   1          csmaRegArr[2].bcnRegion  = (devMode == DEV_MODE_STA ) ? 1 : 0;
2434   1          csmaRegArr[2].duration   = gHpgpHalCB.bcnInitDone ? 0 : 0x5A3;
2435   1          csmaRegArr[2].hybridMd   = gHpgpHalCB.bcnInitDone ? 0 : 1;  
2436   1          
2437   1          csmaRegArr[3].startTime  = 0;
2438   1          csmaRegArr[3].bcnRegion  = 0;
2439   1          csmaRegArr[3].duration   = 0;//0x04A9//0xFF;
2440   1          csmaRegArr[3].hybridMd   = 0;//1;                         
2441   1          // Write CSMA Regions - mixed mode.
2442   1          if(lineMode == LINE_MODE_AC) 
2443   1          {
2444   1      
2445   1          csmaRegArr[1].startTime  = 0;
2446   1          csmaRegArr[1].bcnRegion  = 0;
2447   1          csmaRegArr[1].duration   = 0x4A1;
2448   1          csmaRegArr[1].hybridMd   = 1;
2449   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2450   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2451   1          }
2452   1          else
2453   1          {
2454   1          csmaRegArr[1].startTime  = 0;
2455   1          csmaRegArr[1].bcnRegion  = 0;
2456   1          csmaRegArr[1].duration   = 0x6A1;
2457   1          csmaRegArr[1].hybridMd   = 1;
2458   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2459   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2460   1      
2461   1          }
2462   1          //HHAL_SetCsmaRegions(csmaRegArr,4);
2463   1         
2464   1          WriteU8Reg(0x47F, 0x4);  // PHY AGC Threshold - For auto switch robo on RX
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 42  

2465   1          */
2466   1      }
*** WARNING C280 IN LINE 2319 OF ..\..\..\hal\hal_hpgp.c: 'hal': unreferenced local variable
2467          
2468          
2469          
2470          
2471          // Write AFE registers wian SPI registers in PHY address space
2472          void HHAL_AFEInit()
2473          {
2474   1      
2475   1      #ifdef B_ASICPLC
2476   1          // [YM] 1.8GHz VCO Calibrate
2477   1          mac_utils_spi_write(0x4, 0x20);
2478   1          mac_utils_spi_write(0x4, 0x4);   //[YM] temporary disable AFE calibration    
2479   1      #endif  
2480   1      
2481   1      #ifdef B2_ASICPLC
                  // [YM] 1.8GHz VCO Calibrate
                  mac_utils_spi_write(0x4, 0x20);
                  mac_utils_spi_write(0x4, 0x24);   //[YM] temporary disable AFE calibration    
              #endif  
2486   1      
2487   1      /*
2488   1      #if defined(HYBRII_HPGP) && defined(HYBRII_ZIGBEE)
2489   1          // Program fix gain for PLC
2490   1      #ifndef HYBRII_B
2491   1          mac_utils_spi_write(0x3a, 0x0a);
2492   1          mac_utils_spi_write(0x3b, 0x72);
2493   1      #endif
2494   1      #endif   //defined(HYBRII_HPGP) && defined(HYBRII_ZIGBEE)
2495   1      */
2496   1      #ifdef _LED_DEMO_
                  WriteU8Reg(0x406, 0x00);
                  CHAL_DelayTicks(SPI_WRITE_DELAY);
                  WriteU8Reg(0x406, 0x7F);
              #endif  //_LED_DEMO_
2501   1      }
2502          
2503          
2504          void hal_hpgp_soft_reset ()
2505          {
2506   1          uPlcStatusReg  plcStatus;
2507   1          
2508   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
2509   1          plcStatus.s.txSoftReset = 1;
2510   1          plcStatus.s.rxSoftReset = 1;
2511   1      
2512   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2513   1      
2514   1          CHAL_DelayTicks(100);
2515   1          plcStatus.s.txSoftReset = 0;
2516   1          plcStatus.s.rxSoftReset = 0;
2517   1      
2518   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2519   1      }
2520          
2521          
2522          
2523          #ifdef HPGP_HAL_TEST
              eStatus HHAL_SyncNet(u8 *bpsto) 
              #else    
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 43  

2526          eStatus HHAL_SyncNet(sHaLayer *hal, u8 *bpsto) 
2527          #endif  //HPGP_HAL_TEST
2528          {
2529   1          uBpstoReg    bpstoReg;
2530   1          //u32          ntb1,ntb2;
2531   1          u32          bpstoVal; //, latency;
2532   1          u32          bpst;
2533   1          u32          ss1;
2534   1      //    u32          offset;
2535   1      //    u32          ss2MinusSs1;
2536   1      //    u32 bps;
2537   1          u32 NTB_delta;
2538   1      //    u32 x;
2539   1      //    u32 E_CCOBTS;
2540   1          u32 BcnPer;
2541   1          u32 CCOBpst;
2542   1          u32 RetrievedBTS;
2543   1          u8 rollover_snapshot1 = 0;
2544   1          u8 rollover_retriveBTS = 0;
2545   1          u32 ToatalLatency;
2546   1      
2547   1        eStatus      ret = STATUS_FAILURE;
2548   1      
2549   1                           
2550   1      
2551   1          if (!gHpgpHalCB.nwSelected)
2552   1              return ret;    
2553   1      
2554   1       
2555   1        
2556   1          // Process further if the beacon has been snapshot.
2557   1          if(gHpgpHalCB.snapShot)
2558   1          {
2559   2              bpstoReg.s.bpsto0 = bpsto[0];
2560   2              bpstoReg.s.bpsto1 = bpsto[1];
2561   2              bpstoReg.s.bpsto2 = bpsto[2];
2562   2      
2563   2              bpstoVal = ((u32)(bpsto[2])<<16) + ((u32)(bpsto[1])<<8) + (u32)bpsto[0];
2564   2              //WriteU32Reg(PLC_BPSTOFFSET_REG, ctorl(bpstoVal));     
2565   2              
2566   2              ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2567   2             
2568   2               //ss2 = rtocl(ReadU32Reg(PLC_NTB_REG)); 
2569   2              // printf("\n ssdif= %lu", ((ss1-oldss1) * 40));
2570   2               
2571   2      
2572   2              if(gHpgpHalCB.syncComplete)//normal operation
2573   2              {
2574   3                   if(ss1 < oldss1)
2575   3                      rollover_snapshot1 = 1;
2576   3              }   
2577   2              oldss1 = ss1;
2578   2              RetrievedBTS = gCCO_BTS + PLC_PHY_RXLATENCY_FOR_TCC3;  //PLC_PHY_RXLATENCY_FOR_TCC2;//normal as we
             -ll as cpu scan operation
2579   2               
2580   2               
2581   2              if(gHpgpHalCB.syncComplete)//normal operation
2582   2              {
2583   3                  if(RetrievedBTS < oldRetrievedBTS)
2584   3                      rollover_retriveBTS = 1;
2585   3              } 
2586   2              
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 44  

2587   2              oldRetrievedBTS = RetrievedBTS; 
2588   2              
2589   2              if(RetrievedBTS > ss1)  //sta slower then cco
2590   2              {
2591   3                  if(rollover_retriveBTS)
2592   3                  {
2593   4                      NTB_delta = RetrievedBTS + (0xffffffff - ss1);
2594   4                  }
2595   3                  else 
2596   3                  {
2597   4                      NTB_delta = (RetrievedBTS - ss1);
2598   4                   
2599   4                  }
2600   3                  if(NTB_delta > 10)
2601   3                  {
2602   4                      gHpgpHalCB.halStats.STAlagCCOCount++;
2603   4                  }
2604   3              
2605   3              }
2606   2              else  //sta is faster then cco so take 2's complement
2607   2              {
2608   3              
2609   3                  if(rollover_snapshot1 )
2610   3                  {
2611   4                      NTB_delta = 0xffffffff - (ss1 + (0xffffffff - RetrievedBTS)) + 1;
2612   4                  }
2613   3                  else  
2614   3                  {
2615   4                      NTB_delta = 0xffffffff - (ss1 - RetrievedBTS) + 1;     //taken 2's complement
2616   4                      
2617   4                     
2618   4                  }
2619   3                  if((ss1 - RetrievedBTS) > 10)
2620   3                  {
2621   4                      gHpgpHalCB.halStats.STAleadCCOCount++;
2622   4                  } 
2623   3              }
2624   2              
2625   2              WriteU32Reg( PLC_NTBADJ_REG, ctorl(NTB_delta));  
2626   2               
2627   2            
2628   2                                                 
2629   2              //ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2630   2      
2631   2             
2632   2              //ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC2 + bpstoVal);
2633   2              ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC3+ bpstoVal);
2634   2           
2635   2      
2636   2      
2637   2      #ifdef QCA    
                      ss1 += NTB_delta;//rajan
              #endif             
2640   2      
2641   2              if( ss1 > ToatalLatency)
2642   2              {
2643   3                  if(rollover_snapshot1)
2644   3                      CCOBpst = ss1 + (0xffffffff - ToatalLatency); 
2645   3                   else
2646   3                      CCOBpst = (ss1 - ToatalLatency);
2647   3              }
2648   2              else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 45  

2649   2              {
2650   3                    CCOBpst = ss1 + (0xffffffff - ToatalLatency + 1); 
2651   3              }
2652   2              
2653   2             
2654   2             if(CCOBpst > OldCCOBpst)
2655   2              BcnPer =  (CCOBpst - OldCCOBpst);
2656   2             else
2657   2                  BcnPer = ((0xffffffff - OldCCOBpst) + CCOBpst);
2658   2             
2659   2             OldCCOBpst = CCOBpst; 
2660   2            // printf("\n bcn per = %lu",BcnPer); 
2661   2            
2662   2             if((BcnPer * 40) > MISSING_BCN_PER_THRESHOLD) //if bcn is missed - multiplied with 40 to read in te
             -rms of ms
2663   2             {
2664   3                  gBcnPer = gBcnPer;
2665   3             } 
2666   2             else
2667   2             {
2668   3                  gBcnPer = BcnPer;
2669   3             }
2670   2             
2671   2               //this is just debug purpose to see bcn per
2672   2               if((gBcnPer * 40) > 42000000)
2673   2               {
2674   3                  //THIS IS PRINTED JUST TO DEBUG WHEN WE KEEP OVERNIGHT TEST WHETHER WE GET THIS OR NOT
2675   3      #ifndef MPER            
2676   3                  //printf("\n BCNPER = %lu", (gBcnPer * 40));
2677   3      #endif
2678   3               }
2679   2              
2680   2              //whenever we receives bcn we write sw per avg reg = bcnper/2 
2681   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gBcnPer >> 1))); 
2682   2               
2683   2             
2684   2             // ss2MinusSs1 = (ss2 > ss1) ? (ss2 - ss1) : (0xFFFFFFFF - ss1 + ss2);
2685   2             // if(ss2MinusSs1 <= (gBcnPer - 1000) )
2686   2              {
2687   3                   bpst = CCOBpst + gBcnPer;// + var1;
2688   3                   gbpst1 = bpst;
2689   3                     
2690   3      
2691   3      #ifdef QCA             
                           bpst -= NTB_delta; //rajan
              #endif               
2694   3                  
2695   3                   WriteU32Reg(PLC_BPST_REG, ctorl(bpst)); 
2696   3                   gHpgpHalCB.halStats.BcnSyncCnt++;  
2697   3                   gtimer2 = 0;//reset second timer at every bcn receive
2698   3                   gtimer1 = 0; 
2699   3                   misscnt = 0;
2700   3               }  
2701   2                  
2702   2              }
2703   1      
2704   1             
2705   1              if(gHpgpHalCB.syncComplete)
2706   1              {
2707   2                  ret = STATUS_SUCCESS;
2708   2              }
2709   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 46  

2710   1              if(!gHpgpHalCB.syncComplete && (gHpgpHalCB.halStats.BcnSyncCnt))
2711   1              {
2712   2                  gHpgpHalCB.syncComplete = 1;
2713   2                  CHAL_DelayTicks(80);
2714   2                  HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);  
2715   2                  CHAL_DelayTicks(20);              
2716   2              }      
2717   1       
2718   1               //gtimer2 = 0;//reset second timer at every bcn receive
2719   1               //gtimer1 = 0;
2720   1               
2721   1               return ret;
2722   1      }
*** WARNING C280 IN LINE 2526 OF ..\..\..\hal\hal_hpgp.c: 'hal': unreferenced local variable
2723          // end of Hybrii B
2724          
2725          
2726          #if 0
              
              void HHAL_ProcessPlcTxDone()
              {
              
                  u8 tailIdx;
                  sTxFrmSwDesc  *lpPlcTxFrmSwDesc;
                  sHpgpHalCB *hhalCb; 
              #ifndef HPGP_HAL_TEST    
                  sHaLayer *hal;
              #endif     //HPGP_HAL_TEST
                  volatile u32 val;
                  volatile u8 *val1; 
              
                  
              #ifdef HPGP_HAL_TEST
                  hhalCb = &gHpgpHalCB;
              #else
                  hal = (sHaLayer*)HOMEPLUG_GetHal();
              
                  hhalCb = hal->hhalCb;
              #endif     //HPGP_HAL_TEST
              
                
                  val = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
              
                  val1 = (u8*)&val;
              
                  if ((*val1) & 0x40)
                  {
              #ifdef ETH_BRDG_DEBUG
                  numTxDoneInts++;
              #endif
                      WriteU8Reg(PLC_MEDIUMINTSTATUS_REG, 0x40);         
                         
                                  
                      tailIdx = (hhalCb->gPendingTail & 0x7F);
                      lpPlcTxFrmSwDesc =  &hhalCb->gPending[tailIdx];
              
                      if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_PENDING)
                      {
                          lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;            
              #ifdef DEBUG_DATAPATH                        
                          if (sigDbg)
                              FM_Printf(FM_ERROR," plc txDone t:%bu\n",hhalCb->gPendingTail);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 47  

              #endif   //DEBUG_DATAPATH         
                      }
              
                      
                  }
              
              }
              
              #endif
2780          
2781          
2782          void plc_init_parameters ()
2783          {
2784   1          uPlcIfs0Reg         plcIfs0;
2785   1          uPlcIfs1Reg         plcIfs1;
2786   1      
2787   1          //set_plc_paramter(PLC_PHYLATENCY_SEL,  PLC_PHYLATENCY_INIT_VALUE); 
2788   1        // Added by Varsha
2789   1        
2790   1      //      u32 laten_initval;
2791   1      //     u32 rx_lat = PLC_PHY_RXLATENCY;
2792   1      //     u32 tx_lat = PLC_PHY_TXLATENCY;
2793   1          
2794   1        set_plc_paramter(PLC_TIMINGPARAM_SEL, PLC_TIMINGPARAM_INIT_VALUE);
2795   1      
2796   1          set_plc_paramter(PLC_MPIRXTIMEOUT_SEL, PLC_MPIRXTIMOUT_INIT_VALUE);
2797   1      
2798   1          set_plc_paramter(PLC_MPITXTIMEOUT_SEL, PLC_MPITXTIMOUT_INIT_VALUE);
2799   1      
2800   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_CPUSCANTIMOUT_INIT_VALUE);
2801   1      
2802   1          set_plc_paramter(PLC_500USCNT_SEL, PLC_500US_COUNT);
2803   1      
2804   1        //Added by Varsha
2805   1        
2806   1           /*  laten_initval = PLC_PHY_RXLATENCY;
2807   1           laten_initval = laten_initval << 16;
2808   1           laten_initval += PLC_PHY_TXLATENCY;
2809   1           printf("\n latenval = %lu", laten_initval); */
2810   1           set_plc_paramter(PLC_PHYLATENCY_SEL,   TX_RXLatency_TCC[2]);  //tcc =3
2811   1        
2812   1          // IFS Registers 
2813   1          plcIfs0.reg          = 0;
2814   1          plcIfs0.s.clksPerUs  = HPGP_CLKsPerUs_DEF;
2815   1          plcIfs0.s.cifs_av    = HPGP_CIFSAV_DEF;
2816   1          plcIfs0.s.rifs_av    = HPGP_RIFSAV_DEF;
2817   1          plcIfs0.s.b2bifs     = HPGP_B2BIFS_DEF;
2818   1          set_plc_paramter(PLC_IFS0_SEL, plcIfs0.reg);
2819   1      
2820   1        
2821   1          plcIfs1.reg          = 0;
2822   1          plcIfs1.s.bifs       = HPGP_BIFS_DEF;
2823   1          plcIfs1.s.aifs       = HPGP_AIFS_DEF;
2824   1          set_plc_paramter(PLC_IFS1_SEL, plcIfs1.reg);
2825   1      
2826   1          
2827   1          set_plc_paramter(PLC_IFS2_SEL, PLC_IFS2_INIT_VALUE);
2828   1      
2829   1          set_plc_paramter(PLC_IFS3_SEL, PLC_IFS3_INIT_VALUE);
2830   1      
2831   1      
2832   1        // FL_AV Registers
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 48  

2833   1          // Adding 1 to the actual values, since MAC HW is using a "<" comparison with each of these feilds.
2834   1          set_plc_paramter(PLC_FLAV0_SEL, PLC_FLAV0_INIT_VALUE);
2835   1        
2836   1          set_plc_paramter(PLC_FLAV1_SEL, PLC_FLAV1_INIT_VALUE);
2837   1      
2838   1          set_plc_paramter(PLC_FLAV2_SEL, PLC_FLAV2_INIT_VALUE);
2839   1      
2840   1          set_plc_paramter(PLC_FLAV3_SEL, PLC_FLAV3_INIT_VALUE);
2841   1      
2842   1        set_plc_paramter(PLC_FLAV4_SEL, PLC_FLAV4_INIT_VALUE);
2843   1      
2844   1      
2845   1        // 0x11 is used for Early Wake Count, 0x12 and 0x13 are not being used
2846   1      //    set_plc_paramter(PLC_CRSRDYDLY0_SEL, PLC_CRSDLY0_1_INIT_VALUE); 
2847   1      //    set_plc_paramter(PLC_CRSRDYDLY1_SEL, PLC_CRSDLY2_3_INIT_VALUE);
2848   1      //    set_plc_paramter(PLC_CRSRDYDLY2_SEL, PLC_CRSDLY3_PRS_INIT_VALUE);
2849   1          set_plc_paramter(PLC_CRSRDYDLY0_SEL, 0); 
2850   1      
2851   1          set_plc_paramter(PLC_WAITCRS_SEL, PLC_WAITCRS_INIT_VALUE);
2852   1      
2853   1          set_plc_paramter(PLC_TXRX_TURNAROUND_SEL, PLC_TXRX_TURNAROUND_INIT_VALUE);
2854   1      
2855   1        set_plc_paramter(PLC_PKTTIME_SEL, PLC_PKTTIME_INIT_VALUE);
2856   1        set_plc_paramter(PLC_EIFS_SEL, PLC_EIFS_INIT_VALUE);
2857   1        set_plc_paramter(PLC_VCSPARAM0_SEL, PLC_VCSPARAM0_INIT_VALUE);
2858   1        set_plc_paramter(PLC_VCSPARAM1_SEL, PLC_VCSPARAM1_INIT_VALUE);
2859   1        set_plc_paramter(PLC_VCSPARAM2_SEL, PLC_VCSPARAM2_INIT_VALUE);
2860   1          set_plc_paramter(PLC_MaxPeran,PLC_MaxPeran_INIT_VALUE);
2861   1        set_plc_paramter(PLC_MinPeran,PLC_MinPeran_INIT_VALUE);
2862   1      }
2863          
2864          #ifdef HPGP_HAL_TEST
              void HHAL_Init()
              #else
2867          void HHAL_Init(sHaLayer *hal, sHpgpHalCB **ppHhalCb)
2868          #endif
2869          {
2870   1          uPlcStatusReg       plcStatus;
2871   1          uPlcLineControlReg  plcLineCtrl;  
2872   1        
2873   1      //  uPlcDevCtrlReg      plcDeviceCtrl;
2874   1          uAesCpuCmdStatReg   aesCpuCmd;
2875   1        uPlcSMCounterReg    plcSMCnt;
2876   1          u16 i;
2877   1      
2878   1      //  u32                RegValue;
2879   1      #ifdef POWERSAVE
                u8 byteVal;
              #endif
2882   1      
2883   1      #ifndef HPGP_HAL_TEST
2884   1          gHpgpHalCB.hal = hal;
2885   1          
2886   1          *ppHhalCb = &gHpgpHalCB;
2887   1      #endif    //HPGP_HAL_TEST
2888   1      
2889   1          plcStatus.reg              = 0;
2890   1          plcStatus.s.crsBypass      = 0;
2891   1          plcStatus.s.soundEnable    = 0;
2892   1          plcStatus.s.plcTxQSwCtrl   = 1; 
2893   1      #ifndef MPER
2894   1          plcStatus.s.randomBackoff = 1;  // Upper mac discovey beacon collision with datapath test. so have to 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 49  

             -enable randomBackoff
2895   1      #else
                  plcStatus.s.randomBackoff = 0; 
              #endif
2898   1        //plcStatus.s.plcTxQHwCtrl   = 1;
2899   1        plcStatus.s.mpiChkFlush    = 1;
2900   1      #ifdef _AES_SW_
                  plcStatus.s.hwAesResetEnb  = 1;
              #endif
2903   1      // [YM] plcStatus.s.plcRxEnSwCtrl is used only on Hybrii_A 
2904   1      //    plcStatus.s.plcRxEnSwCtrl  = 1;
2905   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2906   1        plcStatus.s.soundEnable    = 1;
2907   1        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2908   1          // Program PLC_PHYLATENCY_SEL Init Value
2909   1          plc_init_parameters();
2910   1      
2911   1       
2912   1        
2913   1           plcLineCtrl.reg = 0;
2914   1           plcLineCtrl.s.usTimerMark = 0;
2915   1           plcLineCtrl.s.cpuFreq = 0;//25 mhz
2916   1           //plcLineCtrl.s.dcmode = 1;
2917   1           plcLineCtrl.s.hybernate = 1;
2918   1      
2919   1      #ifdef PLC_SW_SYNC
2920   1           plcLineCtrl.s.swSync = 1;
2921   1           plcLineCtrl.s.swPER = 1;
2922   1      //      plcLineCtrl.s.swSync = 0;
2923   1          // plcLineCtrl.s.swPER = 0;
2924   1      #endif
2925   1          WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg); 
2926   1        
2927   1          WriteU32Reg(PLC_MAXRETRYCNT_REG, ctorl(PLC_MAXRETRYCNT_INIT_VALUE));
2928   1        
2929   1        WriteU32Reg(CPU_ETHERSA0_REG, ctorl(CPU_ETHERSA0_INIT_VALUE));
2930   1        
2931   1        WriteU32Reg(CPU_ETHERSA1_REG, ctorl(CPU_ETHERSA1_INIT_VALUE));
2932   1        
2933   1        WriteU8Reg(ETHMAC_MACMODE_REG, 0);
2934   1        WriteU8Reg(ETHMAC_TXDEFPARM_REG, 0xC);
2935   1        WriteU8Reg(ETHMAC_TXCTL1_REG, 0x11);
2936   1        WriteU8Reg(ETHMAC_RXCTL_REG, 0xF);
2937   1        
2938   1        WriteU32Reg(PLC_EARLYHPGPBPINT_REG, ctorl(PLC_EARLYHPGPBPINT_INIT_VALUE));
2939   1      
2940   1         
2941   1           // Initialize SSN Memory - 256*4 DWORDS
2942   1           for(i=0;i<1024;i++) 
2943   1           {
2944   2             WriteU32Reg(PLC_SSNMEMADDR_REG, ctorl(i));
2945   2             WriteU32Reg(PLC_SSNMEMDATA_REG, 0); 
2946   2           }
2947   1         
2948   1           // Wait for Cpu Aes Lut access grant
2949   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2950   1           aesCpuCmd.s.cpuTblReq = 1;
2951   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2952   1         
2953   1           CHAL_DelayTicks(100);
2954   1         
2955   1           // Initialize PPEK Addr table  - 256 bytes
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 50  

2956   1           for(i=0;i<256;i++)  
2957   1           {
2958   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(i));
2959   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
2960   2           }
2961   1         
2962   1           // Initialize NEK Valid table - 8 bytes
2963   1           for(i=0;i<8;i++)  
2964   1           {
2965   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(256+i));
2966   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
2967   2           }
2968   1         
2969   1           // Initilaize AES Key Table  - 1024 DWORDS
2970   1           // only 1152 DWORDS actually used to store keys
2971   1           for(i=0;i<1024;i++) 
2972   1           {
2973   2             WriteU32Reg(PLC_AESKEYLUTADDR_REG, ctorl(i));
2974   2             WriteU32Reg(PLC_AESKEYLUTDATA_REG, 0);
2975   2           }
2976   1         
2977   1           // Release CPU Lock on AES LUT
2978   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2979   1           aesCpuCmd.s.cpuTblGnt = 0;
2980   1           aesCpuCmd.s.cpuTblReq = 0;
2981   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
2982   1      
2983   1      
2984   1      
2985   1          // Initialize HPGP HAL Control Blok  
2986   1          gHpgpHalCB.diagModeEnb       = 0;
2987   1          gHpgpHalCB.bcnInitDone       = 0;
2988   1          gHpgpHalCB.ppekValidReg      = 0;
2989   1          gHpgpHalCB.syncComplete      = 0;
2990   1          gHpgpHalCB.scanEnb           = 0;
2991   1          gHpgpHalCB.swSyncEnb         = 0;
2992   1          gHpgpHalCB.lastNtbB4         = 0;
2993   1          gHpgpHalCB.lastNtbAft        = 0;
2994   1          gHpgpHalCB.lastBpst          = 0;
2995   1          gHpgpHalCB.lastBcnRxTime     = 0;
2996   1          gHpgpHalCB.bcnPerSum         = 0;
2997   1          gHpgpHalCB.curBcnPer         = 0;
2998   1          gHpgpHalCB.perSumCnt         = 0;
2999   1          gHpgpHalCB.bPerAvgInitDone   = 0;
3000   1          gHpgpHalCB.bBcnNotSent       = 0; 
3001   1          gHpgpHalCB.BcnTxWaitTimeoutCnt = 0;
3002   1          gHpgpHalCB.nwSelected        = 0;
3003   1        gHpgpHalCB.nwSelectedSnid = 0;
3004   1          gHpgpHalCB.bTxPending        = 0;
3005   1          //gHpgpHalCB.bBcnTxPending     = 0;
3006   1          gHpgpHalCB.BcnLateCnt = 0;
3007   1      #ifndef HPGP_HAL_TEST 
3008   1          gHpgpHalCB.tei               = 0;
3009   1      #else
                  memcpy(gHpgpHalCB.nid, gDefNID, NID_LEN);
              #endif  
3012   1          gHpgpHalCB.plcTx10FC.reg = HPGP_HP10FC_DEF;
3013   1      #ifdef POWERSAVE
                  gHpgpHalCB.psAvln            = TRUE;
                  gHpgpHalCB.psInSleepMode     = FALSE;
              #endif
3017   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 51  

3018   1      
3019   1          // Setup default network as DC mode CCo & configure default addr
3020   1          // HPGP stack will overwrite in due course.
3021   1      #ifdef HPGP_HAL_TEST
                  HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
                  HHAL_SetDefAddrConfig();
              #else
3025   1          if (opMode == UPPER_MAC)
3026   1          {
3027   2            HHAL_SetSnid(0);
3028   2            HHAL_SetDevMode(hal, DEV_MODE_STA, gHpgpHalCB.lineMode);//LINE_MODE_DC);
3029   2          }
3030   1          else
3031   1          {
3032   2               HHAL_SetDevMode(hal, DEV_MODE_CCO, LINE_MODE_DC);
3033   2               if(gHpgpHalCB.devMode == DEV_MODE_CCO)
3034   2               {
3035   3                   gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
3036   3                   gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
3037   3               }else
3038   2               {
3039   3                   gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
3040   3                   gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
3041   3               }
3042   2               gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
3043   2            
3044   2               HHAL_SetTei(gHpgpHalCB.selfTei);
3045   2       
3046   2               HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other
             - chip snid should be set once we receive bcn from cco and should not get set at power on because 
3047   2          }
3048   1      #endif
3049   1      
3050   1      #if 0
                  //[YM] set RSSI-FIFO lock for sound packet
                  WriteU32Reg(PLC_RSSI_REG, ctorl(0x1));
              #endif
3054   1      
3055   1          // Setting for Hybrii ASIC
3056   1          WriteU8Reg(0x401, 0x03);   //Enable GAFE SPI
3057   1          WriteU8Reg(0x402, 0x10);
3058   1          // ADC PLC Clk flip
3059   1          mac_utils_spi_write(0x29,0x04);   //added by varsha
3060   1        // Enable Sync timeout 
3061   1          WriteU8Reg(0x483, 0x33);
3062   1        //WriteU8Reg(0x483, 0x13);
3063   1      #ifdef B_FPGA   
                  WriteU8Reg(0x4d9, 0x67); //For FPGA only, extra delay
                  WriteU8Reg(0x4d8, 0x84);
                
                //Sync threshold
                  //WriteU8Reg(0x48a, 0x90);     //should be re-check for ASIC, commented out for FPGA
                
                //Energy detection and AGC Saturation Threshold
                  WriteU8Reg(0x479, 0x52); 
              #endif
3073   1      // Add Sync threshold - Rachel 0317-2014
3074   1          //WriteU8Reg(0x478, 0x11);    // For long range
3075   1        WriteU8Reg(0x478, 0x05);    // Jenny new setting 03242014
3076   1        WriteU8Reg(0x484, 0x52);
3077   1        //WriteU8Reg(0x48A, 0xCA);
3078   1        WriteU8Reg(0x48A, 0xFF);     // Jenny new setting 03242014
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 52  

3079   1        WriteU8Reg(0x48B, 0x00);
3080   1        WriteU8Reg(0x4DE, 0xF0);     // Jenny new setting 03242014
3081   1        WriteU8Reg(0x4DF, 0xFF);     // Jenny new setting 03242014
3082   1        WriteU8Reg(0x4E0, 0xFF);     // Jenny new setting 03242014
3083   1        
3084   1      #if 1    
3085   1          // Add init setting for Rachel - YMCHEN 09262013
3086   1          WriteU8Reg(0x48c, 0xcb);
3087   1        WriteU8Reg(0x48d, 0x96);
3088   1        WriteU8Reg(0x48e, 0x2d);
3089   1        WriteU8Reg(0x48f, 0x5b);
3090   1        WriteU8Reg(0x490, 0xb6);
3091   1        WriteU8Reg(0x491, 0x6c);
3092   1        WriteU8Reg(0x492, 0xd9);
3093   1        WriteU8Reg(0x493, 0xb2);
3094   1        WriteU8Reg(0x494, 0x65);
3095   1        WriteU8Reg(0x495, 0xcb);
3096   1        WriteU8Reg(0x496, 0x96);
3097   1        WriteU8Reg(0x497, 0x2d);
3098   1        WriteU8Reg(0x498, 0x5b);
3099   1        WriteU8Reg(0x499, 0xb6);
3100   1        WriteU8Reg(0x49a, 0x6c);
3101   1        WriteU8Reg(0x49b, 0xd9);
3102   1        WriteU8Reg(0x49c, 0xb2);
3103   1        WriteU8Reg(0x49d, 0x65);
3104   1        WriteU8Reg(0x49e, 0xcb);
3105   1        WriteU8Reg(0x49f, 0x96);
3106   1        WriteU8Reg(0x4a0, 0x2d);
3107   1        WriteU8Reg(0x4a1, 0x5b);
3108   1        WriteU8Reg(0x4a2, 0xb6);
3109   1        WriteU8Reg(0x4a3, 0x74);
3110   1        WriteU8Reg(0x4a4, 0xc9);
3111   1        WriteU8Reg(0x4a5, 0xe2);
3112   1        WriteU8Reg(0x4a6, 0x45);
3113   1        WriteU8Reg(0x4a7, 0x0b);
3114   1        WriteU8Reg(0x4a8, 0x17);
3115   1        WriteU8Reg(0x4a9, 0xcc);
3116   1        WriteU8Reg(0x4aa, 0x9d);
3117   1        WriteU8Reg(0x4ab, 0x33);
3118   1        WriteU8Reg(0x4ac, 0x7b);
3119   1        WriteU8Reg(0x4ad, 0xd6);
3120   1        WriteU8Reg(0x4ae, 0xcc);
3121   1        WriteU8Reg(0x4af, 0x19);
3122   1        WriteU8Reg(0x4b0, 0x53);
3123   1        WriteU8Reg(0x4b1, 0xa7);
3124   1        WriteU8Reg(0x4b2, 0x4c);
3125   1        WriteU8Reg(0x4b3, 0x9e);
3126   1        WriteU8Reg(0x4b4, 0x34);
3127   1        WriteU8Reg(0x4b5, 0x71);
3128   1        WriteU8Reg(0x4b6, 0xc2);
3129   1        WriteU8Reg(0x4b7, 0xd8);
3130   1        WriteU8Reg(0x4b8, 0x31);
3131   1        WriteU8Reg(0x4b9, 0xa3);
3132   1        WriteU8Reg(0x4ba, 0x47);
3133   1        WriteU8Reg(0x4bb, 0x8d);
3134   1        WriteU8Reg(0x4bc, 0x1c);
3135   1        WriteU8Reg(0x4bd, 0x31);
3136   1        WriteU8Reg(0x4be, 0x74);
3137   1        WriteU8Reg(0x4bf, 0xc8);
3138   1        WriteU8Reg(0x4c0, 0xe0);
3139   1        WriteU8Reg(0x4c1, 0x41);
3140   1        WriteU8Reg(0x4c2, 0x03);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 53  

3141   1        WriteU8Reg(0x4c3, 0x07);
3142   1        WriteU8Reg(0x4c4, 0x14);
3143   1        WriteU8Reg(0x4c5, 0x2d);
3144   1        WriteU8Reg(0x4c6, 0x52);
3145   1        WriteU8Reg(0x4c7, 0xb8);
3146   1        WriteU8Reg(0x4c8, 0x50);
3147   1        WriteU8Reg(0x4c9, 0xc1);
3148   1        WriteU8Reg(0x4ca, 0x02);
3149   1        WriteU8Reg(0x4cb, 0x41);
3150   1        WriteU8Reg(0x4cc, 0x83);
3151   1        WriteU8Reg(0x4cd, 0x04);
3152   1        WriteU8Reg(0x4ce, 0x0e);
3153   1        WriteU8Reg(0x4cf, 0x14);
3154   1        WriteU8Reg(0x4d0, 0x30);
3155   1        WriteU8Reg(0x4d1, 0x80);
3156   1        WriteU8Reg(0x4d2, 0x51);
3157   1        WriteU8Reg(0x4d3, 0x23);
3158   1        WriteU8Reg(0x4d4, 0x86);
3159   1        WriteU8Reg(0x4d5, 0x0d);
3160   1        WriteU8Reg(0x4d6, 0x19);
3161   1        WriteU8Reg(0x4d7, 0x04);
3162   1      #endif 
3163   1      #if 0
                  // Disable ADC hold - Rachel 0318-2014
                WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x44D, 0x0);
                WriteU8Reg(0x44F, 0x0);
                WriteU8Reg(0x4FA, 0x0); 
              #endif
3170   1      #ifdef B_ASICPLC
3171   1          mac_utils_spi_write(0x16,0x01);    // Enable PLC mode for AFE
3172   1          mac_utils_spi_write(0x36,0x12);   //added by YM, Jenny suggested 
3173   1      #endif
3174   1          //He li provided following regs for DC Offset setting
3175   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3176   1           mac_utils_spi_write(0x3a,0x08);   //added by varsha
3177   1           mac_utils_spi_write(0x3b,0x40);   //added by varsha 
3178   1           mac_utils_spi_write(0x18,0xa0);   //added by varsha
3179   1         // add delay > 100us
3180   1         CHAL_DelayTicks(6400);
3181   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3182   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3183   1           mac_utils_spi_write(0x3a,0x0f);   //added by varsha 
3184   1           mac_utils_spi_write(0x3b,0x74);   //added by varsha
3185   1           mac_utils_spi_write(0x18,0xc0);   //added by varsha
3186   1         // add delay > 100us
3187   1         CHAL_DelayTicks(6400);
3188   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3189   1         
3190   1      #ifdef B_ASICPLC
3191   1           mac_utils_spi_write(0x36,0x0);   //added by YM, Jenny suggested 
3192   1           mac_utils_spi_write(0x16,0x0);
3193   1      #endif
3194   1      
3195   1      //#ifdef B_FPGA
3196   1           WriteU8Reg(0x47F, 0x05);
3197   1      //#endif
3198   1           WriteU8Reg(0x485, TCC_REG_485_486_val[2][0]);  //TCC =3
3199   1           WriteU8Reg(0x486, TCC_REG_485_486_val[2][1]);
3200   1      
3201   1      //#ifdef HPGP_HAL_TEST // WAR: code reactivated to reduce loss in lower mac
3202   1      //    WriteU8Reg(0x478, 0x61); 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 54  

3203   1      //#else
3204   1      //    WriteU8Reg(0x478, 0x51); 
3205   1      //#endif  
3206   1      
3207   1      #if 0
                  // [YM] PHY setting for Hybrii_B FPGA HP101/HP11 Detection 
                  if (gHpgpHalCB.HP101Detection)
                  {
                     plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);   
                   plcStatus.s.HP10Detect = 1;         //Enable MAC for HP10 detection
                     WriteU32Reg(PLC_STATUS_REG,plcStatus.reg);
                      
                      WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
                      tmp = ReadU8Reg(0x46F);
                      WriteU8Reg(0x46F, tmp&0xF7);  //Enable HP101 detection bit
                      WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
                  } 
              #endif
3221   1          
3222   1        // [YM] Based on Jayesh's suggestion 0307-2014
3223   1              WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
3224   1              WriteU8Reg(0x46F, 0xB);  //Enable HP101 detection bit
3225   1              WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
3226   1      #ifdef B_FPGA    
                  // Energy Detection Threshold
                  WriteU8Reg(0x478, 0x69);  //WAR: code should be deactivated to reduce loss in lower mac // according to
             - geetha comments 11/6/2012
              #endif
3230   1      //#ifdef MPER    
3231   1          mac_utils_spi_write(0x34,0x0);   //Set default txpowermode = 2 (High Tx Power Mode)
3232   1        mac_utils_spi_write(0x35,0xF);   //added by YM 0211-2014
3233   1      //#else 
3234   1      //  mac_utils_spi_write(0x34,0x08);    //Set default txpowermode = 0 (Auto Power Mode)
3235   1      //    mac_utils_spi_write(0x35,0x30);   //added by YM 0211-2014
3236   1      //#endif  //MPER
3237   1      
3238   1      #ifndef B_ASICPLC    
                // [YM] Set timeout value, based on He Li suggest
                WriteU8Reg(0x4DF, 0xCA);
              #endif  //B_ASICPLC
3242   1        
3243   1      #if (defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)  
              
              
              //#ifdef GV7013
                  
                    //[YM] change new setting value for long range 11-21-2013, make it as default for GV7013
                      WriteU8Reg(0x48a, 0xEA);   //the same as current default value
                      WriteU8Reg(0x48b, 0x00);
                      WriteU8Reg(0x484, 0x52);
                      WriteU8Reg(0x478, 0x11);
                      WriteU8Reg(0x483, 0x33);
                WriteU8Reg(0x4E0, 0xFF);
                WriteU8Reg(0x4DF, 0xFF);
              //#endif    
              //#if (defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)       
                      //[YM] add new setting value for LED, 01-09-2014
                      WriteU8Reg(0x4F0, 0x80);  //Turn off SCO in PHY, Extend Range
              #endif  //(defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)
3261   1          // Force Hybrid Mode  
3262   1      //    WriteU8Reg(0x4EB, 0x18);  
3263   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 55  

3264   1      
3265   1          // Reset/Init Statistics
3266   1          HHAL_ResetPlcStat();
3267   1         
3268   1          //WriteU8Reg(0xF07,0x01);           // csma 
3269   1      #ifndef B_ASICPLC
                  WriteU8Reg(0x423,0xC3);
              ////////////////////////////////////////////////////////////////
                 //WriteU8Reg(0xF07,0x01);
                 //WriteU8Reg(0xF06,0x00);
              #else
3275   1         //WriteU8Reg(0xF07,0xC1);
3276   1         //WriteU8Reg(0xF06,0x00);
3277   1         WriteU8Reg(0x423,0x81);
3278   1      #endif
3279   1         
3280   1          HHAL_AFEInit();
3281   1      
3282   1      //Set default Rx power mode to 1 - Reduce ADC power consumption
3283   1          mac_utils_spi_write(0x26, 0x1C);   //added by Yiming, 0211-2013
3284   1      
3285   1        // init CP Map
3286   1        for (i = 0; i < HYBRII_CPCOUNT_MAX; i++)
3287   1        {
3288   2          uPlcCpMapIdx plcCpMapIdx;
3289   2          uPlcCpMap plcCpMap;
3290   2      //    uPlcCpuWrCp plcCpuWrCp;
3291   2      
3292   2          plcCpMapIdx.reg = 0;
3293   2          plcCpMapIdx.s.cp_map_idx = i;
3294   2          WriteU32Reg(CPU_CPUSAGECNTIDX_REG, plcCpMapIdx.reg);
3295   2      
3296   2          plcCpMap.reg = 0;
3297   2          plcCpMap.s.cp_map = 1;
3298   2          WriteU32Reg(CPU_CPUSAGECNT_REG, plcCpMap.reg);
3299   2      
3300   2      //    CHAL_DecrementReleaseCPCnt(i);
3301   2        }
3302   1      //    WriteU32Reg(PLC_LINECTRL_REG,ctorl(0x400));
3303   1      
3304   1        // init Hang Counter Int.
3305   1        plcSMCnt.reg = RTOCL(PLC_SM_MAX_CLK_CNT);
3306   1        plcSMCnt.s.enable = TRUE;
3307   1        WriteU32Reg(PLC_SM_MAXCNT, plcSMCnt.reg);
3308   1      
3309   1      // [YM] For Hybrii_B LLP LED project
3310   1      #ifdef LED_PWM
                  WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x45C, 0x0);
                WriteU8Reg(0x45D, 0x0);
                WriteU8Reg(0x45E, 0x0);
                WriteU8Reg(0x45F, 0x0);
                WriteU8Reg(0x460, 0x0);
                WriteU8Reg(0x461, 0x0);
                WriteU8Reg(0x462, 0x0);
                WriteU8Reg(0x463, 0x0);
                WriteU8Reg(0x464, 0x0);
                WriteU8Reg(0x465, 0x0);
                WriteU8Reg(0x466, 0x0);
                WriteU8Reg(0x467, 0x0);
                WriteU8Reg(0x468, 0x0);
                WriteU8Reg(0x469, 0x0);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 56  

                WriteU8Reg(0x46A, 0x0);
                WriteU8Reg(0x46B, 0x0);
                //WriteU8Reg(0x45A, 0xDF);
                //WriteU8Reg(0x45B, 0x05);
                //[YM] 0610-2014, He Li requested range change from 1 ~ 0x2EB
                WriteU8Reg(0x45A, 0xEC);
                WriteU8Reg(0x45B, 0x02);
                WriteU8Reg(0x458, 0x11);
                WriteU8Reg(0x459, 0x11);
                WriteU8Reg(0x4FA, 0x0);
              
                //Set Init value for PWM LED channel
                
                  {
                       WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x45E, 0x01);
                   WriteU8Reg(0x45F, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                  }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x462, 0x01);
                   WriteU8Reg(0x463, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x466, 0x01);
                   WriteU8Reg(0x467, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x46A, 0x01);
                   WriteU8Reg(0x46B, 0x0);
                   WriteU8Reg(0x4FA, 0x0);
                }
              
              #endif
3368   1      #ifdef LED_DC
                  WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x45C, 0x0);
                WriteU8Reg(0x45D, 0x0);
                WriteU8Reg(0x45E, 0x0);
                WriteU8Reg(0x45F, 0x0);
                WriteU8Reg(0x460, 0x0);
                WriteU8Reg(0x461, 0x0);
                WriteU8Reg(0x462, 0x0);
                WriteU8Reg(0x463, 0x0);
                WriteU8Reg(0x464, 0x0);
                WriteU8Reg(0x465, 0x0);
                WriteU8Reg(0x466, 0x0);
                WriteU8Reg(0x467, 0x0);
                WriteU8Reg(0x468, 0x0);
                WriteU8Reg(0x469, 0x0);
                WriteU8Reg(0x46A, 0x0);
                WriteU8Reg(0x46B, 0x0);
                WriteU8Reg(0x45A, 0xFF);
                WriteU8Reg(0x45B, 0x0);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 57  

                WriteU8Reg(0x458, 0x0);
                WriteU8Reg(0x459, 0x10);
                WriteU8Reg(0x4FA, 0x0);
              
                //Set Init value for DC10V LED channel
                WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x46A, 0x01);
                WriteU8Reg(0x4FA, 0x0);
              #endif
3397   1      #ifdef POWERSAVE_NO
                  byteVal = ReadU8Reg(0x422);
                byteVal |= 0x8;
                  WriteU8Reg(0x422,byteVal);
              #endif
3402   1      }
3403          
3404              
3405          void HHAL_ResetPlcStat()
3406          {   
3407   1          memset(&gHpgpHalCB.halStats, 0, sizeof(shpgpHalStats));
3408   1          
3409   1          // Clear Err Count registers
3410   1          WriteU32Reg(PLC_ADDRFILTERERRCNT_REG, 0);
3411   1          WriteU32Reg(PLC_FCCSERRCNT_REG, 0);
3412   1          WriteU32Reg(PLC_PBCSRXERRCNT_REG, 0);
3413   1          WriteU32Reg(PLC_PBCSTXERRCNT_REG, 0);
3414   1          WriteU32Reg(PLC_ICVERRCNT_REG, 0);  
3415   1          WriteU32Reg(PLC_MPDUDROPCNT_REG, 0);  
3416   1        
3417   1        gHalCB.qc_no_1st_desc = 0; 
3418   1        gHalCB.qc_too_many_desc = 0; 
3419   1        gHalCB.qc_no_desc = 0; 
3420   1        gHalCB.qc_no_grant = 0; 
3421   1          gHalCB.cp_no_grant_alloc_cp = 0;
3422   1          gHalCB.cp_no_grant_free_cp = 0;
3423   1          gHalCB.cp_no_grant_write_cp = 0;
3424   1          gHalCB.cp_no_grant_read_cp = 0;
3425   1      }
3426          
3427          // Internal functios 
3428          
3429          void hhal_setStaSnidValid()
3430          {
3431   1          uPlcDevCtrlReg plcDevCtrl;
3432   1      
3433   1          if(gHpgpHalCB.devMode == DEV_MODE_STA)
3434   1          {
3435   2              plcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
3436   2              plcDevCtrl.s.snidValid = 1;
3437   2              WriteU32Reg(PLC_DEVCTRL_REG, plcDevCtrl.reg);
3438   2          }   
3439   1      }
3440          
3441          void hal_hpgp_mac_monitoring (void)
3442          {
3443   1          u32             sm_status1;
3444   1          u32             sm_status2;
3445   1      
3446   1          uPlcMedStatReg  plcMedStat;
3447   1      
3448   1      /*    if(gHpgpHalCB.halStats.bcnSyncCnt == 1 && ReadU32Reg(PLC_FCCSERRCNT_REG)!=0)
3449   1          {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 58  

3450   1              // Reset mpi Rx
3451   1              HHAL_mpiRxReset();
3452   1              //FM_Printf(FM_MINFO,"Resetting Mpi Rx\n");
3453   1          }*/
3454   1          if (gHpgpHalCB.halStats.macTxStuckCnt > 1000) {
3455   2              //printf("\nMAC Tx Stucked");
3456   2          }
3457   1          if (gHpgpHalCB.halStats.macRxStuckCnt > 1000) {
3458   2              //printf("\nMAC Rx Stucked");
3459   2          }
3460   1          //sm_status1 = ReadU32Reg(PLC_SMSHADOW1_REG);// & 0x00003fff;
3461   1          sm_status1 =  hal_common_reg_32_read(PLC_SMSHADOW1_REG);
3462   1          sm_status2 = ReadU32Reg(PLC_SMSHADOW2_REG); //& 0x03ffffff;
3463   1      
3464   1          if (sm_status1 == 0 && sm_status2 == 0) {
3465   2              plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
3466   2              if (plcMedStat.s.phyActive) {
3467   3                  gHpgpHalCB.halStats.phyStuckCnt++;
3468   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3469   4                      //printf("\nPhy Stucked");
3470   4                      // gHpgpHalCB.halStats.macHangRecover1++;
3471   4                      //gHpgpHalCB.halStats.macRxStuckCnt = 0;
3472   4                      /*
3473   4                       * MAC is idle but Phy is stuck. Reset the PHY
3474   4                       * by dropping RX Enable
3475   4                       */
3476   4                      //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3477   4                      //plcStatus.s.nRxEn = 1;
3478   4                      //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3479   4                  }
3480   3              } else {
3481   3                  gHpgpHalCB.halStats.phyStuckCnt = 0;
3482   3              }
3483   2              if (plcMedStat.s.mpiRxEn == 0) {
3484   3                  gHpgpHalCB.halStats.mpiRxStuckCnt++;
3485   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3486   4                      //printf("\nMPI RX Stucked");
3487   4                  }
3488   3              } else {
3489   3                  gHpgpHalCB.halStats.mpiRxStuckCnt = 0;
3490   3              }
3491   2          } else {
3492   2              if (sm_status2 != 0) {
3493   3                  gHpgpHalCB.halStats.smTxStuckCnt++;
3494   3                  if (gHpgpHalCB.halStats.smTxStuckCnt > 1000) {
3495   4                      //printf("\nSM TX Stucked");
3496   4                  }
3497   3              } else {
3498   3                  gHpgpHalCB.halStats.smTxStuckCnt = 0;
3499   3              }
3500   2              if (sm_status1 != 0) {
3501   3                  gHpgpHalCB.halStats.smRxStuckCnt++;
3502   3                  if (gHpgpHalCB.halStats.smRxStuckCnt > 1000) {
3503   4                     // printf("\nSM RX Stucked");
3504   4                  }
3505   3              } else {
3506   3                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
3507   3              }
3508   2          }
3509   1      }
3510          
3511          #ifndef HPGP_HAL_TEST
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 59  

3512          
3513          eStatus  HHAL_BcnRxIntHandler(sHaLayer *hal, sEvent *event)
3514          {
3515   1          sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
3516   1          u32              *pValue32 = NULL;
3517   1          u32               value32 = 0;
3518   1          sHybriiRxBcnHdr*  pRxBcnHdr = NULL;
3519   1          u8                i;
3520   1          uPlcStatusReg     plcStatus;
3521   1          eStatus           ret = STATUS_SUCCESS;
3522   1          sHpgpHdr         *hpgpHdr = NULL;
3523   1          sHpgpHalCB       *hhalCb = hal->hhalCb;
3524   1        u8         *rxArr;
3525   1          u8               u8val;
3526   1          
3527   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3528   1      
3529   1          hhalCb->halStats.BcnRxIntCnt++;
3530   1      
3531   1          //FM_Printf(FM_MINFO, "HHAL_BcnRxIntHandler : Bcn received, SnapShot = %bu, Id = %lX\n", pRxBcnHdr->sn
             -apShot, rtocl(ReadU32Reg(PLC_IDENTIFIER_REG)));
3532   1      
3533   1          // Confirm that Bcn Rx Fifo is not emplty.
3534   1          // plcStatus.s.bcnRxFifoStat;
3535   1          /* read the beacon Rx descriptor first */
3536   1          value32 = ReadU32Reg(PLC_BCNRXFIFO_REG);
3537   1          pRxBcnHdr = (sHybriiRxBcnHdr*)&value32;
3538   1          hhalCb->snapShot = pRxBcnHdr->snapShot;
3539   1          /* then, read the beacon */
3540   1        pValue32  = (u32 *)(event->buffDesc.dataptr);
3541   1      #ifdef UM
3542   1        if(1 == eth_plc_sniffer)
3543   1        {
3544   2            pValue32  += ((sizeof(sEth2Hdr) + sizeof(hostHdr_t)) / sizeof(u32)); // Ethernet header + Hybrii head
             -er
3545   2        }
3546   1      #endif
3547   1      
3548   1        for ( i = 0; i < (BEACON_LEN >> 2); i++)
3549   1          {
3550   2              pValue32[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
3551   2          }
3552   1        event->buffDesc.datalen = BEACON_LEN;
3553   1          //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3554   1          //plcStatus.s.decBcnRxCnt = 1;
3555   1          //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3556   1          u8val = ReadU8Reg(PLC_STATUS_REG+1);
3557   1        u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
3558   1        WriteU8Reg(PLC_STATUS_REG+1, u8val);
3559   1        rxArr = event->buffDesc.dataptr;
3560   1      #ifdef UM 
3561   1      #ifdef HYBRII_ETH
3562   1        if(1 == eth_plc_sniffer)
3563   1        {
3564   2            EHT_FromPlcBcnTx(rxArr, PLC_BCNRX_LEN);
3565   2        }
3566   1        else
3567   1      #endif
3568   1      #endif
3569   1          {
3570   2              // Update statistics.
3571   2      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 60  

3572   2                  /* TODO: if consective good beacons are received */
3573   2      
3574   2      
3575   2              if(pRxBcnHdr->fccsCorrect)
3576   2              {
3577   3                  hhalCb->bcnDetectFlag = 1;
3578   3                  pFrmCtrlBlk = (sFrmCtrlBlk*) (event->buffDesc.dataptr);
3579   3                  hhalCb->bts = ((u32)(pFrmCtrlBlk->bts[3])<<24) + 
3580   3                                ((u32)(pFrmCtrlBlk->bts[2])<<16) + 
3581   3                                ((u32)(pFrmCtrlBlk->bts[1])<<8) + 
3582   3                                 (u32)(pFrmCtrlBlk->bts[0]);                      
3583   3                  /* TODO: Adjust NTB in the device */
3584   3                     gCCO_NTB =  hhalCb->bts;   
3585   3      
3586   3                     gHpgpHalCB.bcnmisscnt = 0;
3587   3      
3588   3      
3589   3                                 
3590   3                     gCCO_BTS =  hhalCb->bts;
3591   3          // Extract Bto, ded
3592   3          
3593   3      //            HHAL_AdjustNextBcnTime(hal, pFrmCtrlBlk->bto);
3594   3              }
3595   2              // Update statistics.
3596   2              if (pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && 
3597   2                  !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && 
3598   2                  !pRxBcnHdr->rsv3 && !pRxBcnHdr->rsv4 )  
3599   2              {  
3600   3                  hhalCb->halStats.TotalRxGoodFrmCnt++;
3601   3                  hhalCb->halStats.RxGoodBcnCnt++;
3602   3      
3603   3                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
3604   3              //            hpgpHdr->tei = rxdesc->ste;
3605   3                  hpgpHdr->snid = pFrmCtrlBlk->snid;
3606   3                  {
3607   4                      event->buffDesc.dataptr += sizeof(sFrmCtrlBlk); 
3608   4                      event->buffDesc.datalen -= sizeof(sFrmCtrlBlk); 
3609   4                      /* process the high priority portion of the beacon */
3610   4      #ifdef CALLBACK
                              hal->procBcn(hal->bcnCookie, event);
              #else
3613   4                      if (hhalCb->devMode == DEV_MODE_CCO)
3614   4                      {
3615   5      #ifdef CCO_FUNC
3616   5                          LINKL_CcoProcBcnHandler(hal->bcnCookie, event);
3617   5      #endif
3618   5                      }
3619   4                      else 
3620   4                      {
3621   5      #ifdef STA_FUNC
3622   5                          LINKL_StaProcBcnHandler(hal->bcnCookie, event);
3623   5      #endif
3624   5                      }
3625   4      #endif
3626   4                  }
3627   3              } 
3628   2              else
3629   2              {
3630   3                  hhalCb->halStats.RxErrBcnCnt++;
3631   3                  /* bad beacon is received, thus the beacon is lost */
3632   3                  /* TODO: adjust the next becaon period using bto */
3633   3                  hhalCb->bcnDetectFlag = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 61  

3634   3                  ret = STATUS_FAILURE;
3635   3              }
3636   2      
3637   2          }
3638   1          // Any more beacons ?
3639   1      //    plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3640   1      
3641   1          return ret;
3642   1      }
3643          
3644          u8 HHAL_GetBcnCnt(sHaLayer *hal)
3645          {
3646   1          uPlcStatusReg     plcStatus;
3647   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3648   1          return plcStatus.s.plcBcnCnt;
3649   1      }
*** WARNING C280 IN LINE 3644 OF ..\..\..\hal\hal_hpgp.c: 'hal': unreferenced local variable
3650          
3651          
3652          
3653          eStatus HHAL_PrepareTxFrame(sHaLayer *hal, sTxDesc *txInfo, 
3654                                      sSwFrmDesc *txFrmSwDesc)
3655          {
3656   1          //FM_Printf(FM_MINFO, ">>>PrepareTxFrame:\n");
3657   1      
3658   1          if(txInfo->mnbc)
3659   1          {
3660   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
3661   2          }
3662   1          else if(txInfo->dtei == 0xFF)
3663   1          {
3664   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
3665   2          }
3666   1          else
3667   1          {
3668   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
3669   2          }
3670   1      
3671   1        if (txInfo->mcst == 1)
3672   1        {
3673   2          txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
3674   2        }
3675   1        
3676   1      //printf("HHAL_PrepareTxFrame=%bu, txInfo->dtei=%bu\n", HHAL_PrepareTxFrame, txInfo->dtei);
3677   1          txFrmSwDesc->frmInfo.plc.dtei = txInfo->dtei;
3678   1          txFrmSwDesc->frmInfo.plc.stei = hal->hhalCb->tei;
3679   1          txFrmSwDesc->frmInfo.plc.eks = txInfo->eks;
3680   1      
3681   1          txFrmSwDesc->frmInfo.plc.clst = HPGP_CLST_ETH;
3682   1          txFrmSwDesc->frmInfo.plc.plid = txInfo->plid;
3683   1          txFrmSwDesc->frmInfo.plc.mfStart = txInfo->mfStart;
3684   1          txFrmSwDesc->frmInfo.plc.mfEnd = txInfo->mfEnd;
3685   1         
3686   1          if (txInfo->plid == PRI_LINK_ID_0) 
3687   1              txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP0;
3688   1          else
3689   1              txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP123;
3690   1      
3691   1          txFrmSwDesc->frmInfo.plc.roboMode = txInfo->roboMode;
3692   1      
3693   1      
3694   1        txFrmSwDesc->frmInfo.plc.snid = txInfo->snid;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 62  

3695   1      
3696   1      
3697   1      #if 0
                  if (txInfo->roboMode == HPGP_ROBOMD_MINI)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_136;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_MINIROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else if (txInfo->roboMode == HPGP_ROBOMD_STD)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_STDROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else
                  {
                      /* HS ROBO */
                      txFrmSwDesc->frmInfo.plc.roboMode = HPGP_ROBOMD_HS;
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      if (txInfo->numPbs == 1)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_1PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                      }
                      else if (txInfo->numPbs == 2)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_2PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_TWO_PB;
                      }
                      else if (txInfo->numPbs == 3)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_3PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_THREE_PB;
                      }
                      else 
                      {
                          FM_Printf(FM_ERROR,"HHAL: PB Num Err");
                          return STATUS_FAILURE;
                      }
                  }
              #endif
3737   1      
3738   1          //FM_Printf(FM_MINFO, "<<<PrepareTxFrame:\n");
3739   1      
3740   1          return STATUS_SUCCESS;      
3741   1      }
3742          
3743          #endif
3744          
3745          
3746          /*******************************************************************
3747          * NAME :            HHAL_AdjustNextBcnTime
3748          *
3749          * DESCRIPTION :     The function is called at STA side passing the bto as input.
3750          *                   It adjusts the BP Length based on the 2's complement bto value
3751          *                   that CCo sends in the FC.bto[0] field.
3752          *
3753          */
3754          #ifdef HPGP_HAL_TEST
              void HHAL_AdjustNextBcnTime(u16 *bto)
              #else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 63  

3757          void HHAL_AdjustNextBcnTime(sHaLayer *hal, u16 *bto)
3758          #endif
3759          {
3760   1          u16 btoVal = le16_to_cpu(*bto);
3761   1          if (gHpgpHalCB.lineMode == LINE_MODE_AC)
3762   1          {   
3763   2              // bto is a negative 2's complement value.
3764   2              if( btoVal > 0x8000)
3765   2              {
3766   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN - (0x10000 - btoVal);
3767   3              }
3768   2      
3769   2              // bto is a positive 2's complement value
3770   2              else if( btoVal != 0x8000)
3771   2              {
3772   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN + btoVal;       
3773   3              }
3774   2              
3775   2              //printf("bpLen = %lx, bto=%bx%02bx, %x\n", gHpgpHalCB.curBcnPer, pFrmCtrlBlk->bto0[1], pFrmCtrlBl
             -k->bto0[0], bto);
3776   2      
3777   2              if(gHpgpHalCB.devMode == DEV_MODE_STA)
3778   2              {
3779   3                  WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
3780   3      
3781   3              }
3782   2          }
3783   1          else
3784   1          {
3785   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
3786   2          }
3787   1      }
*** WARNING C280 IN LINE 3757 OF ..\..\..\hal\hal_hpgp.c: 'hal': unreferenced local variable
3788          
3789          #ifdef UM 
3790               
3791          eStatus CHAL_WriteFrame(sHaLayer *hal, 
3792                                  sSwFrmDesc *txFrmSwDesc, 
3793                                  sBuffDesc *buffdesc)
3794          {
3795   1          s16 resLen = buffdesc->datalen;
3796   1          u8  numCps = txFrmSwDesc->cpCount;
3797   1          u16 cellLen = 0;
3798   1          u8  i = 0;
3799   1          u8  *dataptr = buffdesc->dataptr;
3800   1          volatile u8 XDATA *cellBlk = NULL;
3801   1          sCpSwDesc *cpDesc = NULL;
3802   1      
3803   1      
3804   1          while ((resLen > 0) && (i < numCps))
3805   1          {
3806   2              cpDesc = &txFrmSwDesc->cpArr[i];
3807   2              cellBlk = CHAL_GetAccessToCP(cpDesc->cp);
3808   2              cellLen = MIN(HYBRII_CELLBUF_SIZE, resLen);
3809   2              memcpy (cellBlk, dataptr, cellLen);
3810   2              cpDesc->offsetU32 = 0; 
3811   2              cpDesc->len = (u8)cellLen; 
3812   2              dataptr += cellLen;
3813   2              resLen -= cellLen;
3814   2              i++;
3815   2          }
3816   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 64  

3817   1          if ((resLen > 0) && (i >= numCps))
3818   1          {
3819   2           //   FM_Printf(FM_ERROR, "CHAL: frame len and cp number mismatch.\n");
3820   2          }
3821   1          return STATUS_SUCCESS;
3822   1      }
*** WARNING C280 IN LINE 3791 OF ..\..\..\hal\hal_hpgp.c: 'hal': unreferenced local variable
3823          
3824          #endif
3825          
3826          
3827          void doSynchronization()
3828          {
3829   1           
3830   1         u32 zcCCONTB;
3831   1           
3832   1           zcCCONTB =  rtocl(ReadU32Reg(PLC_ZCNTB_REG));
3833   1      
3834   1      
3835   1           if(firsttime == 0)
3836   1           {
3837   2              firsttime = 1;
3838   2              zcCCONTBold = zcCCONTB; 
3839   2              return;
3840   2           }
3841   1      
3842   1         gHpgpHalCB.syncComplete = 1;
3843   1         
3844   1           if(zcCCONTB > zcCCONTBold)
3845   1              gHpgpHalCB.curBcnPer   = (zcCCONTB - zcCCONTBold);
3846   1           
3847   1      
3848   1           if((gHpgpHalCB.lineMode == LINE_MODE_AC) && (gHpgpHalCB.curBcnPer  < AC_MIN_THRESHOLD))
3849   1           {
3850   2              return;
3851   2           } 
3852   1           
3853   1           zcCCONTBold = zcCCONTB; 
3854   1            
3855   1          if( gHpgpHalCB.devMode == DEV_MODE_CCO && gHpgpHalCB.lineMode == LINE_MODE_AC )
3856   1          {
3857   2              
3858   2              //printf("\n BP = %lu", (gHpgpHalCB.curBcnPer * 40));
3859   2              if( gHpgpHalCB.curBcnPer < PLC_MIN_AC_BPLEN )
3860   2              {
3861   3                  gHpgpHalCB.curBcnPer = PLC_MIN_AC_BPLEN;
3862   3              }
3863   2              else if( gHpgpHalCB.curBcnPer > PLC_MAX_AC_BPLEN )
3864   2              {
3865   3                  gHpgpHalCB.curBcnPer = PLC_MAX_AC_BPLEN;
3866   3              }
3867   2      
3868   2              gHpgpHalCB.bcnPerSum += gHpgpHalCB.curBcnPer;
3869   2              gHpgpHalCB.perSumCnt ++;
3870   2      
3871   2              if( gHpgpHalCB.perSumCnt == PLC_BCNPERAVG_CNT )
3872   2              {
3873   3                  gHpgpHalCB.bPerAvgInitDone = 1;
3874   3                  avgdone = 1;
3875   3              }
3876   2             
3877   2              if(avgdone)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 65  

3878   2              {
3879   3                   avgdone = 0;
3880   3                   gavg       = gHpgpHalCB.bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
3881   3                   gHpgpHalCB.bcnPerSum = 0;
3882   3                   gHpgpHalCB.perSumCnt = 0;
3883   3              }
3884   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gavg >> 1)));
3885   2               
3886   2           }
3887   1      
3888   1          // Prepare and send beacon here for now.
3889   1          // This will eventually be done by hpgp nsm module.
3890   1              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
3891   1              {
3892   2                  gHpgpHalCB.bPerAvgInitDone = 1;
3893   2                   gavg       =   PLC_DC_BP_LEN; 
3894   2              }
3895   1      
3896   1            if(gHpgpHalCB.bPerAvgInitDone)
3897   1          {
3898   2                
3899   2              if(gHpgpHalCB.devMode == DEV_MODE_CCO)
3900   2            {
3901   3             
3902   3                if(zctrack == 0)
3903   3                      {
3904   4                       
3905   4                          gbpst =  gavg  + zcCCONTB + MAC_PROCESSING_CLOCK ;// + 0x1BAFF;//1365 is bpsto
3906   4                          zctrack = 1;
3907   4                          WriteU32Reg(PLC_BPST_REG, ctorl(gbpst));
3908   4                     
3909   4                      }
3910   3                      else
3911   3                      {
3912   4                      
3913   4                           avgcount++;
3914   4                           if(zcCCONTB >  gbpst)
3915   4                           {
3916   5                              
3917   5                               if(gNegativeflag)
3918   5                               {
3919   6                                 gNegativeflag = 0;
3920   6                                 gPositiveflag = 1; 
3921   6                                
3922   6                               }
3923   5                               gBPSTdelta = zcCCONTB - gbpst;
3924   5                              
3925   5                              if(gBPSTdelta > 400)//16 micro sec
3926   5                              {
3927   6                                  
3928   6                                   gNegativeflag = 0;
3929   6                                   gPositiveflag = 1;
3930   6                               }
3931   5                              
3932   5                           }
3933   4                           else
3934   4                           {
3935   5                               if(gPositiveflag)
3936   5                               {
3937   6                                 gNegativeflag = 1;
3938   6                                 gPositiveflag = 0; 
3939   6                                
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 66  

3940   6                               }
3941   5                               gBPSTdelta =  gbpst - zcCCONTB;
3942   5                               
3943   5                               if(gBPSTdelta > 400)//4 micro sec
3944   5                               {
3945   6                                  gNegativeflag = 1;
3946   6                                  gPositiveflag = 0;
3947   6                                 
3948   6                               }   
3949   5                              
3950   5                            }
3951   4                       
3952   4                       } 
3953   3                   }
3954   2               
3955   2            } 
3956   1      
3957   1      }  
3958          
3959          #ifdef FREQ_DETECT
3960          void FREQDET_DetectFrequencyUsingZC()
3961          {   
3962   1          static u8 count = 0;
3963   1           static u8 Retrycnt = 0;
3964   1          static u8 valid60Hz =0;
3965   1          static u8 valid50Hz =0;
3966   1          u32  zcCCONTB;
3967   1          static u32 zcCCONTBOld = 0;
3968   1          u32 linecyclePer;
3969   1          u8 freq;
3970   1          
3971   1      //    uPlcMedInterruptReg PlcMedInterruptReg;
3972   1         
3973   1      #ifdef UM
3974   1          sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3975   1      #endif
3976   1          count++;
3977   1          zcCCONTB =  rtocl(ReadU32Reg(PLC_ZCC_CCONTB_REG));
3978   1          //zcCCONTB =  rtocl(ReadU32Reg(PLC_NTB_REG));
3979   1          linecyclePer = (((zcCCONTB - zcCCONTBOld) * 40) / 2);
3980   1           freq = (1000000000/ linecyclePer);
3981   1          // printf("\n freq = %lu\n", ((zcCCONTB - zcCCONTBOld) * 40)); 
3982   1          zcCCONTBOld = zcCCONTB;
3983   1         
3984   1      
3985   1          if((freq <= MAX_60HZ_FREQ) && (freq >= MIN_60HZ_FREQ))
3986   1          {
3987   2              valid60Hz++;
3988   2          }
3989   1          else if((freq <= MAX_50HZ_FREQ) && (freq >= MIN_50HZ_FREQ))
3990   1          {
3991   2                valid50Hz++;
3992   2          }
3993   1       
3994   1      
3995   1          if(count == 8)
3996   1          { 
3997   2              //Retrycnt++;
3998   2              gHpgpHalCB.gFreqCB.freqDetected = TRUE; 
3999   2              if(valid50Hz > FREQUENCY_ZC_MAX_COUNT)
4000   2              {
4001   3                
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 67  

4002   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4003   3                  FREQDET_FreqSetting(FREQUENCY_50HZ);            
4004   3                  printf("\n50 HZ detected\n");
4005   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4006   3              }
4007   2              else if(valid60Hz > FREQUENCY_ZC_MAX_COUNT)
4008   2              {
4009   3                
4010   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4011   3                  FREQDET_FreqSetting(FREQUENCY_60HZ);            
4012   3                  printf("\n60 HZ detected\n");
4013   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4014   3              }
4015   2              else
4016   2              {
4017   3                 //do not set any default frequency ,insted keep on retrying and based on   gHpgpHalCB.gFreqCB.f
             -reqDetected flag Upper MAc will recognised that freq is not being detected for some problem
4018   3      #ifdef UM
4019   3                 sHaLayer *hal = HOMEPLUG_GetHal();
4020   3      #endif
4021   3             
4022   3                 printf("\n No Frequency detected" );
4023   3                 printf("\n switching to DC ..." );
4024   3                 count = 0;
4025   3                 gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4026   3             
4027   3             gHpgpHalCB.lineMode = LINE_MODE_DC;
4028   3             gHpgpHalCB.lineFreq = FREQUENCY_50HZ;      
4029   3             
4030   3      #ifdef UM
4031   3             HHAL_SetDevMode(hal, gHpgpHalCB.devMode, LINE_MODE_DC);
4032   3      #else
                     HHAL_SetDevMode(gHpgpHalCB.devMode, LINE_MODE_DC);
              #endif
4035   3             
4036   3             FREQDET_FreqSetting(gHpgpHalCB.lineFreq);
4037   3      
4038   3      
4039   3                 //gHpgpHalCB.gFreqCB.freqDetectUsingZC = TRUE;
4040   3              }
4041   2      #ifdef UM
4042   2              CNSM_InitRegion(&linkl->ccoNsm, linkl);
4043   2      
4044   2      #else
                  
              if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                  setCSMA_onCCO();
              else
                  setCSMA_onSTA();
              
              #endif
4052   2      
4053   2             
4054   2          }
4055   1      }
*** WARNING C280 IN LINE 3963 OF ..\..\..\hal\hal_hpgp.c: 'Retrycnt': unreferenced local variable
4056          
4057          void FREQDET_DetectFrequencyUsingBcn()
4058          {
4059   1      #ifndef HPGP_HAL_TEST
4060   1          sHaLayer *hal = HOMEPLUG_GetHal();
4061   1      #endif 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 68  

4062   1          u32     calcBCNper;
4063   1         // static u8 bcnCnt = 0;
4064   1          
4065   1          calcBCNper = gCCO_BTS - gOldBTS;
4066   1      
4067   1          //printf("\n bp = %lu", calcBCNper);
4068   1          gOldBTS = gCCO_BTS;
4069   1         // bcnCnt++;
4070   1      
4071   1       
4072   1              if(gHpgpHalCB.halStats.BcnSyncCnt >= FREQUENCY_BCN_MAX_COUNT)   //set the frequency after syncing 
             -four bcns
4073   1              {
4074   2                  if(((calcBCNper * 40) > MIN_50HZ_BCNPER) && ((calcBCNper * 40) < MAX_50HZ_BCNPER))//38 ms   it
             - is 50 Hz that means bcnper is 40 ms
4075   2                  {                
4076   3                      //gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4077   3                      FREQDET_FreqSetting(FREQUENCY_50HZ);                
4078   3                      printf("\n50 HZ detected\n");
4079   3                     // bcnCnt = 0;
4080   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4081   3      
4082   3                  }
4083   2                  else if(((calcBCNper * 40) < MIN_50HZ_BCNPER))//33.33 ms , 60 hz
4084   2                  {             
4085   3                     // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4086   3                      printf("\n bp = %lu",(calcBCNper * 40));
4087   3      
4088   3                      FREQDET_FreqSetting(FREQUENCY_60HZ);                
4089   3                      printf("\n60 HZ detected\n");
4090   3                      //bcnCnt = 0;
4091   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4092   3                    
4093   3                  }
4094   2              }
4095   1          
4096   1      
4097   1      }
4098          //#endif 
4099          
4100          //#ifdef FREQ_DETECT
4101          void FREQDET_FreqDetectInit(void)
4102          {    
4103   1         // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4104   1         // gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4105   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4106   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4107   1          //HHAL_SetPlcDevMode(STA_CSMANW);
4108   1         
4109   1      //   gHpgpHalCB.bcnInitDone =1;
4110   1          //HHT_DevCfg();
4111   1      
4112   1      }
4113          
4114          void FREQDET_FreqDetectReset(void)
4115          {    
4116   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4117   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4118   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4119   1      
4120   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4121   1      }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          12/02/2014 14:35:34 PAGE 69  

4122          
4123          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16202    ----
   CONSTANT SIZE    =   1298    ----
   XDATA SIZE       =    607    2133
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
