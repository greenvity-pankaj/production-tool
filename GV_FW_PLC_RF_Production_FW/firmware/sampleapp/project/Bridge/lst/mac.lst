C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC
OBJECT MODULE PLACED IN .\obj\mac.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) 
                    -BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\fir
                    -mware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\.
                    -.\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware\
                    -hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\..
                    -\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\..
                    -\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\.
                    -.\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\.
                    -.\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\i
                    -nc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..\
                    -..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compone
                    -nts\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash\
                    -inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\..
                    -\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc;
                    -..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\com
                    -ponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,H
                    -YBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYB
                    -RII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYB
                    -RII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,
                    -SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_A
                    -PP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac.lst) TABS(2) OBJECT(.\ob
                    -j\mac.obj)

line level    source

   1          /**
   2           * @file mac.c
   3           *
   4           * MAC Entry point
   5           *
   6           * $Id: mac.c,v 1.7 2014/11/26 13:19:40 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          
  12          /* === Includes ============================================================= */
  13          #ifdef HYBRII_802154
  14          #ifdef RTX51_TINY_OS
  15          #include <rtx51tny.h>
  16          #include "hybrii_tasks.h"
  17          #endif
  18          #include <stdio.h>
  19          #include <string.h>
  20          #include "papdef.h"
  21          #include "timer.h"
  22          #include "return_val.h"
  23          #include "bmm.h"
  24          #include "qmm.h"
  25          #include "mac_const.h"
  26          #include "mac_msgs.h"
  27          #include "mac_data_structures.h"
  28          #include "timer.h"
  29          #include "list.h"
  30          #include "stm.h"
  31          #include "mac_hal.h"
  32          #include "mac_internal.h"
  33          #include "mac.h"
  34          #include "mac_security.h"
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 2   

  35          
  36          #ifdef PROD_TEST
              #include "hal_rf_prod_test.h"
              #endif
  39          /* === Macros =============================================================== */
  40          
  41          /* === Globals ============================================================== */
  42          mac_stats_t mac_stats_g;
  43          
  44          /**
  45           * Current state of the MAC state machine
  46           */
  47          mac_state_t mac_state;
  48          
  49          /**
  50           * Current state of scanning process.
  51           */
  52          mac_scan_state_t mac_scan_state;
  53          
  54          /**
  55           * Current state of syncronization with parent
  56           * (either coordinator or PAN coordinator).
  57           */
  58          mac_sync_state_t mac_sync_state;
  59          
  60          /**
  61           * Current state of MAC poll state machine,
  62           * e.g. polling for data, polling for Association Response, etc.
  63           */
  64          mac_poll_state_t mac_poll_state;
  65          
  66          /**
  67           * Radio sleep state
  68           */
  69          mac_radio_state_t mac_radio_state;
  70          
  71          /**
  72           * Final Cap Slot of current Superframe
  73           */
  74          uint8_t mac_final_cap_slot;
  75          
  76          /**
  77           * Flag stating that the last received beacon frame from the parent
  78           * indicated pending broadcast data to be received.
  79           */
  80          bool mac_bc_data_indicated;
  81          
  82          /**
  83           * Global parse data
  84           */
  85          parse_t mac_parse_data;
  86          
  87          /*
  88           * Flag indicating that RxEnable is still active.
  89           */
  90          bool mac_rx_enabled;
  91          
  92          /*
  93           * Variables for duplicate detection.
  94           * In order to detect duplicated frames, the DSN and Source Address of the
  95           * last received data frame need to be stored.
  96           */
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 3   

  97          uint8_t mac_last_dsn;
  98          uint64_t mac_last_src_addr;
  99          uint16_t mac_last_src_addr_short;
 100          
 101          /* MAC PIB variables */
 102          
 103          /**
 104           * Indication of whether the device is associated to the PAN through the PAN
 105           * coordinator. A value of TRUE indicates the device has associated through the
 106           * PAN coordinator. Otherwise, the value is set to FALSE.
 107           */
 108          uint8_t mac_pib_macAssociatedPANCoord;
 109          
 110          /**
 111           * The maximum number of CAP symbols in a beaconenabled PAN, or symbols in a
 112           * nonbeacon-enabled PAN, to wait either for a frame intended as a response to
 113           * a data request frame or for a broadcast frame following a beacon with the
 114           * Frame Pending subfield set to one.
 115           * This attribute, which shall only be set by the next higher layer, is
 116           * dependent upon macMinBE, macMaxBE, macMaxCSMABackoffs and the number of
 117           * symbols per octet. See 7.4.2 for the formula relating the attributes.
 118           * Maximum values:
 119           * O-QPSK (2.4 GHz and 900 MHz for Channel page 2): 25766
 120           * BPSK (900 MHz for Channel page 0): 26564
 121           * Both values are valid for
 122           * macMinBE = 8
 123           * macMaxBE = 8
 124           * macMaxCSMABackoffs = 5
 125           *
 126           * This PIB attribute is only used if basic indirect data transmission is used
 127           * or if beacon enabled network is enabled.
 128           */
 129          uint16_t mac_pib_macMaxFrameTotalWaitTime;
 130          
 131          /**
 132           * The maximum time, in multiples of aBaseSuperframeDuration, a device shall
 133           * wait for a response command frame to be available following a request
 134           * command frame.
 135           */
 136          uint16_t mac_pib_macResponseWaitTime;
 137          
 138          /**
 139           * Indication of whether the MAC sublayer has security enabled. A value of
 140           * TRUE indicates that security is enabled, while a value of FALSE indicates
 141           * that security is disabled.
 142           */
 143          bool mac_pib_macSecurityEnabled;
 144          
 145          /**
 146           * Holds the value which states whether a coordinator is currently allowing
 147           * association. A value of true indicates that association is permitted.
 148           */
 149          uint8_t mac_pib_macAssociationPermit;
 150          
 151          /**
 152           * Holds the maximum time (in superframe periods) that a indirect transaction
 153           * is stored by a PAN coordinator.
 154           */
 155          uint16_t mac_pib_macTransactionPersistenceTime;
 156          
 157          
 158          /**
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 4   

 159           * Holds the sequence number added to the transmitted beacon frame.
 160           */
 161          uint8_t mac_pib_macBSN;
 162          
 163          /**
 164           * Holds the contents of the beacon payload.
 165           */
 166          uint8_t mac_beacon_payload[aMaxBeaconPayloadLength];
 167          
 168          /**
 169           * Holds the length, in octets, of the beacon payload.
 170           */
 171          uint8_t mac_pib_macBeaconPayloadLength;
 172          
 173          /**
 174           * Holds the value which states whether a device automatically sends a data
 175           * request command if its address is listed in the beacon frame. A value of true
 176           * indicates that the data request command is automatically sent.
 177           */
 178          uint8_t mac_pib_macAutoRequest;
 179          
 180          /**
 181           * Holds the value which states the number of backoff periods during which the
 182           * receiver is enabled following a beacon in battery life extension mode.
 183           * This value is dependent on the currently selected logical channel.
 184           */
 185          uint8_t mac_pib_macBattLifeExtPeriods;
 186          
 187          /**
 188           * Holds the 64 bit address of the coordinator with which the
 189           * device is associated.
 190           */
 191          uint64_t mac_pib_macCoordExtendedAddress;
 192          
 193          /**
 194           * Holds the 16 bit short address of the coordinator with which the device is
 195           * associated. A value of 0xfffe indicates that the coordinator is only using
 196           * its 64 bit extended address. A value of 0xffff indicates that this
 197           * value is unknown.
 198           */
 199          uint16_t mac_pib_macCoordShortAddress;
 200          
 201          /**
 202           * Holds the sequence number of the transmitted data or command frame.
 203           */
 204          uint8_t mac_pib_macDSN;
 205          
 206          /**
 207           * Holds the value which states whether the MAC sublayer is to enable its
 208           * receiver during idle periods.
 209           */
 210          bool mac_pib_macRxOnWhenIdle;
 211          
 212          /**
 213           * Holds the values of all security related PIB attributes.
 214           */
 215          mac_sec_pib_t mac_sec_pib;
 216          
 217          /**
 218           * Holds the mlme request buffer pointer, used to give the respective
 219           * confirmation in scan, poll and association.
 220           */
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 5   

 221          uint8_t *mac_conf_buf_ptr;
 222          
 223          /**
 224           * Stores the original channel before start of scanning.
 225           */
 226          uint8_t mac_scan_orig_channel;
 227          
 228          /**
 229           * Stores the original channel page before start of scanning.
 230           */
 231          uint8_t mac_scan_orig_page;
 232          
 233          /**
 234           * Stores the original PAN-Id before start of scanning.
 235           */
 236          uint16_t mac_scan_orig_panid;
 237          
 238          /**
 239           * Holds the buffer pointer which is used to send scan command.
 240           */
 241          uint8_t *mac_scan_cmd_buf_ptr;
 242          
 243          /**
 244           * MAC busy state, indicates whether MAC can process any
 245           * request from NHLE.
 246           */
 247          bool mac_busy;
 248          
 249          /**
 250           * NHLE to MAC queue in which NHLE pushes all the requests to the MAC layer
 251           */
 252          queue_t nhle_mac_q;
 253          
 254          /**
 255           * Queue used by MAC for its internal operation. TAL pushes the incoming frames
 256           * in this queue.
 257           */
 258          queue_t hal_mac_q;
 259          
 260          /**
 261           * Queue used by MAC layer in beacon-enabled network to put in broadcast data.
 262           * Any broadcast data given by NHLE at a Coordinator or PAN Coordinator
 263           * in a beacon-enabled network is placed here by MAC.
 264           */
 265          queue_t broadcast_q;
 266          
 267          
 268          /**
 269           * Queue used by MAC layer to put in indirect data. Any indirect data given by
 270           * NHLE is placed here by MAC, until the device polls for the data.
 271           */
 272          queue_t indirect_data_q;
 273          
 274          tTimerId indirect_data_persistence_timer;
 275          tTimerId scan_duration_timer;
 276          tTimerId beacon_tracking_timer;
 277          tTimerId beacon_missed_timer;
 278          tTimerId poll_wait_timer;
 279          tTimerId mac_rsp_wait_timer;
 280          tTimerId mac_asso_rsp_wait_timer;
 281          
 282          #ifdef PROD_TEST
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 6   

              extern tTimerId prod_test_rf_timer;
              #endif
 285          typedef void (*mac_funct_t)(buffer_t *);
 286          
 287          static code mac_funct_t dispatch_table[MLME_LAST_MESSAGE] =
 288          {
 289              NULL,
 290              mlme_associate_request,    // MLME_ASSOCIATE_REQUEST
 291              mlme_associate_response,   // MLME_ASSOCIATE_RESPONSE
 292              mcps_data_request,         // MCPS_DATA_REQUEST
 293              mcps_purge_request,        // MCPS_PURGE_REQUEST
 294              mlme_disassociate_request, // MLME_DISASSOCIATE_REQUEST
 295              mlme_set_request,          // MLME_SET_REQUEST
 296              mlme_orphan_response,      // MLME_ORPHAN_RESPONSE
 297              mlme_get_request,          // MLME_GET_REQUEST
 298              mlme_reset_request,        // MLME_RESET_REQUEST
 299              mlme_rx_enable_request,    // MLME_RX_ENABLE_REQUEST
 300              mlme_scan_request,         // MLME_SCAN_REQUEST
 301              NULL,
 302              mlme_start_request,        // MLME_START_REQUEST
 303              mlme_poll_request,         // MLME_POLL_REQUEST
 304              mlme_sync_request,         // MLME_SYNC_REQUEST
 305          };
 306          
 307          /* === Prototypes =========================================================== */
 308          
 309          
 310          /* === Implementation ======================================================= */
 311          
 312          void mac_q_flush (void)
 313          {
 314   1          qmm_queue_flush(&nhle_mac_q);
 315   1          qmm_queue_flush(&hal_mac_q);
 316   1          qmm_queue_flush(&indirect_data_q);
 317   1          mac_hal_frame_pending(false);
 318   1          qmm_queue_flush(&broadcast_q);
 319   1      }
 320           
 321          /**
 322           *
 323           * This function decodes all MAC messages and calls the appropriate handler.
 324           *
 325           * buffer_p - Pointer to the buffer where the message type and its data 
 326           *            reside
 327           */
 328          void mac_event_dispatcher (buffer_t *buff_p)
 329          {
 330   1          mac_funct_t mac_funct_p;
 331   1          uint8_t *mac_msg_p = BMM_BUFFER_POINTER(buff_p);
 332   1          uint8_t cmd_code;
 333   1      
 334   1          cmd_code = mac_msg_p[MLME_CMD_CODE]; 
 335   1          if (cmd_code < MLME_LAST_MESSAGE) {
 336   2              mac_funct_p = dispatch_table[cmd_code];
 337   2      
 338   2              if (mac_funct_p != NULL) {
 339   3                  mac_funct_p(buff_p);
 340   3              } else {             
 341   3                  bmm_buffer_free(buff_p);
 342   3              }
 343   2          } else {
 344   2              bmm_buffer_free(buff_p);
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 7   

 345   2          }
 346   1      }
 347          
 348          /**
 349           * @brief Runs the MAC scheduler
 350           *
 351           * This function runs the MAC scheduler.
 352           *
 353           * MLME and MCPS queues are removed alternately, starting with MLME queue.
 354           *
 355           * @return true if event is dispatched, false if no event to dispatch.
 356           */
 357          bool mac_task (void)
 358          {
 359   1          buffer_t *buff_p = NULL;
 360   1          bool processed_event = false;
 361   1      
 362   1      #ifdef MAC_802154_TASK  
                while (TRUE) {
              #else     
 365   1        if(1) {
 366   2      #endif    
 367   2              if (mac_busy == FALSE) {        
 368   3                  /* Check whether queue is empty */
 369   3                  while (nhle_mac_q.size != 0) {        
 370   4                      buff_p = qmm_queue_remove(&nhle_mac_q, NULL);
 371   4                      
 372   4                      /* If an event has been detected, handle it. */
 373   4                      if (buff_p != NULL) {
 374   5                          /* Process event due to NHLE requests */
 375   5                          mac_event_dispatcher(buff_p); 
 376   5                          processed_event = true;
 377   5                      }
 378   4              break;
 379   4                  }
 380   3              }
 381   2      
 382   2              /*
 383   2               * Internal event queue should be dispatched
 384   2               * irrespective of the dispatcher state.
 385   2               */
 386   2              /* Check whether queue is empty */
 387   2              if (hal_mac_q.size != 0) {
 388   3                  buff_p = qmm_queue_remove(&hal_mac_q, NULL);
 389   3      
 390   3                  /* If an event has been detected, handle it. */
 391   3                  if (buff_p != NULL) {
 392   4                      mac_event_dispatcher(buff_p);
 393   4                      processed_event = true;
 394   4                  }
 395   3              }
 396   2      #ifdef RTX51_TINY_OS
 397   2              if (nhle_mac_q.size == 0 && hal_mac_q.size == 0) {      
 398   3      #ifdef MAC_802154_TASK  
                          break;
              #endif
 401   3              } else {
 402   3                  /* 
 403   3                   * Stay in the loop to serve the Q's but
 404   3                   * momentaty give up the CPU so other tasks
 405   3                   * can run
 406   3                   */
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 8   

 407   3      #ifdef MAC_802154_TASK  
                          //os_wait(K_TMO, 2, 0);  /* 2 ticks */
                          os_switch_task();
              #endif
 411   3              }
 412   2      #else
                      break; /* Exit while loop immediately if no Tiny OS */
              #endif
 415   2          }
 416   1      
 417   1      #ifndef MAC_802154_TASK         
 418   1      #ifdef RTX51_TINY_OS
 419   1        if ((nhle_mac_q.size != 0) || (hal_mac_q.size != 0)) {
 420   2          os_set_ready(HPGP_TASK_ID_CTRL);
 421   2      #ifdef UM   
 422   2          pending_802154_task = TRUE;
 423   2      #endif
 424   2        }
 425   1      #endif
 426   1      #endif /* MAC_802154_TASK*/
 427   1        
 428   1          return processed_event;
 429   1      } 
 430          
 431          #ifdef PROD_TEST
              extern void STM_Proc(void);
              #endif
 434          
 435          #ifdef MAC_802154_TASK
              #ifdef RTX51_TINY_OS
              void os_mac_task (void) _task_ MAC_802154_TASK_ID
              {
                  while (TRUE) {
                  os_switch_task();
                      mac_task();
                      mac_hal_sm_handler();
              
              #ifdef PROD_TEST
                  STM_Proc();
              #endif
              #ifndef HAL_802154_TASK
                      mac_hal_task();
              #endif
                  }
              }
              #endif
              #endif
 454          
 455          /**
 456           * MAC function to wake-up the radio from sleep state
 457           */
 458          void mac_trx_wakeup (void)
 459          {
 460   1           /* FIXME - Add code to wake up the AFE */
 461   1      }
 462          
 463          /**
 464           * Puts the radio to sleep if this is allowed
 465           */
 466          void mac_trx_sleep (void)
 467          {
 468   1      }
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 9   

 469          
 470          /**
 471           * Puts the radio to sleep mode 
 472           */
 473          void mac_trx_init_sleep (void)
 474          {
 475   1      }
 476          
 477          /*
 478           * Initializes the MAC PIBs
 479           *
 480           * This function initializes all MAC PIBs to their defaults as stated by
 481           * 802.15.4.
 482           */
 483          static void mac_init_pib (void)
 484          {
 485   1          uint32_t random_value;
 486   1      
 487   1          mac_pib_macAssociatedPANCoord = macAssociatedPANCoord_def;
 488   1          mac_pib_macMaxFrameTotalWaitTime = macMaxFrameTotalWaitTime_def;
 489   1          mac_pib_macResponseWaitTime = macResponseWaitTime_def;
 490   1          mac_pib_macSecurityEnabled = macSecurityEnabled_def;
 491   1          mac_pib_macAssociationPermit = macAssociationPermit_def;
 492   1      
 493   1          mac_pib_macBeaconPayloadLength = macBeaconPayloadLength_def;
 494   1          mac_hal_get_current_time(&random_value);
 495   1          mac_pib_macBSN = (uint8_t) random_value;
 496   1      
 497   1          mac_pib_macTransactionPersistenceTime = macTransactionPersistenceTime_def;
 498   1          mac_pib_macAutoRequest = macAutoRequest_def;
 499   1          mac_pib_macBattLifeExtPeriods = macBattLifeExtPeriods_def;
 500   1          mac_pib_macCoordExtendedAddress.lo_u32 = CLEAR_ADDR_32;
 501   1          mac_pib_macCoordExtendedAddress.hi_u32 = CLEAR_ADDR_32;
 502   1          mac_pib_macCoordShortAddress = macCoordShortAddress_def;
 503   1          mac_pib_macDSN = (uint8_t) (random_value >> 8);
 504   1          mac_pib_macRxOnWhenIdle = macRxOnWhenIdle_def;
 505   1      
 506   1          mac_sec_pib.KeyTableEntries = macKeyTableEntries_def;
 507   1          mac_sec_pib.DeviceTableEntries = macDeviceTable_def;
 508   1          mac_sec_pib.SecurityLevelTableEntries = macSecurityLevelTable_def;
 509   1          mac_sec_pib.FrameCounter = macFrameCounter_def;
 510   1      }
 511          
 512          /*
 513           * Intializes the MAC global variables
 514           */
 515          static void mac_init_vars (void)
 516          {
 517   1          mac_busy = false;
 518   1          mac_state = MAC_IDLE;
 519   1          mac_radio_state = RADIO_AWAKE;
 520   1          mac_scan_state = MAC_SCAN_IDLE;
 521   1          mac_sync_state = MAC_SYNC_NEVER;
 522   1          mac_poll_state = MAC_POLL_IDLE;
 523   1          mac_final_cap_slot = FINAL_CAP_SLOT_DEFAULT;
 524   1          mac_bc_data_indicated = false;
 525   1          mac_last_dsn = 0;
 526   1          mac_last_src_addr.lo_u32 = 0xFFFFFFFF;
 527   1          mac_last_src_addr.hi_u32 = 0xFFFFFFFF;
 528   1          mac_rx_enabled = false;
 529   1      }
 530          
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 10  

 531          void mac_clear_stats (void)
 532          {
 533   1          memset(&mac_stats_g, 0, sizeof(mac_stats_g));
 534   1      }
 535          
 536          void mac_display_tx_stats (void)
 537          {
 538   1          printf("\nS/W TX Stats:\n");
 539   1          printf(" NoAck=%lu, NoCCA=%u, FrmPending=%lu, Errs=%u\n", 
 540   1                 mac_stats_g.tx_pkts_no_ack, mac_stats_g.tx_pkts_no_cca,
 541   1                 mac_stats_g.frame_pending, mac_stats_g.tx_errors);
 542   1      }
 543          
 544          void mac_display_rx_stats (void)
 545          {
 546   1          printf("\nS/W RX Stats:\n");
 547   1          printf("Pkts rxed=%lu - Bytes rxed=%lu\n",
 548   1               mac_stats_g.rx_pkts_count, mac_stats_g.rx_bytes_count);
 549   1          printf("Decrypt Err=%u, Decrypt Ok=%u, No buffer=%u, "
 550   1                 "Frm too big=%u, Bad CRC=%u\n",
 551   1                 mac_stats_g.decrypt_error, mac_stats_g.decrypt_ok,
 552   1                 mac_stats_g.rx_no_buffer, mac_stats_g.rx_frame_too_big,
 553   1                 mac_stats_g.rx_bad_crc);
 554   1      }
 555          
 556          void mac_get_tx_stats (uint32_t *tx_count, uint32_t *tx_bytes,
 557                                 uint16_t *tx_errors, uint32_t *tx_bc_count,
 558                                 uint32_t *tx_bc_bytes)
 559          {
 560   1          *tx_count    = mac_stats_g.tx_pkts_count;
 561   1          *tx_bytes    = mac_stats_g.tx_bytes_count;
 562   1          *tx_errors   = mac_stats_g.tx_errors;
 563   1          *tx_bc_count = mac_stats_g.tx_bc_pkts_count;
 564   1          *tx_bc_bytes = mac_stats_g.tx_bc_bytes_count;
 565   1      }
 566          
 567          void mac_get_rx_stats (uint32_t *rx_count, uint32_t *rx_bytes,
 568                                 uint16_t *decrypt_err)
 569          {
 570   1          *rx_count = mac_stats_g.rx_pkts_count;
 571   1          *rx_bytes = mac_stats_g.rx_bytes_count;
 572   1          *decrypt_err = mac_stats_g.decrypt_error;
 573   1      }
 574          
 575          /*
 576           * Internal MAC soft reset function
 577           *
 578           * This function resets the MAC variables, stops all running timers and
 579           * initializes the PIBs.
 580           *
 581           * init_pib - Boolean indicates whether PIB attributes shall be
 582           * initialized or not.
 583           */
 584          static void mac_soft_reset (uint8_t init_pib)
 585          {
 586   1          mac_init_vars();
 587   1      
 588   1          /* Trun off Phy TX and RX */
 589   1          mac_hal_hw_control(PHY_TRX_OFF);
 590   1      
 591   1          // FIXME - Add code to stop of running timer
 592   1      #if 1
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 11  

 593   1      #ifdef RTX51_TINY_OS  
 594   1          STM_StopTimer(indirect_data_persistence_timer);
 595   1          STM_StopTimer(scan_duration_timer);
 596   1          STM_StopTimer(beacon_tracking_timer);     
 597   1          STM_StopTimer(beacon_missed_timer);       
 598   1          STM_StopTimer(poll_wait_timer);       
 599   1          STM_StopTimer(mac_rsp_wait_timer);      
 600   1          STM_StopTimer(mac_asso_rsp_wait_timer);           
 601   1      #endif
 602   1      #endif
 603   1      
 604   1          if (init_pib) {
 605   2              mac_init_pib();
 606   2          }
 607   1      }
 608          
 609          /*
 610          
 611           * This function resets the MAC variables, stops all running timers and
 612           * initializes the PIBs.
 613           *
 614           * init_pib - Boolean indicates whether PIB attributes shall be
 615           * initialized or not.
 616           *
 617           * @return Success or failure status
 618           */
 619          retval_t mac_reset (uint8_t init_pib)
 620          {
 621   1          retval_t status;
 622   1      
 623   1          /* Reset HAL */
 624   1          status = mac_hal_reset(init_pib);
 625   1          
 626   1          mac_soft_reset(init_pib);
 627   1      
 628   1          return (status);
 629   1      }
 630          
 631          /**
 632           * Resets the MAC helper variables and transition to idle state
 633           *
 634           * This function sets the MAC to idle state and resets
 635           * MAC helper variables
 636           */
 637          void mac_idle_trans (void)
 638          {
 639   1          uint16_t default_shortaddress = macShortAddress_def;
 640   1          uint16_t default_panid = macPANId_def;
 641   1      
 642   1          /* Wake up radio first */
 643   1          mac_trx_wakeup();
 644   1      
 645   1          set_hal_pib_internal(macShortAddress, (void *)&default_shortaddress);
 646   1          set_hal_pib_internal(macPANId, (void *)&default_panid);
 647   1      
 648   1          mac_soft_reset(true);
 649   1      
 650   1          /* Set radio to sleep if allowed */
 651   1          mac_trx_sleep();
 652   1      }
 653          
 654          void zb_mac_timer_handler (u16 type, void *cookie)
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 12  

 655          {
 656   1          switch (type) {
 657   2          case BEACON_TRACKING_TIMER:
 658   2              mac_sync_tracking_beacons_cb(cookie);
 659   2              break;
 660   2          case BEACON_MISSED_TIMER:
 661   2              mac_sync_missed_beacons_cb(cookie);
 662   2              break;
 663   2          case POLL_WAIT_TIMER:
 664   2              mac_poll_wait_time_cb(cookie);
 665   2              break;
 666   2          case DATA_PERSISTENCE_TIMER:
 667   2              mac_persistence_timer_cb(cookie);
 668   2              break;
 669   2          case SCAN_DURATION_TIMER:
 670   2              mac_scan_duration_cb(cookie);
 671   2              break;
 672   2        case MAC_RSP_WAIT_TIMER:
 673   2          mac_response_wait_cb(cookie);
 674   2          break;
 675   2        case MAC_ASSO_RSP_WAIT_TIMER:
 676   2              mac_assocresponsetime_cb(cookie); 
 677   2              break;
 678   2      #ifdef PROD_TEST
                case PROD_RF_TEST_TIMER:
                  prod_rf_test_timer_cb(cookie);
                  break;  
              #endif    
 683   2          default:
 684   2              break;
 685   2          }
 686   1      }
 687          
 688          /**
 689           * Initializes the MAC sublayer
 690           *
 691           */
 692          void mac_init (void)
 693          {
 694   1          mac_init_vars();
 695   1          mac_clear_stats();
 696   1          mac_init_pib();
 697   1          qmm_queue_init(&nhle_mac_q, NHLE_MAC_QUEUE_CAPACITY);
 698   1          qmm_queue_init(&hal_mac_q, HAL_MAC_QUEUE_CAPACITY);
 699   1          qmm_queue_init(&indirect_data_q, INDIRECT_DATA_QUEUE_CAPACITY);
 700   1          qmm_queue_init(&broadcast_q, BROADCAST_QUEUE_CAPACITY);
 701   1      #ifdef RTX51_TINY_OS
 702   1      
 703   1          indirect_data_persistence_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 704   1                                                           DATA_PERSISTENCE_TIMER,
 705   1                                                           NULL);
 706   1          if (STM_TIMER_ID_NULL == indirect_data_persistence_timer) {
 707   2             // Display error
 708   2             return;
 709   2          }
 710   1          scan_duration_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 711   1                                               SCAN_DURATION_TIMER,
 712   1                                               NULL);
 713   1          if (STM_TIMER_ID_NULL == scan_duration_timer) {
 714   2             // Display error
 715   2             return;
 716   2          }
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 13  

 717   1      
 718   1          beacon_tracking_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 719   1                                                BEACON_TRACKING_TIMER,
 720   1                                                NULL);
 721   1          if (STM_TIMER_ID_NULL == beacon_tracking_timer) {
 722   2             // Display error
 723   2             return;
 724   2          }
 725   1      
 726   1          beacon_missed_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 727   1                                               BEACON_MISSED_TIMER,
 728   1                                               NULL);
 729   1          if (STM_TIMER_ID_NULL == beacon_missed_timer) {
 730   2             // Display error
 731   2             return;
 732   2          }
 733   1      
 734   1          poll_wait_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 735   1                                           POLL_WAIT_TIMER,
 736   1                                           NULL);
 737   1          if (STM_TIMER_ID_NULL == poll_wait_timer) {
 738   2             // Display error
 739   2             return;
 740   2          }
 741   1      
 742   1          mac_rsp_wait_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 743   1                                              MAC_RSP_WAIT_TIMER,
 744   1                                              NULL);
 745   1          if (STM_TIMER_ID_NULL == mac_rsp_wait_timer) {
 746   2             // Display error
 747   2             return;
 748   2          }
 749   1      
 750   1          mac_asso_rsp_wait_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
 751   1                                                   MAC_ASSO_RSP_WAIT_TIMER,
 752   1                                                   NULL);
 753   1          if (STM_TIMER_ID_NULL == mac_asso_rsp_wait_timer) {
 754   2             // Display error
 755   2             return;
 756   2          }
 757   1      
 758   1      #ifdef PROD_TEST
                prod_test_rf_timer = STM_AllocTimer(ZB_LAYER_TYPE_MAC,
                                     PROD_RF_TEST_TIMER,
                                     NULL);
                printf("Test TimerID %bu\n",(u8)prod_test_rf_timer);
                if (STM_TIMER_ID_NULL == prod_test_rf_timer) {
                       // Display error
                       printf("prod test Talloc f\n");
                    return;
                }
              
              #endif
 770   1      
 771   1      #endif
 772   1          mac_hal_init();
 773   1      
 774   1      #ifdef MAC_802154_TASK
                os_create_task(MAC_802154_TASK_ID);
              #endif
 777   1      }
 778          #endif //HYBRII_802154
C51 COMPILER V9.53.0.0   MAC                                                               11/04/2015 20:09:48 PAGE 14  

 779          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1389    ----
   CONSTANT SIZE    =    292    ----
   XDATA SIZE       =    960      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
