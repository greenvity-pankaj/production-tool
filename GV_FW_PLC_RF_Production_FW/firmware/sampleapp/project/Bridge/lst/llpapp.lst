C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE LLPAPP
OBJECT MODULE PLACED IN .\obj\llpapp.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\sampleapp\src\llpapp.c LARGE OBJECTADVANCED OPTIMIZE(9,SPEED) B
                    -ROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\firm
                    -ware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\..
                    -\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware\h
                    -pgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\..\
                    -..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\..\
                    -..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\..
                    -\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\..
                    -\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\in
                    -c;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..\.
                    -.\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\componen
                    -ts\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash\i
                    -nc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\..\
                    -..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc;.
                    -.\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\comp
                    -onents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HY
                    -BRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYBR
                    -II_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYBR
                    -II_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,S
                    -W_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_AP
                    -P,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\llpapp.lst) TABS(2) OBJECT(.\
                    -obj\llpapp.obj)

line level    source

   1          
   2          /* ========================================================
   3           *
   4           * @file:  llpapp.c
   5           * 
   6           * @brief: This application implements the Led Lighting Protocol 
   7           *         on the remote nodes that are connected to either PLC 
   8           *         link or IEEE 802.15.4 link.
   9           *
  10           *  Copyright (C) 2010-2015, Greenvity Communications, Inc.
  11           *  All Rights Reserved
  12           *  
  13           * =========================================================*/
  14          
  15          #ifdef LLP_APP
  16          
  17          /****************************************************************************** 
  18            * Includes
  19            ******************************************************************************/
  20          
  21          #include <string.h>
  22          #include <stdio.h>
  23          #include <stdlib.h>
  24          #include "gv701x_includes.h"
  25          #ifdef HPGP_DRIVER_APP
  26          #include "gv701x_hpgpdriver.h"
  27          #endif
  28          #ifdef LRWPAN_DRIVER_APP
  29          #include "gv701x_lrwpandriver.h"
  30          #endif
  31          #ifdef NWKSTARTUP_APP
  32          #include "gv701x_nwkstartup.h"
  33          #endif
  34          #ifdef DEVICEINTF_APP
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 2   

  35          #include "deviceintfapp.h"
  36          #endif
  37          #ifdef ROUTE_APP
  38          #include "route.h"
  39          #include "route_fw.h"
  40          #endif
  41          #ifdef REGISTER_APP
  42          #include "register.h"
  43          #include "register_fw.h"
  44          #endif
  45          #ifdef RTOPO_APP
  46          #include "route_topo_fw.h"
  47          #include "route_topo.h"
  48          #endif
  49          #include "llpapp.h"
  50          #include "llpapp_fw.h"
  51          
  52          
  53          /****************************************************************************** 
  54            * Global Data
  55            ******************************************************************************/  
  56          u8 node_app_id;
  57          gv701x_app_queue_t node_queues; 
  58          
  59          /* Node data */
  60          node_data_t node_data;    
  61          
  62          /* Node state */
  63          gv701x_state_t node_state;      
  64          
  65          /****************************************************************************** 
  66            * External Data
  67            ******************************************************************************/
  68          
  69          /******************************************************************************
  70            * External Funtion prototypes
  71            ******************************************************************************/
  72          
  73          /******************************************************************************
  74            * Funtion prototypes
  75            ******************************************************************************/
  76          void LlpApp_Tx(u8* frame, u8 payloadLen, u8 retrycnt);
  77          void LlpApp_HandleUpdateReq(llp_msg_req_t* msg);
  78          void LlpApp_HandleGroupUpdateReq(llp_msg_req_t* msg);
  79          void LlpApp_SendUpdateRsp(u8 solicited, u8 action, u16 seq);
  80          void LlpApp_DispStats(void);
  81          void LlpApp_HandleDevStats(llp_msg_req_t *msg);
  82          
  83          /******************************************************************************
  84           * @fn      LlpApp_Init
  85           *
  86           * @brief   Initializes the Light Link Layer
  87           *
  88           * @param   app_id - application identification number
  89           *
  90           * @return  none
  91           */
  92          void LlpApp_Init (u8 app_id) 
  93          { 
  94   1        u8* macaddr;
  95   1      #ifdef DEVICEINTF_APP
  96   1        u8 idx;
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 3   

  97   1      #endif
  98   1      
  99   1        /*Initializing Node Data*/
 100   1        memset(&node_data, 0x00, sizeof(node_data_t));
 101   1        node_app_id = app_id;
 102   1        SLIST_Init(&node_queues.appRxQueue);
 103   1      
 104   1        FM_Printf(FM_USER, "\nInit LLPApp (app id %bu)", app_id); 
 105   1        memcpy((u8*)&(node_data.macaddr), (u8*)macaddr, MAC_ADDR_LEN);
 106   1      #if 0 
                FM_HexDump(FM_APP, "MAC: ", (u8*)&(node_data.macaddr), MAC_ADDR_LEN);     
              #endif
 109   1      
 110   1        /*Initializing State machine*/
 111   1        memset(&node_state, 0x00, sizeof(gv701x_state_t));
 112   1        node_state.state = NODE_IDLE_STATE;
 113   1        node_state.event = NODE_IDLE_EVNT;
 114   1        node_state.statedata = NULL;
 115   1        node_state.statedatalen = 0;
 116   1        node_data.active = TRUE;
 117   1          
 118   1      #ifdef DEVICEINTF_APP   
 119   1        /*Initialize the device type*/
 120   1        (u8)(*node_data.dev_type) = DEVINTF_NONE;
 121   1        for(idx = 0; (dev_list[idx].type != DEVINTF_NONE); idx++)
 122   1        {   
 123   2          if(dev_list[idx].type != DEVINTF_NONE)
 124   2          {
 125   3            node_data.dev_type = &dev_list[idx].type;
 126   3            node_data.dev_subtype = &dev_list[idx].subtype;
 127   3            break;
 128   3          }
 129   2        }
 130   1      #endif  
 131   1      }
 132          
 133          /******************************************************************************
 134           * @fn      LlpApp_Rx
 135           *
 136           * @brief   Receives Over the Air frame
 137           *
 138           * @param   buf - data packet
 139           *      len - length in number of bytes
 140           *
 141           * @return  none
 142           */
 143          
 144          void LlpApp_Rx(u8* buf, u8 len)
 145          {
 146   1        sEth2Hdr* petherhdr = (sEth2Hdr*)(buf);
 147   1      #ifdef ROUTE_APP
 148   1        route_hdr_t* rhdr = (route_hdr_t* )(&buf[sizeof(sEth2Hdr)]);
 149   1      #endif
 150   1        llp_msg_req_t* msg_hdr; 
 151   1        len = len;
 152   1      
 153   1        if(petherhdr->ethtype != APP_ETHER_PROTO)
 154   1          return;
 155   1      
 156   1        if(RHDR_GET_CMDID(rhdr) != APP_FRAME)
 157   1          return;
 158   1        
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 4   

 159   1        msg_hdr = (llp_msg_req_t*)(&(buf[LLP_HDR_OFFSET]));
 160   1      
 161   1        switch(msg_hdr->cmd_id) 
 162   1        {   
 163   2          case UPDATE_DEVICE_REQ:
 164   2            if(node_state.state == NODE_ACTIVE_STATE)   
 165   2              LlpApp_HandleUpdateReq((llp_msg_req_t*)msg_hdr);
 166   2            else 
 167   2              node_data.stats.drop++;
 168   2          break;
 169   2      
 170   2          case CHANGE_GROUP: 
 171   2            if(node_state.state == NODE_ACTIVE_STATE) 
 172   2              LlpApp_HandleGroupUpdateReq((llp_msg_req_t *)msg_hdr);      
 173   2            else 
 174   2              node_data.stats.drop++;
 175   2          break;
 176   2          
 177   2          case DEV_STATS_REQ:
 178   2            LlpApp_HandleDevStats((llp_msg_req_t *)msg_hdr);  
 179   2          break;
 180   2          
 181   2          default:      
 182   2          break;
 183   2        } 
 184   1      }
 185          
 186          /******************************************************************************
 187           * @fn      LlpApp_Tx
 188           *
 189           * @brief   Sends an Over the Air frame
 190           *
 191           * @param   buf - data packet
 192           *      payloadLen - length in number of bytes
 193           *      retrycnt - number of re-transmissions
 194           *
 195           * @return  none
 196           */
 197          
 198          void LlpApp_Tx(u8* buf, u8 payloadLen, u8 retrycnt)
 199          {
 200   1        u8 i;
 201   1        u8 brdcstmac[MAC_ADDR_LEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 202   1        sEth2Hdr *pEth2Hdr = (sEth2Hdr *)buf;
 203   1        llp_msg_req_t* msg_hdr = (llp_msg_req_t*)(buf + sizeof(sEth2Hdr));
 204   1      
 205   1        /*Fill llp frame control*/
 206   1        msg_hdr->fc.control_bits |= LLP_FRAME_DIR_LIGHT_TO_CONTROLLER \
 207   1                      << LLP_FRAME_DIRECTION; 
 208   1        
 209   1        /* If node is not in the active state, we cannot send data out */
 210   1        if(node_state.state != NODE_ACTIVE_STATE) 
 211   1        {
 212   2          node_data.stats.drop++;
 213   2          return;
 214   2        }
 215   1      
 216   1        /*Send frame and then retry */
 217   1        for(i=0; i<retrycnt; i++)  
 218   1        {
 219   2          if(i)
 220   2            msg_hdr->fc.control_bits |= cpu_to_le16(LLP_FRAME_RETRY); 
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 5   

 221   2      
 222   2          if(node_state.state == NODE_ACTIVE_STATE) 
 223   2          {
 224   3      #ifdef ROUTE_APP      
 225   3            route_send_to_ll((u8*)buf, payloadLen, APP_FRAME, FALSE);     
 226   3      #endif
 227   3          }
 228   2          else
 229   2          {
 230   3      #ifdef ROUTE_APP    
 231   3            route_send_to_ll((u8*)buf, payloadLen, APP_FRAME, FALSE);
 232   3      #endif
 233   3          }
 234   2        }   
 235   1      }
 236          
 237          /******************************************************************************
 238           * @fn      LlpApp_HandleUpdateReq
 239           *
 240           * @brief   Handles the Update Request frame
 241           *
 242           * @param   msg - LLP message (define found in llpapp.h)
 243           *
 244           * @return  none
 245           */
 246          
 247          void LlpApp_HandleUpdateReq (llp_msg_req_t* msg)
 248          {
 249   1        u8 idx, jdx;
 250   1        llp_sta_update_msg_t* update_req = (llp_sta_update_msg_t*)(msg + 1);
 251   1        u8 *payload = (u8*)(update_req);
 252   1        u8 dev_type = 0;
 253   1        u8 num_of_tlv = 0;
 254   1        u8 update_len = 0;
 255   1        u16 mseq = 0;
 256   1      
 257   1        node_data.stats.updtreq++;
 258   1      
 259   1        if( (!(cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_BROADCAST)) &&
 260   1          (!(cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_GROUPCAST)) ) 
 261   1        {   
 262   2          mseq = cpu_to_le16(msg->fc.seq_num);
 263   2          
 264   2          if(memcmp_cpu_to_le(&(update_req->mac_addr), 
 265   2                  &(node_data.macaddr), MAC_ADDR_LEN) )
 266   2          { 
 267   3            return;
 268   3          }
 269   2        }
 270   1        else if((cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_GROUPCAST)) 
 271   1        {
 272   2          if(node_data.llp_grp != msg->llp_group) 
 273   2          {
 274   3      #if 0   
                    FM_Printf(FM_APP, "\nLLP Group not matched");
              #endif
 277   3            return;
 278   3          }
 279   2        }
 280   1      
 281   1        if((update_req->action != LLP_UPDATE_SET) &&
 282   1          (update_req->action != LLP_UPDATE_GET))
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 6   

 283   1        {
 284   2          return;
 285   2        }
 286   1      
 287   1        if(update_req->action == LLP_UPDATE_SET)
 288   1        {
 289   2          update_len += sizeof (llp_sta_update_msg_t);
 290   2          dev_type = (u8)payload[update_len];
 291   2          update_len += sizeof(dev_type);
 292   2          num_of_tlv = (u8)payload[update_len];   
 293   2          update_len += sizeof(num_of_tlv);     
 294   2          payload = payload + update_len;
 295   2          
 296   2      #ifdef DEVICEINTFAPP    
                  if(dev_type == DEVINTF_NONE)
                    return;     
              #endif          
 300   2          
 301   2        node_data.active = update_req->active;
 302   2        }
 303   1        else if(update_req->action == LLP_UPDATE_GET)
 304   1        {
 305   2          update_len += sizeof (llp_sta_update_msg_t);
 306   2          dev_type = (u8)payload[update_len];
 307   2          update_len += sizeof(dev_type);
 308   2          num_of_tlv = (u8)payload[update_len];   
 309   2          update_len += sizeof(num_of_tlv);     
 310   2          payload = payload + update_len; 
 311   2          dev_type = (u8)(*node_data.dev_type);
 312   2        }
 313   1      
 314   1      #if 0
                FM_Printf(FM_APP, "\nUpdReq (a %bu dt %bu act %bu)", update_req->action, dev_type,
                    update_req->active);
              #endif
 318   1      
 319   1      #ifdef DEVICEINTF_APP 
 320   1        
 321   1        for(idx = 0; (deviceintf_data.dev_list[idx].type != DEVINTF_NONE); idx++)
 322   1        {
 323   2          if(deviceintf_data.dev_list[idx].type == dev_type)
 324   2          {
 325   3            break;
 326   3          }
 327   2        }
 328   1        
 329   1        if(idx != 0)
 330   1          return;   
 331   1        
 332   1      
 333   1        for (jdx = 0; (deviceintf_data.dev_list[idx].io_list[jdx].type != DEVINTF_IO_NONE); jdx++) 
 334   1        {       
 335   2          if(update_req->action == LLP_UPDATE_SET)
 336   2          {
 337   3              if(update_req->active == 0)
 338   3                  {
 339   4      
 340   4                  }
 341   3            else if((u8)(*payload) == deviceintf_data.dev_list[idx].io_list[jdx].type)
 342   3            {     
 343   4              payload += 1;
 344   4              memcpy_cpu_to_le((u8*)deviceintf_data.dev_list[idx].io_list[jdx].p_val, (u8*)payload, 
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 7   

 345   4                       deviceintf_data.dev_list[idx].io_list[jdx].len);       
 346   4              //FM_HexDump(FM_USER,"\nSet Tlv: ",(u8*)deviceintf_data.dev_list[idx].io_list[jdx].p_val,
 347   4              //         deviceintf_data.dev_list[idx].io_list[jdx].len);
 348   4                      
 349   4              deviceintf_data.dev_list[idx].io_list[jdx].trigger = TRUE;
 350   4              payload = payload + (u8)deviceintf_data.dev_list[idx].io_list[jdx].len;
 351   4            }
 352   3          }
 353   2          /* Temporarily here cos in a get frame the host does not send tlv's*/
 354   2          else if(update_req->action == LLP_UPDATE_GET)
 355   2          {
 356   3            if((u8)(*payload) == deviceintf_data.dev_list[idx].io_list[jdx].type)   
 357   3            {
 358   4            //  printf("\nType Match %bu", deviceintf_data.dev_list[idx].io_list[jdx].type);    
 359   4              deviceintf_data.dev_list[idx].io_list[jdx].trigger = TRUE;
 360   4              payload = payload + 1;
 361   4              /*TBD: if TLV do not match then there should exists an exit procedure*/
 362   4            }
 363   3          }   
 364   2        } 
 365   1        
 366   1        if(update_req->action == LLP_UPDATE_SET)  
 367   1        {
 368   2          device_inst_msg_t device_inst;
 369   2              
 370   2          if(update_req->active == 0)
 371   2          {
 372   3          
 373   3            device_inst.event = DEVINTF_IO_OFF;
 374   3            device_inst.dev_type = dev_type;
 375   3            node_data.active = 0;
 376   3                      
 377   3          
 378   3          }
 379   2          else
 380   2          {
 381   3            device_inst.event = DEVINTF_IO_INSTRUCTION;
 382   3            device_inst.dev_type = dev_type;
 383   3            node_data.active = 1;
 384   3              
 385   3          }
 386   2          
 387   2          GV701x_SendAppEvent(node_app_id, deviceintf_data.app_id, APP_MSG_TYPE_APPEVENT,
 388   2                APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
 389   2                &device_inst, sizeof(device_inst_msg_t), 0);          
 390   2        }
 391   1      #endif /*DEVICEINTF_APP*/
 392   1      
 393   1        /*Send Response only if unicast*/
 394   1        if((cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_BROADCAST) ||
 395   1          (cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_GROUPCAST))
 396   1        {
 397   2        }
 398   1        else 
 399   1        {
 400   2          LlpApp_SendUpdateRsp(TRUE, update_req->action, mseq);
 401   2        }
 402   1      }
 403          
 404          /******************************************************************************
 405           * @fn      LlpApp_HandleGroupUpdateReq
 406           *
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 8   

 407           * @brief   Handles the Group Update Request frame
 408           *
 409           * @param   msg - LLP message (define found in llpapp.h)
 410           *
 411           * @return  none
 412           */
 413          
 414          void LlpApp_HandleGroupUpdateReq(llp_msg_req_t* msg)
 415          {
 416   1        llp_sta_group_update_req_t *grp_upt = (llp_sta_group_update_req_t *)(msg + 1);
 417   1      
 418   1        if( (!(cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_BROADCAST)) &&
 419   1          (!(cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_GROUPCAST)) )
 420   1        {
 421   2          if(memcmp_cpu_to_le(&(grp_upt->mac_addr), 
 422   2                  &(node_data.macaddr), MAC_ADDR_LEN) )
 423   2            return;
 424   2        }
 425   1        else if((cpu_to_le16(msg->fc.control_bits) & LLP_FRAME_GROUPCAST))
 426   1        {
 427   2          if(node_data.llp_grp != msg->llp_group)
 428   2            return;   
 429   2        }
 430   1      
 431   1          node_data.llp_grp = grp_upt->llp_grp;
 432   1      }
 433          
 434          /******************************************************************************
 435           * @fn      LlpApp_HandleGroupUpdateReq
 436           *
 437           * @brief   Sends the Update Response frame
 438           *
 439           * @param   solicited - if the frame is in response to a request
 440           *                      (TRUE or FLASE)
 441           *      action - LLP_UPDATE_SET: when sent asynchronously 
 442           *                   LLP_UPDATE_GET: when accompained by a request
 443           *
 444           * @return  none
 445           */
 446          
 447          void LlpApp_SendUpdateRsp(u8 solicited, u8 action, u16 seq) 
 448          {
 449   1        u8 idx, jdx, count = 0;
 450   1        u8* payload_numtlv_off = NULL;
 451   1        u8 num_of_tlv = 0;
 452   1        u8 buf[MAX_PKT_BUFFSIZE];
 453   1        llp_msg_req_t* msg_hdr = &buf[LLP_HDR_OFFSET];
 454   1        llp_sta_update_msg_t* update = (llp_sta_update_msg_t*)(msg_hdr + 1);
 455   1        u8 *payload = (u8 *)(update + 1); 
 456   1        
 457   1        memset(buf, 0x00, MAX_PKT_BUFFSIZE);  
 458   1      
 459   1      #if 1
 460   1        FM_Printf(FM_APP, "\nUpdRsp (act %bu s %bu seq %u)", action, solicited, seq);
 461   1      #endif
 462   1      
 463   1        /*Fill message header*/ 
 464   1        msg_hdr->fc.control_bits = 0;
 465   1        msg_hdr->fc.seq_num = cpu_to_le16(seq);
 466   1      
 467   1        if(solicited == TRUE)
 468   1        {
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 9   

 469   2          u16 ctrl_bits = 0;
 470   2          ctrl_bits |= LLP_FRAME_SOLICITED;
 471   2          msg_hdr->fc.control_bits = cpu_to_le16(ctrl_bits);
 472   2          msg_hdr->cmd_id = UPDATE_DEVICE_RSP;
 473   2          node_data.stats.updtrsp++; 
 474   2        }
 475   1        else
 476   1        {
 477   2          node_data.stats.asyncrsp++;
 478   2          msg_hdr->cmd_id = UPDATE_ASYNC_DATA_REQ;
 479   2        }
 480   1        
 481   1      #ifdef REGISTER_APP
 482   1        node_data.nwk_addr = register_data.nwk_addr.addr_16bit; 
 483   1      #endif  
 484   1        msg_hdr->hpgp_group = cpu_to_le16(node_data.nwk_addr);
 485   1        msg_hdr->llp_group = node_data.llp_grp;
 486   1      
 487   1        update->groupid = node_data.llp_grp;
 488   1        update->action = action;
 489   1        update->reqmsg = FALSE; 
 490   1          update->active = node_data.active;
 491   1        memcpy_cpu_to_le((u8*)&(update->mac_addr), (u8*)&(node_data.macaddr), 
 492   1            MAC_ADDR_LEN);
 493   1      
 494   1        payload[count] = (u8)(*node_data.dev_type);
 495   1        count++;
 496   1        payload_numtlv_off = &payload[count];
 497   1        count++;
 498   1      #ifdef DEVICEINTF_APP 
 499   1        for(idx = 0; (deviceintf_data.dev_list[idx].type != DEVINTF_NONE); idx++)
 500   1        {
 501   2          if(deviceintf_data.dev_list[idx].type == (u8)(*node_data.dev_type))
 502   2          {
 503   3            break;
 504   3          }
 505   2        }
 506   1        
 507   1        for (jdx = 0; (deviceintf_data.dev_list[idx].io_list[jdx].type != DEVINTF_IO_NONE); jdx++) 
 508   1        {
 509   2          if(deviceintf_data.dev_list[idx].io_list[jdx].trigger == TRUE)
 510   2          {           
 511   3            num_of_tlv++;
 512   3            if(solicited == TRUE) 
 513   3            {
 514   4              if(update->action == LLP_UPDATE_GET)
 515   4              {
 516   5                deviceintf_data.dev_list[idx].io_list[jdx].trigger = FALSE;     
 517   5              }
 518   4            } 
 519   3            else 
 520   3            {
 521   4              deviceintf_data.dev_list[idx].io_list[jdx].trigger = FALSE;
 522   4            }
 523   3            
 524   3            payload[count] = deviceintf_data.dev_list[idx].io_list[jdx].type; 
 525   3            count++;
 526   3            memcpy((u8*)(&payload[count]), (u8*)deviceintf_data.dev_list[idx].io_list[jdx].p_val, 
 527   3                     deviceintf_data.dev_list[idx].io_list[jdx].len);
 528   3                  
 529   3            count += (u8)deviceintf_data.dev_list[idx].io_list[jdx].len;
 530   3          }
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 10  

 531   2        } 
 532   1        *payload_numtlv_off = num_of_tlv;
 533   1      #endif /*DEVICEINTF_APP*/
 534   1      
 535   1        LlpApp_Tx(buf,(sizeof(llp_msg_req_t) + sizeof(llp_sta_update_msg_t) + 
 536   1                count + LLP_HDR_OFFSET), 1);
 537   1      }
 538          
 539          /******************************************************************************
 540           * @fn      LlpApp_HandleDevStats
 541           *
 542           * @brief   Handles the request to fetch device statistics
 543           *
 544           * @param   msg - LLP message (define found in llpapp.h)
 545           *
 546           * @return  none
 547           */
 548          
 549          void LlpApp_HandleDevStats(llp_msg_req_t *msg)
 550          {
 551   1        u8 len = 0;
 552   1        u8 buf[MAX_PKT_BUFFSIZE]; 
 553   1        llp_msg_req_t* msg_hdr = &buf[LLP_HDR_OFFSET];
 554   1        llp_devstats_req_msg_t* devstats_req = (llp_devstats_req_msg_t*)(msg + 1);
 555   1        llp_devstats_req_msg_t* devstats_rsp = (llp_devstats_rsp_msg_t*)(msg_hdr + 1);  
 556   1        llp_cmd_slave_stats_t* llp_stats =  (u8 *)(devstats_rsp + 1);
 557   1        
 558   1        memset(buf, 0x00, MAX_PKT_BUFFSIZE);  
 559   1      
 560   1        if((devstats_req->action != LLP_UPDATE_SET) &&
 561   1          (devstats_req->action != LLP_UPDATE_GET))
 562   1        {
 563   2          return;
 564   2        }
 565   1      
 566   1        if(devstats_req->action == LLP_UPDATE_SET)
 567   1        {
 568   2          /* ToDo - Action is not decided yet */
 569   2        }
 570   1        else if(devstats_req->action == LLP_UPDATE_GET)
 571   1        {
 572   2          /*Fill message header*/ 
 573   2          msg_hdr->fc.control_bits = 0;
 574   2          msg_hdr->cmd_id = DEV_STATS_RSP;  
 575   2          devstats_rsp->action = devstats_req->action;
 576   2          
 577   2          memcpy_cpu_to_le((u8*)&(devstats_rsp->mac_addr), 
 578   2                  (u8*)&(node_data.macaddr), MAC_ADDR_LEN);
 579   2          llp_stats->llp_RxCnt = RTOCL(node_data.stats.updtrsp);
 580   2          llp_stats->llp_TxCnt = RTOCL(node_data.stats.updtrsp);  
 581   2          //llp_stats->dev_type = 0;  
 582   2          
 583   2      #ifdef ROUTE_APP  
 584   2          //memcpy_cpu_to_le((u8*)&llp_stats->short_add, (u8*)&route_info.zid, sizeof(route_info.zid));
 585   2          memcpy_cpu_to_le((u8*)&llp_stats->rank, (u8*)&route_info.rank, sizeof(route_info.rank));
 586   2          
 587   2          if(route_info.parent != NULL) 
 588   2            llp_stats->link = route_info.parent->link;
 589   2          llp_stats->rssi = route_info.parent->rssi;  
 590   2          llp_stats->lqi  = route_info.parent->lqi;   
 591   2          //llp_stats->totalRx = RTOCL(totalRx);
 592   2          //llp_stats->totalTx = RTOCL(totalTx);      
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 11  

 593   2      #endif
 594   2      
 595   2      #ifdef LRWPAN_DRIVER_APP      
 596   2          llp_stats->rf_channel =  lrwpan_db.channel;
 597   2          memcpy_cpu_to_le((u8*)&llp_stats->rf_panid, (u8*)&lrwpan_db.panid, sizeof(lrwpan_db.panid));
 598   2      #endif  
 599   2      #ifdef HPGP_DRIVER_APP
 600   2          memcpy((u8*)&llp_stats->plc_nid, (u8*)&hpgp_nwk_data.params.nwk.key.nid[0], NID_LEN);
 601   2      #endif
 602   2          len += sizeof(llp_cmd_slave_stats_t);   
 603   2        }
 604   1      
 605   1        LlpApp_Tx(buf,(sizeof(llp_msg_req_t) + sizeof(llp_devstats_req_msg_t) + 
 606   1              len + LLP_HDR_OFFSET), 1);
 607   1      }
 608          
 609          /******************************************************************************
 610           * @fn      LlpApp_RxAppMsg
 611           *
 612           * @brief   Receives a message from another app/fw
 613           *
 614           * @params  msg_buf - message buffer
 615           *
 616           * @return  none
 617           */
 618          
 619          void LlpApp_RxAppMsg(sEvent* event)
 620          {
 621   1        gv701x_app_msg_hdr_t* msg_hdr = (gv701x_app_msg_hdr_t*)event->buffDesc.dataptr;
 622   1        hostHdr_t* hybrii_hdr;
 623   1        hostEventHdr_t* evnt_hdr;
 624   1      
 625   1        hybrii_hdr = (hostHdr_t*)(msg_hdr + 1);
 626   1      
 627   1        if(msg_hdr->dst_app_id == node_app_id)
 628   1        {
 629   2          memcpy(&node_state.msg_hdr, msg_hdr, sizeof(gv701x_app_msg_hdr_t));
 630   2          node_state.eventproto = hybrii_hdr->protocol;
 631   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 632   2            (hybrii_hdr->type == EVENT_FRM_ID))
 633   2          {
 634   3            evnt_hdr = (hostEventHdr_t*)(hybrii_hdr + 1);
 635   3            node_state.event = evnt_hdr->type;  
 636   3            node_state.statedata = (u8*)(evnt_hdr + 1);
 637   3            node_state.statedatalen = (u16)(hybrii_hdr->length - sizeof(hostEventHdr_t));   
 638   3          }
 639   2          else
 640   2          {
 641   3            node_state.event = (u8)(*((u8*)(hybrii_hdr + 1)));
 642   3            node_state.statedata = (u8*)(hybrii_hdr + 1);
 643   3            node_state.statedatalen = (u16)hybrii_hdr->length;
 644   3          }   
 645   2          node_state.eventtype = hybrii_hdr->type;
 646   2          node_state.eventclass = event->eventHdr.eventClass;
 647   2      
 648   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 649   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 650   2            (node_state.event == HOST_EVENT_APP_TIMER))
 651   2          {     
 652   3            LlpApp_TimerHandler((u8*)(evnt_hdr + 1)); 
 653   3            return;
 654   3          }       
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 12  

 655   2          else if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 656   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 657   2            (node_state.event == HOST_EVENT_APP_CMD))
 658   2          {     
 659   3            LlpApp_CmdProcess((char*)(evnt_hdr + 1)); 
 660   3            return;
 661   3          }         
 662   2        }
 663   1        else if(msg_hdr->dst_app_id == APP_BRDCST_MSG_APPID)
 664   1        {
 665   2          u8 *event = (u8*)(hybrii_hdr + 1);
 666   2      #ifdef NWKSTARTUP_APP     
 667   2          if(msg_hdr->src_app_id == nwkstartup_data.app_id)
 668   2          {
 669   3            if(msg_hdr->type == APP_MSG_TYPE_APPIND)
 670   3            {
 671   4              switch(*event)
 672   4              {
 673   5                case NWK_START_IND:
 674   5                {
 675   6                  nwk_start_ind_msg_t* nwk_start_ind = (nwk_start_ind_msg_t*)event;
 676   6      #ifdef RTOPO_APP
 677   6                  {
 678   7                    rtopo_start_evnt_msg_t rtopo_start;
 679   7                    rtopo_start.event = RTOPO_START_EVNT;
 680   7                    rtopo_start.link = nwk_start_ind->link;
 681   7                    rtopo_start.mode = RTOPO_SCAN_PEER_SELECTION;
 682   7                    GV701x_SendAppEvent(node_app_id, rtopo_app_id, APP_MSG_TYPE_APPEVENT,
 683   7                        APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
 684   7                        &rtopo_start, sizeof(rtopo_start_evnt_msg_t), 0); 
 685   7                  }       
 686   6      #else
              #ifdef NWKSTARTUP_APP         
                          {
                            nwk_start_evnt_msg_t nwk_start;
                            nwk_start.event = NWK_START_EVENT;
                            nwk_start.link = nwk_start_ind->link;
                            GV701x_SendAppEvent(node_app_id, nwkstartup_data.app_id, APP_MSG_TYPE_APPEVENT,
                                APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
                                &nwk_start, sizeof(nwk_start_evnt_msg_t), 0);               
                          }
              #endif
              #endif
 698   6                }
 699   5                break;
 700   5      
 701   5                case NWK_LINKUP_IND:
 702   5                  node_state.state = NODE_ACTIVE_STATE;
 703   5                break;
 704   5                
 705   5                case NWK_LINKDWN_IND:
 706   5                {
 707   6                  if((nwkstartup_data.link.power_line.state != LINK_UP) &&
 708   6                    (nwkstartup_data.link.wireless.state != LINK_UP))
 709   6                  {
 710   7                    node_state.state = NODE_INACTIVE_STATE;
 711   7                  }
 712   6                }
 713   5                break;
 714   5                
 715   5                default:
 716   5                break;
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 13  

 717   5              } 
 718   4            }
 719   3          }
 720   2      #endif    
 721   2          return;
 722   2        } 
 723   1        LlpApp_StateMachine(&node_state);     
 724   1      }
 725          
 726          /******************************************************************************
 727           * @fn      LlpApp_TimerHandler
 728           *
 729           * @brief   Timer handler for LLP timer events
 730           *
 731           * @param   event - event from firmware
 732           *
 733           * @return  none
 734           *
 735           */ 
 736          void LlpApp_TimerHandler(u8* buf)
 737          {   
 738   1        hostTimerEvnt_t* timerevt = 
 739   1          (hostTimerEvnt_t*)buf;      
 740   1      
 741   1        if(buf == NULL)
 742   1          return; 
 743   1          
 744   1        /*Demultiplexing the specific timer event*/           
 745   1        switch((u8)timerevt->type)
 746   1        {               
 747   2          
 748   2          default:
 749   2          break;
 750   2        }
 751   1      }
 752          
 753          /******************************************************************************
 754           * @fn      LlpApp_StateMachine
 755           *
 756           * @brief   The LLP State Machine, it executes all internal/external 
 757           *      events triggered
 758           *
 759           * @param   state - state machine object of the module
 760           *          (passed as a reference incase there are more than one object)
 761           *
 762           * @return  none
 763           *
 764           */
 765          
 766          void LlpApp_StateMachine(gv701x_state_t* state) 
 767          {
 768   1        if(state == NULL)
 769   1          return;
 770   1      
 771   1      #if 1
 772   1        if(state->event != NODE_IDLE_EVNT)
 773   1          FM_Printf(FM_APP, "\nLLP State %bu Event %bu P %bu C %bu E %bu Da %bu Sa %bu T %bu", 
 774   1              state->state, state->event,
 775   1              state->eventproto, state->eventclass, state->eventtype, 
 776   1              state->msg_hdr.dst_app_id, state->msg_hdr.src_app_id, state->msg_hdr.type);
 777   1      #endif
 778   1      
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 14  

 779   1        switch(state->state) 
 780   1        {
 781   2          case NODE_IDLE_STATE:
 782   2            if(state->eventproto == APP_MAC_ID)
 783   2            {       
 784   3              switch(state->event) 
 785   3              {   
 786   4                case NODE_IDLE_EVNT:                  
 787   4                break;
 788   4                
 789   4                case NODE_ACTIVE_EVNT:
 790   4                  state->state = NODE_ACTIVE_STATE; 
 791   4                break;
 792   4                  
 793   4                default:          
 794   4                break;
 795   4              }
 796   3            }
 797   2          break;
 798   2                  
 799   2          case NODE_ACTIVE_STATE:
 800   2            if(state->eventproto == APP_MAC_ID)
 801   2            {               
 802   3              switch(state->event) 
 803   3              {   
 804   4                case NODE_TRIGGER_EVNT:
 805   4                  LlpApp_SendUpdateRsp(FALSE, LLP_UPDATE_SET, 0);
 806   4                break;
 807   4              
 808   4                case NODE_INACTIVE_EVNT:
 809   4                  state->state = NODE_INACTIVE_STATE;
 810   4                break;
 811   4                        
 812   4                default:
 813   4                break;
 814   4              }
 815   3            }
 816   2          break;
 817   2      
 818   2          case NODE_INACTIVE_STATE:
 819   2            if(state->eventproto == APP_MAC_ID)
 820   2            {       
 821   3              switch(state->event) 
 822   3              {   
 823   4                case NODE_ACTIVE_EVNT:
 824   4                  state->state = NODE_ACTIVE_STATE;
 825   4                  break;
 826   4                default:
 827   4                  break;
 828   4              }
 829   3            }
 830   2            break;
 831   2          
 832   2          default:
 833   2          break;
 834   2        }
 835   1        
 836   1        state->event = NODE_IDLE_EVNT;
 837   1        state->eventtype = 0;
 838   1        state->eventclass = 0;
 839   1        state->eventproto = 0;
 840   1        state->statedata = NULL;  
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 15  

 841   1        state->statedatalen = 0;  
 842   1        memset((u8*)&state->msg_hdr, 0x00, sizeof(gv701x_app_msg_hdr_t));
 843   1      }
 844          
 845          /******************************************************************************
 846           * @fn      LlpApp_DispStats
 847           *
 848           * @brief   Displays the frame statistics
 849           *
 850           * @param   none
 851           *
 852           * @return  none
 853           */
 854          
 855          void LlpApp_DispStats(void)
 856          {
 857   1      #if 1
 858   1        printf("\ndevtype   = %bu", (u8)(*node_data.dev_type));
 859   1        printf("\ndevsubtype  = %bu", (u8)(*node_data.dev_subtype));
 860   1        printf("\nupdtreq   = %lu",node_data.stats.updtreq);
 861   1        printf("\nupdtrsp   = %lu",node_data.stats.updtrsp);
 862   1        printf("\nasyncrsp  = %lu", node_data.stats.asyncrsp);  
 863   1        printf("\ndrop      = %lu", node_data.stats.drop);
 864   1      #endif  
 865   1      }
 866          
 867          /******************************************************************************
 868           * @fn      LlpApp_ResetStats
 869           *
 870           * @brief   Reset's the frame statistics
 871           *
 872           * @param   none
 873           *
 874           * @return  none
 875           */
 876          
 877          void LlpApp_ResetStats(void) 
 878          {
 879   1        node_data.stats.updtreq = 0 ;
 880   1        node_data.stats.updtrsp = 0;  
 881   1        node_data.stats.updtrspbt = 0;
 882   1        node_data.stats.drop = 0; 
 883   1        node_data.stats.asyncrsp = 0; 
 884   1      }
 885          
 886          /******************************************************************************
 887           * @fn      LlpApp_CmdProcess
 888           *
 889           * @brief   It handles application command line requests
 890           *
 891           * @param   CmdBuf - command string
 892           *
 893           * @return  none
 894           *
 895           */
 896          
 897          void LlpApp_CmdProcess(char* CmdBuf) 
 898          {
 899   1        if(strcmp(CmdBuf, "state") == 0) 
 900   1        {
 901   2          printf("\nLLp S %bu E %bu", node_state.state, node_state.event);
 902   2        }
C51 COMPILER V9.53.0.0   LLPAPP                                                            11/04/2015 20:09:44 PAGE 16  

 903   1        else if(strcmp(CmdBuf, "stats") == 0) 
 904   1        {
 905   2          LlpApp_DispStats();
 906   2        }
 907   1        else if(strcmp(CmdBuf, "nvclear") == 0) 
 908   1        {
 909   2          GV701x_FlashErase(node_app_id);
 910   2        } 
 911   1      }
 912          #endif /*LLP_APP*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5714    ----
   CONSTANT SIZE    =    266    ----
   XDATA SIZE       =     66    1154
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
