C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MUXL
OBJECT MODULE PLACED IN .\obj\muxl.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\mux\muxl.c LARGE OBJECTADVANCED OPTIMIZE(9
                    -,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..
                    -\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\h
                    -al;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\fi
                    -rmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbe
                    -e;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\in
                    -c;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\i
                    -nc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;
                    -..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers
                    -\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..
                    -\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\
                    -components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers
                    -\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilitie
                    -s;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\n
                    -wk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..
                    -\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII
                    -_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC
                    -,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DET
                    -ECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUP
                    -T,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REG
                    -ISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\muxl.lst) TABS(2) OBJ
                    -ECT(.\obj\muxl.obj)

line level    source

   1          /** =========================================================
   2           *
   3           *  @file mux.c
   4           * 
   5           *  @brief Muxtiplex Layer
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * ===========================================================*/
  11          #ifdef RTX51_TINY_OS
  12          #include <rtx51tny.h>
  13          #endif
  14          #include <string.h>
  15          #include "papdef.h"
  16          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  19          #include "list.h"
  20          #include "event.h"
  21          #include "nma.h"
  22          #include "nma_fw.h"
  23          #include "green.h"
  24          #include "fm.h"
  25          #include "sched.h"
  26          #include "muxl.h"
  27          #include "hpgpdef.h"
  28          #include "hpgpapi.h"
  29          #include "ism.h"
  30          #include "hpgpevt.h"
  31          #include "hal.h"
  32          #include "hybrii_tasks.h"
  33          
  34          #if 0
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 2   

              eStatus MUXL_SendEvent(sMuxLayer *muxl, sEvent *event)
              {
              
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                  SEM_WAIT(&muxl->muxSem);
              #endif
              
                  SLIST_Put(&muxl->eventQueue, &event->link);
              
              #ifdef P8051
              __CRIT_SECTION_END__
              #else
                  SEM_POST(&muxl->muxSem);
              #endif
                  return STATUS_SUCCESS;
              }
              
              #endif
  55          
  56          
  57          eStatus MUXL_TransmitMgmtMsg(sEvent *event)
  58          {
  59   1          sMmHdr    *mmh = NULL;
  60   1          sHpgpHdr *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
  61   1      
  62   1          if( event->eventHdr.eventClass != EVENT_CLASS_MSG)
  63   1          {
  64   2              return STATUS_FAILURE;
  65   2          }
  66   1      
  67   1          /* add the mgmt msg header */
  68   1          if(event->buffDesc.buff+sizeof(sMmHdr) > event->buffDesc.dataptr)
  69   1          {
  70   2              FM_Printf(FM_ERROR,"MUXL: Data buffer is small\n");
  71   2              return STATUS_FAILURE;
  72   2          }
  73   1      
  74   1          if (((hpgpHdr->mnbc)&&(event->buffDesc.datalen > HPGP_MNBC_PAYLOAD_MAX)) ||
  75   1               (event->buffDesc.datalen > HPGP_DATA_PAYLOAD_MAX))
  76   1          {
  77   2              /* perform the msg fragment */
  78   2              FM_Printf(FM_ERROR,"MUXL: need msg fragmentation.\n");
  79   2          }
  80   1      
  81   1          event->buffDesc.dataptr -= sizeof(sMmHdr);  
  82   1          event->buffDesc.datalen += sizeof(sMmHdr);  
  83   1          mmh = (sMmHdr *) (event->buffDesc.dataptr);  
  84   1                
  85   1          //add mgmt msg header
  86   1          //fragment is not supported at present
  87   1          mmh->mmv = 0x1;
  88   1          mmh->mmtype = cpu_to_le16(event->eventHdr.type);
  89   1          mmh->nfmi = 0;
  90   1          mmh->fnmi = 0;
  91   1          mmh->fmsn = 0;
  92   1      
  93   1          return HAL_Transmit(HOMEPLUG_GetHal(), event);
  94   1      
  95   1      }
  96          
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 3   

  97          eStatus MUX_InitMux(sMux *mux)
  98          {
  99   1          SLIST_Init(&mux->rxQueue);
 100   1          mux->rxqlen = 0;
 101   1          mux->rxnfmi = 0;
 102   1          mux->rxfmsn = 0;
 103   1         
 104   1          return STATUS_SUCCESS;
 105   1      }
 106          
 107          
 108          int MUX_ResetReassembly(sMux *mux)
 109          {
 110   1          sEvent *event = NULL;
 111   1          sSlink *slink = NULL;
 112   1      
 113   1          while(!SLIST_IsEmpty(&mux->rxQueue))
 114   1          {
 115   2              slink = SLIST_Pop(&mux->rxQueue);
 116   2      
 117   2              event = SLIST_GetEntry(slink, sEvent, link);
 118   2              EVENT_Free(event);
 119   2          }
 120   1          mux->rxqlen = 0;
 121   1          mux->rxnfmi = 0;
 122   1          mux->rxfmsn = 0;
 123   1         
 124   1          return STATUS_SUCCESS;
 125   1      }
 126          
 127          
 128          
 129          void MUX_Proc(sMux *mux, sEvent *event)
 130          {
 131   1          sMmHdr *mmh = NULL; 
 132   1      
 133   1          //now it is a mgmt msg
 134   1          mmh = (sMmHdr *) (event->buffDesc.dataptr);  
 135   1      
 136   1      //FM_Printf(FM_MUX, "MUX: process a mgmt msg (type = 0x%.2x).\n", mmh->mmtype);
 137   1      
 138   1          event->eventHdr.eventClass = EVENT_CLASS_MSG;
 139   1          event->eventHdr.type = le16_to_cpu(mmh->mmtype);
 140   1          //chop off the msg header
 141   1          event->buffDesc.dataptr += sizeof(sMmHdr);
 142   1          event->buffDesc.datalen -= sizeof(sMmHdr);
 143   1      
 144   1          if(mux->rxfmsn != mmh->fmsn)
 145   1          {
 146   2              //receive new mgmt info, reset RX  
 147   2              MUX_ResetReassembly(mux);
 148   2              mux->rxfmsn = mmh->fmsn;
 149   2              mux->rxnfmi = mmh->nfmi;
 150   2          }
 151   1      
 152   1          if(mux->rxnfmi != mmh->nfmi) 
 153   1          {
 154   2              //should not happen
 155   2              MUX_ResetReassembly(mux);
 156   2              EVENT_Free(event);
 157   2              FM_Printf(FM_WARN, "MUX: error in rx fragement.\n");
 158   2              return;
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 4   

 159   2      
 160   2          }
 161   1      
 162   1          if(mux->rxnfmi == 0)
 163   1          {
 164   2              FM_Printf(FM_MUX, "MUX: deliver a mgmt msg.\n");
 165   2              //no fragment and deliver right away
 166   2      #ifdef CALLBACK
                      mux->deliverMgmtMsg(mux->mgmtcookie, event); 
              #else
 169   2              LINKL_RecvMgmtMsg(mux->mgmtcookie, event);
 170   2      #endif
 171   2          }
 172   1          else
 173   1          {
 174   2      //        event->eventHdr.fnmi = mmh->fnmi; //??
 175   2              //check if it is the first fragment 
 176   2      
 177   2      //        mux->fnmi = mmh->fnmi; //??
 178   2             
 179   2              //place the rx fragment into the rx queue in order
 180   2              //At present it is assumed that the fragments are 
 181   2              //transmitted in order of fragment number. Thus, simply
 182   2              //place the fragment at the tail.
 183   2              //Otherwise, a general approach is used.
 184   2              SLIST_Put(&mux->rxQueue, &event->link);
 185   2              mux->rxqlen++;
 186   2              if(mux->rxqlen == (mux->rxnfmi+1))
 187   2              {
 188   3                 //(1) perform message reassembly
 189   3                 
 190   3                 //(2) deliver the assembled message 
 191   3                 FM_Printf(FM_ERROR, "MUX:Msg reassembly not supported\n");
 192   3              }
 193   2          }
 194   1      
 195   1          return;
 196   1      }
 197          
 198          #ifdef MUXP
              u8 MUXL_Proc(void *cookie)
              {
                  sEvent *event = NULL;
                  sSlink *slink = NULL;
                  u8      ret = 0;
                  sMuxLayer *muxl = (sMuxLayer *)cookie;
              //FM_Printf(FM_CTRL, "MUXL: pop a beacon/mgmt.\n");
              
                  while(!SLIST_IsEmpty(&muxl->eventQueue)
              #ifndef RTX51_TINY_OS   
                        && !(ret = SCHED_IsPreempted(&muxl->task))
              #endif
                    )
                  {
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                  SEM_WAIT(&muxl->muxSem);
              #endif
                          slink = SLIST_Pop(&muxl->eventQueue);
              #ifdef P8051
              __CRIT_SECTION_END__
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 5   

              #else
                  SEM_POST(&muxl->muxSem);
              #endif
                      event = SLIST_GetEntry(slink, sEvent, link);
                      MUX_Proc(&muxl->mux, event);
                  }
              
                  return ret;
              }
              
              #endif
 232          void MUXL_RecvMgmtPacket(void* cookie, sEvent *event) __REENTRANT__
 233          {
 234   1          sMuxLayer *muxl = (sMuxLayer *)cookie;
 235   1          /* check beacon */
 236   1          if ((event->eventHdr.eventClass == EVENT_CLASS_CTRL)&&
 237   1              (event->eventHdr.type == EVENT_TYPE_CC_BCN_IND))
 238   1          {
 239   2      #ifdef MUX_PRINT    
                      FM_Printf(FM_MUX, "MUX: deliver a beacon\n");
              #endif
 242   2      #ifdef CALLBACK
                      muxl->mux.deliverMgmtMsg(muxl->mux.mgmtcookie, event); 
              #else
 245   2              LINKL_RecvMgmtMsg(muxl->mux.mgmtcookie, event);
 246   2      #endif
 247   2              return;
 248   2          }
 249   1          else if (event->eventHdr.eventClass == EVENT_CLASS_MSG)
 250   1          {
 251   2      
 252   2      #if 0 
                      /* place the event to the mux layer queue */
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                      SEM_WAIT(&muxl->muxSem);
              #endif
                      SLIST_Put(&muxl->eventQueue, &event->link);
              #ifdef P8051
              __CRIT_SECTION_END__
              #else
                      SEM_POST(&muxl->muxSem);
              #endif
                      /* schedule the task */
              #ifndef RTX51_TINY_OS
                      SCHED_Sched(&muxl->task);
              #else
                      os_set_ready(HPGP_TASK_ID_MUX);
              #endif
              
              #else
 273   2      
 274   2          MUX_Proc(&muxl->mux, event);
 275   2      
 276   2      
 277   2      #endif
 278   2      
 279   2          }
 280   1      }
 281              
 282          
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 6   

 283          #if 0
              //The following function is executed in interrupt context
              //void MUXL_RecvMgmtPacket(void* cookie)
              //void MUXL_RecvMgmtPacket(void* cookie, sTxRxDesc *rxdesc, u8 *rxbuf, u16 pktlen)
              void MUXL_RecvMgmtPacket(void* cookie, sRxDesc *rxdesc, 
                                       u8 *rxbuf, u16 pktlen,
                                       u8 *srcMacAddr)
              {
                  sEvent    *event = NULL;
                  sHpgpHdr  *hpgpHdr = NULL;
              
                  //check the ETH header
              //    sEthHdr *ethhdr = NULL;
              //    sRxDesc rxdesc;
              //    u16 pktlen = 0;
                  sMuxLayer *muxl = (sMuxLayer *)cookie;
                  //check DTEI: cco tei, my tei, and multicast/broadcast tei
                  //memset(&rxdesc, 0, sizeof(sRxDesc));
                  //read Rx descriptor and get packet length
                  
              //FM_Printf(FM_CTRL, "MUX: received a beacon/mgmt (%d).\n", pktlen);
              
                  //create an event
                  event = EVENT_Alloc(pktlen + MAC_ADDR_LEN, sizeof(sHpgpHdr));
                  if(event == NULL)
                  {
                      FM_Printf(FM_ERROR, "MUXL: Fail to allcate an event.\n");
                      return;
                  }
              
                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
              
                  hpgpHdr->tei = rxdesc->stei;
                  hpgpHdr->snid = rxdesc->snid;
              
                  memcpy(event->buffDesc.dataptr, srcMacAddr, MAC_ADDR_LEN);
                  hpgpHdr->macAddr = event->buffDesc.dataptr;
                  event->buffDesc.dataptr += MAC_ADDR_LEN;
              
                  //copy the mm from HPGP MAC to event buff
                  memcpy(event->buffDesc.dataptr, rxbuf, pktlen);
                  event->buffDesc.datalen = pktlen;
              #ifdef SIMU
                  if(rxdesc->frameType == FRAME_TYPE_BEACON)
                  {
                      FM_Printf(FM_MUX|FM_LINFO, "MUX: received a beacon (%d).\n", pktlen);
                      event->eventHdr.eventClass = EVENT_CLASS_CTRL;
                      event->eventHdr.type = EVENT_TYPE_CC_BCN_IND;
                  
                  }
                  else //mgmt msg
                  {
              FM_Printf(FM_MUX, "MUX: receive a mgmt msg.\n");
                      event->eventHdr.eventClass = EVENT_CLASS_MSG;
              
              //        ethhdr = (sEthHdr *)event->buffDesc.dataptr; 
              //        event->eventHdr.macAddr = ethhdr->hdr.ethII.srcaddr;
                      //chop off the ethernet header
              //        event->buffDesc.dataptr += sizeof(sEthHdr); 
              //        event->buffDesc.datalen -= sizeof(sEthHdr); 
                  
                  }
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 7   

              #endif
              
                  //place the event to the mux layer queue
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                  SEM_WAIT(&muxl->muxSem);
              #endif
                  SLIST_Put(&muxl->eventQueue, &event->link);
              #ifdef P8051
              __CRIT_SECTION_END__
              #else
                  SEM_POST(&muxl->muxSem);
              #endif
              
              }
              #endif
 362          
 363          void MUXL_RegisterMgmtMsgCallback(sMuxLayer *muxl, 
 364              void (*callback)(void XDATA *cookie, sEvent XDATA *event),
 365              void *cookie)
 366          {
 367   1          /* Compiler warning suppression */
 368   1          callback = callback;
 369   1      #ifdef CALLBACK
                  muxl->mux.deliverMgmtMsg = callback;
              #endif
 372   1          muxl->mux.mgmtcookie = cookie;
 373   1      }
 374          
 375          
 376          eStatus MUXL_Init(sMuxLayer *muxl)
 377          {
 378   1          eStatus status = STATUS_SUCCESS;
 379   1      
 380   1          SLIST_Init(&muxl->eventQueue);
 381   1      
 382   1          HAL_RegisterRxMgmtCallback(HOMEPLUG_GetHal(), MUXL_RecvMgmtPacket, (void *)muxl); 
 383   1      
 384   1      #ifndef P8051
              #if defined(WIN32) || defined(_WIN32)
                  muxl->muxSem = CreateSemaphore(
                      NULL,           // default security attributes
                      SEM_COUNT,      // initial count
                      SEM_COUNT,      // maximum count
                      NULL);          // unnamed semaphore
                  if(muxl->muxSem == NULL)
              #else
                  if(sem_init(&muxl->muxSem, 0, SEM_COUNT))
              #endif
                  {
                      status = STATUS_FAILURE;
                  }
              #endif
 399   1      #ifdef RTX51_TINY_OS  
 400   1      //    os_create_task(HPGP_TASK_ID_MUX);
 401   1      #else   
                  SCHED_InitTask(&muxl->task, HPGP_TASK_ID_MUX, "MUX", 
                                 HPGP_TASK_PRI_MUX, MUXL_Proc, muxl);
              #endif
 405   1          MUX_InitMux(&muxl->mux);
 406   1      
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 8   

 407   1      
 408   1          FM_Printf(FM_MINFO, "MUX Layer: Initialized.\n");
 409   1          return status;
 410   1      }
 411          
 412          #ifdef MUXP //def RTX51_TINY_OS
              void MUXL_Task(void) //_task_ HPGP_TASK_ID_MUX  
              {
                  sMuxLayer* muxl = (sMuxLayer*)HPGPCTRL_GetLayer(HP_LAYER_TYPE_MUX);
                  while (1) {
              #ifdef UART_HOST_INTF
                  os_switch_task();
              #else
                      os_wait1(K_SIG);
              #endif
                      MUXL_Proc(muxl);
                  }
              }
              #endif
 426          
 427          
 428          /** =========================================================
 429           *
 430           * Edit History
 431           *
 432           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/mux/muxl.c,v $
 433           *
 434           * $Log: muxl.c,v $
 435           * Revision 1.9  2015/01/02 14:55:36  kiran
 436           * 1) Timer Leak fixed while freeing SCB fixed
 437           * 2) Software broadcast supported for LG
 438           * 3) UART Loopback supported for LG
 439           * 4) Keep Alive feature to ageout defunctional STA
 440           * 5) Improved flash API's for NO Host Solution
 441           * 6) Imporved PLC Hang recovery mechanism
 442           * 7) Reduced nested call tree of common path functions
 443           * 8) Code optimization and cleanup (unused arguments, unused local variables)
 444           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
 445           * 10) Use of memory specific pointers instead of generic pointers
 446           *
 447           * Revision 1.8  2014/11/11 14:52:58  ranjan
 448           * 1.New Folder Architecture espically in /components
 449           * 2.Modular arrangment of functionality in new files
 450           *    anticipating the need for exposing them as FW App
 451           *    development modules
 452           * 3.Other improvisation in code and .h files
 453           *
 454           * Revision 1.7  2014/10/28 16:27:43  kiran
 455           * 1) Software recovery using Watchdog Timer
 456           * 2) Hardware recovery monitor and policies
 457           * 3) Timer Polling in Control Task and Frame task for better accuracy
 458           * 4) Common memory optimized by reducing prints
 459           * 5) Discovered netlist corruption fixed
 460           * 6) VCO fix in HHAL_AFEInit()
 461           * 7) Idata optimized by removing floating point operation
 462           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
 463           * 9) Beacon processing protected from interrupts
 464           * 10) Corrupted Beacons are dropped
 465           * 11) Some unused arguments removed to improve code size
 466           *
 467           * Revision 1.6  2014/06/11 13:17:47  kiran
 468           * UART as host interface and peripheral interface supported.
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 9   

 469           *
 470           * Revision 1.5  2014/05/28 10:58:59  prashant
 471           * SDK folder structure changes, Uart changes, removed htm (UI) task
 472           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
 473           *
 474           * Revision 1.4  2014/05/12 08:09:57  prashant
 475           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
 476           *
 477           * Revision 1.3  2014/02/27 10:42:47  prashant
 478           * Routing code added
 479           *
 480           * Revision 1.2  2014/01/10 17:18:24  yiming
 481           * check in Rajan 1/8/2014 code release
 482           *
 483           * Revision 1.5  2014/01/08 10:53:54  ranjan
 484           * Changes for LM OS support.
 485           * New Datapath FrameTask
 486           * LM and UM  datapath, feature verified.
 487           *
 488           * known issues : performance numbers needs revisit
 489           *
 490           * review : pending.
 491           *
 492           * Revision 1.4  2013/09/04 14:51:16  yiming
 493           * New changes for Hybrii_A code merge
 494           *
 495           * Revision 1.16  2012/10/25 11:38:48  prashant
 496           * Sniffer code added for MAC_SAP, Added new commands in MAC_SAP for sniffer, bridge,
 497           *  hardware settings and peer information.
 498           *
 499           * Revision 1.15  2012/07/15 17:31:07  yuanhua
 500           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
 501           *
 502           * Revision 1.14  2012/07/02 23:41:34  kripa
 503           * Converting mmType field from host to hpgp byte order and vice versa.
 504           * Committed on the Free edition of March Hare Software CVSNT Client.
 505           * Upgrade to CVS Suite for more features and support:
 506           * http://march-hare.com/cvsnt/
 507           *
 508           * Revision 1.13  2012/06/05 22:37:12  son
 509           * UART console does not get initialized due to task ID changed
 510           *
 511           * Revision 1.12  2012/06/05 07:25:59  yuanhua
 512           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
 513           *
 514           * Revision 1.11  2012/06/04 23:34:34  son
 515           * Added RTX51 OS support
 516           *
 517           * Revision 1.10  2012/05/19 20:32:17  yuanhua
 518           * added non-callback option for the protocol stack.
 519           *
 520           * Revision 1.9  2012/05/17 05:05:58  yuanhua
 521           * (1) added the option for timer w/o callback (2) added task id and name.
 522           *
 523           * Revision 1.8  2012/05/14 05:22:29  yuanhua
 524           * support the SCHED without using callback functions.
 525           *
 526           * Revision 1.7  2012/04/30 04:05:57  yuanhua
 527           * (1) integrated the HAL mgmt Tx. (2) various updates
 528           *
 529           * Revision 1.6  2012/04/25 13:53:41  yuanhua
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 10  

 530           * changed the HAL_Transmit prototype.
 531           *
 532           * Revision 1.5  2012/04/13 06:15:11  yuanhua
 533           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
 534           *
 535           * Revision 1.4  2012/03/11 17:02:25  yuanhua
 536           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
 537           *
 538           * Revision 1.3  2011/09/14 05:52:36  yuanhua
 539           * Made Keil C251 compilation.
 540           *
 541           * Revision 1.2  2011/09/09 07:02:31  yuanhua
 542           * migrate the firmware code from the greenchip to the hybrii.
 543           *
 544           * Revision 1.7  2011/08/09 22:45:44  yuanhua
 545           * changed to event structure, seperating HPGP-related events from the general event defination so that th
             -e general event could be used for other purposes than the HPGP.
 546           *
 547           * Revision 1.6  2011/07/30 02:43:35  yuanhua
 548           * (1) Split the beacon process into two parts: one requiring an immdiate response, the other tolerating t
             -he delay (2) Changed the API btw the MUX and SHAL for packet reception (3) Fixed bugs in various modules. Now, multiple 
             -STAs could successfully associate/leave the CCo
 549           *
 550           * Revision 1.5  2011/07/22 18:51:05  yuanhua
 551           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
 552           *
 553           * Revision 1.4  2011/07/08 22:23:48  yuanhua
 554           * (1) Implemented CNSM, including its state machine, beacon transmission and process, discover beacon sch
             -eduling, auto CCo selection, discover list, handover countdown, etc. (2) Updated SNSM, including discover list processin
             -g, triggering a switch to the new CCo, etc. (3) Updated CNAM and SNAM, adding the connection state in the SNAM, switch t
             -o the new CCo, etc. (4) Other updates
 555           *
 556           * Revision 1.3  2011/07/02 22:09:02  yuanhua
 557           * Implemented both SNAM and CNAM modules, including network join and leave procedures, systemm resource (
             -such as TEI) allocation and release, TEI renew/release timers, and TEI reuse timer, etc.
 558           *
 559           * Revision 1.2  2011/06/24 14:33:18  yuanhua
 560           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
 561           *
 562           * Revision 1.1  2011/05/06 19:12:25  kripa
 563           * Adding mux layer files to new source tree.
 564           *
 565           * Revision 1.4  2011/04/23 23:07:00  kripa
 566           * MUX_Proc() ;changed references to 'event->data' to 'event->eventData', since 'data' is reserved word in
             - Keil.
 567           *
 568           * Revision 1.3  2011/04/23 19:48:45  kripa
 569           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
 570           *
 571           * Revision 1.2  2011/04/23 17:16:38  kripa
 572           * void MUX_Proc(sMux *mux, sEvent *event) ; event->class to event->eventClass.
 573           *
 574           * Revision 1.1  2011/04/08 21:42:11  yuanhua
 575           * Framework
 576           *
 577           *
 578           * ==========================================================*/
C51 COMPILER V9.53.0.0   MUXL                                                              11/04/2015 20:09:41 PAGE 11  

 579          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1213    ----
   CONSTANT SIZE    =    173    ----
   XDATA SIZE       =   ----      52
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
