C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE HAL_HPGPRX
OBJECT MODULE PLACED IN .\obj\hal_hpgpRx.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hal\hal_hpgpRx.c LARGE OBJECTADVANCED OPTIMIZE(9,SI
                    -ZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..
                    -\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;
                    -..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmw
                    -are\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;.
                    -.\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;.
                    -.\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;
                    -..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\
                    -..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hp
                    -gp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..
                    -\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\com
                    -ponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\fl
                    -ash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;.
                    -.\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\
                    -inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..
                    -\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_80
                    -51,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM
                    -,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT
                    -,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,M
                    -CCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIST
                    -ER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\hal_hpgpRx.lst) TABS(2) 
                    -OBJECT(.\obj\hal_hpgpRx.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgpRx.c,v 1.32 2015/01/02 14:55:35 kiran Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgpRx.c,v $
   5          *
   6          * Description : HPGP HAL Receive module.
   7          *
   8          * Copyright (c) 2010-2011 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines beacon and data receive functions for HPGP, .
  13          *
  14          *
  15          */
  16          #ifdef RTX51_TINY_OS
  17          #include <rtx51tny.h>
  18          #endif
  19          
  20          #include <stdio.h>
  21          #include <string.h>
  22          #include "papdef.h"
  23          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  26          #include "fm.h"
  27          #include "hal_common.h"
  28          #include "hal.h"
  29          #include "nma.h"
  30          #include "nma_fw.h"
  31          #include "hal_hpgp.h"
  32          #include "hal_eth.h"
  33          #include "hal_tst.h"
  34          #include "hpgpevt.h"
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 2   

  35          #include "hpgpdef.h"
  36          #ifdef HPGP_HAL_TEST
              #include "hal_cfg.h"
              #include "mmsg.h"
              #else
  40          #ifndef CALLBACK
  41          #include "hpgpapi.h"
  42          #endif
  43          #endif
  44          #include "frametask.h"
  45          #include "datapath.h"
  46          #include "hybrii_tasks.h"
  47          #include "gv701x_gpiodriver.h"
  48          #include "sys_common.h"
  49          #include "event_fw.h"
  50          #ifdef NO_HOST
  51          #include "gv701x_uartdriver_fw.h"
  52          #endif
  53          
  54          #ifdef UM
  55          #include "NSM.h"
  56          #include "green.h"
  57          #include "muxl.h"
  58          extern sHomePlugCb HomePlug;
  59          #endif
  60          #ifdef DEBUG_DATAPATH
  61          extern u8 pktDbg;
  62          extern u8 sigDbg;
  63          #endif
  64          #ifdef PLC_TEST
              u16 oldssn = 0;
              #endif
  67          u8 dropFlag = 0;
  68          
  69          #ifdef SW_BCST
              volatile u8 gSoftBCST = 1;
              #define SW_SSN_SIZE 1
              #endif
  73          
  74          u8 gpbcscorrect, gvalid;
  75          u32 gsnid;
  76          u32 debugcnt = 0;
  77          extern u32 gBcnPer;
  78          u32 misscnt = 0;
  79          u8 gbcnstart, gflag;
  80          extern u32 gbpst1, gtimer2, gtimer1;
  81          extern u8 opMode;
  82          extern u8 gBcnMissingRescanCnt;
  83          extern u16  prevCsmaRgns[HYBRII_MAXSMAREGION_CNT];
  84          #ifdef ROUTE_TEST
              u8 dropTei[3] = {0,0,0};
              #endif
  87          
  88          #ifdef PLC_TEST
              extern void printmsg(u8* buff, u8 len);
              extern void HHT_ProcessPlcFrame(sSwFrmDesc* plcRxFrmSwDesc);
              #endif
  92          
  93            
  94          #ifdef ASSOC_TEST
              extern eStatus LM_RecvFrame(sSwFrmDesc *rxFrmSwDesc, 
                               uRxFrmHwDesc*  pRxPktQ1stDesc,
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 3   

                               uRxCpDesc*   pRxPktQCPDesc);
                
              #endif
 100          #ifdef ROUTE
              extern sScb* ROUTE_lookUpLRT(u8 *mac);
              #endif
 103          
 104          extern void EHT_FromPlcBcnTx(u8* rxBcnByteArr, u16 frameSize);
 105          extern void SNSM_BcnCheck(u8* bcn);
 106          
 107          
 108          uCSMARegionReg   csmaRegArr[HYBRII_MAXSMAREGION_CNT]; 
 109          u32              u32CSMARegs[HYBRII_MAXSMAREGION_CNT];
 110          
 111          
 112          eStatus CHAL_ReadFrame(sSwFrmDesc *rxFrmSwDesc,
 113                                 sBuffDesc *buffDesc)
 114          {
 115   1          volatile u8 XDATA *cellAddr;
 116   1          u8        frmOffset = 0;
 117   1          u8        i;
 118   1          s16       frmLen = rxFrmSwDesc->frmLen;
 119   1          s16       cellLen;
 120   1          u8       *dataptr = NULL;
 121   1          sHpgpHdr *hpgpHdr = NULL;
 122   1          eStatus   ret = STATUS_SUCCESS;
 123   1      
 124   1      
 125   1          /* sanity test on frame length */
 126   1      /*    if (frmLen != ((rxFrmSwDesc->cpCount -1)*HYBRII_CELLBUF_SIZE +
 127   1                        rxFrmSwDesc->lastDescLen))       
 128   1          {
 129   1              FM_Printf(FM_ERROR, "CHAL: Frame length error.\n");
 130   1              ret = STATUS_FAILURE;
 131   1              goto done;
 132   1          } */
 133   1      
 134   1          if (rxFrmSwDesc->rxPort == PORT_PLC)
 135   1          {
 136   2              /* the first cell of the mgmt frame contains 4-byte */
 137   2              frmOffset = ((rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT) ? 4 : 0);
 138   2          }
 139   1      
 140   1      
 141   1          frmLen -= frmOffset;
 142   1          buffDesc->datalen = frmLen;
 143   1        //cellLen = HYBRII_CELLBUF_SIZE - frmOffset;
 144   1        cellLen = MIN(HYBRII_CELLBUF_SIZE - frmOffset, frmLen);
 145   1      //FM_Printf(FM_MINFO,"rx data len: %d, cell len: %d, cp cnt %bu\n", buffDesc->datalen, cellLen, rxFrmSwDes
             -c->cpCount);
 146   1      //FM_HexDump(FM_DATA|FM_MINFO, "rx buff:", (u8 *)buffDesc->dataptr, 256 );  
 147   1           
 148   1          dataptr = buffDesc->dataptr; 
 149   1      
 150   1        i = 0;
 151   1      //    for (i = 0; i < rxFrmSwDesc->cpCount; i++)
 152   1          while((i < rxFrmSwDesc->cpCount) && cellLen > 0)
 153   1          {
 154   2              cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[i].cp);
 155   2              memcpy(dataptr, cellAddr+frmOffset, cellLen);
 156   2              dataptr += cellLen;
 157   2              frmLen -= cellLen;
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 4   

 158   2              cellLen = MIN(HYBRII_CELLBUF_SIZE, frmLen);
 159   2              frmOffset = 0;
 160   2          i++;
 161   2          }
 162   1      //FM_Printf(FM_MINFO,"rx data len: %d, frm len: %d\n", buffDesc->datalen, frmLen);
 163   1      //FM_HexDump(FM_DATA|FM_MINFO, "rx data:", (u8 *)buffDesc->dataptr, 256 );  
 164   1      //done:
 165   1          /* free cp */
 166   1          CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount);
 167   1          return ret;
 168   1      }
 169          
 170          #if !defined (HPGP_HAL_TEST) && !defined(UM)
              
              void HHAL_ProcRxFrameDesc(struct haLayer *hal, uRxFrmHwDesc *rxFrmHwDesc,
                                        sSwFrmDesc *plcRxFrmSwDesc)
              {
                  uPlcRssiLqiReg  rssiLqi;
                  uPlcStatusReg   plcStatus;
                  u16             frmLen;
                  u8              stei;
              
              #ifdef _AES_SW_    
                  // Reset AES Block
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 1;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 0;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              #endif
              
                  /* Retrieve LQI_RSSI */
                  rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
                  plcRxFrmSwDesc->frmInfo.plc.rssi = rssiLqi.s.rssi;
                  plcRxFrmSwDesc->frmInfo.plc.lqi  = rssiLqi.s.lqi;
              
                  /* Extract Frame Length */
                  frmLen = rxFrmHwDesc->sof.frmLenHi;
                  frmLen = frmLen<<PKTQDESC1_FRMLENHI_POS | rxFrmHwDesc->sof.frmLenLo;
                  plcRxFrmSwDesc->frmLen = frmLen;
              //  printf("\nfrmLen : %d \n", frmLen);
              
                  /* Extract PLC Frame Type */
                  plcRxFrmSwDesc->frmType = (eHpgpHwFrmType)rxFrmHwDesc->sof.frmType;
                  /* Extract source TEI */
                  stei   = rxFrmHwDesc->sof.steiHi2;
                  stei   = (stei << PKTQDESC1_STEIHI_POS ) | rxFrmHwDesc->sof.steiLo6;
                  plcRxFrmSwDesc->frmInfo.plc.stei    = stei; 
              
              
              //  printf("rx len %d\n", frmLen);
                  
              
                  if(plcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MSDU)
                  {
                      gHpgpHalCB.halStats.RxGoodDataCnt++;
                      /* Extract PLC Frame Mcst Mode */
                      if(rxFrmHwDesc->sof.bcst)
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 5   

                      }
                      else if(rxFrmHwDesc->sof.mcst)
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                      }
                      else
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
                      }
                  }
                  else if(plcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
                  {
                      /*
                       * H/W does not provide STEI for Sound packet
                       */
                      plcRxFrmSwDesc->frmInfo.plc.stei = 0;
                      gHpgpHalCB.halStats.RxGoodSoundCnt++;
                  }
                  else 
                  {
                      gHpgpHalCB.halStats.RxGoodMgmtCnt++;
                  }          
              
                  plcRxFrmSwDesc->frmInfo.plc.clst    = rxFrmHwDesc->sof.clst;
              
              
                  /* Update HPGP statistics - may be needed only in diag mode */
                  gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
                  gHpgpHalCB.halStats.TotalRxBytesCnt += plcRxFrmSwDesc->frmLen;
                  gHpgpHalCB.halStats.macRxStuckCnt = 0;
                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
              }
              
              #endif
 254          
 255          #ifndef HPGP_HAL_TEST
 256          
 257          
 258          eStatus HAL_RecvFrame(sHaLayer *hal, sSwFrmDesc *rxFrmSwDesc)
 259          {
 260   1          sEvent    xdata  *event = NULL;
 261   1          sBuffDesc   *buffDesc = NULL;
 262   1          sEth2Hdr    *ethhdr = NULL;
 263   1          sHpgpHdr    *hpgpHdr = NULL; 
 264   1          eStatus      ret = STATUS_SUCCESS;
 265   1          volatile u8 XDATA *cellAddr;
 266   1        sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);    
 267   1          
 268   1      #ifdef ROUTE
                u16 frmlen;
                  u8 i;
              #endif
 272   1          u8 frmOffset;
 273   1      
 274   1      #ifndef B1
 275   1        sScb *scb = CRM_GetScb(LINKL_GetCrm(linkl), rxFrmSwDesc->frmInfo.plc.stei);
 276   1      #endif
 277   1      
 278   1      #ifdef ROUTE
                  sScb *rScb = NULL;    
                  sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
              #endif
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 6   

 282   1          switch(rxFrmSwDesc->rxPort)
 283   1          {
 284   2              case PORT_PLC:
 285   2              {
 286   3                  cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[0].cp);
 287   3                  frmOffset = ((rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT) ? 4 : 0);
 288   3                  
 289   3                ethhdr = (sEth2Hdr *)&cellAddr[frmOffset];
 290   3      #ifdef B1     
                          if ((rxFrmSwDesc->frmInfo.plc.stei == 0) || (IS_GROUP(ethhdr->dstaddr)))
                    {     
                    }
                          else
                    {
                      sScb *scb = CRM_GetScb(LINKL_GetCrm(linkl), rxFrmSwDesc->frmInfo.plc.stei);
                      if (!scb)
                      {
                          if (rxFrmSwDesc->frmType != HPGP_HW_FRMTYPE_MGMT)
                                  {
                                      gHpgpHalCB.halStats.PtoHswDropCnt++;
                            return STATUS_FAILURE;
                                  }
                      }
              #ifdef KEEP_ALIVE       
                      scb->hit = 1;
                      scb->hitCount = 0;
              #endif        
                              if(scb->uWrapAround)
                              {
                                  if(rxFrmSwDesc->frmInfo.plc.ssn < 1000)
                                  {                    
                                      scb->uWrapAround = 0;
                                      scb->uMinSSN = 0;
                                  }
                              }              
                      if ((rxFrmSwDesc->frmInfo.plc.ssn <= scb->uMinSSN) && (scb->uMinSSN != 0))
                      {
                        // Drop duplicate frm
                        gHpgpHalCB.halStats.DuplicateRxCnt++;
                        return STATUS_FAILURE;
                      }
                      
                      scb->uMinSSN = rxFrmSwDesc->frmInfo.plc.ssn;// + numPBs;
                      
                      if(scb->uMinSSN >= 1500)
                      {
                        scb->uWrapAround = 1;
                      }
              
                    }
              
                        
              #endif
 335   3              // Drop frm if dest MAC not match with device MAC address
 336   3              if(IS_GROUP(ethhdr->dstaddr))
 337   3              {
 338   4              }
 339   3              else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
 340   3              {
 341   4                
 342   4              }
 343   3      #ifdef ROUTE
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 7   

                      else if((rScb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                      {
                        
                        //FM_Printf(FM_USER, "LH: %bu\n",scb->tei);
                        if(rScb->lrtEntry.routeIsInvalid == TRUE || rScb->lrtEntry.routeOnHold == TRUE)
                        {
                          return STATUS_FAILURE;
                        }
                        rxFrmSwDesc->frmInfo.plc.dtei = rScb->lrtEntry.nTei;
                        rxFrmSwDesc->frmInfo.plc.eks = staInfo->nekEks;
                        if(linkl->mode == LINKL_STA_MODE_CCO)
                        {
              
                          rxFrmSwDesc->frmInfo.plc.stei = staInfo->ccoScb->tei;
                        }
                        else
                        {
                          rxFrmSwDesc->frmInfo.plc.stei =  staInfo->tei;
                        }
              
              
                         {
              
              
                          rxFrmSwDesc->frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                          rxFrmSwDesc->frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
              
                          rxFrmSwDesc->frmInfo.plc.plid = 0;   //[YM] This line of code has to be changed base on differnet QoS
             - priority
              
              
                          if (rxFrmSwDesc->frmInfo.plc.plid == 0)
                          rxFrmSwDesc->frmInfo.plc.phyPendBlks  = HPGP_PPB_CAP0;
                          else
                          rxFrmSwDesc->frmInfo.plc.phyPendBlks  = HPGP_PPB_CAP123;
              
                          rxFrmSwDesc->frmInfo.plc.mcstMode   = HPGP_UCST;  // Unicast
              
                          rxFrmSwDesc->frmInfo.plc.stdModeSel   = STD_ROBO_TEST; // std robo
                          rxFrmSwDesc->frmInfo.plc.dt_av = HPGP_DTAV_SOF;
                          rxFrmSwDesc->frmInfo.plc.saf = 1;
              
              
                        }
              
                        
                        frmlen = rxFrmSwDesc->frmLen;
                        for(i = 0; i< rxFrmSwDesc->cpCount; i++)
                        {
                          if(( i == 0) && (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT))
                          {
                            rxFrmSwDesc->cpArr[i].offsetU32 = 1;               
                          }
                          rxFrmSwDesc->cpArr[i].len = MIN(frmlen, HYBRII_CELLBUF_SIZE);
                          frmlen = frmlen - HYBRII_CELLBUF_SIZE;
                        }
                        rxFrmSwDesc->txPort = PORT_PLC;
                        fwdAgent_handleData(rxFrmSwDesc);
                        return STATUS_SUCCESS;
                      }
              #endif 
 404   3              else
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 8   

 405   3              {
 406   4                // Drop frm
 407   4      #ifdef DEBUG_DATAPATH
 408   4                if(pktDbg)
 409   4                {
 410   5                  FM_Printf(FM_MINFO, "Drop\n");
 411   5                }
 412   4      #endif
 413   4                gHpgpHalCB.halStats.PtoHswDropCnt++;
 414   4                return STATUS_FAILURE;
 415   4              }
 416   3      #ifndef B1
 417   3            if (!scb)
 418   3            {
 419   4              if (rxFrmSwDesc->frmType != HPGP_HW_FRMTYPE_MGMT)
 420   4              {
 421   5                gHpgpHalCB.halStats.PtoHswDropCnt++;            
 422   5                return STATUS_FAILURE;
 423   5              }
 424   4            
 425   4            }
 426   3            else
 427   3            {
 428   4              scb->rssiLqi.s.rssi = rxFrmSwDesc->frmInfo.plc.rssi;
 429   4              scb->rssiLqi.s.lqi = rxFrmSwDesc->frmInfo.plc.lqi;
 430   4      
 431   4      #ifdef KEEP_ALIVE
 432   4              scb->hit = 1;
 433   4              scb->hitCount = 0;
 434   4      #endif  
 435   4      
 436   4            }
 437   3      
 438   3            
 439   3            //printf("tei %bu rssi %bu\n", scb->tei, scb->rssiLqi.s.rssi);
 440   3            
 441   3      
 442   3                  if ((rxFrmSwDesc->frmInfo.plc.stei == 0) || (IS_GROUP(ethhdr->dstaddr)))
 443   3            {
 444   4            
 445   4            }
 446   3                  else if (scb)
 447   3            {
 448   4              
 449   4                      if(scb->uWrapAround)
 450   4                      {
 451   5                          if(rxFrmSwDesc->frmInfo.plc.ssn < 1000)
 452   5                          {                    
 453   6                              scb->uWrapAround = 0;
 454   6                              scb->uMinSSN = 0;
 455   6                          }
 456   5                      }
 457   4                      
 458   4      
 459   4              //printf("tei %bu rssi %bu\n", scb->tei, scb->rssiLqi.s.rssi);
 460   4              
 461   4              if ((rxFrmSwDesc->frmInfo.plc.ssn <= scb->uMinSSN) && (scb->uMinSSN != 0))
 462   4                      {
 463   5                  // Drop duplicate frm
 464   5                  gHpgpHalCB.halStats.DuplicateRxCnt++;                    
 465   5                          //printf("Dup frm: %u, %u \n",rxFrmSwDesc->frmInfo.plc.ssn, scb->uMinSSN);
 466   5                return STATUS_FAILURE;
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 9   

 467   5              }
 468   4                      
 469   4                      scb->uMinSSN = rxFrmSwDesc->frmInfo.plc.ssn;// + numPBs;
 470   4                      
 471   4                      if(scb->uMinSSN >= 1500)
 472   4                      {
 473   5                          scb->uWrapAround = 1;
 474   5                      }
 475   4      
 476   4            }
 477   3      #endif
 478   3            if (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
 479   3            {
 480   4              /* create an event for the mgmt message */
 481   4              event = EVENT_MgmtAlloc(rxFrmSwDesc->frmLen, sizeof(sHpgpHdr));
 482   4              if (event == NULL)
 483   4              {
 484   5                          FM_Printf(FM_ERROR, "HAL:EAF\n");
 485   5                return STATUS_FAILURE;
 486   5              }
 487   4      
 488   4              buffDesc = &event->buffDesc;
 489   4      
 490   4                      if (CHAL_ReadFrame(rxFrmSwDesc, buffDesc) == STATUS_SUCCESS)
 491   4                      {
 492   5                          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
 493   5                          //hpgpHdr->snid = hal->hhalCb->snid;
 494   5                          hpgpHdr->snid = rxFrmSwDesc->frmInfo.plc.snid;
 495   5                          hpgpHdr->tei = rxFrmSwDesc->frmInfo.plc.stei;
 496   5        //                  FM_Printf(FM_MINFO, "HAL: Rx Snid=%bu, Stei=%bu\n", hpgpHdr->snid, hpgpHdr->tei);
 497   5                          event->eventHdr.eventClass = EVENT_CLASS_MSG;
 498   5                          /* process the MAC header */
 499   5                          ethhdr = (sEth2Hdr *)event->buffDesc.dataptr; 
 500   5      #ifdef LOG_FLASH
                        logEvent(MGMT_MSG,0,event->eventHdr.type,&hpgpHdr->tei,1);
              #endif
 503   5      #if 1         
 504   5                // Drop frm if dest MAC not match with device MAC address
 505   5                if(IS_GROUP(ethhdr->dstaddr))
 506   5                {
 507   6                }
 508   5                else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
 509   5                {
 510   6                }
 511   5                
 512   5      #ifdef ROUTE
                        else if((scb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                        {
                          if(scb->lrtEntry.routeIsInvalid == TRUE || scb->lrtEntry.routeOnHold == TRUE)
                          {
                            return STATUS_SUCCESS;
                          }
              #ifndef RELEASE
                          FM_Printf(FM_USER, "LRT hit: %bu\n",scb->tei);
              #endif
                          hpgpHdr->tei = scb->lrtEntry.nTei;
                          hpgpHdr->eks = staInfo->nekEks;
                          //rxFrmSwDesc->plc.stei =  // TBD
                          fwdAgent_sendFrame(PORT_PLC ,event);
                          return STATUS_SUCCESS;
                        }
              #endif
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 10  

 529   5                else
 530   5                {
 531   6                  // Drop frm
 532   6      #ifdef DEBUG_DATAPATH
 533   6                  if(pktDbg)
 534   6                  {
 535   7                    FM_Printf(FM_MINFO, "MGMT drop\n");
 536   7                  }
 537   6      #endif
 538   6                  EVENT_Free(event);
 539   6                  return STATUS_SUCCESS; //STATUS_FAILURE;
 540   6                }
 541   5      #endif                    
 542   5                hpgpHdr->macAddr = ethhdr->srcaddr;
 543   5      //            hpgpHdr->scb = CRM_FindScbMacAddr(hpgpHdr->macAddr);
 544   5      
 545   5                                    
 546   5                /* chop off the ethernet header */
 547   5                event->buffDesc.dataptr += sizeof(sEth2Hdr); 
 548   5                event->buffDesc.datalen -= sizeof(sEth2Hdr); 
 549   5                /* deliver the mgmt message to the upper layer */
 550   5      #ifdef CALLBACK
                        hal->deliverMgmtPacket(hal->mgmtCookie, event);
              #else
 553   5                MUXL_RecvMgmtPacket(hal->mgmtCookie, event);
 554   5      #endif
 555   5               //   CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount);
 556   5              }
 557   4              else
 558   4              {
 559   5                EVENT_Free(event);
 560   5              }
 561   4            }
 562   3            else if (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MSDU)
 563   3            {
 564   4              /* deliver the data packet to the data plane */
 565   4      
 566   4                
 567   4                
 568   4                // FM_Printf(FM_USER,"DATA ssn: %u\n", rxFrmSwDesc->frmInfo.plc.ssn);
 569   4      
 570   4                  
 571   4      
 572   4      #ifdef ROUTE
              
                          //  cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[0].cp);
                          //  ethhdr = (sEth2Hdr *)cellAddr;
                          // Drop frm if dest MAC not match with device MAC address
                          if(IS_GROUP(ethhdr->dstaddr))
                          {
                          }
                          else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
                          {
                            
                          }
                          else if((scb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                          {
              #ifndef RELEASE             
                            FM_Printf(FM_USER, "LH: %bu\n",scb->tei);
              #endif
                            if(scb->lrtEntry.routeIsInvalid == TRUE || scb->lrtEntry.routeOnHold == TRUE)
                            {
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 11  

                              return STATUS_FAILURE;
                            }
                            rxFrmSwDesc->frmInfo.plc.dtei = scb->lrtEntry.nTei;
                            rxFrmSwDesc->frmInfo.plc.eks = staInfo->nekEks;
                            if(linkl->mode == LINKL_STA_MODE_CCO)
                            {
              
                              rxFrmSwDesc->frmInfo.plc.stei = staInfo->ccoScb->tei;
                            }
                            else
                            {
                              rxFrmSwDesc->frmInfo.plc.stei =  staInfo->tei;
                            }
              
              
                            {
              
              
                              rxFrmSwDesc->frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                              rxFrmSwDesc->frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
              
                              rxFrmSwDesc->frmInfo.plc.plid = 0;   //[YM] This line of code has to be changed base on differnet Q
             -oS priority
              
              
                              if (rxFrmSwDesc->frmInfo.plc.plid == 0)
                              rxFrmSwDesc->frmInfo.plc.phyPendBlks  = HPGP_PPB_CAP0;
                              else
                              rxFrmSwDesc->frmInfo.plc.phyPendBlks  = HPGP_PPB_CAP123;
              
                              rxFrmSwDesc->frmInfo.plc.mcstMode   = HPGP_UCST;  // Unicast
              
                              rxFrmSwDesc->frmInfo.plc.stdModeSel   = STD_ROBO_TEST; // std robo
                              rxFrmSwDesc->frmInfo.plc.dt_av = HPGP_DTAV_SOF;
                              rxFrmSwDesc->frmInfo.plc.saf = 1;
              
              
                            }
                            frmlen = rxFrmSwDesc->frmLen;
                            for(i = 0; i< rxFrmSwDesc->cpCount; i++)
                            {
                              rxFrmSwDesc->cpArr[i].offsetU32 = 0;
                              rxFrmSwDesc->cpArr[i].len = MIN(frmlen, HYBRII_CELLBUF_SIZE);
                              frmlen = frmlen - HYBRII_CELLBUF_SIZE;
                            }
                            rxFrmSwDesc->txPort = PORT_PLC;
                            fwdAgent_handleData(rxFrmSwDesc);
                            return STATUS_SUCCESS;
                          }
                          else
                          {
                            // Drop frm
              #ifdef DEBUG_DATAPATH
                            if(pktDbg)
                            {
                              FM_Printf(FM_MINFO, "DATA drop\n");
                            }
              #endif
                            return STATUS_FAILURE;
                          }
              #endif
 651   4      
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 12  

 652   4      
 653   4        //            FM_Printf(FM_USER, "prx\n");
 654   4      #if (defined UART_HOST_INTF) && (defined NO_HOST)//#ifdef NO_HOST
 655   4                  if(rxFrmSwDesc->frmLen > (APP_DATA_MAX_SIZE + 14))
 656   4                  {
 657   5                     gHpgpHalCB.halStats.PtoHswDropCnt++;
 658   5                     return STATUS_FAILURE;
 659   5                  }
 660   4      #ifdef SW_BCST      
                          if(gSoftBCST == 1)
                          {
                            if(IS_GROUP(ethhdr->dstaddr))
                                      {
                                        //sScb *scb;
                                        u8 lastDescLen;
                              u8 xdata* cellAddr;
                                        //scb = CRM_GetScb(LINKL_GetCrm(linkl), rxFrmSwDesc->frmInfo.plc.stei);
                              //if(scb != NULL)
                              //{
                                lastDescLen = rxFrmSwDesc->frmLen % HYBRII_CELLBUF_SIZE;
                                //printf("lastDescLen %bu\n",lastDescLen);
                                cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[(rxFrmSwDesc->cpCount)-1].cp);
                                //printf("rx SSN %bu\n",cellAddr[lastDescLen - SW_SSN_SIZE]);
                                if(cellAddr[lastDescLen - SW_SSN_SIZE] == scb->swSsn)
                                {
                                  gHpgpHalCB.halStats.PtoHswDropCnt++;
                                  gHpgpHalCB.halStats.swBcstDropCnt++;
                                  return STATUS_FAILURE;
                                }
                                else
                                {
                                  scb->swSsn = cellAddr[lastDescLen-1];
                                  rxFrmSwDesc->frmLen -= SW_SSN_SIZE;
                                  if(lastDescLen > SW_SSN_SIZE)
                                  {   
                                    rxFrmSwDesc->cpArr[(rxFrmSwDesc->cpCount)-1].len -= SW_SSN_SIZE;
                                    rxFrmSwDesc->lastDescLen -= SW_SSN_SIZE;
                                  }
                                  else
                                  {
                                    rxFrmSwDesc->lastDescLen = HYBRII_CELLBUF_SIZE;
                                    rxFrmSwDesc->cpCount--;
                                    CHAL_freeCP(rxFrmSwDesc->cpArr[(rxFrmSwDesc->cpCount)-1].cp);
                                  }
                                }
                              //}
                            }
                                    }
              #endif
 701   4      #endif
 702   4                  fwdAgent_handleData(rxFrmSwDesc);
 703   4            }
 704   3            else
 705   3            {
 706   4              /* unknown HPGP frame type */
 707   4            }
 708   3            break;
 709   3          }
 710   2            /* TODO: need to differentiate the mgmt and data */       
 711   2            /* create an event for the mgmt message */
 712   2      
 713   2              /* deliver the mgmt message to the upper layer */
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 13  

 714   2               // CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount); // [PRA] double free
 715   2          default:
 716   2          {
 717   3            /* deliver the data packet to the data plane */
 718   3            //hal->deliverDataPacket(hal->dataCookie, rxFrmSwDesc);
 719   3          }
 720   2        }
 721   1      
 722   1        return ret;
 723   1      }
 724          
 725          #endif
 726          
 727          void HHAL_RxSoundIntHandler()
 728          {
 729   1          uPlcRssiLqiReg  rssiLqi;
 730   1          // Retrieve LQI_RSSI   
 731   1          rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
 732   1          //printf(" SOUND int: 0xE4C REG Value= %lx, \n", rssiLqi.reg);
 733   1        
 734   1        //rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
 735   1        //printf(" SOUND 2: 0xE48 REG Value= %lx, \n", ReadU32Reg(PLC_RSSILQI_REG));
 736   1        
 737   1      }
 738          
 739          
 740          #ifdef HPGP_HAL_TEST
              void HHAL_RxIntHandler(sCommonRxFrmSwDesc* pRxFrmDesc)
              #else
 743          void HHAL_RxIntHandler(sCommonRxFrmSwDesc* pRxFrmDesc, void *cookie)
 744          #endif
 745          {
 746   1      
 747   1          // If SrcPort is PLC, Frametype Bcn,Mgmt
 748   1          // Write to PLCCmdQ
 749   1      //#ifdef PLC_TEST
 750   1          volatile u8 xdata * cellAddr;
 751   1      //#endif
 752   1          uRxFrmHwDesc*   pRxPktQ1stDesc;
 753   1          uRxCpDesc*      pRxPktQCPDesc;
 754   1          uPlcRssiLqiReg  rssiLqi;
 755   1          sSwFrmDesc      plcRxFrmSwDesc;
 756   1          u16             frmLen;
 757   1          u16             tmpfrmLen;
 758   1          u8              snid;
 759   1          u8              stei;
 760   1          u16             ssn;
 761   1          u8              i;
 762   1          eStatus         status = STATUS_SUCCESS;
 763   1          sEth2Hdr         *ethHdr;
 764   1      #ifdef UM
 765   1          sScb *scb;
 766   1      #endif
 767   1      #ifdef _AES_SW_    
                  // Reset AES Block
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 1;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 0;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 14  

              #endif
 777   1      
 778   1      #ifdef PLC_DELAY    
                  CHAL_DelayTicks(500);
              #endif
 781   1      
 782   1      
 783   1      
 784   1      
 785   1      
 786   1      #if 0
                  // Retrieve LQI_RSSI   -- [YM] May change to only do this on sound packet
                  //rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
                  rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
                  //plcRxFrmSwDesc.frmInfo.plc.rssi = rssiLqi.s.rssi;
                  //plcRxFrmSwDesc.frmInfo.plc.lqi  = rssiLqi.s.lqi;  
                printf(" E48 REG = %lx, \n", rssiLqi.reg);
                rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
                printf(" E4C REG = %lx, \n", rssiLqi.reg);
              
              #endif
 797   1      
 798   1          pRxPktQ1stDesc      = (uRxFrmHwDesc*)&pRxFrmDesc->hdrDesc;
 799   1          pRxPktQCPDesc       = (uRxCpDesc*)&pRxFrmDesc->firstCpDesc;
 800   1      
 801   1          plcRxFrmSwDesc.rxPort = pRxPktQ1stDesc->sof.srcPort;
 802   1        plcRxFrmSwDesc.txPort = pRxPktQ1stDesc->sof.dstPort;
 803   1          plcRxFrmSwDesc.frmInfo.plc.rssi = pRxFrmDesc->rssiLqi.s.rssi;
 804   1          plcRxFrmSwDesc.frmInfo.plc.lqi  = pRxFrmDesc->rssiLqi.s.lqi;
 805   1          // 1.1.1 Extract PLC Frame Length
 806   1          frmLen = pRxPktQ1stDesc->sof.frmLenHi;
 807   1          frmLen = frmLen<<PKTQDESC1_FRMLENHI_POS | pRxPktQ1stDesc->sof.frmLenLo;
 808   1          plcRxFrmSwDesc.frmLen = frmLen;
 809   1      
 810   1          // 1.1.2 Extract PLC Frame Type
 811   1          plcRxFrmSwDesc.frmType = (eHpgpHwFrmType)pRxPktQ1stDesc->sof.frmType;
 812   1          stei   = pRxPktQ1stDesc->sof.steiHi2;
 813   1          stei   = (stei << PKTQDESC1_STEIHI_POS ) | pRxPktQ1stDesc->sof.steiLo6;
 814   1      
 815   1          snid   = pRxPktQCPDesc->plc.snidHi;
 816   1          snid   = (snid << PKTQDESC1_SNIDHI_POS ) | pRxPktQCPDesc->plc.snidLo;
 817   1          
 818   1          tmpfrmLen = frmLen;
 819   1          // Update HPGP statistics - may be needed only in diag mode
 820   1      
 821   1      
 822   1        /*{
 823   1      
 824   1          uPlcTxPktQDescVF0 *vf0 = (uPlcTxPktQDescVF0*)&pRxFrmDesc->fc[0];
 825   1      
 826   1      
 827   1            stei = vf0->s.stei;
 828   1      
 829   1            snid  = vf0->s.snid;
 830   1      
 831   1      
 832   1        }*/
 833   1      #ifdef UM
 834   1          if (stei == 0)       
 835   1          {
 836   2            cellAddr = CHAL_GetAccessToCP(pRxPktQCPDesc->plc.cp);
 837   2              //if(cellAddr != NULL)// cellAddress is never NULL. Kiran
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 15  

 838   2              //{
 839   2                   if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT)
 840   2                   {
 841   3                       ethHdr = (sEth2Hdr*)(&(cellAddr + 4));
 842   3                   }
 843   2                   else
 844   2                   {
 845   3                       ethHdr = (sEth2Hdr*)cellAddr;
 846   3                   }
 847   2                   scb = CRM_FindScbMacAddr(ethHdr->srcaddr);
 848   2                   if(scb != NULL)
 849   2                   {
 850   3                       stei = scb->tei;
 851   3                   }
 852   2              //}
 853   2          }
 854   1      #endif
 855   1          plcRxFrmSwDesc.frmInfo.plc.snid    = snid;
 856   1          plcRxFrmSwDesc.frmInfo.plc.stei    = stei; 
 857   1      
 858   1          ssn    = pRxPktQCPDesc->plc.ssnHi;
 859   1          ssn    = (ssn << PKTQDESC1_SSNHI_POS ) | pRxPktQCPDesc->plc.ssnLo;
 860   1      #ifdef PLC_TEST
                  if(opMode == LOWER_MAC)
                  {
                      if(pRxPktQ1stDesc->sof.bcst == 0 && pRxPktQ1stDesc->sof.mcst == 0)
                      {
                          if((ssn == oldssn) && (ssn != 0))
                          {
                              CHAL_DecrementReleaseCPCnt(pRxPktQCPDesc->plc.cp);
                              for (i = 1; i < pRxFrmDesc->cpCount; i++)
                              {
                              CHAL_DecrementReleaseCPCnt(pRxFrmDesc->cpArr[i]);
                              }
                              //printf("Dup frm: %u, %u \n",ssn, oldssn);
                              return;
                          }
                          oldssn = ssn;
                          if(oldssn == 2047)
                          {
                              oldssn = 0;
                          }
                      }
                  }
              #endif    
 883   1          gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
 884   1          gHpgpHalCB.halStats.TotalRxBytesCnt += plcRxFrmSwDesc.frmLen;
 885   1          gHpgpHalCB.halStats.macRxStuckCnt = 0;
 886   1          gHpgpHalCB.halStats.smRxStuckCnt = 0;
 887   1      
 888   1          if(plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MSDU)
 889   1          {
 890   2              gHpgpHalCB.halStats.RxGoodDataCnt++;
 891   2              // 1.1.3 Extract PLC Frame Mcst Mode
 892   2              if(pRxPktQ1stDesc->sof.bcst)
 893   2              {
 894   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_MNBCST;
 895   3              }
 896   2              else if(pRxPktQ1stDesc->sof.mcst)
 897   2              {
 898   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_MCST;
 899   3              }
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 16  

 900   2              else
 901   2              {
 902   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_UCST;
 903   3              }
 904   2          }
 905   1          else if(plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
 906   1          {
 907   2              /*
 908   2               * H/W does not provide STEI for Sound packet
 909   2               */
 910   2              plcRxFrmSwDesc.frmInfo.plc.stei = 0;
 911   2              gHpgpHalCB.halStats.RxGoodSoundCnt++;
 912   2          //rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
 913   2              //plcRxFrmSwDesc.frmInfo.plc.rssi = rssiLqi.s.rssi;
 914   2              //plcRxFrmSwDesc.frmInfo.plc.lqi  = rssiLqi.s.lqi;  
 915   2            //printf(" SOUND: E48 REG = %lx, \n", rssiLqi.reg);
 916   2            rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
 917   2            //printf(" SOUND: E4C REG = %lx, \n", rssiLqi.reg);   
 918   2          }
 919   1          else 
 920   1          {
 921   2              gHpgpHalCB.halStats.RxGoodMgmtCnt++;
 922   2          }
 923   1                     
 924   1          plcRxFrmSwDesc.frmInfo.plc.clst    = pRxPktQ1stDesc->sof.clst;
 925   1          
 926   1          plcRxFrmSwDesc.frmInfo.plc.ssn = ssn;
 927   1      
 928   1          plcRxFrmSwDesc.cpArr[0].cp = pRxPktQCPDesc->plc.cp;
 929   1          plcRxFrmSwDesc.cpArr[0].offsetU32 =0;
 930   1          plcRxFrmSwDesc.lastDescLen  = pRxFrmDesc->lastDescLen;
 931   1      
 932   1          // 1.1.4 Read second and subsequent CP descriptors
 933   1          plcRxFrmSwDesc.cpCount = pRxFrmDesc->cpCount;
 934   1      
 935   1          for( i=1 ; i< plcRxFrmSwDesc.cpCount ; i++ )
 936   1          {
 937   2              plcRxFrmSwDesc.cpArr[i].cp = pRxFrmDesc->cpArr[i];
 938   2              plcRxFrmSwDesc.cpArr[i].offsetU32 = 0;
 939   2          }
 940   1          // 1.1.6 Call PLC Rx Callback -- tbd
 941   1        
 942   1      #ifdef PLC_TEST
                      cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc.cpArr[0].cp);
                      
                      if((cellAddr[0] == '/') && 
                          (cellAddr[1] == '?') &&
                          (cellAddr[2] == '!'))//chek /?! header bytes for propritary protocol
                      {
                              
                          //printf("\n cell add");
                          //printmsg(&cellAddr[0],6);
                         gHpgpHalCB.halStats.RxGoodDataCnt--;
                          HHT_ProcessPlcFrame(&plcRxFrmSwDesc);
                      }
                     else
              #endif
 957   1          
 958   1      #ifdef HPGP_HAL_TEST
                  if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
                // Sound  pakcet process
                { 
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 17  

                     printf("free sound packet, dt_av=%X\n", plcRxFrmSwDesc.frmType);
                   CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
                }
                else
                {
                  if(1 == eth_plc_bridge)
                  //if((1 == eth_plc_bridge) && (plcRxFrmSwDesc.frmType != HPGP_HW_FRMTYPE_SOUND))
                  { 
              #ifdef ASSOC_TEST         
                      if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT)
                      {
                           LM_RecvFrame(&plcRxFrmSwDesc,pRxPktQ1stDesc,
                                          pRxPktQCPDesc);
                      }
                      else
              #endif
                      {
              #ifdef HYBRII_ETH
              //      memcpy((u8*)plcRxFrmSwDesc.fc, (u8*)pRxFrmDesc->fc, VF_SIZE);
              
              
                    fwdAgent_handleData(&plcRxFrmSwDesc);
              #endif  //HYBRII_ETH
              
                      }
                  }
                  else
                  {
                      HHT_ProcessPlcMacFrame(&plcRxFrmSwDesc);
                  }
                }  //End of frame type = SOUND
              
              #else  //HPGP_HAL_TEST
 995   1          if(1 == eth_plc_bridge)
 996   1          {
 997   2      #ifdef HYBRII_ETH
              //        memcpy((u8*)plcRxFrmSwDesc.fc, (u8*)pRxFrmDesc->fc, VF_SIZE);
              
              
                   fwdAgent_handleData(&plcRxFrmSwDesc);
              #else
1003   2                 CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
1004   2      #endif  //HYBRII_ETH
1005   2          }
1006   1          else
1007   1          {
1008   2              status = HAL_RecvFrame((sHaLayer *)cookie, &plcRxFrmSwDesc);
1009   2          }
1010   1          
1011   1      
1012   1      #endif  //HPGP_HAL_TEST
1013   1          if (status == STATUS_FAILURE)
1014   1          {
1015   2              CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
1016   2          }
1017   1      }
1018          
1019          
1020          #ifdef HPGP_HAL_TEST
              extern sHalCB gHalCB;
              void HHAL_BcnRxIntHandler()
               {
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 18  

                      u32 xdata        rxBcnWordArr[(PLC_BCNRX_LEN>>2) + 5];  // 5 DWORD of Ether II header
                                                                                 // and hostHdr_t
                      u32              *prxBcnWordArr = NULL;
                      u8*              rxBcnByteArr;
                      u8               i, u8val;
                      u8               bcnDataOffset;
                      uPlcStatusReg    plcStatus;
                      sHybriiRxBcnHdr* pRxBcnHdr;
              #ifdef SNIFFER
                      if(1 == eth_plc_sniffer)
                      {
                          bcnDataOffset = (sizeof(hostHdr_t) + sizeof(sEth2Hdr));
                  }
                  else
              #endif
                  {
                      bcnDataOffset = 0;
                  }
              
              
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  rxBcnByteArr  = (u8*)rxBcnWordArr;
              
                  prxBcnWordArr =  (u32*)(rxBcnByteArr + bcnDataOffset);
                  gHpgpHalCB.halStats.BcnRxIntCnt++;
                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
                  // Confirm that Bcn Rx Fifo is not emplty.  //[YM] We should check the BcnCnt to make sure there is a 
             -valid beacon in RxFifo
                  do
                  {
                      // Read from fifo to local memory.
                      for( i=0 ; i<(PLC_BCNRX_LEN>>2) ; i++)
                      {
                          prxBcnWordArr[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
                      }
                  // use R/W byte operation so we don't set plcTxQRdy here
                  u8val = ReadU8Reg(PLC_STATUS_REG+1);
                  u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
                    WriteU8Reg(PLC_STATUS_REG+1, u8val);
                     
                      pRxBcnHdr = (sHybriiRxBcnHdr*)(rxBcnByteArr + (bcnDataOffset*4));
                      // Update statistics.  //[YM] why check rsv1,2,3,4 bit fields??
                      //if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && !
             -pRxBcnHdr->rsv3 && !pRxBcnHdr->rsv4)  
                      if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect)
                      {             
                          gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
                          gHpgpHalCB.halStats.RxGoodBcnCnt++;
                          gHpgpHalCB.halStats.macRxStuckCnt = 0; 
              #ifdef FREQ_DETECT
                              if(gHpgpHalCB.gFreqCB.freqDetected == FALSE && (gHpgpHalCB.devMode == DEV_MODE_STA))
                              {
                                sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
                        
                                  pFrmCtrlBlk = (sFrmCtrlBlk*) (rxBcnByteArr + sizeof(sHybriiRxBcnHdr)) ;
                        
                                  FREQDET_DetectFrequencyUsingBcn(pFrmCtrlBlk->snid);
                              }
              #endif
                      }
                      else
                      {
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 19  

                         gHpgpHalCB.halStats.RxErrBcnCnt++;
                         gHpgpHalCB.halStats.macRxStuckCnt++;  //[YM] It is not a right way to add macRxStuck count here
             -. 
                      }
                      // Call BeaconProcess function
                      if(pRxBcnHdr->fccsCorrect)
                      {
                          if(0 == eth_plc_sniffer)
                          {
                              HHAL_ProcBcnLow(rxBcnByteArr + bcnDataOffset * 4);
                          }
                      }
              #ifdef HYBRII_ETH
                      if(1 == eth_plc_sniffer)
                      {
                          EHT_FromPlcBcnTx((rxBcnByteArr + sizeof(sHybriiRxBcnHdr)), 
                                               (PLC_BCNRX_LEN-sizeof(sHybriiRxBcnHdr)));
                      }
              #endif
                      // Any more beacons ?
                      plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  } while (plcStatus.s.plcBcnCnt);
              }
              
              void HAL_SetCsmaRegions(uCSMARegionReg* regionArr)
              {
                  uCSMARegionReg   *pCSMARgn;
                  u8 i = 0;
              
                  pCSMARgn = regionArr;
                  
              
                  while(i < HYBRII_MAXSMAREGION_CNT)
                  {
                      switch(i)
                      {
                          case 0:
                              
                              WriteU32Reg(PLC_CSMAREGION0_REG, (pCSMARgn->reg));
                              
                          break;
                      
                          case 1:
                           WriteU32Reg(PLC_CSMAREGION1_REG, (pCSMARgn->reg));
                               //printf("\n ET2_low = %bu",  pCSMARgn->s.csma_endtime_lo);
                               //printf("\n ET2_h = %bu",  pCSMARgn->s.csma_endtime_hi);
                          break;
              
                          case 2:
                               WriteU32Reg(PLC_CSMAREGION2_REG, (pCSMARgn->reg));
                          break;
              
                          case 3:
                               WriteU32Reg(PLC_CSMAREGION3_REG, (pCSMARgn->reg));
                          break;
              
                          case 4:
                               WriteU32Reg(PLC_CSMAREGION4_REG, (pCSMARgn->reg));
                          break;
              
                          case 5:
                           WriteU32Reg(PLC_CSMAREGION5_REG, (pCSMARgn->reg));
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 20  

                          break;
                      }
                      i++;
                      pCSMARgn++;
                  }
              }
              
              void process_region(u8 *dataptr)
              {
              //  sBEntry     *   pEntry;
                  sRegion  *pRgn;
                  uCSMARegionReg   *pCSMARgn;
                  u8      i, rgn_num;
              //    u32     new_csma;
                  u16     start_time;
                  u8      update = 0;
                  sRegions    *pRgns;
              
              //  pEntry = (sBEntry  *)dataptr;
              //  rgn_num = pEntry->entry.region.nr;
              //  pRgn = pEntry->entry.region.regn;
                  pRgns = (sRegions *)dataptr;
                  rgn_num = pRgns->nr;
                  pRgn = pRgns->regn;
              
              //printf("rgns : %bd\n", rgn_num);
                  memset(&csmaRegArr[0], 0, sizeof(csmaRegArr));
                  pCSMARgn = &csmaRegArr[0];
              
                  start_time = 0;
                if (rgn_num > HYBRII_MAXSMAREGION_CNT)
                  rgn_num = HYBRII_MAXSMAREGION_CNT;
              
                  for (i=0; i < rgn_num; i++, pRgn++, pCSMARgn++)
                  {
                  // only set CSMA regions if they're different than previous values
                  if (pRgn->reg16 != prevCsmaRgns[i])
                  {
                        update = 1;
              //      printf("update CSMA regions: pRgn->reg16=0x%x, prevCsmaRgns[%bu]=0x%x, rgn_num=%bu\n",pRgn->reg16, i,
             - prevCsmaRgns[i],rgn_num);
                    prevCsmaRgns[i] = pRgn->reg16;
              
                      pRgn->reg16 = rtocs(pRgn->reg16);
              
                        pCSMARgn->s.csma_start_time_lo = 0; //start_time;
                        pCSMARgn->s.csma_start_time_hi = 0;
                        if(pRgn->s.region_type == REGION_TYPE_STAYOUT)
                            pCSMARgn->s.csma_rxOnly = 1;    //stayout region is rx only region
                        //pCSMARgn->s.bcnRegion = 0; //pRgn->s.region_type;
                        pCSMARgn->s.csma_hybrid = 1;
                        pCSMARgn->s.csma_endtime_lo = pRgn->s.region_end_time & 0x00FF;
                        pCSMARgn->s.csma_endtime_hi = ((pRgn->s.region_end_time & 0xFF00) >> 8);
                        //printf("type:%X\n", pRgn->s.region_type);
                        // printf("endHi: %bx\n", pCSMARgn->s.csma_endtime_hi);
                        // printf("endLo: %bx\n", pCSMARgn->s.csma_endtime_lo);
                        start_time = pRgn->s.region_end_time;
                  }
              //    else printf(" no update CSMA region %bu\n", i);
                  }
              
                  if (update != 0)
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 21  

                  {
                      /*for (i=rgn_num; i < HYBRII_MAXSMAREGION_CNT; i++, pCSMARgn++)
                      {
                          pCSMARgn->reg = 0;  
                      } */
              
                    //  printf(" \n ET0_low = %bu", csmaRegArr[0].s.csma_endtime_lo);
                     //  printf(" \n ET0_hi = %bu", csmaRegArr[0].s.csma_endtime_hi);
                     //   printf(" \n ET1_low = %bu", csmaRegArr[1].s.csma_endtime_lo);
                      // printf(" \n ET1_hi = %bu", csmaRegArr[1].s.csma_endtime_hi);
                      
              
                      HAL_SetCsmaRegions(csmaRegArr);
                  }
              }
              
              #ifdef ASSOC_TEST
              extern u8 gCCoMacAddr;
              #endif
              void HHAL_ProcBcnLow(u8* bcn)
              {
                  sHybriiRxBcnHdr* pRxBcnHdr;
                  sFrmCtrlBlk*     pFrmCtrlBlk;
                  sHybriiRxBcn*    rxBcn;      
                  sBcnHdr*         pBcnHdr = 0;
                  sBeHdr*          pBeHdr = 0;
                  u8               hm; 
                  u8               reqDiscList = 0;
                  u8               nbe = 0;
                  u8*              dataptr = 0;
                  u8*              macAddr = 0;   
                  u32              bts;
              
                  rxBcn       = (sHybriiRxBcn*)bcn;
                  pRxBcnHdr   = (sHybriiRxBcnHdr*)bcn; 
                  pFrmCtrlBlk = (sFrmCtrlBlk*) (bcn + sizeof(sHybriiRxBcnHdr)) ;
                  pBcnHdr     = (sBcnHdr*) ((u8*)pFrmCtrlBlk + sizeof(sFrmCtrlBlk)); 
                  hm          = (pBcnHdr->nid[NID_LEN-1])&0xC0;
                  //pBcnHdr->nid[NID_LEN-1] &= 0x3F;
                  //pBcnHdr->nid[NID_LEN-1] &= 0xFC;                          
                  nbe         = pBcnHdr->nbe;
                  dataptr     = (u8*)pBcnHdr + sizeof(sBcnHdr);
                  pBeHdr      = (sBeHdr*) dataptr;
              
                  bts  =  ((u32)(pFrmCtrlBlk->bts[3])<<24) + ((u32)(pFrmCtrlBlk->bts[2])<<16) + ((u32)(pFrmCtrlBlk->bts[
             -1])<<8) + (u32)(pFrmCtrlBlk->bts[0]); 
                  memcpy(gHpgpHalCB.nid, pBcnHdr->nid, NID_LEN);
              
                  gHpgpHalCB.nid[NID_LEN-1]  &= NID_EXTRA_BIT_MASK;
                  // Extract Bto, deduce AC mode Cco's Bcn Period Len and write SWBcnPeriodAvg register.
              
                 // HHAL_AdjustNextBcnTime(&pFrmCtrlBlk->bto[0]);
                 /* if (gHpgpHalCB.lineMode == LINE_MODE_AC)
                  {   
                     
                      if(gHpgpHalCB.devMode == DEV_MODE_STA)
                      {
                          WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(PLC_AC_BP_LEN));//33.31
                          //WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(0xCB5E8));
                          
                      }
                  }*/
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 22  

                 
              
                  // Process Low MAC relevant BENTRYs
                  if(gHpgpHalCB.devMode == DEV_MODE_STA &&  pRxBcnHdr->pbcsCorrect  && pRxBcnHdr->valid)
                  {
                      while(nbe)
                      { 
                          dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
                          switch (pBeHdr->beType)
                          {
                              case BEHDR_MAC_ADDR:
                              {
                                  macAddr = dataptr;
              #ifdef ASSOC_TEST
                                  memcpy ((u8*)&gCCoMacAddr, macAddr, 6);
              #endif
                                  break;
                              }
                              case BEHDR_BPSTO:
                              {        
                                  
                                   gsnid = pFrmCtrlBlk->snid;
                                    
                                  if( ((pBcnHdr->bt == BEACON_TYPE_CENTRAL) || (pBcnHdr->bt == BEACON_TYPE_PROXY))   &&
                                        (pFrmCtrlBlk->snid == gHpgpHalCB.snid) && gHpgpHalCB.nwSelected )              
                                   {
                                      gHpgpHalCB.snapShot = pRxBcnHdr->snapShot;
                                      gHpgpHalCB.bcnDetectFlag = 1;
                                      HHAL_SyncNet(dataptr);
                                   }
                                  break;
                              }
                              case BEHDR_REGIONS:
                                  process_region(dataptr); // WAR: Need to revisit code, deactivated to reduce loss in l
             -ower mac
                                  break;
              
                              default:
                              {
                                  break;
                              }
                          }
                          //move to the next BEHDR
                          dataptr = dataptr + pBeHdr->beLen; 
                          pBeHdr = (sBeHdr*) dataptr;
                          nbe--;
                      }
                      HHT_ProcessBcnHle(bcn);
                  }
               
              }
              
              
              void HHAL_BcnRxTimeoutIntHandler()
              {
              //     uPlcLineControlReg plcLineCtrl;
              
              
                
              
                 
                 /* if(gtimer2 > gsyncTimeout)  //if time is greate then 40 ms
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 23  

                  {
                      
                      //gflag = 0;
                     // printf("\n miss");
                      misscnt++;
                   
                      gbpst1 += gBcnPer; 
                      gtimer2 = 1;
                      WriteU32Reg(PLC_BPST_REG,ctorl(gbpst1)); 
                   }*/
                  /* misscnt++;
              
                   if(misscnt > 6)   //go for rescan
                   {
                      
                      if(gHpgpHalCB.lineMode == LINE_MODE_DC )
                          WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8F430000));
                      else 
                          WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8CB60000));
                      
                      gHpgpHalCB.scanEnb           = 0;
                      HHAL_SetSWStatReqScanFlag(REG_FLAG_SET); //afetr this when we receive next bcn snid will be set an
             -d nw sel will be set
                      gtimer2 = 0;
                      misscnt =0;
                      gHpgpHalCB.devMode = DEV_MODE_STA;
                      HHAL_SetDevMode(gHpgpHalCB.devMode, gHpgpHalCB.lineMode); 
                      HHAL_SetDefAddrConfig();
                      printf("\n Rescan");
                   }   */
                   /*if(gtimer1 > gBcnMissingRescanCnt)
                   {
                      if(gHpgpHalCB.lineMode == LINE_MODE_DC )
                          WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8F430000));
                      else 
                          WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8CB60000));
                      
                      gHpgpHalCB.scanEnb           = 0;
                      HHAL_SetSWStatReqScanFlag(REG_FLAG_SET); //afetr this when we receive next bcn snid will be set an
             -d nw sel will be set
                      gtimer2 = 0;
                      gtimer1 = 0;
                      gHpgpHalCB.devMode = DEV_MODE_STA;
                      HHAL_SetDevMode(gHpgpHalCB.devMode, gHpgpHalCB.lineMode); 
                      HHAL_SetDefAddrConfig();
                      printf("\n rescan");
                      
                   }*/ 
              
                  //if((gHalCB.timerIntCnt >= gHpgpHalCB.lastBcnRxTime + 13) && (gflag ==1)) //13 *4 = 52ms
                 /* if((gHalCB.timerIntCnt >= gHpgpHalCB.lastBcnRxTime + 12) && (gflag ==1)) //13 *4 = 52ms
                  {
                     
                      gflag = 0;
                      //if(gtimer2 > 10)   //we miss bcn
                      if(gtimer2 > 9)   //we miss bcn
                      {
                         gHpgpHalCB.lastBcnRxTime = (gHalCB.timerIntCnt - 4); 
                         gflag = 1; 
                         //gtimer2 = 0;
                          printf("\n miss");
                           if(gHpgpHalCB.lineMode == LINE_MODE_DC)
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 24  

                       gbpst1 += PLC_DC_BP_LEN;
                       else
                        gbpst1 += PLC_AC_BP_LEN;
              
                     WriteU32Reg(PLC_BPST_REG,ctorl(gbpst1)); 
                      }
                     
                  } */
              
              }    
              
              /*
              void HHAL_BPIntHandler()
              {
                  uPlcMedStatReg  plcMedStat;   
                  uPlcStatusReg   plcStatus;
                  static u32 prevBPInt_TimerCnt;
                  static u32 curBPInt_TimerCnt;
                  static u8  bpInit;
              
                  // Determine time gap between 2  consecutive HPGP BP interrupts.
                  if( gHpgpHalCB.halStats.bpIntCnt )
                  {
                        bpInit = 1;
                  } 
                  if( bpInit )
                  {
                      prevBPInt_TimerCnt = curBPInt_TimerCnt;
                  }
                  curBPInt_TimerCnt   = gHalCB.timerIntCnt;
                  gHpgpHalCB.bpIntGap = curBPInt_TimerCnt - prevBPInt_TimerCnt;
                  gHpgpHalCB.halStats.bpIntCnt++;
              
                  // Compute running average of prev 64 ZeroCrossing periods
                  // and write to Bcn Period Average register.
                  if( gHpgpHalCB.devMode == DEV_MODE_CCO && gHpgpHalCB.lineMode == LINE_MODE_AC )
                  {
                      //printf("HW Bcn PER = %lx\n",rtocl(ReadU32Reg(PLC_HWBCNPERLEN_REG)));
                      gHpgpHalCB.curBcnPer = rtocl(ReadU32Reg(PLC_HWBCNPERCUR_REG));
                      if( gHpgpHalCB.curBcnPer < PLC_MIN_AC_BPLEN )
                      {
                          gHpgpHalCB.curBcnPer = PLC_MIN_AC_BPLEN;
                      }
                      else if( gHpgpHalCB.curBcnPer > PLC_MAX_AC_BPLEN )
                      {
                          gHpgpHalCB.curBcnPer = PLC_MAX_AC_BPLEN;
                      }
              
                      gHpgpHalCB.bcnPerSum += gHpgpHalCB.curBcnPer;
                      gHpgpHalCB.perSumCnt ++;
              
                      if( gHpgpHalCB.perSumCnt >= PLC_BCNPERAVG_CNT )
                      {
                          gHpgpHalCB.bPerAvgInitDone = 1;
                      }
                      if( gHpgpHalCB.bPerAvgInitDone )
                      {
                          gHpgpHalCB.curBcnPer       = gHpgpHalCB.bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
                          gHpgpHalCB.bcnPerSum      -= gHpgpHalCB.curBcnPer;
                      }
                      WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
                      //WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(0xCB735));
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 25  

                      //printf("SW Bcn PER = %lx\n",gHpgpHalCB.curBcnPer);
                  }
              
                  // Prepare and send beacon here for now.
                  // This will eventually be done by hpgp nsm module.
                  HHT_BPIntHandler();
              
                  // PHY Active Hang workaround
                  plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                  plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
                  if( plcMedStat.s.phyActive && plcMedStat.s.mpiRxEn )
                  {
                      if(gHpgpHalCB.halStats.paRxEnHiCnt > PLC_RXPHYACT_HANG_THRES )
                      {
              #ifdef _RX_RECOVERY_                        
                          plcStatus.s.nRxEn = 1;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                          CHAL_DelayTicks(5);
                          
                          plcStatus.s.plcRxEnSwCtrl  = 0;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                          plcStatus.s.plcRxEnSwCtrl  = 1;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg); 
              #endif             
                          gHpgpHalCB.halStats.paRxEnHiCnt = 0;   
                          gHpgpHalCB.halStats.phyActHangRstCnt++;                    
                      }
                      else if( gHpgpHalCB.halStats.prevBPTotalRxCnt == gHpgpHalCB.halStats.TotalRxGoodFrmCnt )
                      {
                          gHpgpHalCB.halStats.paRxEnHiCnt ++;
                      } 
                      else
                      {
                          gHpgpHalCB.halStats.paRxEnHiCnt = 0;  
                      }                
                  }
                  gHpgpHalCB.halStats.prevBPTotalRxCnt = gHpgpHalCB.halStats.TotalRxGoodFrmCnt;  
              }
              */
              #else  /* HPGP_HAL_TEST */
1491          
1492          u8 HHAL_IsSnidMatched (sHaLayer *hal, uRxCpDesc *rxCpDesc)
1493          {
1494   1          u8  snid;
1495   1          snid = rxCpDesc->plc.snidHi;
1496   1          snid = (snid << PKTQDESC1_SNIDHI_POS) | rxCpDesc->plc.snidLo;
1497   1          return (snid == hal->hhalCb->snid);
1498   1      }
1499          
1500          #if 0
              eStatus HHAL_ProcRxFrameDesc(sHaLayer *hal, 
                                         uRxFrmHwDesc *rxFrmHwDesc, 
                                         sRxFrmSwDesc *rxFrmSwDesc)
              {
                  uPlcRssiLqiReg   rssiLqi;
                  u8               stei;
              
                  /*  LQI and RSSI */
                  rssiLqi.reg = ReadU32Reg(PLC_RSSILQI_REG);
                  rxFrmSwDesc->frmInfo.plc.rssi = rssiLqi.s.rssi;
                  rxFrmSwDesc->frmInfo.plc.lqi = rssiLqi.s.lqi;
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 26  

              
                  /*  multicast and unicast */
                  if(rxFrmHwDesc->plc.bcst)
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
                  }
                  else if(rxFrmHwDesc->plc.mcst)
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                  }
                  else
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
                  }
              
                  /* source TEI */
                  stei = rxFrmHwDesc->plc.steiHi2;
                  stei = (stei << PKTQDESC1_STEIHI_POS ) | rxFrmHwDesc->plc.steiLo6;
                  rxFrmSwDesc->frmInfo.plc.stei = stei;
              
                  /* CLST */
                  rxFrmSwDesc->frmInfo.plc.clst = rxFrmHwDesc->plc.clst;
                  return STATUS_SUCCESS;
              
              }
              
              #endif
1539          
1540          
1541          
1542          #endif /* HPGP_HAL_TEST */
1543          
1544          
1545          
1546          void HAL_beaconRxHandler(void *cookie)
1547           {
1548   1       
1549   1      #ifndef HPGP_HAL_TEST
1550   1        sHaLayer         *hal = (sHaLayer *)cookie;
1551   1        sHpgpHalCB       *hhalCb = hal->hhalCb;
1552   1          sEvent        xdata   *event = NULL;
1553   1          sHpgpHdr         *hpgpHdr = NULL;
1554   1      #else //#ifndef HPGP_HAL_TEST
                  // 5 DWORD of Ether II header
                sHpgpHalCB       *hhalCb = &gHpgpHalCB;                              // and hostHdr_t
              #endif // #ifndef HPGP_HAL_TEST
1558   1          sBcnHdr        *bcnHdr = NULL;
1559   1        u32 xdata    rxBcnWordArr[(PLC_BCNRX_LEN>>2) + 5];
1560   1        sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
1561   1      
1562   1        u32              *prxBcnWordArr = NULL;
1563   1        u8*              rxBcnByteArr;
1564   1        u8               i, u8val;
1565   1        u32        bts;
1566   1        u8               bcnDataOffset;
1567   1        sHybriiRxBcnHdr* pRxBcnHdr;
1568   1          
1569   1          uPlcStatusReg    plcStatus;
1570   1        
1571   1        if(1 == eth_plc_sniffer)
1572   1        {
1573   2          bcnDataOffset = (sizeof(hostHdr_t) + sizeof(sEth2Hdr));
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 27  

1574   2        }
1575   1        else
1576   1        {
1577   2          bcnDataOffset = 0;
1578   2        }
1579   1      
1580   1        // use R/W byte operation so we don't set plcTxQRdy here
1581   1        EA = 0;
1582   1        plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1583   1        EA = 1;
1584   1          // Confirm that Bcn Rx Fifo is not emplty.  //[YM] We should check the BcnCnt to make sure there is a 
             -valid beacon in RxFifo
1585   1          while (plcStatus.s.plcBcnCnt)
1586   1        {
1587   2              if(eth_plc_sniffer == 1)
1588   2              {
1589   3                  // Size for (Ethernet header  + Hybri header) added
1590   3                  //event = EVENT_Alloc(BEACON_LEN + (sizeof(sEth2Hdr) + sizeof(hostHdr_t)+4), sizeof(sHpgpHdr))
             -;
1591   3                  rxBcnByteArr  = (u8*)(rxBcnWordArr);
1592   3              }
1593   2              else
1594   2              {
1595   3              
1596   3      #ifndef HPGP_HAL_TEST
1597   3          
1598   3                  event = EVENT_BcnAlloc(BEACON_LEN, sizeof(sHpgpHdr));
1599   3            if (event == NULL)
1600   3                  {
1601   4              #ifndef RELEASE
1602   4                      FM_Printf(FM_ERROR, "BErr\n");
1603   4              #endif
1604   4                      return;
1605   4                  }
1606   3            
1607   3          
1608   3                  event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1609   3                  event->eventHdr.type = EVENT_TYPE_CC_BCN_IND;
1610   3                  
1611   3                  rxBcnByteArr = event->buffDesc.dataptr;
1612   3                  
1613   3                  event->buffDesc.datalen = BEACON_LEN;
1614   3      #else
                          rxBcnByteArr  = (u8*)(rxBcnWordArr);
                  
              #endif
1618   3          
1619   3              }
1620   2              
1621   2              prxBcnWordArr =  (u32*)((u8*)rxBcnByteArr + bcnDataOffset);
1622   2              
1623   2              hhalCb->halStats.smRxStuckCnt = 0;
1624   2          // Read from fifo to local memory.
1625   2          EA = 0;
1626   2          for( i=0 ; i<(PLC_BCNRX_LEN>>2) ; i++)
1627   2          {   
1628   3            prxBcnWordArr[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);       
1629   3          }
1630   2              EA = 1;
1631   2              bcnHdr = (sBcnHdr *) (rxBcnByteArr + (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr)));
1632   2          hhalCb->halStats.BcnRxIntCnt++;            
1633   2      
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 28  

1634   2          pRxBcnHdr = (sHybriiRxBcnHdr*)&prxBcnWordArr[0];
1635   2      
1636   2          hhalCb->snapShot = pRxBcnHdr->snapShot;
1637   2          
1638   2          // use R/W byte operation so we don't set plcTxQRdy here
1639   2          EA = 0;
1640   2          u8val = ReadU8Reg(PLC_STATUS_REG+1);
1641   2          u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
1642   2          WriteU8Reg(PLC_STATUS_REG+1, u8val);
1643   2              
1644   2              EA = 1;
1645   2      
1646   2          if(1 == eth_plc_sniffer)
1647   2          {
1648   3          
1649   3          
1650   3      #ifdef HYBRII_ETH        
                    EHT_FromPlcBcnTx((rxBcnByteArr + sizeof(sHybriiRxBcnHdr)), 
                             (PLC_BCNRX_LEN-sizeof(sHybriiRxBcnHdr)));
              #endif
1654   3            return;
1655   3      
1656   3          }
1657   2      
1658   2      #ifdef BCN_ERR
1659   2          if ((!(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect)) ||
1660   2              ((bcnHdr->stei == 0) || (bcnHdr->bt >= 3))) //(bcnHdr->nbe > 4) || 
1661   2            {
1662   3              gHpgpHalCB.halStats.RxErrBcnCnt++;
1663   3              gHpgpHalCB.halStats.macRxStuckCnt++;  //[YM] It is not a right way to add macRxStuck count here. 
1664   3      
1665   3      #ifndef HPGP_HAL_TEST
1666   3              //FM_HexDump(FM_ERROR,"BCN Rx Issue PBCS\n",(u8*)&bcnHdr,sizeof(sBcnHdr));
1667   3              EVENT_Free(event);
1668   3      
1669   3      #endif
1670   3              return;
1671   3          
1672   3            }
1673   2              
1674   2      #endif
1675   2      
1676   2      
1677   2          // Update statistics.  //[YM] why check rsv1,2,3,4 bit fields??
1678   2          //if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && !pRxBcn
             -Hdr->rsv3 && !pRxBcnHdr->rsv4)  
1679   2          if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect)
1680   2          {             
1681   3            gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
1682   3            gHpgpHalCB.halStats.RxGoodBcnCnt++;
1683   3            gHpgpHalCB.halStats.macRxStuckCnt = 0; 
1684   3       #ifdef FREQ_DETECT
1685   3                      if((gHpgpHalCB.gFreqCB.freqDetected == FALSE) &&  ((gHpgpHalCB.devMode == DEV_MODE_STA)
1686   3      #ifdef MCCO
1687   3                ||(gHpgpHalCB.devMode == DEV_MODE_PCCO)
1688   3      #endif
1689   3                  ))
1690   3                      {
1691   4                        pFrmCtrlBlk = (sFrmCtrlBlk*) (rxBcnByteArr + sizeof(sHybriiRxBcnHdr)) ;
1692   4                          FREQDET_DetectFrequencyUsingBcn(pFrmCtrlBlk->snid);// Kiran disabled to debug 60HZ at 
             -STA
1693   4      //                    printf("\n using bcn \n");
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 29  

1694   4                      }
1695   3      #endif
1696   3      
1697   3          }
1698   2      
1699   2      
1700   2          pFrmCtrlBlk = (sFrmCtrlBlk*) (rxBcnByteArr + sizeof(sHybriiRxBcnHdr)) ;
1701   2          
1702   2          bts  =  ((u32)(pFrmCtrlBlk->bts[3])<<24) +
1703   2              ((u32)(pFrmCtrlBlk->bts[2])<<16) + 
1704   2              ((u32)(pFrmCtrlBlk->bts[1])<<8) + 
1705   2               (u32)(pFrmCtrlBlk->bts[0]);
1706   2      
1707   2      #ifdef PSDEBUG
                          if (psDebug2)
                          {
              //              if (staInfo->staScb->bpCnt && !(staInfo->staScb->bpCnt % staInfo->staScb->commAwd.numBp))
                              printf("RX a beacon at NTB=%lu\n", (rtocl(ReadU32Reg(PLC_NTB_REG))*40)/1000000);
                          }
              #endif    
1714   2      #ifdef ROUTE_TEST
              
                      for(i=0; i < 3; i++)
                      {
                          if(bcnHdr->stei == dropTei[i])
                          {
              #ifndef HPGP_HAL_TEST                
                              EVENT_Free(event);                
              #endif
                              return;
                          }
                      }
                  
              #endif
1728   2      
1729   2      #ifdef HPGP_HAL_TEST
                  
                      HHAL_ProcBcnLow(rxBcnByteArr);
              #else
1733   2      
1734   2          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1735   2          hpgpHdr->snid = pFrmCtrlBlk->snid;
1736   2      
1737   2          event->buffDesc.dataptr += (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr));
1738   2          event->buffDesc.datalen -= (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr)); 
1739   2      #ifdef BCN_ERR
1740   2          bpstoFound = FALSE;
1741   2      #endif
1742   2          if ((hhalCb->devMode == DEV_MODE_CCO) && (dropFlag == 0))
1743   2          {
1744   3      #ifdef CCO_FUNC
1745   3            //LINKL_CcoProcBcnHandler(hal->bcnCookie, event, bts);
1746   3            sLinkLayer     *linkl = (sLinkLayer *)hal->bcnCookie;
1747   3              sCnsm     *cnsm = (sCnsm *)LINKL_GetCnsm(linkl);
1748   3              CNSM_ProcBcnHigh(cnsm, event->buffDesc.dataptr, bts);
1749   3      #endif
1750   3          }
1751   2      #ifdef MCCO   
1752   2          else 
1753   2          if (hhalCb->devMode == DEV_MODE_PCCO)
1754   2          {
1755   3              LINKL_PassiveCcoProcBcnHandler(hal->bcnCookie, event, bts);
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 30  

1756   3          }
1757   2      #endif    
1758   2          else if(dropFlag == 0)
1759   2          {
1760   3      #ifdef STA_FUNC
1761   3          //LINKL_StaProcBcnHandler(hal->bcnCookie, event, bts);
1762   3            { 
1763   4              sLinkLayer     *linkl = (sLinkLayer *)hal->bcnCookie;
1764   4                sSnsm*         snsm = (sSnsm *)LINKL_GetSnsm(linkl);
1765   4              SNSM_BcnCheck(event->buffDesc.dataptr);
1766   4      #ifdef BCN_ERR
1767   4              if(bpstoFound == TRUE)
1768   4      #endif
1769   4              {
1770   5                  SNSM_ProcBcnHigh(snsm, event->buffDesc.dataptr, hpgpHdr->snid, bts);
1771   5      
1772   5                  if(snsm->txDiscBcn)
1773   5                  {
1774   6                      //SNSM_TransmitDiscBcn(snsm);
1775   6                  
1776   6                    sTxDesc         txinfo;
1777   6                    sBuffDesc       buffDesc;
1778   6                    u8              offset = 0; 
1779   6      
1780   6      //              FM_Printf(FM_HINFO, "SNSM:>>DISC BCN\n");
1781   6      
1782   6      #ifdef SIMU
                            offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
1785   6                    offset = sizeof(sFrmCtrlBlk);
1786   6      #endif
1787   6      
1788   6                    //transmit the beacon 
1789   6                    txinfo.dtei = 0xFF;
1790   6                    txinfo.stei = snsm->staInfo->staScb->tei;
1791   6                    txinfo.frameType = BEACON_TYPE_DISCOVER;
1792   6                    txinfo.snid = snsm->staInfo->snid;
1793   6                  
1794   6                    //prepare tx control information
1795   6                    buffDesc.buff = snsm->discBcnBuff;
1796   6                    buffDesc.bufflen = BEACON_BUFF_LEN;
1797   6                    buffDesc.dataptr = snsm->discBcnBuff + offset;
1798   6                    buffDesc.datalen = BEACON_PAYLOAD_SIZE;
1799   6      
1800   6                    //FM_HexDump(FM_DATA|FM_MINFO, "SNSM: discovery beacon:", 
1801   6                    //                             buffDesc.dataptr,
1802   6                    //                             buffDesc.datalen);
1803   6      
1804   6                    //HAL_TransmitBeacon(HOMEPLUG_GetHal(), &txinfo, &buffDesc, snsm->bpstoOffset);
1805   6                    HAL_TransmitBeacon(&HomePlug.haLayer, &txinfo, &buffDesc, snsm->bpstoOffset);
1806   6                    
1807   6                      snsm->txDiscBcn = FALSE;
1808   6                  }
1809   5      
1810   5              }
1811   4      #ifdef BCN_ERR
1812   4              else
1813   4              {
1814   5                //FM_Printf(FM_ERROR,"\nBL2\n");
1815   5              }
1816   4      #endif        
1817   4            }
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 31  

1818   3      #endif
1819   3          }
1820   2      #ifdef BCN_ERR
1821   2              if(bpstoFound == TRUE && dropFlag == 0)
1822   2      #endif
1823   2              {
1824   3              //MUXL_RecvMgmtPacket(hal->mgmtCookie, event);
1825   3            {
1826   4                sMuxLayer *muxl = (sMuxLayer *)hal->mgmtCookie;
1827   4                /* check beacon */
1828   4                if ((event->eventHdr.eventClass == EVENT_CLASS_CTRL)&&
1829   4                    (event->eventHdr.type == EVENT_TYPE_CC_BCN_IND))
1830   4                {
1831   5      #ifdef MUX_PRINT    
                            FM_Printf(FM_MUX, "MUX: deliver a beacon\n");
              #endif
1834   5      #ifdef CALLBACK
                            muxl->mux.deliverMgmtMsg(muxl->mux.mgmtcookie, event); 
              #else
1837   5                    //LINKL_RecvMgmtMsg(muxl->mux.mgmtcookie, event);
1838   5                {
1839   6                    sLinkLayer *linkl = (sLinkLayer *)muxl->mux.mgmtcookie;
1840   6      
1841   6      #ifdef P8051
1842   6      __CRIT_SECTION_BEGIN__
1843   6      #else
                            SEM_WAIT(&linkl->linkSem);
              #endif
1846   6      
1847   6                    //place the event to the queue
1848   6                    SLIST_Put(&linkl->eventQueue, &event->link);
1849   6      
1850   6      #ifdef P8051
1851   6      __CRIT_SECTION_END__
1852   6      #else
                            SEM_POST(&linkl->linkSem);
              #endif
1855   6                    /* schedule the task */
1856   6      #ifndef RTX51_TINY_OS
                            SCHED_Sched(&linkl->task);
              #else
1859   6                  os_set_ready(HPGP_TASK_ID_CTRL);
1860   6      #endif
1861   6                }
1862   5      #endif
1863   5            
1864   5                }
1865   4                else if (event->eventHdr.eventClass == EVENT_CLASS_MSG)
1866   4                {
1867   5                MUX_Proc(&muxl->mux, event);
1868   5                
1869   5                }
1870   4            }
1871   3              }
1872   2      #ifdef BCN_ERR
1873   2              else
1874   2              {
1875   3          //  FM_HexDump(FM_ERROR,"BCN Rx Issue BPSTO\n",(u8*)&bcnHdr,sizeof(sBcnHdr));
1876   3                //  FM_Printf(FM_ERROR, "BL1\n");
1877   3                  EVENT_Free(event);
1878   3              }
1879   2      #endif
C51 COMPILER V9.53.0.0   HAL_HPGPRX                                                        11/04/2015 20:09:45 PAGE 32  

1880   2      
1881   2      
1882   2      #endif
1883   2      
1884   2          
1885   2      
1886   2          EA = 0;
1887   2          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1888   2          EA = 1;
1889   2        }
1890   1      
1891   1      }
1892          
1893          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4519    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =     65     376
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
