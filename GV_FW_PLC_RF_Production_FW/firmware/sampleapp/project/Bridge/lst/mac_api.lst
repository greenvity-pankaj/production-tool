C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_API
OBJECT MODULE PLACED IN .\obj\mac_api.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_api.c LARGE OBJECTADVANCED OPTIMIZE(9,SI
                    -ZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..
                    -\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;
                    -..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmw
                    -are\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;.
                    -.\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;.
                    -.\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;
                    -..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\
                    -..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hp
                    -gp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..
                    -\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\com
                    -ponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\fl
                    -ash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;.
                    -.\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\
                    -inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..
                    -\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_80
                    -51,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM
                    -,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT
                    -,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,M
                    -CCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIST
                    -ER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_api.lst) TABS(2) OBJ
                    -ECT(.\obj\mac_api.obj)

line level    source

   1          /**
   2           * @file mac_api.c
   3           *
   4           * This file contains MAC API functions.
   5           *
   6           * $Id: mac_api.c,v 1.4 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          
  12          /* === Includes ============================================================ */
  13          #ifdef HYBRII_802154
  14          #ifdef RTX51_TINY_OS
  15          #include <rtx51tny.h>
  16          #include "hybrii_tasks.h"
  17          #endif
  18          #include <stdio.h>
  19          #include <string.h>
  20          #include "papdef.h"
  21          #include "timer.h"
  22          #include "return_val.h"
  23          #include "bmm.h"
  24          #include "qmm.h"
  25          #include "mac_const.h"
  26          #include "mac_msgs.h"
  27          #include "mac_data_structures.h"
  28          #include "mac_hal.h"
  29          #include "mac_internal.h"
  30          #include "mac.h"
  31          #include "fm.h"
  32          
  33          /* === Types =============================================================== */
  34          
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 2   

  35          
  36          /* === Macros ============================================================== */
  37          
  38          
  39          /* === Globals ============================================================= */
  40          
  41          
  42          /* === Prototypes ========================================================== */
  43          
  44          
  45          /* === Implementation ====================================================== */
  46          static bool mac_api_to_nhle_mac_queue (buffer_t *buffer_p)
  47          {
  48   1          if (FALSE == qmm_queue_append(&nhle_mac_q, buffer_p)) {
  49   2              bmm_buffer_free(buffer_p);
  50   2              return (false);
  51   2          } 
  52   1      #ifdef RTX51_TINY_OS
  53   1      #ifdef MAC_802154_TASK
                os_set_ready(MAC_802154_TASK_ID);
              #else
  56   1        os_set_ready(HPGP_TASK_ID_CTRL);
  57   1      #endif /* MAC_802154_TASK */
  58   1      #ifdef UM
  59   1        pending_802154_task = TRUE;
  60   1      #endif
  61   1          os_switch_task();
  62   1      #endif
  63   1          return (true);
  64   1      }
  65          
  66          /* MAC level API */
  67          
  68          bool mac_api_mcps_data_req (uint8_t SrcAddrMode,
  69                                      wpan_addr_spec_t *DstAddrSpec_p,
  70                                      uint8_t msduLength,
  71                                      uint8_t *msdu_p,
  72                                      uint8_t msduHandle,
  73                                      uint8_t TxOptions,
  74                                      security_info_t *sec_p)
  75          {
  76   1          buffer_t *buffer_p;
  77   1          mcps_data_req_t *mcps_data_req_p;
  78   1          uint8_t *payload_pos_p;
  79   1      
  80   1          if (msduLength > aMaxMACPayloadSize) {
  81   2              /* Frame is too long and thus rejected immediately */
  82   2              return false;
  83   2          }
  84   1      
  85   1          /* Allocate a buffer for mcps data request */
  86   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
  87   1      
  88   1          if (NULL == buffer_p) {
  89   2              /* Buffer is not available */
  90   2              return false;
  91   2          }
  92   1      
  93   1          /* Get the buffer body from buffer header */
  94   1          mcps_data_req_p = (mcps_data_req_t *)BMM_BUFFER_POINTER(buffer_p);
  95   1      
  96   1          /* Construct mcps_data_req_t message */
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 3   

  97   1          mcps_data_req_p->cmdcode = MCPS_DATA_REQUEST;
  98   1      
  99   1          /* Source addr mode */
 100   1          mcps_data_req_p->SrcAddrMode = SrcAddrMode;
 101   1      
 102   1          /* Destination addr spec */
 103   1          mcps_data_req_p->DstAddrMode = DstAddrSpec_p->AddrMode;
 104   1      
 105   1          mcps_data_req_p->DstPANId = DstAddrSpec_p->PANId;
 106   1      
 107   1          mcps_data_req_p->DstAddr.hi_u32 = 0;
 108   1          mcps_data_req_p->DstAddr.lo_u32 = 0;
 109   1        
 110   1          if (WPAN_ADDRMODE_SHORT == mcps_data_req_p->DstAddrMode) {
 111   2              mcps_data_req_p->DstAddr.lo_u32 = 
 112   2                                     (uint32_t)DstAddrSpec_p->Addr.short_address; 
 113   2          } else {
 114   2              mcps_data_req_p->DstAddr = DstAddrSpec_p->Addr.long_address;
 115   2          }
 116   1      
 117   1          /* Other fields */
 118   1          mcps_data_req_p->msduHandle             = msduHandle;
 119   1          mcps_data_req_p->TxOptions              = TxOptions;
 120   1          mcps_data_req_p->msduLength             = msduLength;
 121   1          if (sec_p) {
 122   2              mcps_data_req_p->Security.SecurityLevel = sec_p->SecurityLevel;
 123   2              mcps_data_req_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 124   2              mcps_data_req_p->Security.KeyIndex      = sec_p->KeyIndex;
 125   2              memcpy(mcps_data_req_p->Security.KeySource, sec_p->KeySource,
 126   2                     SEC_KEY_SRC_MAX);
 127   2          } else {
 128   2              mcps_data_req_p->Security.SecurityLevel = 0;
 129   2          }
 130   1      
 131   1          /* Find the position where the data payload is to be updated */
 132   1          payload_pos_p = ((uint8_t *)mcps_data_req_p) +
 133   1                           (BUFFER_SIZE - msduLength);
 134   1      
 135   1          /* Copy the payload to the end of buffer */
 136   1          memcpy(payload_pos_p, msdu_p, msduLength);
 137   1      
 138   1          /* Enqueue the message to MAC Q */
 139   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 140   1      }
 141          
 142          bool mac_api_mcps_purge_req (uint8_t msduHandle)
 143          {
 144   1          buffer_t *buffer_p;
 145   1          mcps_purge_req_t *mcps_purge_req_p;
 146   1      
 147   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 148   1      
 149   1          if (NULL == buffer_p) {
 150   2              /* Buffer is not available */
 151   2              return false;
 152   2          }
 153   1      
 154   1          /* Get the buffer body from buffer header */
 155   1          mcps_purge_req_p = (mcps_purge_req_t *)BMM_BUFFER_POINTER(buffer_p);
 156   1      
 157   1          /* Update the purge request structure */
 158   1          mcps_purge_req_p->cmdcode = MCPS_PURGE_REQUEST;
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 4   

 159   1          mcps_purge_req_p->msduHandle = msduHandle;
 160   1      
 161   1          /* Enqueue the message to MAC Q */
 162   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 163   1      }
 164          
 165          bool mac_api_mlme_start_req (uint16_t PANId,
 166                                       uint8_t LogicalChannel,
 167                                       uint8_t ChannelPage,
 168                                       uint32_t StartTime,
 169                                       uint8_t BeaconOrder,
 170                                       uint8_t SuperframeOrder,
 171                                       bool PANCoordinator,
 172                                       bool BatteryLifeExtension,
 173                                       bool CoordRealignment,
 174                                       security_info_t *CoordRealignmentSecurity_p,
 175                                       security_info_t *BeaconSecurity_p)
 176          {
 177   1          buffer_t *buffer_p;
 178   1          mlme_start_req_t *mlme_start_req_p;
 179   1      
 180   1          /* Allocate a buffer for start request */
 181   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 182   1      
 183   1          if (NULL == buffer_p) {
 184   2              /* Buffer is not available */
 185   2              return false;
 186   2          }
 187   1      
 188   1          /* Get the buffer body from buffer header */
 189   1          mlme_start_req_p = (mlme_start_req_t *)BMM_BUFFER_POINTER(buffer_p);
 190   1      
 191   1          /* Update the start request structure */
 192   1          mlme_start_req_p->cmdcode = MLME_START_REQUEST;
 193   1      
 194   1          mlme_start_req_p->PANId = PANId;
 195   1          mlme_start_req_p->LogicalChannel = LogicalChannel;
 196   1          mlme_start_req_p->ChannelPage = ChannelPage;
 197   1          mlme_start_req_p->StartTime = StartTime;
 198   1          mlme_start_req_p->BeaconOrder = BeaconOrder;
 199   1          mlme_start_req_p->SuperframeOrder = SuperframeOrder;
 200   1          mlme_start_req_p->PANCoordinator = PANCoordinator;
 201   1          mlme_start_req_p->BatteryLifeExtension = BatteryLifeExtension;
 202   1          mlme_start_req_p->CoordRealignment = CoordRealignment;
 203   1          mlme_start_req_p->ChannelPage = ChannelPage;
 204   1          if (CoordRealignmentSecurity_p) {
 205   2              mlme_start_req_p->CoordRealignmentSecurity.SecurityLevel =
 206   2                                            CoordRealignmentSecurity_p->SecurityLevel;
 207   2              mlme_start_req_p->CoordRealignmentSecurity.KeyIdMode =
 208   2                                            CoordRealignmentSecurity_p->KeyIdMode;
 209   2              mlme_start_req_p->CoordRealignmentSecurity.KeyIndex  =
 210   2                                            CoordRealignmentSecurity_p->KeyIndex;
 211   2              memcpy(mlme_start_req_p->CoordRealignmentSecurity.KeySource,
 212   2                     CoordRealignmentSecurity_p->KeySource, SEC_KEY_SRC_MAX);
 213   2          }
 214   1          if (BeaconSecurity_p) {
 215   2              mlme_start_req_p->BeaconSecurity.SecurityLevel =
 216   2                                            BeaconSecurity_p->SecurityLevel;
 217   2              mlme_start_req_p->BeaconSecurity.KeyIdMode =
 218   2                                            BeaconSecurity_p->KeyIdMode;
 219   2              mlme_start_req_p->BeaconSecurity.KeyIndex  =
 220   2                                            BeaconSecurity_p->KeyIndex;
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 5   

 221   2              memcpy(mlme_start_req_p->BeaconSecurity.KeySource,
 222   2                     BeaconSecurity_p->KeySource, SEC_KEY_SRC_MAX);
 223   2          } else {
 224   2              mlme_start_req_p->BeaconSecurity.SecurityLevel = 0;
 225   2          }
 226   1      
 227   1          /* Enqueue the message to MAC Q */
 228   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 229   1      }
 230          
 231          bool mac_api_mlme_associate_req (uint8_t LogicalChannel,
 232                                           uint8_t ChannelPage,
 233                                           wpan_addr_spec_t *CoordAddrSpec_p,
 234                                           uint8_t CapabilityInformation,
 235                                           security_info_t *sec_p)
 236          {
 237   1          buffer_t *buffer_p;
 238   1          mlme_associate_req_t *mlme_associate_req_p;
 239   1      
 240   1          /* Allocate a buffer for mlme associate request */
 241   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 242   1      
 243   1          /* Check for buffer availability */
 244   1          if (NULL == buffer_p) {
 245   2              return false;
 246   2          }
 247   1      
 248   1          /* Get the buffer body from buffer header */
 249   1          mlme_associate_req_p = (mlme_associate_req_t*)
 250   1                                 BMM_BUFFER_POINTER(buffer_p);
 251   1      
 252   1          /* Construct mlme_associate_req_t message */
 253   1          mlme_associate_req_p->cmdcode = MLME_ASSOCIATE_REQUEST;
 254   1      
 255   1          /* Operating channel */
 256   1          mlme_associate_req_p->LogicalChannel = LogicalChannel;
 257   1      
 258   1          /* Coordinator address spec */
 259   1          mlme_associate_req_p->CoordAddrMode = CoordAddrSpec_p->AddrMode;
 260   1          mlme_associate_req_p->CoordPANId    = CoordAddrSpec_p->PANId;
 261   1      
 262   1          mlme_associate_req_p->CoordAddress.long_address.lo_u32 = 
 263   1                                            CoordAddrSpec_p->Addr.long_address.lo_u32;
 264   1          mlme_associate_req_p->CoordAddress.long_address.hi_u32 = 
 265   1                                            CoordAddrSpec_p->Addr.long_address.hi_u32;
 266   1      
 267   1          /* Other fields */
 268   1          mlme_associate_req_p->CapabilityInformation = CapabilityInformation;
 269   1          mlme_associate_req_p->ChannelPage           = ChannelPage;
 270   1      
 271   1          if (sec_p) {
 272   2              mlme_associate_req_p->Security.SecurityLevel = sec_p->SecurityLevel;
 273   2              mlme_associate_req_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 274   2              mlme_associate_req_p->Security.KeyIndex      = sec_p->KeyIndex;
 275   2              memcpy(mlme_associate_req_p->Security.KeySource, sec_p->KeySource,
 276   2                     SEC_KEY_SRC_MAX);
 277   2          } else {
 278   2              mlme_associate_req_p->Security.SecurityLevel = 0;
 279   2          }
 280   1      
 281   1          /* Enqueue the message to MAC Q */
 282   1          return (mac_api_to_nhle_mac_queue(buffer_p));
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 6   

 283   1      }
 284          
 285          bool mac_api_mlme_associate_resp (uint64_t DeviceAddress,
 286                                       uint16_t AssocShortAddress,
 287                                       uint8_t status,
 288                                       security_info_t *sec_p)
 289          {
 290   1          buffer_t *buffer_p;
 291   1          mlme_associate_resp_t *mlme_associate_resp_p;
 292   1      
 293   1          /* Allocate a buffer for association response */
 294   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 295   1      
 296   1          if (NULL == buffer_p) {
 297   2              /* Buffer is not available */
 298   2              return false;
 299   2          }
 300   1      
 301   1          /* Get the buffer body from buffer header */
 302   1          mlme_associate_resp_p = (mlme_associate_resp_t *)
 303   1                                  BMM_BUFFER_POINTER(buffer_p);
 304   1      
 305   1          /* Construct mlme_associate_resp_t message */
 306   1          mlme_associate_resp_p->cmdcode = MLME_ASSOCIATE_RESPONSE;
 307   1      
 308   1          /* Other fields */
 309   1          mlme_associate_resp_p->DeviceAddress  = DeviceAddress;
 310   1          mlme_associate_resp_p->AssocShortAddress = AssocShortAddress;
 311   1          mlme_associate_resp_p->status = status;
 312   1          if (sec_p) {
 313   2              mlme_associate_resp_p->Security.SecurityLevel = sec_p->SecurityLevel;
 314   2              mlme_associate_resp_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 315   2              mlme_associate_resp_p->Security.KeyIndex      = sec_p->KeyIndex;
 316   2              memcpy(mlme_associate_resp_p->Security.KeySource, sec_p->KeySource,
 317   2                     SEC_KEY_SRC_MAX);
 318   2          } else {
 319   2              mlme_associate_resp_p->Security.SecurityLevel = 0;
 320   2          }
 321   1          /* Enqueue the message to MAC Q */
 322   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 323   1      }
 324          
 325          bool mac_api_mlme_disassociate_req (wpan_addr_spec_t *DeviceAddrSpec,
 326                                         uint8_t DisassociateReason,
 327                                         bool TxIndirect,
 328                                         security_info_t *sec_p)
 329          {
 330   1          buffer_t *buffer_p;
 331   1          mlme_disassociate_req_t *mlme_disassociate_req_p;
 332   1      
 333   1          /* Allocate a buffer for disassociation request */
 334   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 335   1      
 336   1          if (NULL == buffer_p) {
 337   2              /* Buffer is not available */
 338   2              return false;
 339   2          }
 340   1      
 341   1          /* Get the buffer body from buffer header */
 342   1          mlme_disassociate_req_p = (mlme_disassociate_req_t *)
 343   1                                    BMM_BUFFER_POINTER(buffer_p);
 344   1      
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 7   

 345   1          /* Update the disassociate request structure */
 346   1          mlme_disassociate_req_p->cmdcode = MLME_DISASSOCIATE_REQUEST;
 347   1          mlme_disassociate_req_p->DisassociateReason = DisassociateReason;
 348   1          mlme_disassociate_req_p->DeviceAddrMode = DeviceAddrSpec->AddrMode;
 349   1          mlme_disassociate_req_p->DevicePANId = DeviceAddrSpec->PANId;
 350   1          mlme_disassociate_req_p->DeviceAddress.long_address = 
 351   1                                                  DeviceAddrSpec->Addr.long_address;
 352   1          mlme_disassociate_req_p->TxIndirect = TxIndirect;
 353   1          if (sec_p) {
 354   2              mlme_disassociate_req_p->Security.SecurityLevel = sec_p->SecurityLevel;
 355   2              mlme_disassociate_req_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 356   2              mlme_disassociate_req_p->Security.KeyIndex      = sec_p->KeyIndex;
 357   2              memcpy(mlme_disassociate_req_p->Security.KeySource, sec_p->KeySource,
 358   2                     SEC_KEY_SRC_MAX);
 359   2          } else {
 360   2              mlme_disassociate_req_p->Security.SecurityLevel = 0;
 361   2          }
 362   1      
 363   1          /* Enqueue the message to MAC Q */
 364   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 365   1      }
 366          
 367          bool mac_api_mlme_orphan_resp (uint64_t OrphanAddress,
 368                                         uint16_t ShortAddress,
 369                                         bool AssociatedMember,
 370                                         security_info_t *sec_p)
 371          {
 372   1          buffer_t *buffer_p;
 373   1          mlme_orphan_resp_t *mlme_orphan_resp_p;
 374   1      
 375   1          /* Allocate a small buffer for orphan response */
 376   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 377   1      
 378   1          if (NULL == buffer_p) {
 379   2              /* Buffer is not available */
 380   2              return false;
 381   2          }
 382   1      
 383   1          /* Get the buffer body from buffer header */
 384   1          mlme_orphan_resp_p = (mlme_orphan_resp_t *)BMM_BUFFER_POINTER(buffer_p);
 385   1      
 386   1          /* Update the orphan response structure */
 387   1          mlme_orphan_resp_p->cmdcode = MLME_ORPHAN_RESPONSE;
 388   1          mlme_orphan_resp_p->OrphanAddress = OrphanAddress;
 389   1          mlme_orphan_resp_p->ShortAddress  = ShortAddress;
 390   1          mlme_orphan_resp_p->AssociatedMember = AssociatedMember;
 391   1          if (sec_p) {
 392   2              mlme_orphan_resp_p->Security.SecurityLevel = sec_p->SecurityLevel;
 393   2              mlme_orphan_resp_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 394   2              mlme_orphan_resp_p->Security.KeyIndex      = sec_p->KeyIndex;
 395   2              memcpy(mlme_orphan_resp_p->Security.KeySource, sec_p->KeySource,
 396   2                     SEC_KEY_SRC_MAX);
 397   2          } else {
 398   2              mlme_orphan_resp_p->Security.SecurityLevel = 0;
 399   2          }
 400   1      
 401   1          /* Enqueue the message to MAC Q */
 402   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 403   1      }
 404          
 405          bool mac_api_mlme_reset_req (bool SetDefaultPib)
 406          {
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 8   

 407   1          buffer_t *buffer_p;
 408   1          mlme_reset_req_t *mlme_reset_req_p;
 409   1      
 410   1          /* Allocate a buffer for reset request */
 411   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 412   1      
 413   1          if (NULL == buffer_p) {
 414   2              /* Buffer is not available */
 415   2              return false;
 416   2          }
 417   1      
 418   1          /* Get the buffer body from buffer header */
 419   1          mlme_reset_req_p = (mlme_reset_req_t *)BMM_BUFFER_POINTER(buffer_p);
 420   1      
 421   1          /* Update the reset request structure */
 422   1          mlme_reset_req_p->cmdcode = MLME_RESET_REQUEST;
 423   1          mlme_reset_req_p->SetDefaultPIB = SetDefaultPib;
 424   1      
 425   1          /* Enqueue the message to MAC Q */
 426   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 427   1      }
 428          
 429          bool mac_api_mlme_get_req (uint8_t PIBAttribute, uint8_t PIBAttributeIndex)
 430          {
 431   1          buffer_t *buffer_p;
 432   1          mlme_get_req_t *mlme_get_req_p;
 433   1      
 434   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 435   1      
 436   1          /* Check for buffer availability */
 437   1          if (NULL == buffer_p) {
 438   2              return false;
 439   2          }
 440   1      
 441   1          /* Get the buffer body from buffer header */
 442   1          mlme_get_req_p = (mlme_get_req_t*)BMM_BUFFER_POINTER(buffer_p);
 443   1      
 444   1          /* Update the get request structure */
 445   1          mlme_get_req_p->cmdcode = MLME_GET_REQUEST;
 446   1          mlme_get_req_p->PIBAttribute = PIBAttribute;
 447   1          mlme_get_req_p->PIBAttributeIndex = PIBAttributeIndex;
 448   1      
 449   1          /* Enqueue the message to MAC Q */
 450   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 451   1      }
 452          
 453          bool mac_api_mlme_set_req (uint8_t PIBAttribute,
 454                                     uint8_t PIBAttributeIndex,
 455                                     void *PIBAttributeValue)
 456          {
 457   1          buffer_t *buffer_p;
 458   1          mlme_set_req_t *mlme_set_req_p;
 459   1          uint8_t pib_attribute_octet_no;
 460   1      
 461   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 462   1      
 463   1          /* Check for buffer availability */
 464   1          if (NULL == buffer_p) {
 465   2              return false;
 466   2          }
 467   1      
 468   1          /* Get size of PIB attribute to be set */
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 9   

 469   1          pib_attribute_octet_no = mac_get_pib_attribute_size(PIBAttribute);
 470   1      
 471   1          /* Get the buffer body from buffer header */
 472   1          mlme_set_req_p = (mlme_set_req_t *)BMM_BUFFER_POINTER(buffer_p);
 473   1      
 474   1          /* Construct mlme_set_req_t message */
 475   1          mlme_set_req_p->cmdcode = MLME_SET_REQUEST;
 476   1      
 477   1          /* Attribute and attribute value length */
 478   1          mlme_set_req_p->PIBAttribute = PIBAttribute;
 479   1          mlme_set_req_p->PIBAttributeIndex = PIBAttributeIndex;
 480   1      
 481   1          /* Attribute value */
 482   1      
 483   1          memcpy((void *)&(mlme_set_req_p->PIBAttributeValue),
 484   1                          (void *)PIBAttributeValue,
 485   1                          (size_t)pib_attribute_octet_no);
 486   1      
 487   1          /* Enqueue the message to MAC Q */
 488   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 489   1      }
 490          
 491          bool mac_api_mlme_rx_enable_req (bool DeferPermit,
 492                                           uint32_t RxOnTime,
 493                                           uint32_t RxOnDuration)
 494          {
 495   1          buffer_t *buffer_p;
 496   1          mlme_rx_enable_req_t *mlme_rx_enable_req_p;
 497   1      
 498   1          /* Allocate a buffer for rx enable request */
 499   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 500   1      
 501   1          if (NULL == buffer_p) {
 502   2              /* Buffer is not available */
 503   2              return false;
 504   2          }
 505   1      
 506   1          /* Get the buffer body from buffer header */
 507   1          mlme_rx_enable_req_p = (mlme_rx_enable_req_t *)
 508   1                                 BMM_BUFFER_POINTER(buffer_p);
 509   1      
 510   1          /* Update the rx enable request structure */
 511   1          mlme_rx_enable_req_p->cmdcode = MLME_RX_ENABLE_REQUEST;
 512   1          mlme_rx_enable_req_p->DeferPermit = DeferPermit;
 513   1          mlme_rx_enable_req_p->RxOnTime = RxOnTime;
 514   1          mlme_rx_enable_req_p->RxOnDuration = RxOnDuration;
 515   1      
 516   1          /* Enqueue the message to MAC Q */
 517   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 518   1      }
 519          
 520          bool mac_api_mlme_scan_req (uint8_t ScanType,
 521                                      uint32_t ScanChannels,
 522                                      uint8_t ScanDuration,
 523                                      uint8_t ChannelPage,
 524                                      security_info_t *sec_p)
 525          {
 526   1          buffer_t *buffer_p;
 527   1          mlme_scan_req_t* mlme_scan_req_p;
 528   1      
 529   1          /* Allocate a buffer for scan request */
 530   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 10  

 531   1      
 532   1          if (NULL == buffer_p) {
 533   2              /* Buffer is not available */
 534   2          FM_Printf(FM_APP, "\nba:scanF");
 535   2              return false;
 536   2          }
 537   1      
 538   1          /* Get the buffer body from buffer header */
 539   1          mlme_scan_req_p = (mlme_scan_req_t*)BMM_BUFFER_POINTER(buffer_p);
 540   1      
 541   1          /* Update the scan request structure */
 542   1          mlme_scan_req_p->cmdcode = MLME_SCAN_REQUEST;
 543   1          mlme_scan_req_p->ScanType = ScanType;
 544   1          mlme_scan_req_p->ScanChannels = ScanChannels;
 545   1          mlme_scan_req_p->ScanDuration = ScanDuration;
 546   1          mlme_scan_req_p->ChannelPage = ChannelPage;
 547   1          if (sec_p) {
 548   2              mlme_scan_req_p->Security.SecurityLevel = sec_p->SecurityLevel;
 549   2              mlme_scan_req_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 550   2              mlme_scan_req_p->Security.KeyIndex      = sec_p->KeyIndex;
 551   2              memcpy(mlme_scan_req_p->Security.KeySource, sec_p->KeySource,
 552   2                     SEC_KEY_SRC_MAX);
 553   2          } else {
 554   2              mlme_scan_req_p->Security.SecurityLevel = 0; 
 555   2          }
 556   1       
 557   1          /* Enqueue the message to MAC Q */
 558   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 559   1      }
 560          
 561          bool mac_api_mlme_sync_req (uint8_t LogicalChannel,
 562                                      uint8_t ChannelPage,
 563                                      bool TrackBeacon)
 564          {
 565   1          buffer_t *buffer_p;
 566   1          mlme_sync_req_t *mlme_sync_req_p;
 567   1      
 568   1          /* Allocate a small buffer for sync request */
 569   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 570   1      
 571   1          if (NULL == buffer_p) {
 572   2              /* Buffer is not available */
 573   2              return false;
 574   2          }
 575   1      
 576   1          /* Get the buffer body from buffer header */
 577   1          mlme_sync_req_p = (mlme_sync_req_t *)BMM_BUFFER_POINTER(buffer_p);
 578   1      
 579   1          /* Update the sync request structure */
 580   1          mlme_sync_req_p->cmdcode = MLME_SYNC_REQUEST;
 581   1          mlme_sync_req_p->LogicalChannel = LogicalChannel;
 582   1          mlme_sync_req_p->ChannelPage = ChannelPage;
 583   1          mlme_sync_req_p->TrackBeacon = TrackBeacon;
 584   1      
 585   1          /* Enqueue the message to MAC Q */
 586   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 587   1      }
 588          
 589          bool mac_api_mlme_poll_req (wpan_addr_spec_t *CoordAddrSpec,
 590                                      security_info_t *sec_p)
 591          {
 592   1          buffer_t *buffer_p;
C51 COMPILER V9.53.0.0   MAC_API                                                           11/04/2015 20:09:48 PAGE 11  

 593   1          mlme_poll_req_t *mlme_poll_req_p;
 594   1      
 595   1          /* Allocate a buffer for poll request */
 596   1          buffer_p = bmm_buffer_alloc(BUFFER_SIZE);
 597   1      
 598   1          if (NULL == buffer_p) {
 599   2              /* Buffer is not available */
 600   2              return false;
 601   2          }
 602   1      
 603   1          /* Get the buffer body from buffer header */
 604   1          mlme_poll_req_p = (mlme_poll_req_t *)BMM_BUFFER_POINTER(buffer_p);
 605   1      
 606   1          /* construct mlme_poll_req_t message */
 607   1          mlme_poll_req_p->cmdcode = MLME_POLL_REQUEST;
 608   1      
 609   1          /* Other fileds. */
 610   1          mlme_poll_req_p->CoordAddrMode = CoordAddrSpec->AddrMode;
 611   1          mlme_poll_req_p->CoordPANId = CoordAddrSpec->PANId;
 612   1      
 613   1          mlme_poll_req_p->CoordAddress.long_address.hi_u32 = 0;
 614   1          mlme_poll_req_p->CoordAddress.long_address.lo_u32 = 0;
 615   1          if (WPAN_ADDRMODE_SHORT == CoordAddrSpec->AddrMode) {
 616   2              mlme_poll_req_p->CoordAddress.long_address.lo_u32 = CoordAddrSpec->Addr.short_address;
 617   2          } else {
 618   2              mlme_poll_req_p->CoordAddress.long_address = CoordAddrSpec->Addr.long_address;
 619   2          }
 620   1      
 621   1          if (sec_p) {
 622   2              mlme_poll_req_p->Security.SecurityLevel = sec_p->SecurityLevel;
 623   2              mlme_poll_req_p->Security.KeyIdMode     = sec_p->KeyIdMode;
 624   2              mlme_poll_req_p->Security.KeyIndex      = sec_p->KeyIndex;
 625   2              memcpy(mlme_poll_req_p->Security.KeySource, sec_p->KeySource,
 626   2                     SEC_KEY_SRC_MAX);
 627   2          } else {
 628   2              mlme_poll_req_p->Security.SecurityLevel = 0;
 629   2          }
 630   1      
 631   1          /* Enqueue the message to MAC Q */
 632   1          return (mac_api_to_nhle_mac_queue(buffer_p));
 633   1      }
 634          #endif // HYBRII_802154


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3657    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----     189
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
