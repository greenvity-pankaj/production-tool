C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GV701X_CFG
OBJECT MODULE PLACED IN .\obj\gv701x_cfg.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\common\gv701x_cfg.c LARGE OBJECTADVANCED OPTIMIZE(9
                    -,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..
                    -\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\h
                    -al;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\fi
                    -rmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbe
                    -e;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\in
                    -c;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\i
                    -nc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;
                    -..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers
                    -\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..
                    -\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\
                    -components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers
                    -\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilitie
                    -s;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\n
                    -wk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..
                    -\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII
                    -_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC
                    -,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DET
                    -ECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUP
                    -T,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REG
                    -ISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\gv701x_cfg.lst) TABS(
                    -2) OBJECT(.\obj\gv701x_cfg.obj)

line level    source

   1          /*
   2          * $Id: gv701x_cfg.c,v 1.21 2015/01/06 23:53:04 son Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/common/gv701x_cfg.c,v $
   5          *
   6          * Description : GV701x H/W Initialization/Configuration.
   7          *
   8          * Copyright (c) 2012 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *    
  13          *
  14          */
  15          #include <stdio.h>
  16          #include "papdef.h"
  17          #include "hal_reg.h"
  18          #include "hal_common.h"
  19          #include "mac_const.h"
  20          #include "utils_fw.h"
  21          #include "utils.h"
  22          #include "gv701x_cfg.h"
  23          #ifdef UM
  24          #include "ctrll.h"
  25          #include "fm.h"
  26          #endif
  27          #ifdef HYBRII_802154
  28          #ifdef HYBRII_B
  29          /* From Rachel 05/19/2014 @ 10 dB Gain for RX */
  30          static char baseband_gain_table [] = {
  31              0x09, 0x12, 0x24, 0x48, 0x90, 0x20, 0x41, 0x82,
  32              0x04, 0x09, 0x12, 0x24, 0x48, 0x90, 0x21, 0x43,
  33              0x06, 0x04, 0x49, 0x92, 0xe4, 0xc8, 0x81, 0xe1,
  34              0x00, 0x12, 0x24, 0x38, 0x70, 0x5c, 0x30, 0x70,
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 2   

  35              0xe4, 0xc8, 0x8d, 0x1b, 0x16, 0x0a, 0x18, 0x31,
  36              0x62, 0xc3, 0x46, 0x05, 0x02, 0x45, 0x8a, 0xd4,
  37              0xa8, 0x41, 0x61, 0x00, 0x11, 0x22, 0x34, 0x68,
  38              0x4c, 0x10, 0x30, 0x64, 0xc8, 0x8c, 0x19, 0x12,
  39              0x02, 0x08, 0x11, 0x22, 0x43, 0x46, 0x04, 0x00,
  40              0x41, 0x82, 0xc4, 0x88, 0x01, 0x21, 0x0a, 0x10,
  41              0x20, 0x30, 0x60, 0xc4, 0x81, 0x02, 0x08, 0x10,
  42              0x20, 0x38, 0x70, 0x20, 0x01, 0x03, 0x06, 0x0c,
  43              0x16, 0x2c, 0x68, 0x00, 0x01, 0x02,
  44          };
  45          #endif
  46          #ifdef GT_20DB
              /* From Rachel 05/19/2014 @ 20 dB */
              static char baseband_gain_table [] = {
                  0x09, 0x12, 0x24, 0x48, 0x90, 0x20, 0x41, 0x82,
                  0x04, 0x09, 0x12, 0x24, 0x48, 0x90, 0x20, 0x41,
                  0x82, 0x04, 0x09, 0x12, 0x24, 0x48, 0x90, 0x20,
                  0x41, 0x86, 0x0c, 0x19, 0x10, 0x24, 0x49, 0x92,
                  0x23, 0x07, 0x86, 0x03, 0x48, 0x90, 0xe0, 0xc0,
                  0x71, 0xc1, 0xc0, 0x91, 0x23, 0x37, 0x6e, 0x58,
                  0x28, 0x60, 0xc4, 0x88, 0x0d, 0x1b, 0x15, 0x08,
                  0x14, 0x29, 0x52, 0xa3, 0x06, 0x85, 0x01, 0x44,
                  0x88, 0xd0, 0xa0, 0x31, 0x41, 0xc0, 0x90, 0x21,
                  0x33, 0x66, 0x48, 0x08, 0x20, 0x44, 0x88, 0x0c,
                  0x19, 0x11, 0x00, 0x04, 0x09, 0x12, 0x23, 0x06,
                  0x84, 0x28, 0x40, 0x80, 0xc0, 0x80, 0x11, 0x07,
                  0x0a, 0x20, 0x40, 0x80, 0xe0, 0x00,
              };
              #endif
  64          
  65          #ifndef HYBRII_B
              #ifdef GT_49DB
              /* From Rachel 07/15/2013 @ 49 dB */
              static char baseband_gain_table [] = {
                  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 
                  0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 
                  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
                  0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 
                  0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
                  0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 
                  0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 0x08, 
                  0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 0x04, 
                  0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 0x02, 
                  0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x01, 
                  0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 
                  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 
                  0x00, 0x01, 0x02, 0x04, 0x08, 0x00,
              };
              #endif
              
              //#ifdef GT_69DB
              /* From Rachel 07/20/2013 @ 69 dB */
              static char baseband_gain_table [] = {
                  0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 0x47, 0x8e, 
                  0x1c, 0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 0x47, 
                  0x8e, 0x1c, 0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 
                  0x47, 0x8e, 0x1c, 0x39, 0x72, 0xe4, 0xc8, 0x91, 
                  0x23, 0x47, 0x8e, 0x1c, 0x39, 0x72, 0xe4, 0xc8, 
                  0x91, 0x23, 0x47, 0x8e, 0x1c, 0x39, 0x72, 0xe4, 
                  0xc8, 0x91, 0x23, 0x47, 0x8e, 0x1c, 0x39, 0x72, 
                  0xe4, 0xc8, 0x91, 0x23, 0x47, 0x8e, 0x1c, 0x39, 
                  0x72, 0xe4, 0xc8, 0x91, 0x23, 0x47, 0x8e, 0x1c, 
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 3   

                  0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 0x47, 0x8e, 
                  0x1c, 0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 0x47, 
                  0x8e, 0x1c, 0x39, 0x72, 0xe4, 0xc8, 0x91, 0x23, 
                  0x47, 0x8e, 0x1c, 0x39, 0x72, 0x00,
              };
              //#endif
              
              #endif
 105          
 106          #ifdef HYBRII_ASIC
 107          #ifdef HYBRII_ASIC_A2
 108          static uint16_t afe_channel_to_vco_tx_freq[16] = {
 109              0x7e4e, 0x8481, 0x8ac4, 0x9107, 0x974a, 0x9d8d, 0xa3c0, 0xaa04,
 110              0xb047, 0xb68a, 0xbccd, 0xc300, 0xc943, 0xcf86, 0xd5c9, 0xdc0d,
 111          };
 112          
 113          #else
              static uint16_t afe_channel_to_vco_tx_freq[16] = {
                  0x7e40, 0x8480, 0x8ac0, 0x9100, 0x9740, 0x9d80, 0xa3c0, 0xaa00,
                  0xb040, 0xb680, 0xbcc0, 0xc300, 0xc940, 0xcf80, 0xd5c0, 0xdc00,
              };
              #endif
 119          
 120          static uint16_t afe_channel_to_vco_rx_freq[16] = {
 121              0x7c60, 0x82a0, 0x88e0, 0x8f20, 0x9560, 0x9ba0, 0xa1e0, 0xa820,
 122              0xae60, 0xb4a0, 0xbae0, 0xc120, 0xc760, 0xcda0, 0xd3e0, 0xda20,
 123          };
 124          
 125          u16 rx_dco_cal_threshold = 400;
 126          
 127          /* === Externals ============================================================ */
 128          extern bool mac_scan_is_running(void);
 129          
 130          
 131          uint16_t gv701x_zb_read_bb_fft (void)
 132          {
 133   1          uint16_t bb_fft;
 134   1          
 135   1          mac_utils_delay_ms(1);
 136   1          WriteU8Reg(0x442, 1);
 137   1          //WriteU8Reg(0x442, 5); /* HW is doing average */
 138   1          mac_utils_delay_ms(1);
 139   1          WriteU8Reg(0x442, 0);
 140   1          WriteU8Reg(0x4fa, 1);  /* Select Bank 3 */
 141   1          //printf("\n452 = %bx, 453 = %bx", ReadU8Reg(PHY_FFT_LSB),
 142   1          //       ReadU8Reg(PHY_FFT_MSB));
 143   1          bb_fft = (ReadU8Reg(PHY_FFT_MSB) << 8) | ReadU8Reg(PHY_FFT_LSB);
 144   1          //printf("\n456 = %bx, 457 = %bx", ReadU8Reg(0x456),
 145   1          //       ReadU8Reg(0x457));
 146   1          //bb_fft = (ReadU8Reg(0x457) << 8) | ReadU8Reg(0x456);
 147   1          WriteU8Reg(0x4fa, 0);  /* Select Bank 0 */
 148   1          bb_fft &= 0xfff;       /* 12-bit value  */
 149   1      
 150   1          return (bb_fft);
 151   1      }
 152          #ifndef B2
              void gv701x_zb_lock_channel (uint8_t channel)
              {
              #ifdef Flash_Config
                  uint8_t  cal_val;
              #endif
                  channel = channel - MIN_CHANNEL;
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 4   

                  /*
                   * [YM] Get the channel lock value from flash
                   * cal_val = read_flash_lock_channel_value(channel);
                   */
              #ifdef Flash_Config
                  cal_val = sysConfig.VCOCal[channel];
                  printf("lock channel %bx VCO cal value = %bx\n", channel+ MIN_CHANNEL, cal_val);
              
                  mac_utils_spi_write(AFE_CAL_CNTRL, 
                                      0x70 | AFE_CAL_CNTRL_RESET);  /* 04 = 0x72 */
                  mac_utils_spi_write(AFE_VCO_CAL_WRITE, cal_val);  /* 05 = preset value */
                  mac_utils_spi_write(AFE_PLL_CNTRL,                /* 03 = 0x20 */
                                      PLL_CNTRL_SEL_CAL_BY_SPI);
                  mac_utils_spi_write(AFE_CAL_CNTRL, 
                                      0x70 | AFE_CAL_CNTRL_START);  /* 04 = 0x74 */
              #endif  
              }
              #endif
 177          
 178          void gv701x_zb_set_afe_channel (uint8_t channel, bool afe_rx_cal)
 179          {
 180   1          mac_utils_spi_write(AFE_MOD, 0x03);
 181   1          mac_utils_spi_write(AFE_FRACTION_LSB, 
 182   1                 afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] & 0xFF);
 183   1          mac_utils_spi_write(AFE_FRACTION_MSB, 
 184   1                 afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] >> 8);
 185   1          mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_FRACTION_LOAD);
 186   1          //mac_utils_spi_write(0x03, 0xa0); // Francisco
 187   1      #ifndef B2   
                  WriteU8Reg(0x400,  
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] & 0xFF);
                  WriteU8Reg(0x42a, 
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] >> 8);
                WriteU8Reg(0x408,  
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] & 0xFF);
                  WriteU8Reg(0x409, 
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] >> 8);
              #endif
 197   1          mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_SEL_CAL_BY_SPI);
 198   1          mac_utils_spi_write(AFE_CAL_CNTRL, 0x72);
 199   1          mac_utils_spi_write(AFE_CAL_CNTRL, 0x60);
 200   1      
 201   1      #ifdef HYBRII_B_AFE
 202   1      #ifdef B2
 203   1          mac_utils_spi_write(AFE_CAL_CNTRL, 0x60 |
 204   1                                             AFE_CAL_CNTRL_START);
 205   1      #else
                  mac_utils_spi_write(AFE_CAL_CNTRL, 0x60 |
                                                     AFE_CAL_CNTRL_RESET);
                  gv701x_zb_lock_channel(channel);
              #endif /* B2 */
 210   1      #endif /* HYBRII_B_AFE */
 211   1          /* 
 212   1           * Per Rachel: 
 213   1           * Need to do RX calibration every time setting the channel
 214   1           */
 215   1          if (afe_rx_cal) {
 216   2              gv701x_cfg_rx_dco_bb_cal();
 217   2          }
 218   1      }
 219          
 220          /* Can's AFE TX Calibration */
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 5   

 221          void gv701x_zb_lo_leakage_calibration_init (void)
 222          {
 223   1          mac_utils_spi_write(AFE_MODE_CNTRL_1,
 224   1                              AFE_SPI_MODE_EN  |
 225   1                              AFE_SPI_WL_RX_EN |
 226   1                              AFE_SPI_WL_HB_EN); /* 0xE4 - Enable TX and RX */
 227   1          mac_utils_spi_write(AFE_MODE_CNTRL_2, AFE_SPI_WL_PA_EN);
 228   1      
 229   1          mac_utils_spi_write(AFE_ZIG_GC_TX_FLTR_GAIN, 0x0f); /* Set PA power to max. */
 230   1      
 231   1          /* 
 232   1           * RX DC offset calibration after enable peek detector
 233   1           * according to spec
 234   1           */
 235   1          gv701x_cfg_zb_dc_offset_calibration();
 236   1          mac_utils_spi_write(AFE_MODE_CNTRL_1,
 237   1                              AFE_SPI_MODE_EN  |
 238   1                              AFE_SPI_WL_RX_EN |
 239   1                              AFE_SPI_WL_TX_EN |
 240   1                              AFE_SPI_WL_HB_EN);
 241   1          mac_utils_spi_write(AFE_ZIG_PEEK_DETECT_TX, 0x04); /* Enable Power Detector */
 242   1      
 243   1          WriteU8Reg(PHY_DECI_SEL_GARF_CFG, 0x40);  /* Set DAC clock to 12 Mhz */
 244   1          WriteU8Reg(PHY_DAC_TEST_CONTROL, 0x25);   /* Enable 1 Mhz tone from DAC */
 245   1          WriteU8Reg(PHY_ECO_CFG, 0x0f);            /* Turn of phy rx */
 246   1      }
 247          
 248          #define NUM_READ    8
 249          
 250          uint32_t  min_bb_fft = 0xffffffff;
 251          
 252          #ifdef UM
 253          extern sysProfile_t gSysProfile;
 254          #endif
 255          void gv701x_zb_lo_leakage_calibration_start ()
 256          {
 257   1          uint8_t   i;
 258   1          uint8_t   j;
 259   1          uint32_t  cur_bb_fft;
 260   1          uint8_t   min_afe_i;
 261   1          uint8_t   min_afe_q;
 262   1          uint8_t   num_read;
 263   1          uint8_t   afe_i;
 264   1          uint8_t   afe_q;
 265   1          bool      change_dir_i;
 266   1          bool      change_dir_q;
 267   1      
 268   1          /* [YM] min_afe_i = Read register 23 value from flash
 269   1           *      min_afe_q = Read register 24 value from flash
 270   1           */
 271   1          /*Compiler warning suppression*/    
 272   1          i = i;
 273   1          j = j;
 274   1          cur_bb_fft = cur_bb_fft;
 275   1          num_read = num_read;
 276   1          afe_i = afe_i;
 277   1          afe_q = afe_q;
 278   1          change_dir_i = change_dir_i;
 279   1          change_dir_q = change_dir_q;
 280   1          
 281   1      #if 1 
 282   1      //#ifdef Flash_Config
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 6   

 283   1      #ifdef UM
 284   1        min_afe_i = gSysProfile.rfParam.reg_23;
 285   1        min_afe_q = gSysProfile.rfParam.reg_24;
 286   1        FM_Printf(FM_WARN,"\n%bx/%bx", min_afe_i, min_afe_q);
 287   1      #else
                min_afe_i = sysConfig.defaultLOLeak23;
                min_afe_q = sysConfig.defaultLOLeak24;    
                printf("\n%bx/%bx", min_afe_i, min_afe_q);
              #endif
 292   1        
 293   1          mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, min_afe_i);
 294   1          mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, min_afe_q);
 295   1      //#endif
 296   1      #else
              
                  afe_i = 0xf0;
                  change_dir_i = FALSE;
                  /*
                   * Adjust I and Q by 16 steps
                   */
                  for (i = 0; i < 15; i++) {
                      mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, afe_i);
                      afe_q = 0xf0;
                      change_dir_q = FALSE;
                      for (j = 0; j < 15; j++){
                          mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, afe_q);
                          num_read = NUM_READ;
                          cur_bb_fft = 0;
                          while (num_read--){
                              cur_bb_fft += gv701x_zb_read_bb_fft();
                          }
                          cur_bb_fft /= NUM_READ;
              
                          // printf("\n%bx/%bx %lx", afe_i, afe_q, cur_bb_fft);
                          if (cur_bb_fft < min_bb_fft) {
                              min_bb_fft = cur_bb_fft;
                              min_afe_i = mac_utils_spi_read(AFE_ZIG_TX_OC_I_MSB);
                              min_afe_q = mac_utils_spi_read(AFE_ZIG_TX_OC_Q_MSB);
                          }
                          if (afe_q == 0x80) {
                              afe_q = 0;
                              change_dir_q = TRUE;
                          }
                          if (change_dir_q) {
                              afe_q += 0x10;
                          } else {
                              afe_q -= 0x10;
                          }
                      }
                      if (afe_i == 0x80) {
                          afe_i = 0;
                          change_dir_i = TRUE;
                      }
                      if (change_dir_i) {
                          afe_i += 0x10;
                      } else {
                          afe_i -= 0x10;
                      }
                  }
                  printf("\nMin FFT %bx/%bx %lx", min_afe_i, min_afe_q, min_bb_fft);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, min_afe_i);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, min_afe_q);
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 7   

              
              #ifdef FIXME /* Per Jenny - Small step LO Leakage is not required */
                  afe_i = min_afe_i;
                  afe_q = min_afe_q;
                  min_bb_fft = 0xffffffff;
                  /*
                   * Adjust I by 1 step
                   */
                  for (i = 0; i < 15; i++) {
                      mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, afe_i);
                      num_read = NUM_READ;
                      cur_bb_fft = 0;
                      while (num_read--){
                          cur_bb_fft += gv701x_zb_read_bb_fft();
                      }
                      cur_bb_fft /= NUM_READ;
                      if (cur_bb_fft < min_bb_fft) {
                          min_bb_fft = cur_bb_fft;
                          min_afe_i = mac_utils_spi_read(AFE_ZIG_TX_OC_I_MSB);
                          min_afe_q = mac_utils_spi_read(AFE_ZIG_TX_OC_Q_MSB);
                      }
                      afe_i += 1;
                  }
                  printf("\nMin FFT %bx/%bx %lx", min_afe_i, min_afe_q, min_bb_fft);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, min_afe_i);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, min_afe_q);
                  afe_i = min_afe_i;
                  afe_q = min_afe_q;
                  min_bb_fft = 0xffffffff;
                  /*
                   * Adjust Q by 1 step
                   */
                  for (i = 0; i < 15; i++) {
                      mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, afe_q);
                      num_read = NUM_READ;
                      cur_bb_fft = 0;
                      while (num_read--){
                          cur_bb_fft += gv701x_zb_read_bb_fft();
                      }
                      cur_bb_fft /= NUM_READ;
                      if (cur_bb_fft < min_bb_fft) {
                          min_bb_fft = cur_bb_fft;
                          min_afe_i = mac_utils_spi_read(AFE_ZIG_TX_OC_I_MSB);
                          min_afe_q = mac_utils_spi_read(AFE_ZIG_TX_OC_Q_MSB);
                      }
                      afe_q += 1;
                  }
                  printf("\nMin FFT %bx/%bx %lx", min_afe_i, min_afe_q, min_bb_fft);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, min_afe_i);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, min_afe_q);
              #endif
              #endif
 397   1      }
 398          
 399          void gv701x_zb_lo_leakage_calibration_done (void)
 400          {
 401   1          mac_utils_spi_write(AFE_VGA1_CNTRL, 0x00);
 402   1          mac_utils_spi_write(AFE_VGA2_CNTRL, 0x00);
 403   1          mac_utils_spi_write(AFE_ZIG_PEEK_DETECT_TX, 0x00);
 404   1          WriteU8Reg(PHY_DECI_SEL_GARF_CFG, 0x41); /* 0x412 = 0x41 */    
 405   1          WriteU8Reg(PHY_ECO_CFG, 0x03);           /* 0x417 = 0x03 */
 406   1          WriteU8Reg(PHY_DAC_TEST_CONTROL, 0x00);  /* 0x40a = 0x00 -> Turn off 1 Mhz tone from DAC */
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 8   

 407   1      }
 408          
 409          #ifdef FIXME
              void gv701x_zb_lo_leakage_read (void)
              {
                  uint16_t bb_fft_curr;
                  uint8_t  num_read;
              
                  mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, 0x10);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, 0);
                  num_read = NUM_READ;
                  bb_fft_curr = 0;
                  while (num_read--){
                      bb_fft_curr += gv701x_zb_read_bb_fft();
                  }
                  bb_fft_curr /= NUM_READ;
                  //printf("%x\n", bb_fft_curr);
              }
              #endif
 426          
 427          void gv701x_zb_lo_leakage_calibration (uint8_t channel)
 428          {
 429   1      #ifdef CAL_MULTIPLE
                  uint8_t   cal_time = 3;
                  uint8_t   num_read;
                  uint8_t   i_min_bb_fft;
                  uint8_t   q_min_bb_fft;
                  uint32_t  bb_fft_curr;
                  uint32_t  min_bb_fft = 0x0fff;
              #else
 437   1          uint8_t   cal_time = 8;
 438   1      #endif
 439   1      
 440   1          gv701x_zb_set_afe_channel(channel, TRUE);
 441   1      
 442   1          //gv701x_zb_lo_leakage_calibration_init();
 443   1          //mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, 0);
 444   1          while (cal_time --) {
 445   2              gv701x_zb_lo_leakage_calibration_init();
 446   2              gv701x_zb_lo_leakage_calibration_start();
 447   2              gv701x_zb_lo_leakage_calibration_done();
 448   2      #ifdef CAL_MULTIPLE        
                      num_read = NUM_READ;
                      while (num_read--){
                          bb_fft_curr += gv701x_zb_read_bb_fft();
                      }
                      bb_fft_curr /= NUM_READ;
              
                      if (bb_fft_curr < min_bb_fft) {
                          min_bb_fft = bb_fft_curr;
                          i_min_bb_fft = mac_utils_spi_read(AFE_ZIG_TX_OC_I_MSB);
                          q_min_bb_fft = mac_utils_spi_read(AFE_ZIG_TX_OC_Q_MSB);
                      }
              #endif
 461   2          }
 462   1      #ifdef CAL_MULTIPLE
                  mac_utils_spi_write(AFE_ZIG_TX_OC_I_MSB, i_min_bb_fft);
                  mac_utils_spi_write(AFE_ZIG_TX_OC_Q_MSB, q_min_bb_fft);
              #endif
 466   1      
 467   1          //gv701x_zb_lo_leakage_calibration_done();
 468   1      
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 9   

 469   1      }
 470          
 471          /*
 472           * AFE Calibration procedure
 473           */
 474          void gv701x_cfg_zb_afe_tx_init (uint8_t channel)
 475          {
 476   1          static bool rx_cal = TRUE;
 477   1      
 478   1          gv701x_zb_set_afe_channel(channel, rx_cal);
 479   1          rx_cal = FALSE;
 480   1          
 481   1          //mac_utils_spi_write(0x04, 0x00);  // Francisco
 482   1          
 483   1          mac_utils_spi_write(AFE_MODE_CNTRL_1, 
 484   1                              AFE_SPI_MODE_EN  |
 485   1                              AFE_SPI_WL_TX_EN |
 486   1                              AFE_SPI_WL_HB_EN);  // 0xa4 - TX Enable
 487   1          mac_utils_spi_write(AFE_MODE_CNTRL_2, AFE_SPI_WL_PA_EN);
 488   1      
 489   1          mac_utils_spi_write(AFE_ZIG_GC_TX_FLTR_GAIN, 0x0f);  // (Set PA power to max.)
 490   1      
 491   1          // Board dependent #12
 492   1          //mac_utils_spi_write(0x23, 0x60);  // (LO leakage tuning)
 493   1          //mac_utils_spi_write(0x24, 0xc0);  // Board dependent
 494   1          //mac_utils_spi_write(0x25, 0x00);  // Board dependent
 495   1          
 496   1          //Board dependent #4
 497   1          //mac_utils_spi_write(0x23, 0x00);  // LO leakage tuning)
 498   1          //mac_utils_spi_write(0x24, 0x3f);  // Board dependent
 499   1          //mac_utils_spi_write(0x25, 0x00);  // Board dependent
 500   1          
 501   1          //Board dependent #27, #28
 502   1          //mac_utils_spi_write(0x23, 0x1f);  // LO leakage tuning)
 503   1          //mac_utils_spi_write(0x24, 0x0f);  // Board dependent
 504   1          //mac_utils_spi_write(0x25, 0x00);  // Board dependent
 505   1      
 506   1          // Son
 507   1          //mac_utils_spi_write(0x23, 0x3f);  // LO leakage tuning)
 508   1          //mac_utils_spi_write(0x24, 0x00);  // Board dependent
 509   1          //mac_utils_spi_write(0x25, 0x00);  // Board dependent
 510   1      
 511   1          //mac_utils_spi_write(0x23, 0x7f);  // Board dependent #9
 512   1          //mac_utils_spi_write(0x24, 0x3f);  // Board dependent
 513   1          //mac_utils_spi_write(0x25, 0xf0);  // Board dependent
 514   1          
 515   1          //mac_utils_spi_write(0x23, 0x00);  // Board dependent Rachel's board
 516   1          //mac_utils_spi_write(0x24, 0x00);  // Board dependent
 517   1          //mac_utils_spi_write(0x25, 0x00);  // Board dependent
 518   1         
 519   1          mac_utils_spi_write(AFE_MODE_CNTRL_1, 0x0);  // son
 520   1          // RX Gain for board C4
 521   1          mac_utils_spi_write(AFE_VGA1_CNTRL, AFE_VGA1_SPI_VGA_EN);
 522   1          //mac_utils_spi_write(0x39, 0x1f);
 523   1          mac_utils_spi_write(AFE_VGA2_CNTRL,
 524   1                              AFE_VGA2_SPI_GA_PPF_EN | 0x04);
 525   1          /* Turn off CCA detection (always has CCA) */
 526   1          // hal_common_bit_field_reg_write(ZIG_PHY_CCA_MODE, 0x03);
 527   1         
 528   1      #ifdef BB_GAIN_TABLE
 529   1          if (mac_scan_is_running() == FALSE) {
 530   2              mac_utils_spi_write(AFE_VGA1_CNTRL, 0x00); // AFE to use Baseband gain table
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 10  

 531   2          }
 532   1      #endif
 533   1      #ifdef HYBRII_B_AFE
 534   1      
 535   1          mac_utils_spi_write(AFE_ZIG_FLTR_BW_SEL, 0xe0); // Enable RX, TX 2Mhz BW Sel
 536   1      
 537   1      #endif
 538   1      }
 539          
 540          #ifdef BB_CAL
 541          static u16  abs_12bit (u16 a)
 542          {
 543   1      #ifdef CAL_DEB
                  printf("\na = 0x%x", a);
              #endif
 546   1          if (a & 0x800) {
 547   2              a = 0x1000 - a;
 548   2          }
 549   1      #ifdef CAL_DEB
                  printf("\na = 0x%x", a);
              #endif
 552   1      
 553   1          return (a);
 554   1      }
 555          
 556          static bool abs_12bit_compare (u16 a, u16 b)
 557          {
 558   1          a = abs_12bit(a);
 559   1          b = abs_12bit(b);
 560   1          
 561   1          if (a >= b) {
 562   2              return (TRUE);
 563   2          } else {
 564   2              return (FALSE);
 565   2          }
 566   1      }
 567          
 568          static void gv701x_cfg_read_phy_i_q (u16 *i, u16 *q)
 569          {
 570   1          u16 temp;
 571   1          
 572   1          WriteU8Reg(PHY_PD_THRESHOLD_MSB, 0x29);    // Clear BB RX DCO calc
 573   1          WriteU8Reg(PHY_PD_THRESHOLD_MSB, 0x2d);    // Start BB RX DCO calc
 574   1          mac_utils_delay_ms(1);
 575   1      
 576   1          temp = (ReadU8Reg(PHY_DC_OFFSET_I_Q) & DC_OFFSET_I_MSB_MASK) << 8;
 577   1          *i =  temp | ReadU8Reg(PHY_DC_OFFSET_I_LSB);
 578   1      
 579   1          temp = ReadU8Reg(PHY_DC_OFFSET_Q_MSB);
 580   1          *q = (temp << 4) | (ReadU8Reg(PHY_DC_OFFSET_I_Q) >> 4);
 581   1      }
 582          
 583          static u8 gv701x_cfg_read_afe_i_msb (void)
 584          {
 585   1          u8 afe_i_msb;
 586   1      
 587   1      #ifdef HYBRII_B_AFE
 588   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 
 589   1                              AFE_ZIG_RX_OC_SELG1 |
 590   1                              AFE_ZIG_RX_OC_SELG2 |
 591   1                              AFE_ZIG_RX_OC_SELG3 |
 592   1                              AFE_ZIG_RX_OC_RD);
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 11  

 593   1      #else
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I,
                                      AFE_ZIG_RX_OC_SELG1 |
                                      AFE_ZIG_RX_OC_RD);   /* Bit <6:5> = 10 -> Read MSB */
              #endif    
 598   1          afe_i_msb = mac_utils_spi_read(AFE_ZIG_EXT_DAT_OUT_I);
 599   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);
 600   1      
 601   1          return (afe_i_msb);
 602   1      }
 603          
 604          static u8 gv701x_cfg_read_afe_i_lsb (void)
 605          {
 606   1          u8 afe_i_lsb;
 607   1      
 608   1      #ifdef HYBRII_B_AFE
 609   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, AFE_ZIG_RX_OC_RD);
 610   1          afe_i_lsb = mac_utils_spi_read(AFE_ZIG_EXT_DAT_OUT_I);
 611   1          // FIXME - different location of 2 LSB */
 612   1      #else
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I,
                                      AFE_ZIG_RX_OC_SELG2 |
                                      AFE_ZIG_RX_OC_RD);   /* Bit <6:5> = 01 -> Read LSB */
                  
                  afe_i_lsb = mac_utils_spi_read(AFE_ZIG_EXT_DAT_OUT_I);
              #endif
 619   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);
 620   1      
 621   1          return (afe_i_lsb);
 622   1      }
 623          
 624          static u16 gv701x_cfg_read_afe_i (void)
 625          {
 626   1          u16 afe_i;
 627   1      
 628   1          afe_i = gv701x_cfg_read_afe_i_msb();
 629   1          afe_i = afe_i << 2;
 630   1      
 631   1          /* Read 2 LSB <7:6> and combine with 8 MSB to form a 10 bit value */
 632   1          afe_i |= ((gv701x_cfg_read_afe_i_lsb() & AFE_I_Q_LSB_VALID) >> 6);
 633   1      
 634   1          return (afe_i); 
 635   1      }
 636          
 637          static u8 gv701x_cfg_read_afe_q_msb (void)
 638          {
 639   1          u8 afe_q_msb;
 640   1      
 641   1          // FIXME - Need to check A2 vs B
 642   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x40);   /* Bit <6:5> = 10 -> Read MSB */
 643   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, AFE_ZIG_RX_OC_RD_Q);
 644   1          afe_q_msb = mac_utils_spi_read(AFE_ZIG_EXT_DAT_OUT_Q);
 645   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);
 646   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, 0x00);
 647   1      
 648   1          return (afe_q_msb);
 649   1      }
 650          
 651          static u8 gv701x_cfg_read_afe_q_lsb (void)
 652          {
 653   1          u8 afe_q_lsb;
 654   1      
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 12  

 655   1          // FIXME - Need to check A2 vs B
 656   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x20);   /* Bit <6:5> = 01 -> Read LSB */
 657   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, AFE_ZIG_RX_OC_RD_Q);
 658   1          afe_q_lsb = mac_utils_spi_read(AFE_ZIG_EXT_DAT_OUT_Q);
 659   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);
 660   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, 0x00);
 661   1      
 662   1          return (afe_q_lsb);
 663   1      }
 664          
 665          static u16 gv701x_cfg_read_afe_q (void)
 666          {
 667   1          u16 afe_q;
 668   1      
 669   1          afe_q = gv701x_cfg_read_afe_q_msb();
 670   1          afe_q = afe_q << 2;
 671   1      
 672   1          /* Read LSB <7:6> and combine wiht 8 MSB to form a 10 bit value */
 673   1          afe_q |= ((gv701x_cfg_read_afe_q_lsb() & AFE_I_Q_LSB_VALID) >> 6);
 674   1      
 675   1          return (afe_q); 
 676   1      }
 677          
 678          static void gv701x_cfg_write_afe_i (u16 afe_i)
 679          {
 680   1          u8 lsb;
 681   1      
 682   1          lsb = gv701x_cfg_read_afe_i_lsb();
 683   1          lsb &= ~AFE_I_Q_LSB_VALID;     /* Clear <7:6> */
 684   1          lsb |= ((afe_i & 0x03) << 6);  /* new value for <7:6> */
 685   1          // FIXME - Need to check A2 vs B
 686   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x0);
 687   1          mac_utils_spi_write(AFE_ZIG_EXT_DAT_IN_I_MSB, (u8)(afe_i >> 2));   /* MSB */
 688   1          mac_utils_spi_write(AFE_ZIG_EXT_DAT_IN_I_LSB, lsb);                /* LSB */
 689   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x50); /* Does actual write */
 690   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00); 
 691   1      }
 692          
 693          static void gv701x_cfg_write_afe_q (u16 afe_q)
 694          {
 695   1          u8 lsb;
 696   1      
 697   1          lsb = gv701x_cfg_read_afe_q_lsb();
 698   1          lsb &= ~AFE_I_Q_LSB_VALID;     /* Clear <7:6> */
 699   1          lsb |= ((afe_q & 0x03) << 6);  /* new value for <7:6> */
 700   1          // FIXME - Need to check A2 vs B
 701   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x0);
 702   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, 0x0);
 703   1          mac_utils_spi_write(AFE_ZIG_EXT_DAT_IN_Q_MSB, (u8)(afe_q >> 2));   /* MSB */
 704   1          mac_utils_spi_write(AFE_ZIG_EXT_DAT_IN_Q_LSB, lsb);                /* LSB */
 705   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x40); /* Does actual write */
 706   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x04); 
 707   1      }
 708          
 709          /* Can's dc offset calibration steps */
 710          void gv701x_cfg_zb_dc_offset_calibration ()
 711          {
 712   1          /*
 713   1           * Expecting the caller to set AFE_MODE_CNTRL_1 register
 714   1           */
 715   1      #ifdef HYBRII_B_AFE
 716   1          mac_utils_spi_write(AFE_ZIG_FLTR_BW_SEL, 0);                // 16 = 0
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 13  

 717   1          // (DC cal, disconnect RF input port)
 718   1          mac_utils_spi_write(AFE_VGA1_CNTRL, AFE_VGA1_SPI_VGA_EN);   // 38 = 20
 719   1          mac_utils_spi_write(AFE_VGA2_CNTRL, 0x0f);                  // 39 = 0f
 720   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0);                // 08 = 00
 721   1          mac_utils_spi_write(AFE_ZIG_RX_OC_Q, 0);                    // 17 = 00
 722   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xc0);             // 07 = c0
 723   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);             // 07 = 00
 724   1          mac_utils_spi_write(AFE_ZIG_ADC_CAL, 0x05);                 // 10 = 05
 725   1      
 726   1      #if 0
                  mac_utils_spi_write(AFE_ZIG_FLTR_BW_SEL, 0xc0);             // 16 = C0
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x82);             // 07 = 82
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);             // 07 = 00
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x05);             // 08 = 05
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);             // 07 = A0
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);             // 07 = 00
              #endif
 734   1      #else
                  mac_utils_spi_write(AFE_VGA1_CNTRL, AFE_VGA1_SPI_VGA_EN);   // 38 = 20
                  mac_utils_spi_write(AFE_VGA2_CNTRL, 0x10);                  // 39 = 10
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);             // 16 = a0
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);             // 16 = 00
                  mac_utils_spi_write(AFE_VGA2_CNTRL, 0x1f);                  // 39 = 1f
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xc0);             // 16 = c0
                  mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);             // 16 = 00
                  mac_utils_spi_write(AFE_VGA1_CNTRL, 0);                     // 38 = 20
              #endif
 744   1      }
 745          
 746          #ifdef HYBRII_B_AFE
 747          /* Rachel's AFE RX Calibration steps */
 748          void gv701x_cfg_rx_dco_bb_cal ()
 749          {
 750   1          u16 cur_phy_i;
 751   1          u16 cur_phy_q;
 752   1          u16 cur_phy_i_q;
 753   1          u16 min_i_q = 0xffff;
 754   1          u8  i_q_cfg;
 755   1      
 756   1          mac_utils_spi_write(AFE_MODE_CNTRL_1,
 757   1                              AFE_SPI_MODE_EN  |
 758   1                              AFE_SPI_WL_RX_EN |
 759   1                              AFE_SPI_WL_HB_EN);                    // 36 = c4 RX Enanle
 760   1          mac_utils_spi_write(AFE_VGA1_CNTRL, AFE_VGA1_SPI_VGA_EN); // 38 = 20
 761   1          mac_utils_spi_write(AFE_VGA2_CNTRL, 
 762   1                              AFE_VGA2_SPI_GA_PPF_EN | 0x0f);       // 39 = 1f Fix gain 79db
 763   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xc0);           // 07 = c0 Cal DAC1
 764   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07 = 00 Stop cal DAC1
 765   1      
 766   1          mac_utils_spi_write(AFE_ZIG_FLTR_BW_SEL, 0xc0);           // 16 = c0 Enable 2 Mhz bw selection
 767   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x82);           // 07 = 82 Cal DAC3
 768   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07 = 00 Stop cal DAC3
 769   1      
 770   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x05);           // 08 = 05 Enable ilow/qlow
 771   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);           // 07 = a0 Cal DAC2
 772   1      
 773   1          gv701x_cfg_read_phy_i_q(&cur_phy_i, &cur_phy_q);
 774   1      #ifdef CAL_DEB 
                  printf("\nIL/QL I = %d, Q = %d", cur_phy_i, cur_phy_q);
              #endif
 777   1      
 778   1          cur_phy_i_q = abs_12bit(cur_phy_i) + abs_12bit(cur_phy_q);
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 14  

 779   1      #ifdef CAL_DEB
                  printf("\nIL/QL |I + Q| = %d", cur_phy_i_q);
              #endif
 782   1          
 783   1          if (min_i_q > cur_phy_i_q) {
 784   2              min_i_q = cur_phy_i_q;
 785   2              i_q_cfg = IL_QL;
 786   2          }
 787   1          if (abs_12bit(cur_phy_i) < rx_dco_cal_threshold & 
 788   1              abs_12bit(cur_phy_q) < rx_dco_cal_threshold){
 789   2              goto done;
 790   2          }
 791   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07  = 0
 792   1      
 793   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x09);           // 08 = 09 Enable ihi/qlow
 794   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);           // 07 = a0 Cal DAC2
 795   1          gv701x_cfg_read_phy_i_q(&cur_phy_i, &cur_phy_q); 
 796   1      #ifdef CAL_DEB
                  printf("\nIH/QL I = %d, Q = %d", cur_phy_i, cur_phy_q);
              #endif
 799   1          cur_phy_i_q = abs_12bit(cur_phy_i) + abs_12bit(cur_phy_q);
 800   1      #ifdef CAL_DEB
                  printf("\nIH/QL |I + Q| = %d", cur_phy_i_q);
              #endif
 803   1      
 804   1          if (min_i_q > cur_phy_i_q) {
 805   2              min_i_q = cur_phy_i_q;
 806   2              i_q_cfg = IH_QL;
 807   2          }
 808   1      
 809   1          if (abs_12bit(cur_phy_i) < rx_dco_cal_threshold & 
 810   1              abs_12bit(cur_phy_q) < rx_dco_cal_threshold){
 811   2              goto done;
 812   2          }
 813   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07  = 0
 814   1      
 815   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x06);           // 08 = 06 Enable ilow/qhi
 816   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);           // 07 = a0 Cal DAC2
 817   1          gv701x_cfg_read_phy_i_q(&cur_phy_i, &cur_phy_q);
 818   1      #ifdef CAL_DEB 
                  printf("\nIL/QH I = %d, Q = %d", cur_phy_i, cur_phy_q);
              #endif
 821   1          cur_phy_i_q = abs_12bit(cur_phy_i) + abs_12bit(cur_phy_q);
 822   1      #ifdef CAL_DEB
                  printf("\nIL/QH |I + Q| = %d", cur_phy_i_q);
              #endif
 825   1      
 826   1          if (min_i_q > cur_phy_i_q) {
 827   2              min_i_q = cur_phy_i_q;
 828   2              i_q_cfg = IL_QH;
 829   2          }
 830   1      
 831   1          if (abs_12bit(cur_phy_i) < rx_dco_cal_threshold & 
 832   1              abs_12bit(cur_phy_q) < rx_dco_cal_threshold){
 833   2              goto done;
 834   2          }
 835   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07  = 0
 836   1      
 837   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x0a);           // 08 = 0a Enable ihi/qhi
 838   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);           // 07 = a0 Cal DAC2
 839   1          gv701x_cfg_read_phy_i_q(&cur_phy_i, &cur_phy_q); 
 840   1      #ifdef CAL_DEB
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 15  

                  printf("\nIL/QH I = %d, Q = %d", cur_phy_i, cur_phy_q);
              #endif
 843   1          cur_phy_i_q = abs_12bit(cur_phy_i) + abs_12bit(cur_phy_q);
 844   1      #ifdef CAL_DEB
                  printf("\nIL/QH |I + Q| = %d", cur_phy_i_q);
              #endif
 847   1      
 848   1          if (min_i_q > cur_phy_i_q) {
 849   2              min_i_q = cur_phy_i_q;
 850   2              i_q_cfg = IH_QH;
 851   2          }
 852   1      
 853   1          if (abs_12bit(cur_phy_i) < rx_dco_cal_threshold & 
 854   1              abs_12bit(cur_phy_q) < rx_dco_cal_threshold){
 855   2              goto done;
 856   2          }
 857   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07  = 0
 858   1          switch (i_q_cfg) {
 859   2          case IL_QL:
 860   2      #ifdef CAL_DEB
                      printf("\nIL/QL");
              #endif
 863   2              mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x05);
 864   2              break;
 865   2          case IH_QL:
 866   2      #ifdef CAL_DEB
                      printf("\nIH/QL");
              #endif
 869   2              mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x09);
 870   2              break;
 871   2          case IL_QH:
 872   2      #ifdef CAL_DEB
                      printf("\nIL/QH");
              #endif
 875   2              mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x06);
 876   2              break;
 877   2          case IH_QH:
 878   2      #ifdef CAL_DEB
                      printf("\nIH/QH");
              #endif
 881   2              mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG1A, 0x0a);
 882   2              break;    
 883   2          }
 884   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0xa0);           // 07 = a0 Cal DAC2
 885   1          gv701x_cfg_read_phy_i_q(&cur_phy_i, &cur_phy_q);
 886   1      #ifdef CAL_DEB 
                  printf("\nI = %d, Q = %d", cur_phy_i, cur_phy_q);
              #endif
 889   1          cur_phy_i_q = abs_12bit(cur_phy_i) + abs_12bit(cur_phy_q);
 890   1      #ifdef CAL_DEB
                  printf("\n|I + Q| = %d", cur_phy_i_q);
              #endif
 893   1      
 894   1      done:
 895   1          WriteU8Reg(PHY_PD_THRESHOLD_MSB, 0x29);                   // 419 = 29
 896   1          mac_utils_spi_write(AFE_ZIG_RX_OC_ZIG_I, 0x00);           // 07  = 0
 897   1          
 898   1          mac_utils_spi_write(AFE_MODE_CNTRL_1, 0x00);  /* Phy to control RX, TX Enable */
 899   1          mac_utils_spi_write(AFE_ZIG_FLTR_BW_SEL, 0x00);
 900   1          mac_utils_spi_write(AFE_VGA1_CNTRL, 0x00);
 901   1          mac_utils_spi_write(AFE_VGA2_CNTRL, 0x00);
 902   1      }
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 16  

 903          
 904          #endif /* HYBRII_B_AFE */
 905          #endif /* BB_CAL */
 906          
 907          #ifndef HYBRII_ASIC_A2
              #ifndef HYBRII_FPGA_A2
              void gv701x_cfg_zb_afe_rx_init (uint8_t channel)
              {
                  mac_utils_spi_write(AFE_MOD, 0x03);
                  mac_utils_spi_write(AFE_FRACTION_LSB, 
                         afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] & 0xFF);
                  mac_utils_spi_write(AFE_FRACTION_MSB, 
                         afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] >> 8);
              
                  mac_utils_spi_write(AFE_PLL_CNTRL, 0x20); // Francisco
              
                  //mac_utils_spi_write(AFE_PLL_CNTRL, 0x80);
                  mac_utils_spi_write(AFE_PLL_CNTRL, 0xa0); // Francisco
              
                  mac_utils_spi_write(AFE_PLL_CNTRL, 0x20);
                  mac_utils_spi_write(AFE_CAL_CNTRL, 0x60);
                  mac_utils_spi_write(AFE_CAL_CNTRL, 0x64);
              
                  mac_utils_spi_write(AFE_CAL_CNTRL, 0x00);  // Francisco
              } 
              #endif
              #endif
 930          
 931          void gv701x_cfg_zb_afe_init (uint8_t channel, bool calibration)
 932          {
 933   1      #ifdef BB_CAL
 934   1          if (calibration) {
 935   2              gv701x_zb_lo_leakage_calibration(channel);
 936   2          }
 937   1      #endif
 938   1          /*
 939   1           * We only need to calibrate TX or RX bot not both
 940   1           */
 941   1          gv701x_cfg_zb_afe_tx_init(channel);
 942   1      #ifdef HYBRII_FPGA_A2
                WriteU8Reg(0x400,  
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] & 0xFF);
                  WriteU8Reg(0x42a, 
                             afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] >> 8);
                WriteU8Reg(0x408,  
                             afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] & 0xFF);
                  WriteU8Reg(0x409, 
                             afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] >> 8);
              #endif
 952   1      }
 953          
 954          #ifndef HYBRII_ASIC_A2
              #ifndef HYBRII_FPGA_A2
              void gv701x_cfg_zb_afe_set_vco_tx (uint8_t channel)
              {
                  mac_utils_spi_write(AFE_FRACTION_LSB, 
                         afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] & 0xFF);
                  mac_utils_spi_write(AFE_FRACTION_MSB, 
                         afe_channel_to_vco_tx_freq[channel - MIN_CHANNEL] >> 8);
                  mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_FRACTION_LOAD);
              
                  //mac_utils_spi_write(AFE_PLL_CNTRL, 0xa0); // Francisco
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 17  

                  mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_SEL_CAL_BY_SPI); // Francisco
              }
              
              void gv701x_cfg_zb_afe_set_vco_rx (uint8_t channel)
              {
                  mac_utils_spi_write(AFE_FRACTION_LSB, 
                         afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] & 0xFF);
                  mac_utils_spi_write(AFE_FRACTION_MSB, 
                         afe_channel_to_vco_rx_freq[channel - MIN_CHANNEL] >> 8);
                  mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_FRACTION_LOAD);
                  
                  mac_utils_spi_write(AFE_PLL_CNTRL, PLL_CNTRL_SEL_CAL_BY_SPI); // Francisco
              }
              #endif
              #endif
 980          
 981          #ifdef HYBRII_B
 982          static void gv701x_cfg_zb_gain_table (void)
 983          {
 984   1          u8  idx = 0;
 985   1          u16 reg;
 986   1      
 987   1          WriteU8Reg(0x4F8, 0x01);
 988   1      
 989   1          for (reg = 0x400; reg < 0x466; reg++) {
 990   2              WriteU8Reg(reg, baseband_gain_table[idx++]);
 991   2          }
 992   1          WriteU8Reg(0x4F8, 0x00);
 993   1      //    mac_utils_spi_write(AFE_VGA1_CNTRL, 0x00); // AFE to use Baseband gain table
 994   1      }
 995          #endif
 996          
 997          void gv701x_cfg_zb_phy_init (void)
 998          {
 999   1      #ifdef HYBRII_FPGA_A2
                  WriteU8Reg(0x401, 0x13);
              #else
1002   1          WriteU8Reg(0x401, 0x03);
1003   1      #endif
1004   1          WriteU8Reg(0x402, 0x10);
1005   1      
1006   1          // Per Rachel
1007   1          //WriteU8Reg(0x414, 0x37);  /* 04/29/2013 */
1008   1          //WriteU8Reg(0x414, 0x20);  /* 07/16/2013 */
1009   1        WriteU8Reg(0x414, 0x42);
1010   1      #ifdef HYBRII_B
1011   1          WriteU8Reg(0x411, 0x84);  /* Enable Filter (bit 7) */ 
1012   1        
1013   1        WriteU8Reg(0x415, 0x2b);
1014   1          WriteU8Reg(0x416, 0x2d);
1015   1      #endif
1016   1          WriteU8Reg(0x414, 0x00);  /* Per Herbe 08/01/13 */
1017   1          WriteU8Reg(0x415, 0x2b);
1018   1          WriteU8Reg(0x416, 0x2d);
1019   1          WriteU8Reg(0x418, 0xff);  /* Sync Threshold - Per Rachel 07/15 */
1020   1          WriteU8Reg(0x426, 0x6f);  /* Per Jenny 08/12/13 - Raise TX EN early which */
1021   1          WriteU8Reg(0x427, 0x02);  /* is 50 usecs before beginning of packet */
1022   1          WriteU8Reg(0x42c, 0x00);  /* RSSI Value Calibration */
1023   1      
1024   1      #ifdef HYBRII_B
1025   1          gv701x_cfg_zb_gain_table();
1026   1      #endif
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 18  

1027   1      #ifdef BB_GAIN_TABLE
1028   1          mac_utils_spi_write(AFE_VGA1_CNTRL, 0x00);   /* Using BB Gain Table */
1029   1      #endif
1030   1      }
1031          
1032          #else
              void gv701x_cfg_zb_afe_init (uint8_t channel)
              {
                  channel = channel;
                  WriteU8Reg(0x40a, 0x08);  // Set DAC input format to Binary Offset
                  WriteU8Reg(0x408, 0x31);
                  WriteU8Reg(0x419, 0x31);
              
                  WriteU8Reg(0x401, 0x00);
                  mac_utils_spi_write(0x40, 0x1d);
                  mac_utils_spi_write(0x01, 0x15);
                  mac_utils_spi_write(0x04, 0x00);
                  mac_utils_spi_write(0x09, 0xfc);
                  mac_utils_spi_write(0x0d, 0xb9);
                  mac_utils_spi_write(0x10, 0x0a);
                  mac_utils_spi_write(0x14, 0x8D);
                  mac_utils_spi_write(0x18, 0x06);
                  mac_utils_spi_write(0x1c, 0x00);
                  //mac_utils_spi_write(0x20, 0x83); // Manual AGC
                  mac_utils_spi_write(0x20, 0x80);  // Automatic AGC
                  mac_utils_spi_write(0x24, 0x1c);
                  mac_utils_spi_write(0x28, 0x18);
                  mac_utils_spi_write(0x2c, 0x16);
                  mac_utils_spi_write(0x32, 0x4f);
                  mac_utils_spi_write(0x35, 0x50);
                  mac_utils_spi_write(0x3b, 0xc5);
                  mac_utils_spi_write(0x3c, 0x01);
                  mac_utils_spi_write(0x53, 0x49);
                  mac_utils_spi_write(0x54, 0x3d);
                  mac_utils_spi_write(0x59, 0xa9);
                  mac_utils_spi_write(0x5e, 0x4f);
                  mac_utils_spi_write(0x61, 0x00);
                  mac_utils_spi_write(0x66, 0x00);
                  mac_utils_spi_write(0x6b, 0xc0);
                  mac_utils_spi_write(0x6c, 0xfb);
                  mac_utils_spi_write(0x70, 0xc0);
                  mac_utils_spi_write(0x74, 0x07);
                  mac_utils_spi_write(0x78, 0x31);
                  mac_utils_spi_write(0x7f, 0x5b);
                  mac_utils_spi_write(0x4d, 0x51);
                  mac_utils_spi_write(0x4a, 0xaa);
                  mac_utils_spi_write(0x46, 0xab);
              
                  WriteU8Reg(0x401, 0x01);  /* ADC SPI Enable */
              
                  mac_utils_spi_write(0x00, 0x01);
                  mac_utils_spi_write(0x10, 0x00);
                  mac_utils_spi_write(0x11, 0x00);
                  mac_utils_spi_write(0x12, 0x00);
                  mac_utils_spi_write(0x13, 0x10);
                  mac_utils_spi_write(0x14, 0x00);
                  mac_utils_spi_write(0x16, 0x00);
                  mac_utils_spi_write(0x17, 0x00);
                  mac_utils_spi_write(0x18, 0x00);
                  mac_utils_spi_write(0x19, 0x00);
                  mac_utils_spi_write(0x1a, 0x00);
                  mac_utils_spi_write(0x1b, 0x00);
C51 COMPILER V9.53.0.0   GV701X_CFG                                                        11/04/2015 20:09:40 PAGE 19  

                  mac_utils_spi_write(0x1c, 0x00);
                  mac_utils_spi_write(0x1d, 0x00);
                  mac_utils_spi_write(0x1e, 0x00);
                  mac_utils_spi_write(0x1f, 0x00);
              
                  WriteU8Reg(0x417, 0x73);
                  WriteU8Reg(0x418, 0xff);
              
                  WriteU8Reg(0x414, 0x25); // For testing new AGC
                  WriteU8Reg(0x437, 0x13);
              }
              #endif
1101          #endif /* HYBRII_802154 */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2512    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =    173      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
