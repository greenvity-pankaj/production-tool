C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE DATAPATH
OBJECT MODULE PLACED IN .\obj\datapath.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\..\common\datapath\datapath.c LARGE OMF2 OPTIMIZE(9,SPEED) BROWSE INT
                    -VECTOR(0X2100) INCDIR(..\..\..\common\datapath;..\..\..\common\include;..\..\..\hal;..\..\src\crypto;..\..\src\ctrl;..\.
                    -.\src\hal;..\..\src\link;..\..\src\mux;..\..\src\nma;..\..\src\route;..\..\src\sap;..\..\src\test;..\..\..\project\hal\s
                    -rc;..\..\..\zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\u
                    -tilities\event\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\
                    -sampleapp\src;..\..\..\..\sampleapp\inc;..\..\..\common;..\..\..\hpgp;..\..\src;..\..\..\..\components\hpgp\inc;..\..\..
                    -\app_support;..\..\..\HybriiB_configuration_rw\src) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBRII_HPGP,CCO
                    -_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HYBRII_ETH,HPGP_MAC_SAP,NMA,HYBRII_SPI,NEW_SYN
                    -C,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,AUTH_AES,PLC_TEST,B_ASICPLC,UART_HOST_INTF_,UART_RAW,MPER_,FREQ_DETEC
                    -T,SW_RECOVERY,PROD_TEST) DEBUG PRINT(.\lst\datapath.lst) TABS(2) OBJECT(.\obj\datapath.obj)

line level    source

   1          
   2          #ifdef RTX51_TINY_OS
   3          #include <rtx51tny.h>
   4          #endif
   5          #include <stdio.h>
   6          #include <string.h>
   7          #include "fm.h"
   8          #include <intrins.h>
   9          #include "papdef.h"
  10          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  13          #include "fm.h"
  14          #include "hal_common.h"
  15          #include "hal.h"
  16          #include "hal_eth.h"
  17          #include "hal_tst.h"
  18          #include "hal_cfg.h"
  19          #include "hal_spi.h"
  20          #include "hpgpdef.h"
  21          #include "datapath.h"
  22          
  23          #include "papdef.h"
  24          //#include "crm.h"
  25          #ifdef UM
  26          #include "ctrll.h"
  27          #include "linkl.h"
  28          #include "timer.h"
  29          #include "stm.h"
  30          #endif
  31          #include "hpgpapi.h"
  32          
  33          
  34          #include "frametask.h"
  35          #include "hybrii_tasks.h"
  36          //#define printf(x)
  37          //#define FM_Printf(x, z)
  38          
  39          sConnState  ConnState[MAX_NUM_STATIONS];
  40          
  41          #ifdef POWERSAVE
              extern u32 psNoTxFrmCnt;
              extern u32 psTxFrmCnt;
              extern u32 psPlcTxWriteErrCnt;
              extern u32 psPlcIdleErrCnt;
              extern u32 psPlcTxOKCnt;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 2   

              extern u32 psPclTxWriteFromBcn;
              extern u32 psPclTxWriteFromFrame;
              extern u32 psFrmBcnNoTxFrmCnt;
              extern u32 psFrmBcnTxFrmCnt;
              extern u32 psFrmBcnPlcTxWriteErrCnt;
              extern u32 psFrmBcnPlcIdleErrCnt;
              extern u32 psFrmBcnPlcTxOKCnt;
              extern u32 psNoTxWrongBpFrmCnt;
              extern u32 psFrmBcnNoTxWrongBpFrmCnt;
              extern u32 psNoTxZeroAwdFrmCnt;
              extern u32 psFrmBcnNoTxZeroAwdFrmCnt;
              extern u8 psDebug;
              #endif
  60          
  61          #if defined(UM) || defined(HPGP_HAL_TEST)
  62          #include "mac_intf_common.h"
  63          #endif
  64          #include "utils.h"
  65          #ifdef UART_HOST_INTF
              #include "uart_driver.h"
              #endif
  68          
  69          #ifdef AUTO_PING
              #include "htm.h"
              #endif
  72          #include "utils.h"
  73          
  74          
  75          
  76          
  77          
  78          volatile dqueue_t gDqueue[MAX_DATA_QUEUES];
  79          
  80          extern u8 spi_payload_rx_pending;
  81          extern u8 gEthMacAddrDef[];
  82          
  83          #ifdef UM
  84          extern u8 xdata ufrm[];
  85          #endif
  86          
  87          extern u8 eth_plc_bridge;
  88          
  89          
  90          volatile u8 host_intf_max_cp =0;
  91          volatile u8 numHostCPs = 0;
  92          static u32 plcTxTime = 0;
  93          
  94          
  95                                   
  96          u8  gNekEks = HPGP_UNENCRYPTED_EKS;
  97          
  98          #ifdef DEBUG_DATAPATH
              extern u8 sigDbg;
              extern u8 pktDbg;
              extern u8 ethQueueDebug;
              
              #endif
 104          
 105          #ifdef FREQ_DETECT
 106          extern u32 PLC_MIN_AC_BPLEN;
 107          extern u32 PLC_AC_BP_LEN; 
 108          extern u32 PLC_MAX_AC_BPLEN; 
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 3   

 109          #endif
 110          #ifdef ETH_BRDG_DEBUG
              extern u8 myDebugFlag;
              
              extern u32 ethTxFrameCnt;
              extern u32 numEthTxCp;
              extern u32 plcRxFrameCnt;
              extern u8 myDebugFlag1;
              extern u32 numPlcPendingRet;
              extern u32 numForcePlcTxDone; 
              extern u32 numEthTxDoneInts;
              extern u32 numEthTxCpReleased;
              extern u32 numPlcTxCp;
              extern u32 plcTxWriteFail;
              extern u32 plcTxFrameCnt;
              
              extern u32 ethRxFrameCnt;
              extern u32 numTxDoneInts;
              
              
              
              extern u32 ethTxWriteFail;
              #endif
 132          
 133          #ifdef SPI_DEBUG
              extern u8 mySpiDebugFlag;
              extern hal_spi_stats_t hal_spi_stats;
              #endif
 137          
 138          #ifdef UM
 139          
 140          
 141          static void Host_MgmtCmdRxHandler(sHpgpHalCB *pHalCb, 
 142                                                sCommonRxFrmSwDesc* pRxFrmDesc,
 143                              u16 frmLen, u8 frmType);
 144          
 145          #endif
 146          
 147          void datapath_writeHostIntf(sSwFrmDesc *hostTxFrmSwDesc)
 148          {
 149   1      
 150   1        u16       crc16 = 0;
 151   1        
 152   1        eStatus     status;
 153   1      
 154   1        u8         firstCp = 0;
 155   1      
 156   1      
 157   1      
 158   1        if(hostIntf == HOST_INTF_ETH)
 159   1        {
 160   2      #ifdef HYBRII_ETH            
 161   2          status = EHAL_EthTxQWrite(hostTxFrmSwDesc);
 162   2      #endif //HYBRII_ETH
 163   2          if(status != STATUS_SUCCESS)
 164   2          {
 165   3      #ifdef ETH_BRDG_DEBUG
                    if (myDebugFlag1)
                      printf("EHT_SendToHost: EHAL_EthTxQWrite returned FAIL\n");
                    ethTxWriteFail++;
              #endif
 170   3              FM_Printf(FM_ERROR, "Tx to Eth Fail\n");
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 4   

 171   3          
 172   3                  gHpgpHalCB.halStats.PtoHswDropCnt++;
 173   3              // free CPs 
 174   3              CHAL_FreeFrameCp(hostTxFrmSwDesc->cpArr, hostTxFrmSwDesc->cpCount);
 175   3          } 
 176   2          numHostCPs -= hostTxFrmSwDesc->cpCount;
 177   2        }
 178   1      #ifdef HYBRII_SPI
 179   1        else if(hostIntf == HOST_INTF_SPI)
 180   1        {       
 181   2      
 182   2        
 183   2          // FM_Printf(FM_USER, "s t\n");
 184   2          status = hal_spi_tx_dma_cp(hostTxFrmSwDesc->frmLen, 
 185   2                         hostTxFrmSwDesc);
 186   2      
 187   2          if(status != STATUS_SUCCESS)
 188   2          {
 189   3            ///  FM_Printf(FM_ERROR, "Tx to SPI Failed\n");
 190   3      #ifdef SPI_DEBUG
                      hal_spi_stats.tx_return_err++;
                    if (mySpiDebugFlag)
                    {
                          printf("Tx to SPI Fail\n"); // TODO need to take action if tx failed
                    }
              #endif
 197   3                  gHpgpHalCB.halStats.PtoHswDropCnt++;
 198   3              // Free CPs
 199   3              CHAL_FreeFrameCp(hostTxFrmSwDesc->cpArr, hostTxFrmSwDesc->cpCount);
 200   3          }
 201   2      
 202   2          numHostCPs -= hostTxFrmSwDesc->cpCount;    
 203   2            
 204   2        }
 205   1      #endif  //HYBRII_SPI
 206   1      #ifdef UART_HOST_INTF //UART_16550
                else if(hostIntf == HOST_INTF_UART)
                {
                  if(hostTxFrmSwDesc->frmLen != 0)
                  {     
                    status = hal_uart_tx_cp (hostTxFrmSwDesc);
                    if(status != STATUS_SUCCESS)
                    {
              
                        CHAL_FreeFrameCp(hostTxFrmSwDesc->cpArr, hostTxFrmSwDesc->cpCount);
                    }
                    numHostCPs -= hostTxFrmSwDesc->cpCount;
                  }
                }
              
              #endif //UART_HOST_INTF
 222   1      
 223   1      
 224   1      
 225   1      }
 226          
 227          
 228          
 229          void datapath_handlePlcTxDone()
 230          {
 231   1      
 232   1        u8 tailIdx;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 5   

 233   1        sSwFrmDesc *lpPlcTxFrmSwDesc;
 234   1      #ifdef UART_HOST_INTF
                EA = 0;
              #endif
 237   1        if (1)
 238   1        {
 239   2      #ifdef ETH_BRDG_DEBUG
                  numTxDoneInts++;
              #endif
 242   2             
 243   2                
 244   2          tailIdx = gDqueue[PLC_DATA_QUEUE].tail & 0x7F;
 245   2      
 246   2          lpPlcTxFrmSwDesc =  &gDqueue[PLC_DATA_QUEUE].desc[tailIdx];
 247   2      
 248   2          if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_PENDING)
 249   2          {
 250   3            lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;        
 251   3      
 252   3            
 253   3      
 254   3      #ifdef DEBUG_DATAPATH                        
                    if (sigDbg)
                        FM_Printf(FM_ERROR," plc txDone t:%bu\n",gDqueue[PLC_DATA_QUEUE].tail);
              #endif   //DEBUG_DATAPATH         
 258   3          }
 259   2      
 260   2          
 261   2        }
 262   1      #ifdef UART_HOST_INTF
                EA = 1;
              #endif
 265   1      
 266   1      }
 267          void datapath_init()
 268          {
 269   1        memset((u8*)&gDqueue, 0, sizeof(gDqueue));
 270   1      }
 271          
 272          bool datapath_IsQueueFull(queue_id_e id)
 273          {
 274   1        u8 head = gDqueue[id].head;
 275   1        u8 tail = gDqueue[id].tail;
 276   1      #ifdef UART_HOST_INTF
                EA = 0;
              #endif
 279   1        if ((head & 0x7F) != (tail  & 0x7F)||
 280   1               ((head & 0x80) != (tail  & 0x80)))
 281   1        {
 282   2      
 283   2          // check if pending queue is full. if yes drop the frame or if not-full queue the frame
 284   2      
 285   2          if (((head & 0x80) != (tail  & 0x80)) &&
 286   2            ((head & 0x7F) == (tail  & 0x7F)))
 287   2          {
 288   3      
 289   3      #ifdef DEBUG_DATAPATH
                    if (sigDbg)
                    {
                      FM_Printf(FM_ERROR,"q id %bu full\n", id);
                    }
              
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 6   

              #endif
 296   3      #ifdef UART_HOST_INTF
                    EA = 1;
              #endif
 299   3            return TRUE;
 300   3      
 301   3      
 302   3          }
 303   2      
 304   2        }
 305   1      #ifdef UART_HOST_INTF
                EA = 1;
              #endif
 308   1          return FALSE;
 309   1      
 310   1      }
 311          
 312          extern u8 CHAL_GetFreeCPCnt() __REENTRANT__;
 313          
 314          void datapath_queue_depth(queue_id_e id)   
 315          {
 316   1        u8 head = gDqueue[id].head;
 317   1        u8 tail = gDqueue[id].tail;
 318   1      #ifndef MPER  
 319   1        printf ("h %bu \n ", head);
 320   1        
 321   1        printf ("t %bu \n ", tail);
 322   1        
 323   1          printf("fr = %bu\n",CHAL_GetFreeCPCnt());   
 324   1      #endif  
 325   1      }
 326          
 327          
 328          void datapath_queue(queue_id_e id,
 329                         sSwFrmDesc *pPlcTxFrmSwDesc)
 330          {
 331   1        u8 wrapBit;
 332   1          u8 indexHd;
 333   1        sSwFrmDesc *swDesc;
 334   1      
 335   1      #ifdef UART_HOST_INTF
                EA = 0;
              #endif
 338   1        indexHd = (gDqueue[id].head & 0x7F);       
 339   1      
 340   1        swDesc = &gDqueue[id].desc[indexHd];
 341   1        
 342   1        memcpy ((void*)swDesc, (void*)pPlcTxFrmSwDesc,
 343   1               sizeof(sSwFrmDesc)); 
 344   1      
 345   1        wrapBit = gDqueue[id].head & 0x80;
 346   1      
 347   1        swDesc->frmInfo.plc.status = 0;
 348   1      
 349   1      
 350   1        if (id == PLC_DATA_QUEUE)
 351   1        {
 352   2      
 353   2          host_intf_max_cp += pPlcTxFrmSwDesc->cpCount;
 354   2      
 355   2        }
 356   1      
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 7   

 357   1        gDqueue[id].head = ((gDqueue[id].head & 0x7F) + 1 ) | wrapBit;
 358   1        
 359   1        if ((gDqueue[id].head & 0x7F)== MAX_Q_BUFFER)
 360   1        {
 361   2          gDqueue[id].head ^= 0x80;     //inverse wraparound bit
 362   2          gDqueue[id].head &= 0x80;
 363   2        }
 364   1      
 365   1      #ifdef UART_HOST_INTF
                EA = 1;
              #endif
 368   1      }
 369          
 370          
 371          sSwFrmDesc *datapath_getHeadDesc(queue_id_e id, u8 pop)
 372          {
 373   1        u8 wrapBit;
 374   1        u8 tailIdx;
 375   1        sSwFrmDesc  *lpPlcTxFrmSwDesc;
 376   1      #ifdef UART_HOST_INTF
                EA = 0;
              #endif
 379   1        tailIdx = (gDqueue[id].tail & 0x7F);
 380   1        lpPlcTxFrmSwDesc =  &gDqueue[id].desc[tailIdx];
 381   1      
 382   1      
 383   1        if (pop)
 384   1        {
 385   2      
 386   2          wrapBit = gDqueue[id].tail & 0x80;
 387   2          gDqueue[id].tail = ((gDqueue[id].tail & 0x7F) + 1) | wrapBit;
 388   2      
 389   2          if (id == PLC_DATA_QUEUE)
 390   2          {
 391   3      
 392   3            host_intf_max_cp -= lpPlcTxFrmSwDesc->cpCount;
 393   3      
 394   3          }
 395   2          if ((gDqueue[id].tail & 0x7F) == MAX_Q_BUFFER)
 396   2          {
 397   3            gDqueue[id].tail ^= 0x80;     //inverse wraparound bi
 398   3            gDqueue[id].tail &= 0x80;
 399   3      
 400   3          }
 401   2      
 402   2      
 403   2      
 404   2        }
 405   1      #ifdef UART_HOST_INTF
                EA = 1;
              #endif
 408   1        return lpPlcTxFrmSwDesc;
 409   1      }
 410          
 411          bool datapath_IsQueueEmpty(queue_id_e id)
 412          {
 413   1      
 414   1        u8 head = gDqueue[id].head;
 415   1        u8 tail = gDqueue[id].tail;
 416   1      #ifdef UART_HOST_INTF
                EA = 0;
              #endif
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 8   

 419   1      
 420   1        if (((head & 0x7F) != (tail & 0x7F)||
 421   1           ((head & 0x80) != (tail & 0x80))))
 422   1        {
 423   2      
 424   2          return FALSE;
 425   2      
 426   2        }
 427   1      #ifdef UART_HOST_INTF
                EA = 1;
              #endif
 430   1        return TRUE;
 431   1      
 432   1      
 433   1      
 434   1      }
 435          
 436          
 437          
 438          void EHT_SetFrameTypeLen (u8* rxBcnByteArr, u8 frmType, u16 frmLen)
 439          {
 440   1          sMfHdr *mh_hdr;
 441   1          mh_hdr = (sMfHdr *)rxBcnByteArr;
 442   1          switch (frmType)
 443   1          {
 444   2             //MFT and MFL is not presend in Beacon and sound frames
 445   2              case HPGP_HW_FRMTYPE_MGMT:  // SOF frame
 446   2      #ifdef UM
 447   2                  memset(rxBcnByteArr, 0, (sizeof(sMfHdr) + CONFOUNDER_SIZE) );
 448   2      #endif
 449   2      
 450   2                  // Beacon should have different type
 451   2                  // SOF frame len + confounder
 452   2                  frmLen += CONFOUNDER_SIZE;
 453   2                  mh_hdr->mft = HPGP_HW_FRMTYPE_MGMT;
 454   2                  mh_hdr->mflHi = (frmLen >> 6) & 0xFF;
 455   2                  mh_hdr->mflLo =  (frmLen & 0x3F);
 456   2      
 457   2                  break;
 458   2              case HPGP_HW_FRMTYPE_MSDU: // Data frame
 459   2                  memset(rxBcnByteArr, 0, sizeof(sMfHdr));
 460   2                  mh_hdr->mft = HPGP_HW_FRMTYPE_MSDU;
 461   2                  mh_hdr->mflHi = (frmLen >> 6) & 0xFF;
 462   2                  mh_hdr->mflLo = frmLen & 0x3F;
 463   2                  break;
 464   2              default:
 465   2                  return;
 466   2          }
 467   1      
 468   1      
 469   1      }
 470          
 471          void EHT_FillEtherHeader (u8* rxBcnByteArr)
 472          {
 473   1          sEth2Hdr*  pEth2Hdr;
 474   1      
 475   1          pEth2Hdr = (sEth2Hdr*)rxBcnByteArr;
 476   1          pEth2Hdr->ethtype = 0x88E1;
 477   1          memset(pEth2Hdr->dstaddr, 0xFF, MAC_ADDR_LEN);
 478   1          memcpy(pEth2Hdr->srcaddr, gEthMacAddrDef, MAC_ADDR_LEN);
 479   1      }
 480          #if defined(UM) || defined(HPGP_HAL_TEST)
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 9   

 481          u8 ETH_FillHybriiHeader(u8 *rxArr,
 482                                  sSwFrmDesc *pPlcRxFrmSwDesc,
 483                                  u16 frameSize,
 484                                  u8 offset)
 485          {
 486   1          u8 addLen = 0;
 487   1          hostHdr_t *hostHdr;
 488   1      
 489   1          memset(rxArr, 0, sizeof(hostHdr_t));
 490   1          addLen = sizeof(hostHdr_t);
 491   1          hostHdr = (hostHdr_t *)rxArr;
 492   1          if(pPlcRxFrmSwDesc != NULL)
 493   1          {
 494   2              hostHdr->length     = frameSize;
 495   2              switch (pPlcRxFrmSwDesc->frmType)
 496   2              {
 497   3                  case HPGP_HW_FRMTYPE_SOUND:
 498   3      
 499   3                      hostHdr->rsvd       = offset;
 500   3                      break;
 501   3                  case HPGP_HW_FRMTYPE_MGMT:
 502   3      
 503   3                      hostHdr->type       = MGMT_FRM_ID;
 504   3                      hostHdr->protocol   = HPGP_MAC_ID;
 505   3                      //hostHdr->rsvd       = ((u16)offset << 8);
 506   3      
 507   3                      break;
 508   3      
 509   3                  case HPGP_HW_FRMTYPE_MSDU:
 510   3                      hostHdr->type       = DATA_FRM_ID;
 511   3                      hostHdr->protocol   = HPGP_MAC_ID;
 512   3                     // hostHdr->rsvd       = ((u16)offset << 8);
 513   3                      break;
 514   3                 default:
 515   3                      hostHdr->type       = 0x03;
 516   3                      hostHdr->protocol   = HPGP_MAC_ID;
 517   3                  //    hostHdr->rsvd       = ((u16)offset << 8);
 518   3              }
 519   2          }
 520   1          else
 521   1          {
 522   2              hostHdr->type       = MGMT_FRM_ID;
 523   2              hostHdr->protocol   = HPGP_MAC_ID;
 524   2           //   hostHdr->rsvd       = ((u16)offset << 8);
 525   2          }
 526   1          return (addLen);
 527   1      }
 528          #endif
 529          #ifdef HYBRII_ETH
 530          void EHT_FromPlcBcnTx (u8* rxBcnByteArr, u16 frameSize)
 531          {
 532   1          u16              dataIdx;
 533   1          u16              curFrmLen;
 534   1          u8               cpIdx;
 535   1          u8               len;
 536   1          eStatus          status;
 537   1          sSwFrmDesc      ethTxFrmSwDesc;
 538   1      
 539   1          if (frameSize == 0)
 540   1          {
 541   2              return;
 542   2          }
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 10  

 543   1      
 544   1          EHT_FillEtherHeader(rxBcnByteArr);
 545   1          len = sizeof(sEth2Hdr);
 546   1          ETH_FillHybriiHeader(&rxBcnByteArr[len],
 547   1                              NULL,
 548   1                              frameSize,
 549   1                              0);
 550   1          dataIdx                = 0;
 551   1          cpIdx                  = 0;
 552   1          // Smiffer expected 14 bytes ethernet header and 6 bytes Hybrii header
 553   1          curFrmLen              = frameSize + sizeof(sEth2Hdr)+ sizeof(hostHdr_t);  
 554   1      
 555   1          ethTxFrmSwDesc.frmLen  = curFrmLen;
 556   1          ethTxFrmSwDesc.cpCount = 0;
 557   1      
 558   1          while (curFrmLen)
 559   1          {
 560   2              u8                  cp;
 561   2              volatile u8 xdata * cellAddr;
 562   2              u8                  actualDescLen;
 563   2      
 564   2              status = CHAL_RequestCP(&cp);
 565   2              if (status != STATUS_SUCCESS)
 566   2              {
 567   3                  return;
 568   3              }
 569   2              cellAddr = CHAL_GetAccessToCP(cp);
 570   2              if (curFrmLen > HYBRII_CELLBUF_SIZE)
 571   2              {
 572   3                  actualDescLen = HYBRII_CELLBUF_SIZE;
 573   3              }
 574   2              else
 575   2              {
 576   3                  actualDescLen = curFrmLen;
 577   3              }
 578   2              memcpy(cellAddr, &rxBcnByteArr[dataIdx], actualDescLen);
 579   2              dataIdx += actualDescLen;
 580   2              ethTxFrmSwDesc.cpArr[cpIdx].offsetU32 = 0;
 581   2              ethTxFrmSwDesc.cpArr[cpIdx].len  = actualDescLen;
 582   2              ethTxFrmSwDesc.cpArr[cpIdx].cp = cp;
 583   2              cpIdx++;
 584   2              ethTxFrmSwDesc.cpCount++;
 585   2              curFrmLen -= actualDescLen;
 586   2          }
 587   1          status = EHAL_EthTxQWrite(&ethTxFrmSwDesc);
 588   1          if (status == STATUS_FAILURE)
 589   1          {
 590   2              for (cpIdx = 0; cpIdx < ethTxFrmSwDesc.cpCount; cpIdx++)
 591   2              {
 592   3                  CHAL_DecrementReleaseCPCnt(ethTxFrmSwDesc.cpArr[cpIdx].cp);
 593   3              }
 594   2              //printf("\nCannot send Eth packet");
 595   2          }
 596   1          else
 597   1          {
 598   2              gEthHalCB.CurTxTestFrmCnt++;
 599   2              gEthHalCB.CurTxTestBytesCnt+= frameSize;
 600   2          }
 601   1      }
 602          #endif
 603          u8 EHT_GetSniffHdrSize (eHpgpHwFrmType frmType)
 604          {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 11  

 605   1          u8 addLen = sizeof(sEth2Hdr);  // Ether header is common
 606   1      
 607   1          switch (frmType)
 608   1          {
 609   2              case HPGP_HW_FRMTYPE_SOUND:
 610   2                  addLen += (VF_SIZE);
 611   2                  break;
 612   2              case HPGP_HW_FRMTYPE_MGMT:
 613   2                  addLen += (VF_SIZE  + sizeof(sMfHdr) + CONFOUNDER_SIZE);
 614   2                  break;
 615   2              case HPGP_HW_FRMTYPE_MSDU:
 616   2                  addLen += (VF_SIZE + sizeof(sMfHdr));
 617   2              default:
 618   2                  break;
 619   2          }
 620   1      //#ifdef HPGP_MAC_SAP
 621   1          addLen += sizeof(hostHdr_t); // Len for hybrii header
 622   1      //#endif
 623   1      
 624   1      
 625   1          return (addLen);
 626   1      }
 627          #if 0
              u8 EHT_FillVariantField (u8*            rxBcnByteArr,
                                       sSwFrmDesc*  pPlcRxFrmSwDesc,
                                       uRxFrmHwDesc*  pRxPktQ1stDesc,
                                       uRxCpDesc*     pRxPktQCPDesc)
              {
                  u8 addLen = 0;
              
                  switch (pPlcRxFrmSwDesc->frmType)
                  {
                      case HPGP_HW_FRMTYPE_SOUND:
                          memset(rxBcnByteArr, 0, 16);
                          addLen = 16;
                          rxBcnByteArr[0]  = 0x04 | (pPlcRxFrmSwDesc->frmInfo.plc.snid << 4); // dt_av = 0b0 100
                          rxBcnByteArr[1]  = pPlcRxFrmSwDesc->frmInfo.plc.stei;
                          rxBcnByteArr[4]  = pRxPktQ1stDesc->sound.saf << 3 |
                                             pRxPktQ1stDesc->sound.scf << 4;
                          rxBcnByteArr[4]  = 0x3E;
                          rxBcnByteArr[8] = pRxPktQ1stDesc->sound.srcHi << 6 |
                                             pRxPktQ1stDesc->sound.srcLo;
                          break;
                      case HPGP_HW_FRMTYPE_MGMT:
                          memset(rxBcnByteArr, 0, 16);
                          addLen = 16;
                          rxBcnByteArr[0]  = 0x01 | (pPlcRxFrmSwDesc->frmInfo.plc.snid << 4); // dt_av = 0b0 100
                          rxBcnByteArr[1]  = pPlcRxFrmSwDesc->frmInfo.plc.stei;
                          rxBcnByteArr[4]  = pRxPktQCPDesc->plc.eks << 4;
                          rxBcnByteArr[8]  = 0x3E;
                          rxBcnByteArr[10] = pRxPktQ1stDesc->sof.mcst << 6;
                          rxBcnByteArr[11] = pRxPktQ1stDesc->sof.clst << 1;
                          break;
                      case HPGP_HW_FRMTYPE_MSDU:
                          memset(rxBcnByteArr, 0, 16);
                          addLen = 16;
                          rxBcnByteArr[0]  = 0x01 | (pPlcRxFrmSwDesc->frmInfo.plc.snid << 4); // dt_av = 0b0 100
                          rxBcnByteArr[1]  = pPlcRxFrmSwDesc->frmInfo.plc.stei;
                          rxBcnByteArr[4]  = pRxPktQCPDesc->plc.eks << 4;
                          rxBcnByteArr[8]  = 0x3E;
                          rxBcnByteArr[10] = pRxPktQ1stDesc->sof.mcst << 6;
                          rxBcnByteArr[11] = pRxPktQ1stDesc->sof.clst << 1;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 12  

                          break;
                      default:
                          break;
                  }
              
                  return (addLen);
              }
              #endif
 675          
 676          eStatus datapath_queueToHost (sSwFrmDesc*  pPlcRxFrmSwDesc,
 677                                        u16            frameSize)
 678          {
 679   1          u8                i, j, rsvd = 0;
 680   1          eStatus           status;
 681   1          u8                eth_hdr_cp = 0;
 682   1          u8 xdata          *cellAddr;  
 683   1       
 684   1          sSwFrmDesc        hostTxFrmSwDesc;
 685   1          u8                actualDescLen;
 686   1          u8                headerStart;
 687   1          
 688   1      #ifdef SW_RETRY
                  u16                pad = 0;
              #endif  //SW_RETRY
 691   1          u8                addFrameSize;
 692   1          u16               curFrmLen;
 693   1          u8                offsetAdj = 0; // 0 to 3 -  if hdrOffset is not align to 4 bytes then set
 694   1          u8 ptr;
 695   1                                          // offsetAdj to align hdrOffset
 696   1      
 697   1          u8 HybriLen;
 698   1      
 699   1          u16               crc16 = 0;
 700   1          u8                alin128 = 0;
 701   1      #ifdef MEM_PROTECTION
                u8          cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
              #endif
 704   1      
 705   1          status = STATUS_FAILURE;
 706   1      #ifdef UM
 707   1          if((numHostCPs + pPlcRxFrmSwDesc->cpCount) >= PLC_TO_HOST_MAX_CP)
 708   1          {
 709   2              // Return fail
 710   2              FM_Printf(FM_ERROR, "H CP lim\n");
 711   2          gHpgpHalCB.halStats.PtoHswDropCnt++;
 712   2            return (status);
 713   2          }
 714   1        numHostCPs += pPlcRxFrmSwDesc->cpCount;
 715   1      
 716   1      #endif  //HPGP_MAC_SAP        
 717   1          memset(&hostTxFrmSwDesc, 0, sizeof(sSwFrmDesc));
 718   1      
 719   1          if (frameSize == 0 || hostIntf == HOST_INTF_NO)
 720   1          {
 721   2              return (status);
 722   2          }
 723   1          if (pPlcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
 724   1          {
 725   2             
 726   2              pPlcRxFrmSwDesc->cpArr[0].offsetU32  = 1;
 727   2      
 728   2              
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 13  

 729   2              frameSize -= 4; // offset in first CP.
 730   2      
 731   2          }
 732   1      
 733   1          if(1 == eth_plc_sniffer)
 734   1          {
 735   2              status = CHAL_RequestCP(&eth_hdr_cp);
 736   2              if (status != STATUS_SUCCESS)
 737   2              {
 738   3                  //printf("\nFailed to allocate CP");     
 739   3      #ifdef UM
 740   3                  numHostCPs -= pPlcRxFrmSwDesc->cpCount;
 741   3      #endif  //HPGP_MAC_SAP
 742   3                  return (status);
 743   3              }
 744   2      #ifdef UM
 745   2              numHostCPs += 1;
 746   2      #endif  //HPGP_MAC_SAP
 747   2      #ifdef MEM_PROTECTION
                  if (HHAL_CP_Get_Copy(eth_hdr_cp, &cp_localBuf[0], HYBRII_CELLBUF_SIZE) == STATUS_FAILURE) 
                  {
                    printf("datapath_queueToHost: Failed to make a copy of CP %bu. Return\n", eth_hdr_cp);
                      return (STATUS_FAILURE);
                  }
                      cellAddr = &cp_localBuf[0];
              #else
 755   2              cellAddr = CHAL_GetAccessToCP(eth_hdr_cp);
 756   2      #endif
 757   2              addFrameSize = EHT_GetSniffHdrSize(pPlcRxFrmSwDesc->frmType);
 758   2      
 759   2              headerStart = (HYBRII_CELLBUF_SIZE - addFrameSize);
 760   2      
 761   2              offsetAdj = headerStart % sizeof(u32);
 762   2      
 763   2              addFrameSize += offsetAdj;
 764   2      
 765   2              headerStart -= offsetAdj;
 766   2      
 767   2              ptr = headerStart;
 768   2      
 769   2      
 770   2              EHT_FillEtherHeader(&cellAddr[ptr]);
 771   2      
 772   2      
 773   2              ptr += sizeof(sEth2Hdr);
 774   2              HybriLen = (frameSize + addFrameSize -
 775   2                          (sizeof(sEth2Hdr) + sizeof(hostHdr_t)));
 776   2      
 777   2      
 778   2      
 779   2              ETH_FillHybriiHeader(&cellAddr[ptr],
 780   2                                      pPlcRxFrmSwDesc,
 781   2                                      HybriLen,
 782   2                                      offsetAdj);
 783   2      
 784   2      
 785   2              ptr += (sizeof(hostHdr_t) + offsetAdj);
 786   2      
 787   2      /*
 788   2              EHT_FillVariantField(&cellAddr[ptr],
 789   2                                      pPlcRxFrmSwDesc,
 790   2                                      pRxPktQ1stDesc,
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 14  

 791   2                                      pRxPktQCPDesc);
 792   2      */
 793   2      //        memcpy(&cellAddr[ptr], (u8*)pPlcRxFrmSwDesc->fc, VF_SIZE);
 794   2      
 795   2              ptr += VF_SIZE;
 796   2      
 797   2              EHT_SetFrameTypeLen(&cellAddr[ptr],
 798   2                                      pPlcRxFrmSwDesc->frmType,
 799   2                                      frameSize);
 800   2      
 801   2              if (pPlcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
 802   2              {
 803   3      
 804   3                  ptr += sizeof(sMfHdr) + CONFOUNDER_SIZE;
 805   3      
 806   3              }
 807   2              else
 808   2              {
 809   3                  ptr += sizeof(sMfHdr);
 810   3      
 811   3              }
 812   2      #ifdef MEM_PROTECTION
                      if(HHAL_CP_Put_Copy(eth_hdr_cp, cp_localBuf, HYBRII_CELLBUF_SIZE) == STATUS_FAILURE)
                      {
                        printf("datapath_queueToHost: Failed to make a copy of CP %bu. Return\n", eth_hdr_cp);
                          return (STATUS_FAILURE);
                      }
              #endif
 819   2      #ifdef UM
 820   2      #if 0
                      hostTxFrmSwDesc->frmLen             = frameSize + addFrameSize;
                      hostTxFrmSwDesc->cpArr[0].cp        = eth_hdr_cp;
                      hostTxFrmSwDesc->cpArr[0].len       = addFrameSize;
                      hostTxFrmSwDesc->cpArr[0].offsetU32 = headerStart / sizeof(u32);
                      hostTxFrmSwDesc->cpCount            = 1;
              
              #else
 828   2      hostTxFrmSwDesc.frmLen             = frameSize + addFrameSize;
 829   2             hostTxFrmSwDesc.cpArr[0].cp        = eth_hdr_cp;
 830   2             hostTxFrmSwDesc.cpArr[0].len       = addFrameSize;
 831   2             hostTxFrmSwDesc.cpArr[0].offsetU32 = headerStart / sizeof(u32);
 832   2             hostTxFrmSwDesc.cpCount            = 1;
 833   2      
 834   2      
 835   2      #endif // 0
 836   2      
 837   2      #else
                      hostTxFrmSwDesc.frmLen             = frameSize + addFrameSize;
                      hostTxFrmSwDesc.cpArr[0].cp        = eth_hdr_cp;
                      hostTxFrmSwDesc.cpArr[0].len       = addFrameSize;
                      hostTxFrmSwDesc.cpArr[0].offsetU32 = headerStart / sizeof(u32);
                      hostTxFrmSwDesc.cpCount            = 1;
              #endif  //HPGP_MAC_SAP
 844   2      
 845   2      
 846   2          }
 847   1          else
 848   1          {                        
 849   2      
 850   2              if(hostIntf == HOST_INTF_SPI)
 851   2              {
 852   3                  
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 15  

 853   3      #ifdef HYBRII_SPI
 854   3      
 855   3              status = CHAL_RequestCP(&eth_hdr_cp);
 856   3      
 857   3                  if (status != STATUS_SUCCESS)
 858   3                  {
 859   4                      FM_Printf(FM_USER, "\nSPI - Failed to alloc CP");
 860   4                      numHostCPs -= pPlcRxFrmSwDesc->cpCount;
 861   4                      return (status);
 862   4                  }
 863   3      
 864   3                  numHostCPs += 1;
 865   3                  
 866   3                  cellAddr = CHAL_GetAccessToCP(eth_hdr_cp);
 867   3                  // addFrameSize = sizeof(hostHdr_t) + rsvd  + sizeof(hybrii_tx_req_t);        
 868   3      
 869   3                  addFrameSize = sizeof(hybrii_tx_req_t); 
 870   3      
 871   3                  headerStart = sizeof(hybrii_tx_req_t);
 872   3      #ifdef HYBRII_B
 873   3                  hostTxFrmSwDesc.frmLen       = frameSize + addFrameSize;
 874   3      #else
                          hostTxFrmSwDesc.frmLen       = frameSize + addFrameSize + SPI_CRC_LEN ;
              #endif
 877   3      #ifdef SW_RETRY
              
                          //        pHybrii->rsvd += pad;
              #endif  //SW_RETRY
 881   3      
 882   3                  hostTxFrmSwDesc.cpArr[0].cp        = eth_hdr_cp;
 883   3      #ifndef HYBRII_B
                          for (j = headerStart; j < addFrameSize; j++) {
                              crc16 = crc_ccitt_update(crc16, cellAddr[j]);
                          }
              #endif
 888   3                  hostTxFrmSwDesc.cpArr[0].offsetU32 = 0;
 889   3                  hostTxFrmSwDesc.cpArr[0].len      = addFrameSize;        
 890   3                  hostTxFrmSwDesc.cpCount            = 1;
 891   3      #endif  //HYBRII_SPI
 892   3      
 893   3      
 894   3              }else
 895   2              {
 896   3                  hostTxFrmSwDesc.cpCount            = 0;
 897   3                  hostTxFrmSwDesc.frmLen             = frameSize;
 898   3      
 899   3              }
 900   2      
 901   2          }
 902   1      
 903   1          curFrmLen = frameSize;  
 904   1          alin128 = frameSize % HYBRII_CELLBUF_SIZE;
 905   1          for (i = 0 ; i < pPlcRxFrmSwDesc->cpCount ; i++)
 906   1          {
 907   2      
 908   2      
 909   2              if(hostIntf == HOST_INTF_SPI)
 910   2              {
 911   3                cellAddr =
 912   3                    CHAL_GetAccessToCP(pPlcRxFrmSwDesc->cpArr[i].cp);
 913   3          }
 914   2      #ifdef DEBUG_DATAPATH   
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 16  

                  else
                  {
                    cellAddr =
                    CHAL_GetAccessToCP(pPlcRxFrmSwDesc->cpArr[i].cp);
              
                  }
              
              #endif
 923   2      
 924   2              if (i == 0)
 925   2              {
 926   3                  actualDescLen = ((curFrmLen < HYBRII_CELLBUF_SIZE)? curFrmLen : (HYBRII_CELLBUF_SIZE -
 927   3                                   (pPlcRxFrmSwDesc->cpArr[i].offsetU32 *4)));
 928   3              }
 929   2              else
 930   2              if (curFrmLen > HYBRII_CELLBUF_SIZE)
 931   2              {
 932   3                  actualDescLen = HYBRII_CELLBUF_SIZE;
 933   3              }
 934   2              else
 935   2              {
 936   3                  actualDescLen = curFrmLen;
 937   3              }
 938   2      
 939   2              
 940   2      #ifdef DEBUG_DATAPATH
              
                      if (pktDbg || sigDbg)
                          FM_Printf(FM_ERROR,"p rx\n");
              
              #endif  //DEBUG_DATAPATH
 946   2      
 947   2              if(hostIntf == HOST_INTF_SPI)
 948   2              {
 949   3      #ifndef HYBRII_B
                          for (j = 0; j < actualDescLen; j++) {
                              crc16 = crc_ccitt_update(crc16, cellAddr[j]);
                          }
              #endif
 954   3      
 955   3      #ifdef DEBUG_DATAPATH
              
                              if (pktDbg) {
                                  FM_HexDump(FM_ERROR,"SPI: ", cellAddr, actualDescLen);
                              }
              #endif  //DEBUG_DATAPATH                
 961   3      #ifndef HYBRII_B        
                          if(actualDescLen <= (HYBRII_CELLBUF_SIZE - SPI_CRC_LEN))
                          {
                              cellAddr[j] = crc16 & 0xFF;
                              j++;
                              cellAddr[j] = (crc16 >> 8) & 0xFF;
                              actualDescLen += SPI_CRC_LEN;
                              
                          }
                          else if(actualDescLen == (HYBRII_CELLBUF_SIZE - 1) && 
                                      alin128 == (HYBRII_CELLBUF_SIZE - 1)) // len chech of descriptor (127)
                          {
                              cellAddr[j] = crc16 & 0xFF;
                              actualDescLen += (SPI_CRC_LEN - 1);
                          }
                          else if(actualDescLen != HYBRII_CELLBUF_SIZE)
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 17  

                          {
                              FM_Printf(FM_ERROR, "Error in adding CRC\n");
                          }
              #endif
 981   3            }
 982   2              
 983   2      #ifdef DEBUG_DATAPATH
                  else
                   {
                  if (pktDbg)
                  {    
                    FM_HexDump(FM_ERROR,"", cellAddr, actualDescLen);
                  }
                   }
              #endif  //DEBUG_DATAPATH
 992   2      
 993   2             
 994   2              
 995   2              if(1 == eth_plc_sniffer)
 996   2              {
 997   3      #ifdef UM
 998   3                  hostTxFrmSwDesc.cpArr[i+1].offsetU32 = pPlcRxFrmSwDesc->cpArr[i].offsetU32;
 999   3                  hostTxFrmSwDesc.cpArr[i+1].len = actualDescLen;
1000   3                  hostTxFrmSwDesc.cpArr[i+1].cp  = pPlcRxFrmSwDesc->cpArr[i].cp;
1001   3      #else
                          hostTxFrmSwDesc.cpArr[i+1].offsetU32 = pPlcRxFrmSwDesc->cpArr[i].offsetU32;
                          hostTxFrmSwDesc.cpArr[i+1].len = actualDescLen;
                          hostTxFrmSwDesc.cpArr[i+1].cp  = pPlcRxFrmSwDesc->cpArr[i].cp;
              #endif  //HPGP_MAC_SAP
1006   3              }
1007   2              else
1008   2              {
1009   3                  if(hostIntf == HOST_INTF_SPI)
1010   3                  {
1011   4      
1012   4                      hostTxFrmSwDesc.cpArr[i+1].offsetU32 = 0;
1013   4                      hostTxFrmSwDesc.cpArr[i+1].len = actualDescLen;
1014   4                      hostTxFrmSwDesc.cpArr[i+1].cp  = pPlcRxFrmSwDesc->cpArr[i].cp;
1015   4      
1016   4                  }
1017   3                  else
1018   3                  {
1019   4      
1020   4                      hostTxFrmSwDesc.cpArr[i].offsetU32 = 0;
1021   4                      hostTxFrmSwDesc.cpArr[i].len = actualDescLen;
1022   4                      hostTxFrmSwDesc.cpArr[i].cp  = pPlcRxFrmSwDesc->cpArr[i].cp;
1023   4      
1024   4                  }
1025   3      
1026   3              }
1027   2      
1028   2              hostTxFrmSwDesc.cpCount++;
1029   2              curFrmLen -= actualDescLen;
1030   2      
1031   2          }
1032   1      
1033   1      #ifdef DEBUG_DATAPATH
              
                  if (pktDbg)
                      FM_Printf(FM_ERROR,"rx end\n");
              #endif  //DEBUG_DATAPATH
1038   1      #ifndef HYBRII_B
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 18  

                  if(hostIntf == HOST_INTF_SPI)
                  {
                      // If crc need to be added in next CP
                      if(alin128 == (HYBRII_CELLBUF_SIZE - 1) || alin128 == 0)
                      {
                          status = CHAL_RequestCP(&eth_hdr_cp);
                          if (status != STATUS_SUCCESS)
                          {
                              FM_Printf(FM_ERROR, "\nFailed to alloc CP");
                              numHostCPs -= (pPlcRxFrmSwDesc->cpCount + 1);
                              return (status);
                          }
                          numHostCPs += 1;
                          cellAddr = CHAL_GetAccessToCP(eth_hdr_cp);
                          if(alin128 == 0)
                          {
                              cellAddr[0] = crc16 & 0xFF;
                              cellAddr[1] = (crc16 >> 8) & 0xFF;
                          }
                          else
                          {
                              cellAddr[0] = (crc16 >> 8) & 0xFF;
                          }
              #ifdef UM        
                          hostTxFrmSwDesc.cpArr[i+1].offsetU32 = 0;
                          hostTxFrmSwDesc.cpArr[i+1].len = (alin128 == 0)? SPI_CRC_LEN:1;
                          hostTxFrmSwDesc.cpArr[i+1].cp  = eth_hdr_cp;
                          hostTxFrmSwDesc.cpCount++;
              #else
                          hostTxFrmSwDesc.cpArr[i+1].offsetU32 = 0;
                          hostTxFrmSwDesc.cpArr[i+1].len = (alin128 == 0)? SPI_CRC_LEN:1;
                          hostTxFrmSwDesc.cpArr[i+1].cp  = eth_hdr_cp;
                          hostTxFrmSwDesc.cpCount++;
              #endif  //HPGP_MAC_SAP
                      }
                  }
              #endif //HYBRII_B
1076   1      #ifdef AUTO_PING
                      {
              //            sEth2Hdr *pEthHdr;
                    volatile u8 xdata * cellAddr1stCP;
                          u8 stei;
              #if 1
                          cellAddr1stCP  = CHAL_GetAccessToCP(pPlcRxFrmSwDesc->cpArr[0].cp);
                          stei = pPlcRxFrmSwDesc->frmInfo.plc.stei;
                          
                          if (HHAL_RcvPing((sEth2Hdr*)cellAddr1stCP, stei) == TRUE)
                          {
                              CHAL_DecrementReleaseCPCnt(eth_hdr_cp);
              #ifdef UM
                              numHostCPs -= pPlcRxFrmSwDesc->cpCount;
              #endif  //HPGP_MAC_SAP
                              return STATUS_FAILURE; // To let caller free PLC CPs
                          }
              #endif
              
              
                      }
              
              
              
              #endif //AUTO_PING
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 19  

1101   1          if(hostIntf == HOST_INTF_SPI)
1102   1          {
1103   2      #ifdef HYBRII_SPI
1104   2      
1105   2              hostTxFrmSwDesc.frmLen -= sizeof(hybrii_tx_req_t);
1106   2      #endif  //HYBRII_SPI
1107   2          }
1108   1      #if 1 //def HPGP_MAC_SAP
1109   1      
1110   1          if (datapath_IsQueueFull(HOST_DATA_QUEUE) == TRUE)
1111   1          {
1112   2      
1113   2              
1114   2              numHostCPs -= hostTxFrmSwDesc.cpCount;
1115   2      if(hostIntf == HOST_INTF_SPI)
1116   2              {
1117   3                  
1118   3      #ifdef HYBRII_SPI        
1119   3                CHAL_DecrementReleaseCPCnt(eth_hdr_cp);
1120   3      #endif
1121   3          }
1122   2              return STATUS_FAILURE;
1123   2                  
1124   2          }
1125   1      
1126   1        
1127   1        
1128   1      #ifdef ETH_BRDG_DEBUG
                  plcRxFrameCnt++;
              #endif
1131   1        os_set_ready(HYBRII_TASK_ID_FRAME);
1132   1        datapath_queue(HOST_DATA_QUEUE, &hostTxFrmSwDesc);
1133   1      
1134   1        
1135   1          status = STATUS_SUCCESS;
1136   1      #else
                  if(hostIntf == HOST_INTF_SPI)
                  {
              #ifdef HYBRII_SPI
                      hal_spi_tx_cleanup ();
                      hal_spi_rx_cleanup ();
                      hostTxFrmSwDesc.frmLen -= sizeof(hybrii_tx_req_t);
                      status = hal_spi_tx_dma_cp(hostTxFrmSwDesc.frmLen, &hostTxFrmSwDesc);
              #endif  //HYBRII_SPI
                  }
                  else if(hostIntf == HOST_INTF_ETH)
                  {
                      status = EHAL_EthTxQWrite(&hostTxFrmSwDesc);
                  }
                  
                  if (status == STATUS_FAILURE)
                  {
                      if((eth_plc_sniffer)
              #ifdef HPGP_MAC_SAP
                          || (1)
              #endif  //HPGP_MAC_SAP
                          )
                      {
                          CHAL_DecrementReleaseCPCnt(eth_hdr_cp);
                      }
                     FM_Printf(FM_ERROR,"\nCan not send packet to interface");
                  }
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 20  

              #endif  // 1
1164   1      
1165   1      
1166   1        return STATUS_SUCCESS;
1167   1      
1168   1      }
*** WARNING C280 IN LINE 679 OF ..\..\..\common\datapath\datapath.c: 'j': unreferenced local variable
1169          
1170          
1171          #ifndef HYBRII_FPGA
1172          void datapath_transmitDataHost()
1173          {
1174   1        sSlink *slink = NULL;
1175   1        sSwFrmDesc* tHostTxFrmSwDesc = NULL;
1176   1        sSwFrmDesc hostTxFrmSwDesc;
1177   1      
1178   1        eStatus status = STATUS_FAILURE;
1179   1      
1180   1          // If Eth interface
1181   1          if((tHostTxFrmSwDesc = 
1182   1                        datapath_getHeadDesc(HOST_DATA_QUEUE, 1)) != NULL)
1183   1          {
1184   2               memcpy((u8*)&hostTxFrmSwDesc,
1185   2              (u8*)tHostTxFrmSwDesc, sizeof(hostTxFrmSwDesc));
1186   2      
1187   2      
1188   2      
1189   2          datapath_writeHostIntf(&hostTxFrmSwDesc);
1190   2          
1191   2          }
1192   1      
1193   1        
1194   1      } 
1195          #endif   //HYBRII_FPGA
1196          /*
1197          -------------------------------------------------------------------------
1198          
1199          
1200            HAL_ETH.C
1201          
1202          ----------------=======================================----------------------=-------------=-
1203          */
1204          
1205          eStatus hostRxPostProcess(sSwFrmDesc *plcTxFrmSwDesc)
1206          {
1207   1        
1208   1        u8 dropFrame=0;
1209   1        sEth2Hdr *pktEthHdr;
1210   1        u8 dstTei=0;
1211   1        sHpgpHalCB *hhalCb;
1212   1      #ifdef UM 
1213   1        sHaLayer *hal;
1214   1        sLinkLayer *linkLayer;
1215   1        sStaInfo *staInfo = NULL;
1216   1      #endif
1217   1      
1218   1      #ifdef UM
1219   1        
1220   1        xdata u8 *cellAddr;
1221   1      
1222   1        linkLayer = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1223   1        staInfo = LINKL_GetStaInfo(linkLayer);  
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 21  

1224   1        
1225   1        if(plcTxFrmSwDesc->frmInfo.plc.dtei == 0 )
1226   1        {
1227   2          cellAddr = CHAL_GetAccessToCP(plcTxFrmSwDesc->cpArr[0].cp);
1228   2      
1229   2          pktEthHdr = ((sEth2Hdr*)cellAddr);
1230   2          if ((pktEthHdr->dstaddr[0] & 0x01))
1231   2          {
1232   3      
1233   3          /*
1234   3          Note : dstTei should be set to 0xFF for broadcast frame.
1235   3          Has to be revisited. 0xFF was getting dropped by receiver
1236   3      
1237   3          */
1238   3      
1239   3            dstTei = 0xFF;
1240   3      
1241   3          }
1242   2          else
1243   2          {
1244   3            sScb* dstScb = NULL;
1245   3            
1246   3            sCnam *ccoNam = &linkLayer->ccoNam;
1247   3            u8 devmode = LINKL_GetMode(linkLayer);
1248   3      
1249   3            //dstScb = CRM_FindScbMacAddr(&pktEthHdr->dstaddr);
1250   3            {
1251   4            //sScb* dstScb = NULL;
1252   4            //sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1253   4              sCrm      *crm = LINKL_GetCrm(linkLayer);
1254   4              dstScb = CRM_GetNextScb(crm, dstScb);
1255   4              while(dstScb)
1256   4              {
1257   5                if(memcmp(&pktEthHdr->dstaddr, &dstScb->macAddr, MAC_ADDR_LEN) == 0)
1258   5                {
1259   6                  break;
1260   6                }
1261   5                dstScb = CRM_GetNextScb(crm, dstScb);
1262   5              }
1263   4            }
1264   3      
1265   3            if (!dstScb)
1266   3            {
1267   4              dropFrame = 1;
1268   4              FM_Printf(FM_ERROR,"post proc drop\n");
1269   4      #if 0
                      FM_HexDump(FM_USER,"DST Address",&pktEthHdr->dstaddr,MAC_ADDR_LEN);
              #endif
1272   4            }
1273   3            else
1274   3            {
1275   4              if(devmode == LINKL_STA_MODE_STA)
1276   4              {
1277   5                if(0)//staInfo->staStatus.fields.authStatus != 1)
1278   5                {
1279   6                  
1280   6                // dropFrame = 1;
1281   6                }
1282   5              }
1283   4      
1284   4              else if(devmode == LINKL_STA_MODE_CCO)
1285   4              {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 22  

1286   5                if(0)//dstScb->staStatus.fields.authStatus != 1)
1287   5                {
1288   6                  //dropFrame = 1;
1289   6                }
1290   5              }
1291   4              else
1292   4              {
1293   5                dropFrame = 1;
1294   5              }
1295   4      #ifdef ROUTE
                      if(dstScb->lrtEntry.routeIsInvalid == TRUE || dstScb->lrtEntry.routeOnHold == TRUE)
                      {
                        dropFrame = 1;
                        FM_Printf(FM_USER,"Route drop\n");
                      }
                      else
                      {
                        dstTei = dstScb->lrtEntry.nTei;
                      }
              #else
1306   4              dstTei = dstScb->tei;
1307   4      #endif
1308   4            }
1309   3      
1310   3      
1311   3          }
1312   2      #else
                  dstTei = 1;
              #endif
1315   2      
1316   2          if(1 == dropFrame)
1317   2          {
1318   3          //FM_Printf(FM_USER,"Frame dropped\n");
1319   3            datapath_getHeadDesc(PLC_DATA_QUEUE, 1);
1320   3            CHAL_FreeFrameCp(plcTxFrmSwDesc->cpArr,plcTxFrmSwDesc->cpCount);
1321   3            return STATUS_FAILURE;
1322   3          }
1323   2      
1324   2      
1325   2          if (dstTei == 0xFF)
1326   2          {
1327   3            plcTxFrmSwDesc->frmInfo.plc.mcstMode     = HPGP_MCST;
1328   3              
1329   3            plcTxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_MCFRPT;
1330   3          }
1331   2          else
1332   2          {
1333   3            plcTxFrmSwDesc->frmInfo.plc.mcstMode     = HPGP_UCST;  // Unicast
1334   3          }
1335   2      
1336   2      
1337   2      #ifdef HPGP_HAL_TEST
                  hhalCb = &gHpgpHalCB;
              #else
1340   2          hal = (sHaLayer*)HOMEPLUG_GetHal();
1341   2      
1342   2          hhalCb = hal->hhalCb;
1343   2      #endif
1344   2      
1345   2      #ifdef HPGP_HAL_TEST
                  plcTxFrmSwDesc->frmInfo.plc.eks =  gNekEks; //HPGP_UNENCRYPTED_EKS;
                  plcTxFrmSwDesc->frmInfo.plc.dtei           = hhalCb->remoteTei;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 23  

                  plcTxFrmSwDesc->frmInfo.plc.stei           = hhalCb->selfTei;//HYBRII_DEFAULT_TEISTA;
              #else
1350   2        
1351   2          plcTxFrmSwDesc->frmInfo.plc.eks = staInfo->nekEks;//HPGP_UNENCRYPTED_EKS;
1352   2      #endif
1353   2          plcTxFrmSwDesc->frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
1354   2          plcTxFrmSwDesc->frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
1355   2          plcTxFrmSwDesc->frmType        = HPGP_HW_FRMTYPE_MSDU;
1356   2      
1357   2      #ifdef UM
1358   2          if(linkLayer->mode == LINKL_STA_MODE_CCO)
1359   2          {
1360   3      
1361   3          //    FM_Printf(FM_USER, "f cc\n");
1362   3      #ifdef CCO_FUNC               
1363   3            plcTxFrmSwDesc->frmInfo.plc.dtei      = dstTei;
1364   3            plcTxFrmSwDesc->frmInfo.plc.stei      = staInfo->ccoScb->tei;
1365   3      #endif
1366   3          }
1367   2          else
1368   2          {
1369   3      #ifdef STA_FUNC
1370   3            plcTxFrmSwDesc->frmInfo.plc.dtei      = dstTei;//staInfo->ccoScb->tei;
1371   3            plcTxFrmSwDesc->frmInfo.plc.stei      = staInfo->tei;
1372   3      #endif
1373   3      
1374   3          }
1375   2      
1376   2          } 
1377   1      #endif  
1378   1        plcTxFrmSwDesc->frmInfo.plc.plid = 0;   //[YM] This line of code has to be changed base on differnet QoS 
             -priority
1379   1      
1380   1      
1381   1        if (plcTxFrmSwDesc->frmInfo.plc.plid == 0)
1382   1        {
1383   2          plcTxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
1384   2        }
1385   1        else
1386   1        {
1387   2          plcTxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP123;
1388   2        }
1389   1      
1390   1      #ifdef UM
1391   1      
1392   1        plcTxFrmSwDesc->frmInfo.plc.snid = staInfo->snid;
1393   1      
1394   1      
1395   1      #endif
1396   1      
1397   1      #if 1 //def HPGP_HAL_TEST
1398   1        plcTxFrmSwDesc->frmInfo.plc.stdModeSel     = STD_ROBO_TEST; // std robo
1399   1      #endif
1400   1        plcTxFrmSwDesc->frmInfo.plc.dt_av = HPGP_DTAV_SOF;
1401   1        plcTxFrmSwDesc->frmInfo.plc.saf = 1;
1402   1      
1403   1          
1404   1        return STATUS_SUCCESS;
1405   1      }
1406          
1407          
1408          #ifdef POWERSAVE
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 24  

              void datapath_transmitDataPlc(u8 from)
              #else
1411          void datapath_transmitDataPlc()
1412          #endif
1413          {
1414   1        // their is something queued in hea
1415   1        eStatus status;
1416   1      #ifndef HPGP_HAL_TEST    
1417   1        sHaLayer *hal;
1418   1      #endif    
1419   1        sHpgpHalCB *hhalCb;
1420   1        u8  RegValue;
1421   1        u8   TxLoop;
1422   1        uPlcTxPktQCAP_Write   cap_write;
1423   1      #ifdef POWERSAVE
                  sLinkLayer    *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sStaInfo      *staInfo = LINKL_GetStaInfo(linkLayer);
                sScb          *scb;
                sScb          *dstScb;
                u32 ntb=0;
                u32 bpst=0;
                u32 timeDiff=0;
                sPsSchedule commAwd;
                u8 tmpPss;
                u8 dtei;
                u8 modVal;
                u32 tmpBpCnt;
              #endif
1437   1      
1438   1      #ifdef HPGP_HAL_TEST
                hhalCb = &gHpgpHalCB;
              #else
1441   1        hal = (sHaLayer*)HOMEPLUG_GetHal();
1442   1      
1443   1        hhalCb = hal->hhalCb;
1444   1      #endif
1445   1          TxLoop = 0;
1446   1        RegValue = 0;
1447   1      SWQCheckAgain:
1448   1      
1449   1      
1450   1      #if 1
1451   1          //RegValue = ReadU32Reg(PLC_CMDQ_STAT);
1452   1        //[YM] check CMD queue count
1453   1        RegValue = ReadU8Reg(0xEAC);         //Check CMD queue number
1454   1        if (RegValue > 0)
1455   1        {
1456   2            uPlcStatusReg         plcStatus;
1457   2      
1458   2           //printf("RegValue = %bX\n", RegValue);
1459   2           cap_write.capw.CapRdy = 1;   //[YM] Temporary set CAP 0 packet only
1460   2           WriteU32Reg(PLC_CAP_REG, cap_write.reg);
1461   2      
1462   2           plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1463   2           plcStatus.s.plcTxQRdy = 1;
1464   2           WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1465   2        }
1466   1      #endif
1467   1      
1468   1        if (datapath_IsQueueEmpty(PLC_DATA_QUEUE)
1469   1                    == FALSE )
1470   1        {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 25  

1471   2          sSwFrmDesc  *lpPlcTxFrmSwDesc;
1472   2      
1473   2          lpPlcTxFrmSwDesc =
1474   2                  datapath_getHeadDesc(PLC_DATA_QUEUE, 0);
1475   2      
1476   2          if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_PENDING)
1477   2          {
1478   3      #ifdef  HPGP_HAL_TEST_DONT_DO_THIS
                    if( MAX_PLC_TX_TIMEOUT < (get_TimerTick() - plcTxTime))
                    {
                      lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;
              #ifdef ETH_BRDG_DEBUG
                      numForcePlcTxDone++; 
                      if (myDebugFlag)
                        printf("LM Forcing PLC TX Done\n");
              #endif
                    }
              #endif
1489   3            // Tx timeout handling to release Tx pending flag
1490   3      #ifdef HPGP_HAL_TEST_DONT_DO_THIS           
                    if( MAX_PLC_TX_TIMEOUT < (STM_GetTick() - plcTxTime))
                    {
                      lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;
              #if 1 //def DEBUG_DATAPATH
                      if(1)
                      {
                        FM_Printf(FM_USER, "Missing PLC TX Done\n");
                      }
              #endif
                    }
              #endif
1502   3            /*
1503   3                 we dont process next frame until TX_PENDING is cleared
1504   3              */
1505   3      
1506   3      #ifdef ETH_BRDG_DEBUG
                    numPlcPendingRet++;
              #endif      
1509   3      
1510   3          //rajantbd  os_set_ready(HYBRII_TASK_ID_FRAME); 
1511   3            return;
1512   3          }
1513   2          else 
1514   2          if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_DONE)
1515   2          {
1516   3            
1517   3            lpPlcTxFrmSwDesc->frmInfo.plc.status = 0;        
1518   3            
1519   3          //        FM_Printf(FM_USER, "pop\n");
1520   3            datapath_getHeadDesc(PLC_DATA_QUEUE, 1);
1521   3            goto SWQCheckAgain;
1522   3          }
1523   2      
1524   2        }
1525   1        
1526   1        if (datapath_IsQueueEmpty(PLC_DATA_QUEUE)
1527   1                      == FALSE )
1528   1      
1529   1        {
1530   2        
1531   2          sSwFrmDesc  *lpPlcTxFrmSwDesc;  
1532   2      
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 26  

1533   2          RegValue = ReadU8Reg(0xEAC);         //Check CMD queue number
1534   2        //if (RegValue > 0)            // [YM] Push multiple paclets to Tx queue
1535   2            status = HHAL_IsPlcIdle();
1536   2        //else
1537   2        //  status = STATUS_SUCCESS;
1538   2      
1539   2          if (status == STATUS_SUCCESS)
1540   2          {
1541   3            lpPlcTxFrmSwDesc =
1542   3                datapath_getHeadDesc(PLC_DATA_QUEUE, 0);
1543   3      
1544   3      //      lpPlcTxFrmSwDesc->frmInfo.plc.retry = 0;
1545   3      
1546   3      #ifdef POWERSAVE
                  if (psDebug)
                  {
                    printf("tx plc(from=%bu):\n", from);
                  }
                  if (from == 1)
                    psPclTxWriteFromBcn++;
                  else psPclTxWriteFromFrame++;
              
                  if (hhalCb->psInSleepMode == TRUE)
                    // in Sleep mode, can't Tx
                    return;
                  // STA should only talk to CCO in our implementation.
                  memset(&commAwd, 0, sizeof(sPsSchedule));
                  dtei = lpPlcTxFrmSwDesc->frmInfo.plc.dtei;
              
                  if( hhalCb->devMode == DEV_MODE_STA)
                  {
                    u8 dteiIsCco = 0; // 0: unknown, 1: CCO's TEI, 2: broadcast
              
                    scb = staInfo->staScb;
                    if (scb)
                    {
                      if (scb->psState == PSM_PS_STATE_ON)
                      {
                        if (dtei == staInfo->ccoScb->tei)
                        {
                          // DTEI is CCO, use STA's common AWD
                          memcpy(&commAwd, &scb->commAwd, sizeof(sPsSchedule));
                        }
                        else
                        {
                        if (psDebug)
                          printf("txPlc: STA: dtei %bu is not CCO\n", dtei);
                          // any other types, ie. broadcast, just use STA's PSS
                          PSM_cvrtPss_Awd(scb->pss, &commAwd);
                        }
                      }
                    }
                    else
                    {
                      if (psDebug)
                        printf("txPlc: STA: scb=NULL\n");
                    }
                  }
                  else
                  {
                    scb = staInfo->ccoScb;
                    if (scb)
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 27  

                    {
                      if (scb->psState == PSM_PS_STATE_ON)
                      {
                        if (dtei == 0xFF)
                        {
                          // DTEI is broadcast, use CCO's common AWD
                          memcpy(&commAwd, &scb->commAwd, sizeof(sPsSchedule));
                        }
                        else
                        {
                          // DTEI is unicast, get the smaller of the 2 AWDs
                          if ((dstScb = CRM_GetScb(&linkLayer->ccoRm, dtei)) != NULL)
                          {
                            u8 tmpPss;
              
                            tmpPss =  scb->pss;
                            PSM_getLargerPSS(&tmpPss, dstScb->pss);
                            PSM_cvrtPss_Awd(tmpPss, &commAwd);
                          }
                          else
                          {
                            if (psDebug)
                              printf("txPlc: CCO: cannot find dtei %bu\n");
                          }
                        }
                      }
                    }
                    else
                    {
                      if (psDebug)
                        printf("txPlc: CCO: scb=NULL\n");
                    }
                  }
              
                  if (psDebug)
                  {
                    printf("txPlc: commAwd.awdTime=%bu, commAwd.numBp=%d, scb->bpCnt=%d, gHpgpHalCB.halStats.psBpIntCnt=%lu
             -\n", 
                        commAwd.awdTime, commAwd.numBp, scb->bpCnt, gHpgpHalCB.halStats.psBpIntCnt);
                  }
              
                  if (commAwd.awdTime && commAwd.numBp)
                  {
                    // common AWD exists. This means that: 
                    // if CCO: at least 1 station is in PS mode. if STA: it must be in PS mode
              //      printf("scb->bpCnt=%d, scb->commAwd.numBp=%d\n", scb->bpCnt, scb->commAwd.numBp);
                    if (gHpgpHalCB.devMode == DEV_MODE_STA)
                      tmpBpCnt = gHpgpHalCB.halStats.psBpIntCnt;
                    else tmpBpCnt = scb->bpCnt;
              
                    modVal = tmpBpCnt % commAwd.numBp;
                    if (modVal == 0)
                    {
                      // start of PSP: commAwd.numBp must be of power of 2
                      if (!(commAwd.awdTime & 0x80))
                      {
                        // AwdTime is in ms
                        ntb = (rtocl(ReadU32Reg(PLC_NTB_REG))*40)/1000000;
                        bpst = (rtocl(ReadU32Reg(PLC_CurBPST_REG))*40)/1000000;
                        // take care of wrap-around ???
                        if (ntb > bpst)
                          timeDiff = ntb-bpst;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 28  

                        else timeDiff = 0;
                        if (psDebug)
                          printf("txPlc: ntb=%lu, bpst=%lu, timeDiff=%lu\n", ntb, bpst, timeDiff);
                        if (timeDiff > commAwd.awdTime)
                        {
                          if (psDebug)
                            printf("timediff too big. Return\n");
                          if (from == 2)
                            psNoTxFrmCnt++;
                          else psFrmBcnNoTxFrmCnt++;
                          return;
                        }
                      }
                      // AwdTime is in # of BP, allow Tx 
                      if (psDebug)
                        printf("PSP: AWD = %bu >= modVal = %bu. OK to Tx\n", commAwd.awdTime & 0xF, modVal);
                    }
                    else
                    {
                      // in between PSPs
                      if (commAwd.awdTime & 0x80)
                      {
                        // AwdTime is in # of BP 
                        if (modVal >= (commAwd.awdTime & 0xF))
                        {
                          if (psDebug)
                            printf("AWD = %bu >= modVal = %bu. Return\n", commAwd.awdTime & 0xF, modVal);
                          return;
                        }
                        if (psDebug)
                          printf("AWD = %bu < modVal = %bu. OK to Tx\n", commAwd.awdTime & 0xF, modVal);
                      }
                      else
                      {
                        
                        if (psDebug)
                          printf("Mod op not 0. Return\n");
                        if (from == 2)
                          psNoTxWrongBpFrmCnt++;
                        else  psFrmBcnNoTxWrongBpFrmCnt++;
                        return;
                      }
                    }
                  }
                  else
                  {
                    if (from == 2)
                      psNoTxZeroAwdFrmCnt++;
                    else  psFrmBcnNoTxZeroAwdFrmCnt++;
              
                    if (from == 1)
                      // only send frames from ZeroCrossing interrupt and BcnRx interrupt if this sta is in PS mode
                      return;
                  }
                  if (from == 2)
                    psTxFrmCnt++;
                  else psFrmBcnTxFrmCnt++;
                  if (psDebug)
                    printf("OK to PLC TX\n");
              #endif
1716   3      
1717   3          status = hostRxPostProcess(lpPlcTxFrmSwDesc);
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 29  

1718   3          if(status == STATUS_FAILURE)//kiran
1719   3          {
1720   4            //FM_Printf(FM_USER,"RX Failed\n");
1721   4            return;
1722   4          }
1723   3      #ifdef DEBUG_DATAPATH
                  if (sigDbg)
                  FM_Printf(FM_USER, "ptx\n");
              #endif
1727   3      
1728   3      #ifdef HPGP_HAL_TEST
                    status  = HHAL_PlcTxQWrite(lpPlcTxFrmSwDesc);
              #else                          
1731   3            status = HHAL_PlcTxQWrite(hal, lpPlcTxFrmSwDesc);
1732   3      #endif
1733   3            hhalCb->halStats.CurTxTestFrmCnt++;
1734   3      #ifdef ETH_BRDG_DEBUG
                    plcTxFrameCnt++;
              #endif
1737   3            TxLoop++;
1738   3            if (status == STATUS_FAILURE)
1739   3            {
1740   4              u16 i;
1741   4      #ifdef ETH_BRDG_DEBUG
                      plcTxWriteFail++;
              #endif
1744   4      #ifdef POWERSAVE
                  if (from == 2)
                    psPlcTxWriteErrCnt++;
                  else psFrmBcnPlcTxWriteErrCnt++;
              #endif
1749   4              datapath_getHeadDesc(PLC_DATA_QUEUE, 1);
1750   4                      gHpgpHalCB.halStats.HtoPswDropCnt++;
1751   4      
1752   4              for( i=0 ; i< lpPlcTxFrmSwDesc->cpCount ; i++ )
1753   4              {
1754   5                CHAL_DecrementReleaseCPCnt(lpPlcTxFrmSwDesc->cpArr[i].cp);
1755   5              }
1756   4      
1757   4            }
1758   3            else
1759   3            {
1760   4      
1761   4              lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;  //PLC_TX_PENDING;
1762   4            
1763   4      #ifdef UM
1764   4              plcTxTime = STM_GetTick();
1765   4      #else
              //           plcTxTime = get_TimerTick();
              #endif
1768   4              lpPlcTxFrmSwDesc->frmInfo.plc.attemptCnt++;
1769   4      #ifdef POWERSAVE
                  if (from == 2)
                    psPlcTxOKCnt++;
                  else psFrmBcnPlcTxOKCnt++;
              #endif
1774   4            }
1775   3          }
1776   2          else
1777   2          {
1778   3      #ifdef ETH_BRDG_DEBUG
                    if (myDebugFlag)
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 30  

                      printf("SendToPlc: HHAL_IsPlcIdle returns FAIL\n"); 
                    
              #endif
1783   3      #ifdef POWERSAVE
                    if (from == 2)
                      psPlcIdleErrCnt++;
                    else psFrmBcnPlcIdleErrCnt++;
              #endif
1788   3      //      FM_Printf(FM_USER, "per\n");
1789   3      
1790   3          
1791   3            os_set_ready(HYBRII_TASK_ID_FRAME); 
1792   3      
1793   3          }         
1794   2                
1795   2      
1796   2        }
1797   1      
1798   1      }
1799          
1800          u32 plcTxDataSeqNum = 1;
1801          u32 plcRxDataSeqNum = 0;
1802          #define MAX_U32_VALUE 0xFFFFFFFF
1803          
1804          
1805          // isGCIpkt checks the 1st CP of a received ETH pkt to determine
1806          // whether this is a Greenvity test pkt
1807          // Return:
1808          //      - TRUE if it's a GCI pkt
1809          //      - FALSE otherwise
1810          #ifdef DO_GV_ETH_TEST
              
              u8 isGCIpkt(uRxPktQCPDesc *pRxPktQCPDesc,
                          sSwFrmDesc *pEthTxFrmSwDesc, u16 frmLen,
                          u8 descLen, u8 *pRetId, 
                          u8 *pRetRcvPkt, u8 *pdropPkt)
              {
              //    volatile u8 XDATA *cellAddr;
                u8 *cellAddr; 
                  u8 boardId;
                  u8 rcvPkt;
                  u8 nxtPktType = 0;
                  u8 GCIpkt = FALSE;
              #ifdef MEM_PROTECTION
                u8 cp_localBuf[HYBRII_CELLBUF_SIZE];  // local CP buffer
              #endif
              
              #ifdef MEM_PROTECTION
                // copy cp to local buf
                if (HHAL_CP_Get_Copy(pRxPktQCPDesc->s.cp, &cp_localBuf[0], sizeof(sEth2Hdr)+sizeof(sEthGCIHdr)) == STATUS
             -_FAILURE)
                {
                  printf("isGCIpkt: Failed to make a copy of CP. Return FALSE\n");
                  return(FALSE);
                }
                cellAddr = &cp_localBuf[0];
              #else
                  cellAddr = CHAL_GetAccessToCP(pRxPktQCPDesc->s.cp);
              #endif
              
                  if (descLen >= (sizeof(sEth2Hdr)+sizeof(sEthGCIHdr)))
                  {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 31  

                      volatile sEth2Hdr   *pEthHdr;
                      volatile sEthGCIHdr *pGCIHdr;
                      u8                  tmpAddr[MAC_ADDR_LEN];
              
                      pEthHdr = (sEth2Hdr *) cellAddr;
              
                      if (pEthHdr->ethtype == ETH_TYPE_GREENVITY)
                      {
                          /* Our test pkt */
                          GCIpkt = TRUE;
                          pGCIHdr = (sEthGCIHdr *) (cellAddr + sizeof(sEth2Hdr));
                          rcvPkt = pGCIHdr->pktType;
                          boardId = 0xff;
                          if (rcvPkt == CMD_CONN_REQ_PKT)
                          {
                              // this must be a slave, ConnState must be the 1st index
                              boardId = 0;
                              if (ConnState[boardId].state == GCI_STATE_OPEN)
                              {
                                  // this station is already OPEN for a test, do nothing
                                  *pdropPkt = TRUE;
                              }
                              else
                              {
                                  // Conn Req to start of test (slave), send CONN RESP
                                  // the dest MAC Addr is broadcast, copy slave addr 
                                  // to dest so we can swap the addr when transmit the CONN RESP later
                                  memcpy(pEthHdr->dstaddr, pGCIHdr->slaveMACaddr, MAC_ADDR_LEN);
                                  nxtPktType = CMD_CONN_RESP_PKT; // Conn Response back
                              }
                          } else if (rcvPkt  == CMD_CONN_RESP_ACK_PKT)
                          {
                              // this must be a slave, ConnState must be the 1st index
                              boardId = 0;
                              if (ConnState[boardId].state == GCI_STATE_OPEN)
                              {
                                  // this connection is already OPEN, do nothing
                                  *pdropPkt = TRUE;
                              }
                              else
                              {
                                  // ACK for Conn Response(slave), set station ready to 
                                  // receive test data
                                  ConnState[boardId].state = GCI_STATE_OPEN;
                                  ConnState[boardId].testType = pGCIHdr->testType;
                                  ConnState[boardId].my_numPktTx = 0;
                                  ConnState[boardId].my_numPktRx = 0;
                                  memcpy(ConnState[boardId].myMACaddr, pGCIHdr->slaveMACaddr, 
                                          MAC_ADDR_LEN);
                                  stationType = SLAVE_STATION;
                                  *pdropPkt = TRUE;
                                  printf("\nStation %bx:%bx:%bx:%bx:%bx:%bx is ready to receive data from "
                                          "%bx:%bx:%bx:%bx:%bx:%bx\n", 
                                          pGCIHdr->slaveMACaddr[0], pGCIHdr->slaveMACaddr[1], 
                                          pGCIHdr->slaveMACaddr[2], pGCIHdr->slaveMACaddr[3],
                                          pGCIHdr->slaveMACaddr[4], pGCIHdr->slaveMACaddr[5], 
                                          pEthHdr->srcaddr[0], pEthHdr->srcaddr[1], 
                                          pEthHdr->srcaddr[2], pEthHdr->srcaddr[3], pEthHdr->srcaddr[4], 
                                          pEthHdr->srcaddr[5]);
                              }
                          } else if (rcvPkt == CMD_DISCON_REQ_PKT)
                          {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 32  

                              // end of test (slave), send ACK with slave's statistics
                              // make sure MAC dest addr match with this station's
                              if (ConnExistSlave(pEthHdr->dstaddr, &boardId) == FALSE)
                              {
                                  *pdropPkt = TRUE;
                              }
                              else
                              {
                                  pGCIHdr->numPktTx = ConnState[boardId].my_numPktTx;
                                  pGCIHdr->numPktRx = ConnState[boardId].my_numPktRx;
                                  nxtPktType = CMD_DISCON_ACK_PKT;    // ACK back
                                  memset(&ConnState[boardId], 0, sizeof(sConnState));
              //                  stationType = UNDEFINED_STATION;    // set it to unknown
                              }
                          } else if (rcvPkt == CMD_CONN_RESP_PKT)
                          {
                              // Conn Response (master). Set State to OPEN and send ACK
                              // make sure MAC dest addr match with this station's
                              if (ConnExistMaster(pEthHdr->dstaddr, pEthHdr->srcaddr, &boardId)
                                       == TRUE)
                              {
                                  if (ConnState[boardId].state == GCI_STATE_OPEN)
                                  {
                                      // this connection is already OPEN, do nothing
                                      *pdropPkt = TRUE;
                                  }
                                  else
                                  {
                                      stationType = MASTER_STATION;
                                      ConnState[boardId].state = GCI_STATE_OPEN;
                                      ConnState[boardId].my_numPktTx = 0;
                                      ConnState[boardId].my_numPktRx = 0;
                                      nxtPktType = CMD_CONN_RESP_ACK_PKT; // ACK back
                                  }
                              }
                          } else if (rcvPkt == CMD_DISCON_ACK_PKT)
                          {
                              // DISC ACK:  Stop of test (master). Set State to CLOSED, copy the 
                              // slave's statistics and return
                              // make sure MAC dest addr match with this station's
                              if (ConnExistMaster(pEthHdr->dstaddr, pEthHdr->srcaddr, 
                                      &boardId) == TRUE)
                              {
                                  ConnState[boardId].state = GCI_STATE_CLOSED;
                                  ConnState[boardId].slave_numPktTx = pGCIHdr->numPktTx;
                                  ConnState[boardId].slave_numPktRx = pGCIHdr->numPktRx;
                              }
                              *pdropPkt =  TRUE;
                          } else if (rcvPkt == CMD_DATA_PKT)
                          {
                              // DATA pkt. 2 scenarios:
                              //      - if this is the master: discard the pkt
                              //      - if this is a slave: if it's half duplex, discard
                              //        the pkt, otherwise, xmit that same pkt
                              //        back to the master
                              if ((stationType != MASTER_STATION) && (stationType != SLAVE_STATION))
                              {
                                  *pdropPkt = TRUE;
                              }
                              else
                              {
                                  // make sure MAC dest addr match with this station's
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 33  

                                  if (((stationType == MASTER_STATION) && 
                                      (ConnExistMaster(pEthHdr->dstaddr, pEthHdr->srcaddr, &boardId)
                                           == FALSE)) ||
                                      ((stationType == SLAVE_STATION) && 
                                          (ConnExistSlave(pEthHdr->dstaddr, &boardId) == FALSE)))
                                  {
                                      *pdropPkt = TRUE;
                                  }
                                  else
                                  {
                                      // both master and slave can receive DATA pkts
                                      if (ConnState[boardId].state == GCI_STATE_OPEN)
                                      {
                                          ConnState[boardId].my_numPktRx++;
                                          if(((ConnState[boardId].my_numPktRx % 64) == 0) && 
                                              (ConnState[boardId].my_numPktRx> 0))
                                          {
                                              printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
                                                     "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
                                              if (ConnState[boardId].testType == HALF_DUPLEX_TEST)
                                                  printf("Received %li ETH Data frames", 
                                                      ConnState[boardId].my_numPktRx);
                                              else
                                                  printf("Sent %li Data frames, rcvd %li Data frames", 
                                                      ConnState[boardId].my_numPktTx, 
                                                      ConnState[boardId].my_numPktRx);
                                          }
                                          if ((stationType == SLAVE_STATION) && 
                                              (ConnState[boardId].testType == FULL_DUPLEX_TEST))
                                              // transmit the DATA pkt back to sender if 
                                              // we are slave and this is a Full Duplex test
                                              nxtPktType = CMD_DATA_PKT;
                                          else
                                          {
                                              *pdropPkt = TRUE;
                                          }
                                      } else
                                      {
                                          *pdropPkt =  TRUE;   // bad state
                                      }
                                  }
                              }
                          } else
                          {
                              *pdropPkt =  TRUE;       // invalid pkt
                          }
              
                          if (!*pdropPkt)
                          {
                              // if it gets here, it means that we need to transmit a response 
                              // pkt or it's a DATA pkt and we need to transmit it back in
                              // the FULL Duplex test mode 
                              // swap src and dest addresses of MAC layer
                              memcpy(tmpAddr, pEthHdr->dstaddr, MAC_ADDR_LEN);
                              memcpy(pEthHdr->dstaddr, pEthHdr->srcaddr, MAC_ADDR_LEN);
                              memcpy(pEthHdr->srcaddr, tmpAddr, MAC_ADDR_LEN);
                              pEthHdr->ethtype = ETH_TYPE_GREENVITY;
                              // Greenvity's
                              pGCIHdr->pktType = nxtPktType;
                              if (nxtPktType == CMD_DATA_PKT)
                              {
                                  // DATA pkt
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 34  

                                  pEthTxFrmSwDesc->frmLen =  frmLen; // pkt len
                                  pEthTxFrmSwDesc->cpArr[0].len = descLen; // CP len
                              } else
                              {
                                 // CONN RESPONSE or ACK pkt
                                 // pkt len is ETH+GREENVITY headers
                                  pEthTxFrmSwDesc->frmLen = pEthTxFrmSwDesc->cpArr[0].len = 
                                          sizeof(sEth2Hdr) + sizeof(sEthGCIHdr); 
                              }
                              pEthTxFrmSwDesc->cpArr[0].offsetU32 = 0;
                              pEthTxFrmSwDesc->cpArr[0].cp        = pRxPktQCPDesc->s.cp;
                              pEthTxFrmSwDesc->cpCount++;
              
              #ifdef MEM_PROTECTION
                      if (HHAL_CP_Put_Copy(pRxPktQCPDesc->s.cp, cellAddr, sizeof(sEth2Hdr)+sizeof(sEthGCIHdr)) == STATUS_FAI
             -LURE)
                      {
                        printf("isGCIpkt: Failed to put a copy of CP. Return FALSE\n");
                      }
              #endif
                          }
                      } else GCIpkt = FALSE;
                  } else GCIpkt = FALSE;
              
                  *pRetRcvPkt = rcvPkt;
                  *pRetId = boardId;
                  return(GCIpkt);
              }       
              
              #endif //#ifdef DO_GV_ETH_TEST
2056          
2057          #ifdef HPGP_HAL_TEST
              void Host_RxHandler(sCommonRxFrmSwDesc* pRxFrmDesc)
              
              #else
2061          
2062          void Host_RxHandler(sHaLayer *pHal, sCommonRxFrmSwDesc* pRxFrmDesc)
2063          
2064          #endif
2065          
2066          {
2067   1      
2068   1      
2069   1          uRxPktQDesc1*      pRxPktQ1stDesc;
2070   1          uRxPktQCPDesc*     pRxPktQCPDesc;
2071   1      //    volatile u8 XDATA * cellAddr;
2072   1        u8          *cellAddr;
2073   1          u16                frmLen;
2074   1          u8                 i;
2075   1          u16                tmpFrmLen = 0;
2076   1          u8                 tmpdescLen = 0;
2077   1          eStatus status = STATUS_SUCCESS;
2078   1          u16                retriesCnt = 0;
2079   1          u16                lclPrintCount = 0;
2080   1          u16                lclCount = 0;
2081   1          u8                  GreenvityPkt = FALSE;
2082   1          u8                  leave = FALSE;
2083   1          u8                  myStationId = 0xff;
2084   1          u8                  rcv_pktType = 0;
2085   1      #ifdef UM
2086   1          hostHdr_t     *pHybrii;
2087   1         
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 35  

2088   1          u8          isCmd= 0;
2089   1         sEth2Hdr   *pktEthHdr;
2090   1          sStaInfo      *staInfo = NULL;
2091   1          sLinkLayer      *linkl;
2092   1      #endif
2093   1          sHpgpHalCB      *hhalCb;
2094   1      #ifdef MEM_PROTECTION
                u8          cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
              #endif      
2097   1        u8           dropFrame = 0;
2098   1      
2099   1          u8          isEthData = 0;
2100   1      
2101   1      
2102   1          u8 dstTei =0;
2103   1      
2104   1          u8 brdcast[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
2105   1          //  sPlcTxFrmSwDesc plcTxFrmSwDesc;
2106   1          sSwFrmDesc    plcTxFrmSwDesc;
2107   1          sSwFrmDesc    ethTxFrmSwDesc;
2108   1        u8 alingOffset = 0;
2109   1          u8 payloadOffset = 0;
2110   1          u8 FIFOCtrl=0;
2111   1      
2112   1        u8 cp = 0;
2113   1          if(hostDetected == FALSE) //hostIntf == HOST_INTF_NO)
2114   1          {
2115   2              hostIntf = HOST_INTF_ETH;
2116   2          }
2117   1      //#ifdef UM
2118   1          hostDetected = TRUE;
2119   1      //#endif
2120   1          memset (&plcTxFrmSwDesc, 0x00, sizeof(sSwFrmDesc));
2121   1      
2122   1          plcTxFrmSwDesc.cpCount        = 0;
2123   1          ethTxFrmSwDesc.cpCount        = 0;
2124   1      #ifdef HPGP_HAL_TEST       
                  hhalCb = &gHpgpHalCB;
              #else   
2127   1             
2128   1          hhalCb = pHal->hhalCb;
2129   1      #endif
2130   1          
2131   1      
2132   1          pRxPktQ1stDesc = &pRxFrmDesc->hdrDesc;
2133   1          pRxPktQCPDesc  = &pRxFrmDesc->firstCpDesc;
2134   1          frmLen = pRxPktQ1stDesc->s.frmLenHi;
2135   1          frmLen = frmLen<<PKTQDESC1_FRMLENHI_POS | pRxPktQ1stDesc->s.frmLenLo;
2136   1        plcTxFrmSwDesc.txPort = pRxPktQ1stDesc->s.dstPort;
2137   1        plcTxFrmSwDesc.rxPort = pRxPktQ1stDesc->s.srcPort;  
2138   1      
2139   1          gEthHalCB.TotalRxFrmCnt++;
2140   1          gEthHalCB.TotalRxBytesCnt += frmLen;
2141   1      
2142   1        if (hostIntf == HOST_INTF_ETH) 
2143   1        {
2144   2            if (frmLen > MAX_ETH_BUFF || frmLen < MIN_ETH_BUFF)
2145   2            {
2146   3              
2147   3                hal_common_free_frame(pRxFrmDesc);
2148   3                  gHpgpHalCB.halStats.HtoPswDropCnt++;
2149   3                return;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 36  

2150   3            }
2151   2      #if 0   //[YM] temp comment out pause function
                    // Check for FIFO Overrun reg. If it's set, send a PAUSE pkt out
                    FIFOCtrl     = ReadU8Reg(ETHMAC_FIFOCTL_REG);
                    if (FIFOCtrl & 4)
                  {
                        /* Rcv FIFO Overrun flag is set, send ETH Pause pkt out */
                        EHAL_EthSendPause();
                  }
              #endif    
2160   2        }
2161   1          
2162   1        if (hostIntf == HOST_INTF_SPI) {
2163   2          cellAddr = CHAL_GetAccessToCP(pRxFrmDesc->cpArr[0]);
2164   2      
2165   2        } else if (hostIntf == HOST_INTF_ETH) {
2166   2      #ifdef UM
2167   2      #ifdef MEM_PROTECTION
                  // copy cp to local buf
                  if (HHAL_CP_Get_Copy(pRxPktQCPDesc->s.cp, &cp_localBuf[0], HYBRII_CELLBUF_SIZE) 
                      == STATUS_FAILURE)
                  {
                    printf("Host_RxHandler: Failed to make a copy of CP. Return\n");
                        hal_common_free_frame(pRxFrmDesc);
                        return;
                  }
                  cellAddr = &cp_localBuf[0];
              #else
2178   2            //cellAddr = CHAL_GetAccessToCP(pRxPktQCPDesc->s.cp);
2179   2          cellAddr = CHAL_GetAccessToCP(pRxFrmDesc->cpArr[0]);//kiran
2180   2      #endif
2181   2      #endif
2182   2        } 
2183   1        else if(hostIntf == HOST_INTF_UART)
2184   1        {
2185   2          cellAddr = CHAL_GetAccessToCP(pRxPktQCPDesc->s.cp);
2186   2        } 
2187   1          if(frmLen < HYBRII_CELLBUF_SIZE)
2188   1          {
2189   2              tmpdescLen = frmLen;
2190   2          }
2191   1          else
2192   1          {
2193   2              tmpdescLen = HYBRII_CELLBUF_SIZE;
2194   2          }
2195   1      
2196   1          
2197   1      #ifdef DEBUG_DATAPATH
                      
                  if (pktDbg)
                  {
                      FM_Printf(FM_ERROR, "\n host rx\n");
                      for( lclPrintCount=0; lclPrintCount<tmpdescLen; lclPrintCount++ )
                      {
                          FM_Printf(FM_ERROR, "0x%02bX ", *(cellAddr+lclPrintCount));
                      }
                      FM_Printf(FM_ERROR, "\n end \n");
              
                  }
                      
              #endif
2211   1      
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 37  

2212   1          tmpFrmLen = tmpdescLen;
2213   1      
2214   1      
2215   1      #ifdef UM
2216   1          // Check for MAC SAP pkt
2217   1         
2218   1             pktEthHdr = ((sEth2Hdr*)cellAddr);
2219   1                    
2220   1              if (pktEthHdr->ethtype == 0x88E1)
2221   1              {            
2222   2                  pHybrii = (hostHdr_t*)(((u8*)cellAddr) + sizeof(sEth2Hdr));        
2223   2           
2224   2                  #if 0
                          
                          alingOffset = (u8)pHybrii->rsvd;  
              
                          if( alingOffset > 3)
                          {
                      //      FM_Printf(FM_ERROR, "Invalid alingoffset : %bu, %d\n", alingOffset, pHybrii->rsvd);
                              hal_common_free_frame(pRxFrmDesc);
                              return;
                          }
                          
                          #endif           
2236   2                              
2237   2                  
2238   2                  if ((pHybrii->type == CONTROL_FRM_ID) ||
2239   2                      (pHybrii->type == MGMT_FRM_ID))
2240   2                  {
2241   3      
2242   3              if (pHybrii->protocol == HPGP_MAC_ID 
2243   3      #ifdef HYBRII_ZIGBEE          
                        || pHybrii->protocol == IEEE802_15_4_MAC_ID
              #endif          
2246   3                                      )
2247   3              {
2248   4                Host_MgmtCmdRxHandler(hhalCb, pRxFrmDesc, 
2249   4                                  frmLen,pHybrii->type);          
2250   4              }
2251   3                  }
2252   2                 
2253   2            hal_common_free_frame(pRxFrmDesc);
2254   2            return;
2255   2      
2256   2      
2257   2              }
2258   1              else
2259   1      #endif      
2260   1          {
2261   2      
2262   2      #if 1
2263   2            if (datapath_IsQueueFull(PLC_DATA_QUEUE)
2264   2                == TRUE)
2265   2            {
2266   3      
2267   3            
2268   3      #ifdef DEBUG_DATAPATH
                          
                      if (sigDbg)
                      FM_Printf(FM_ERROR,"q f\n");
              #endif        
2273   3              dropFrame = 1;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 38  

2274   3            }
2275   2            
2276   2            if ((host_intf_max_cp + pRxFrmDesc->cpCount)> HOST_TO_PLC_MAX_CP)
2277   2            {       
2278   3      
2279   3              
2280   3                
2281   3      #ifdef DEBUG_DATAPATH
                          
                      if (sigDbg)
                      FM_Printf(FM_ERROR,"max cp %bu\n",(pRxFrmDesc->cpCount + host_intf_max_cp));
                
              #endif          
2287   3              dropFrame = 1;
2288   3      
2289   3            }
2290   2      
2291   2              
2292   2      #ifdef UM       
2293   2            if (0)//(!MCTRL_IsAssociated())
2294   2            {       
2295   3              dropFrame = 1;
2296   3            }
2297   2      #endif
2298   2      
2299   2            if (dropFrame)
2300   2            {
2301   3              hal_common_free_frame(pRxFrmDesc); // drop frame
2302   3      #if 1 //def DEBUG_DATAPATH
2303   3            //  FM_Printf(FM_USER, "drop frame\n");
2304   3      #endif      
2305   3                      gHpgpHalCB.halStats.HtoPswDropCnt++;
2306   3              return;
2307   3            }
2308   2            
2309   2      #endif
2310   2      
2311   2            
2312   2      #ifdef UM
2313   2      
2314   2            isEthData = 1;
2315   2            
2316   2              /* Check to drop the Ethernet frame based on peer's connection status */
2317   2             /* !memcmp(pktEthHdr->dstaddr, brdcast, sizeof(brdcast)) */
2318   2              if ((pktEthHdr->dstaddr[0] & 0x01))
2319   2              {
2320   3      
2321   3                      /*
2322   3                                      Note : dstTei should be set to 0xFF for broadcast frame.
2323   3                                      Has to be revisited. 0xFF was getting dropped by receiver
2324   3      
2325   3                                      */
2326   3      
2327   3                  dstTei = 0xFF;
2328   3      
2329   3              }
2330   2              else
2331   2              {
2332   3                  sScb* dstScb = NULL;
2333   3                  sLinkLayer *linkLayer = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2334   3                  sCnam *ccoNam = &linkLayer->ccoNam;
2335   3                  u8 devmode = LINKL_GetMode(linkLayer);
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 39  

2336   3              
2337   3                  dstScb = CRM_FindScbMacAddr(&pktEthHdr->dstaddr);
2338   3      
2339   3                  if (!dstScb)
2340   3                  {
2341   4                      dropFrame = 1;
2342   4      
2343   4                  }
2344   3                  else
2345   3                  {
2346   4                      if(devmode == LINKL_STA_MODE_STA)
2347   4                      {
2348   5                          if(0)//staInfo->staStatus.fields.authStatus != 1)
2349   5                          {
2350   6                              dropFrame = 1;
2351   6                          }
2352   5                      }
2353   4      
2354   4                      else if(devmode == LINKL_STA_MODE_CCO)
2355   4                      {
2356   5                          if(0)//dstScb->staStatus.fields.authStatus != 1)
2357   5                          {
2358   6                              dropFrame = 1;
2359   6                          }
2360   5                      }
2361   4                      else
2362   4                      {
2363   5                          dropFrame = 1;
2364   5                      }
2365   4      #ifdef ROUTE
                                  if(dstScb->lrtEntry.routeIsInvalid == TRUE || dstScb->lrtEntry.routeOnHold == TRUE)
                                  {
                                      dropFrame = 1;
                                  }
                                  else
                                  {
                                      dstTei = dstScb->lrtEntry.nTei;
                                  }
              #else
2375   4                      dstTei = dstScb->tei;
2376   4      #endif
2377   4                  }
2378   3      
2379   3      
2380   3              }
2381   2      
2382   2      
2383   2      #else
              
                isEthData = 1;
                dstTei = 1;
              
              #endif
2389   2      
2390   2          }
2391   1      
2392   1      
2393   1      #ifdef UM
2394   1           isEthData = 1;
2395   1      #endif    
2396   1         
2397   1      #ifdef HYBRII_ETH
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 40  

2398   1          // now examine the pkt once more to see if it's
2399   1          // a Greenvity test pkt
2400   1      #ifdef DO_GV_ETH_TEST // make this test compilable to save time to examine ETH header
                  if ((GreenvityPkt = isGCIpkt(pRxPktQCPDesc, &ethTxFrmSwDesc, frmLen, 
                          tmpdescLen, &myStationId, &rcv_pktType, &leave)) == TRUE)
                  {
                  }
              #else
2406   1        GreenvityPkt = FALSE;
2407   1      #endif //HYBRII_ETH 
2408   1      #endif
2409   1      
2410   1          if (leave
2411   1      #ifdef UM
2412   1              || dropFrame
2413   1      #endif
2414   1          ) {
2415   2      
2416   2          //FM_Printf(FM_USER, "drop x\n");
2417   2              // free the received pkt and return
2418   2              hal_common_free_frame(pRxFrmDesc);
2419   2              gHpgpHalCB.halStats.HtoPswDropCnt++;
2420   2              return;
2421   2          }
2422   1      
2423   1          if ((eth_plc_bridge
2424   1      #ifdef UM
2425   1          || (isEthData == 1)
2426   1      #endif
2427   1              ) && !GreenvityPkt)
2428   1          {
2429   2            
2430   2            plcTxFrmSwDesc.cpArr[0].offsetU32 = 0;
2431   2            plcTxFrmSwDesc.cpArr[0].len       = tmpdescLen;
2432   2        
2433   2          plcTxFrmSwDesc.cpArr[0].cp    = pRxFrmDesc->cpArr[0];
2434   2            plcTxFrmSwDesc.cpCount++;
2435   2      
2436   2      #ifdef HPGP_HAL_TEST
                  plcTxFrmSwDesc.frmInfo.plc.eks =  gNekEks; //HPGP_UNENCRYPTED_EKS;
              
                  hhalCb = &gHpgpHalCB;
              #else
2441   2      
2442   2          linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2443   2      
2444   2          staInfo = LINKL_GetStaInfo(linkl);
2445   2      
2446   2          hhalCb = pHal->hhalCb;
2447   2      
2448   2          plcTxFrmSwDesc.frmInfo.plc.eks = staInfo->nekEks;//HPGP_UNENCRYPTED_EKS;
2449   2      #endif
2450   2      
2451   2      
2452   2          plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
2453   2          plcTxFrmSwDesc.frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
2454   2      
2455   2          plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;
2456   2      
2457   2      
2458   2        
2459   2      #ifdef UM
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 41  

2460   2          /*
2461   2          we need to fetch scb and then populate TEIs.
2462   2          */
2463   2          if(linkl->mode == LINKL_STA_MODE_CCO)
2464   2          {
2465   3      
2466   3      //    FM_Printf(FM_USER, "f cc\n");
2467   3      #ifdef CCO_FUNC               
2468   3              plcTxFrmSwDesc.frmInfo.plc.dtei       = dstTei;
2469   3              plcTxFrmSwDesc.frmInfo.plc.stei       = staInfo->ccoScb->tei;
2470   3      #endif
2471   3          }
2472   2          else
2473   2          {
2474   3      #ifdef STA_FUNC
2475   3              plcTxFrmSwDesc.frmInfo.plc.dtei       = dstTei;//staInfo->ccoScb->tei;
2476   3              plcTxFrmSwDesc.frmInfo.plc.stei       = staInfo->tei;
2477   3      #endif
2478   3          }
2479   2      
2480   2      
2481   2      #else
                  plcTxFrmSwDesc.frmInfo.plc.dtei           = hhalCb->remoteTei;
                  plcTxFrmSwDesc.frmInfo.plc.stei           = hhalCb->selfTei;//HYBRII_DEFAULT_TEISTA;
              
              #endif
2486   2        if (dstTei == 0xFF)
2487   2        {
2488   3          plcTxFrmSwDesc.frmInfo.plc.mcstMode    = HPGP_MCST;
2489   3          plcTxFrmSwDesc.frmInfo.plc.phyPendBlks   = HPGP_PPB_MCFRPT;
2490   3        }
2491   2        else
2492   2        {
2493   3          plcTxFrmSwDesc.frmInfo.plc.mcstMode    = HPGP_UCST;  // Unicast
2494   3        }
2495   2      
2496   2          plcTxFrmSwDesc.frmLen         = frmLen;
2497   2      #if 0
                  plcTxFrmSwDesc.frmInfo.plc.plid = 0;   //[YM] This line of code has to be changed base on differnet Qo
             -S priority
              
              
                  if (plcTxFrmSwDesc.frmInfo.plc.plid == 0)
                      plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
                else
                  plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP123;
              
                 
              #if 1 //def HPGP_HAL_TEST
                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel     = STD_ROBO_TEST; // std robo
              #endif
                  plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_SOF;
                  plcTxFrmSwDesc.frmInfo.plc.saf = 1;
              
              #endif
2514   2          }
2515   1      
2516   1          // Read second and subsequent CP descriptors
2517   1          for( i=1 ; i< pRxFrmDesc->cpCount ; i++ )
2518   1          {
2519   2      #ifdef UM
2520   2      #ifdef MEM_PROTECTION
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 42  

                  // copy cp to local buf
                  if (HHAL_CP_Get_Copy(pRxFrmDesc->cpArr[i], &cp_localBuf[0], HYBRII_CELLBUF_SIZE) == STATUS_FAILURE)
                  {
                    printf("Host_RxHandler: Failed to make a copy of CP %bu. Return\n", pRxFrmDesc->cpArr[i]);
                        hal_common_free_frame(pRxFrmDesc);
                        return;
                  }
                  //cellAddr = &cp_localBuf[0];// Kiran. Commented as no one uses cellAddr
              #else
2530   2              //cellAddr = CHAL_GetAccessToCP(pRxFrmDesc->cpArr[i]);// Kiran. Commented as no one uses cellAddr
2531   2      #endif
2532   2      #endif
2533   2      
2534   2              if((frmLen - tmpFrmLen) > HYBRII_CELLBUF_SIZE)
2535   2                  tmpdescLen = HYBRII_CELLBUF_SIZE;
2536   2              else
2537   2                  tmpdescLen = frmLen - tmpFrmLen;
2538   2      
2539   2              if (GreenvityPkt)
2540   2              {
2541   3      #ifdef HYBRII_ETH
2542   3                  // our test pkt
2543   3                  if ((rcv_pktType == CMD_DATA_PKT) && 
2544   3                      (ConnState[myStationId].testType == FULL_DUPLEX_TEST))
2545   3                  {
2546   4                      // only DATA pkts can have more than 1 CP
2547   4                      // and we're going to xmit this DATA pkt back out
2548   4                      // in FULL DUPLEX mode
2549   4                      ethTxFrmSwDesc.cpArr[i].offsetU32 = 0;
2550   4                      ethTxFrmSwDesc.cpArr[i].len       = tmpdescLen;
2551   4                      ethTxFrmSwDesc.cpArr[i].cp        = pRxFrmDesc->cpArr[i];
2552   4                      ethTxFrmSwDesc.cpCount++;
2553   4                      tmpFrmLen += tmpdescLen;
2554   4                  }
2555   3      #endif
2556   3              } else if((1 == eth_plc_bridge)
2557   2      #ifdef UM
2558   2              || (isEthData == 1)
2559   2      #endif
2560   2              )
2561   2              {
2562   3                  //either bridging would be on or mac sap would be on
2563   3      
2564   3            plcTxFrmSwDesc.cpArr[i].offsetU32 = 0;
2565   3                  plcTxFrmSwDesc.cpArr[i].len       = (u8)tmpdescLen; 
2566   3                  plcTxFrmSwDesc.cpArr[i].cp    = pRxFrmDesc->cpArr[i];
2567   3                  plcTxFrmSwDesc.cpCount++;
2568   3                  tmpFrmLen += tmpdescLen;
2569   3              }
2570   2      
2571   2          } // for i..
2572   1      
2573   1      
2574   1          if(eth_plc_bridge || GreenvityPkt
2575   1      #ifdef UM
2576   1              || (isEthData == 1)
2577   1      #endif
2578   1              )
2579   1          {
2580   2              // Transmit the frame
2581   2              retriesCnt=0;
2582   2      #if 0 //def HYBRII_ETH
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 43  

              
                      if(GreenvityPkt)
                      {
                          // Greenvity test pk, xmit it back out via ETH
                          do
                          {                   
                          // Greenvity test pk, xmit it back out via ETH
                          status = EHAL_EthTxQWrite(&ethTxFrmSwDesc);
              
                          // check for pending Tx and process it.
                          if( status != STATUS_SUCCESS)
                          {
                          // TODO try for ETH_PLC_TX_RETRIES number of times, if not success then break
                          if(retriesCnt >= ETH_PLC_TX_RETRIES)
                          {
                              break;
                          }
                          retriesCnt++;
                          }
                          }while(status != STATUS_SUCCESS);
              
                          if(status == STATUS_SUCCESS)
                          {
                          gHpgpHalCB.halStats.CurTxTestFrmCnt++;
                          if ((rcv_pktType == CMD_DATA_PKT))
                          // only the slave transmits the DATA pkt in the ETH_RCV ISR
                          ConnState[myStationId].my_numPktTx++;
                          }
                          else
                          {
                          FM_Printf(FM_ERROR,"ETH, PLC or MAC SAP tx failed\n");
                          // If Tx failed, free the rcv pkt
                          hal_common_free_frame(pRxFrmDesc);
                          }
              
                      }
                      else
              #endif
2621   2      
2622   2          {
2623   3      
2624   3            
2625   3      //      FM_Printf(FM_USER, "hr\n");
2626   3          
2627   3            fwdAgent_handleData(&plcTxFrmSwDesc);
2628   3          }
2629   2              // if MAC SAP or Bridging is ON, send it to PLC
2630   2              
2631   2              // end of bridge or mac case
2632   2          } 
2633   1        else
2634   1      
2635   1      
2636   1          {
2637   2              // pkt is not for ETH testing nor bridging nor MAC SAP, free the CP
2638   2              hal_common_free_frame(pRxFrmDesc);
2639   2              gHpgpHalCB.halStats.HtoPswDropCnt++;
2640   2          } 
2641   1      
2642   1      //        CHAL_DecrementReleaseCPCnt(pRxFrmDesc->cpArr[i]);
2643   1              //FM_Printf(FM_MINFO,"EHAL_EthRxIntHandler2: Releasing CP %02bX \n",pRxFrmDesc->cpArr[i]);
2644   1      }
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 44  

2645          
2646          
2647          
2648          #ifdef UM
2649          
2650          void Host_SendIndication(u8 eventId, u8 *payload, u8 length)
2651          {
2652   1        hostEventHdr_t  *pHostEvent;
2653   1        hostHdr_t  *pHostHdr;
2654   1        sEvent     *event = NULL;
2655   1      #ifdef ROUTE    
                  u8 i;
                  if(HOST_EVENT_ROUTE_VALID== eventId)
                  {
                      FM_Printf(FM_ROUTE,"ROUTE Valid: TEI=%bu NTEI=%bu NHOP=%bu\n",payload[0],payload[1],payload[2]);
                  }
                  else if(HOST_EVENT_ROUTE_INVALID== eventId)
                  {
                      FM_Printf(FM_ROUTE,"ROUTE Invalid: TEI=%bu\n",payload[0]);
                  }
                  else if(HOST_EVENT_ROUTE_CHANGE == eventId)
                  {
                      FM_Printf(FM_ROUTE,"ROUTE Change: TEI=%bu NTEI=%bu NHOP=%bu\n",payload[0],payload[1],payload[2]);
                  }
                  else if(HOST_EVENT_ROUTE_HOLD== eventId)
                  {
                      FM_Printf(FM_ROUTE,"ROUTE Hold: TEIs = ");
                      for(i = 0; i < length; i++)
                      {
                          FM_Printf(FM_ROUTE,"%bu ", payload[i]);
                      }
                      FM_Printf(FM_ROUTE,"\n");
                  }
              #endif
2679   1      
2680   1      
2681   1          event = EVENT_Alloc(sizeof(hostHdr_t) + length + sizeof(hostEventHdr_t), sizeof(hostHdr_t));
2682   1      
2683   1          if(event != NULL)
2684   1          {
2685   2            event->eventHdr.eventClass = EVENT_CLASS_CTRL;
2686   2          event->eventHdr.type = eventId;
2687   2      
2688   2            pHostHdr = (hostHdr_t*)event->buffDesc.dataptr;
2689   2            
2690   2            pHostEvent = (hostEventHdr_t*)(pHostHdr + 1);
2691   2      
2692   2            pHostHdr->type = EVENT_FRM_ID;
2693   2            pHostHdr->protocol = HPGP_MAC_ID;
2694   2            pHostHdr->rsvd = 0;
2695   2            pHostHdr->length = sizeof(hostEventHdr_t) +  length;
2696   2      #ifndef NO_HOST
2697   2            pHostHdr->length = HTONHS(pHostHdr->length);
2698   2      #endif
2699   2            pHostEvent->eventClass = EVENT_CLASS_CTRL;
2700   2          pHostEvent->type = eventId;
2701   2      
2702   2            if (payload)
2703   2              memcpy ((u8*)(pHostEvent + 1),  payload, length);
2704   2            
2705   2            event->buffDesc.datalen = sizeof(hostHdr_t) +  
2706   2                          sizeof(hostEventHdr_t) + length;
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 45  

2707   2            SEND_HOST_EVENT(event);
2708   2          }
2709   1      
2710   1      return;
2711   1      
2712   1      }
2713          
2714          
2715          
2716          void Host_MgmtCmdRxHandler(sHpgpHalCB *pHalCb, 
2717                                                sCommonRxFrmSwDesc* pRxFrmDesc,
2718                              u16 frmLen, u8 frmType)
2719          {
2720   1        u8          *cellAddr;
2721   1        u8 dropFrame = 0;
2722   1        u16          lclPrintCount = 0;
2723   1        u8            *cmdPtr;
2724   1        u16          lclCount = 0;
2725   1        u8           copylen;
2726   1        u16          remainingLen;
2727   1        u8 i;
2728   1      
2729   1        u8 payloadOffset;
2730   1      #ifdef MEM_PROTECTION
                u8          cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
              #endif      
2733   1      
2734   1        if ((frmLen <= MAX_FRAME_LEN) && ((CONTROL_FRM_ID == frmType) || (MGMT_FRM_ID == frmType)))
2735   1        {
2736   2      
2737   2          if(frmLen < HYBRII_CELLBUF_SIZE)
2738   2          {
2739   3            copylen = frmLen;
2740   3          }
2741   2          else
2742   2          {
2743   3            copylen = HYBRII_CELLBUF_SIZE;
2744   3          }
2745   2      
2746   2          remainingLen = frmLen;
2747   2      
2748   2          if (pRxFrmDesc->cpCount == 1) // If more than one cp are present then copy them to buffer
2749   2          {
2750   3            cmdPtr = CHAL_GetAccessToCP(pRxFrmDesc->cpArr[0])+ sizeof(sEth2Hdr);
2751   3            // First cell pointer contains ethernet header + payload. We need to offset ethernet header
2752   3            lclCount =  frmLen;
2753   3          }
2754   2          else
2755   2          {
2756   3      
2757   3            // Read second and subsequent CP descriptors
2758   3            for( i=0; i< pRxFrmDesc->cpCount ; i++ )
2759   3            {
2760   4              payloadOffset = (i == 0)?sizeof(sEth2Hdr):0;
2761   4      
2762   4      
2763   4      
2764   4      #ifdef HPGP_MAC_SAP
2765   4      #ifdef MEM_PROTECTION
                  // copy cp to local buf
                  if (HHAL_CP_Get_Copy(pRxFrmDesc->cpArr[i], &cp_localBuf[0], HYBRII_CELLBUF_SIZE) 
                  == STATUS_FAILURE)
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 46  

                  {
                  printf("Host_RxHandler: Failed to make a copy of CP %bu. Return\n", pRxFrmDesc->cpArr[i]);
                  hal_common_free_frame(pRxFrmDesc);
                  return;
                  }
                  cellAddr = &cp_localBuf[0];
              #else
2776   4          cellAddr = CHAL_GetAccessToCP(pRxFrmDesc->cpArr[i]);
2777   4      #endif
2778   4      #endif
2779   4      
2780   4      
2781   4          for( lclPrintCount=0; lclPrintCount< ( copylen - payloadOffset);
2782   4              lclPrintCount++ )
2783   4          {
2784   5            ufrm[lclCount++] = *(cellAddr + payloadOffset + lclPrintCount);
2785   5          }
2786   4      
2787   4          //FM_Printf(FM_MINFO,"EHAL_EthRxIntHandler2: Releasing CP %02bX \n",pRxFrmDesc->cpArr[i]);
2788   4      
2789   4          
2790   4          remainingLen = remainingLen - copylen;
2791   4      
2792   4          if(remainingLen > HYBRII_CELLBUF_SIZE)
2793   4            copylen = HYBRII_CELLBUF_SIZE;
2794   4          else
2795   4            copylen = remainingLen; 
2796   4      
2797   4          
2798   4          
2799   4          }
2800   3      
2801   3            cmdPtr = ufrm;
2802   3      
2803   3          }
2804   2          // Command Handling
2805   2          GV701x_CmdSend((hostHdr_t*)cmdPtr, lclCount);
2806   2      
2807   2        }
2808   1      
2809   1      
2810   1      }
*** WARNING C280 IN LINE 2716 OF ..\..\..\common\datapath\datapath.c: 'pHalCb': unreferenced local variable
2811          
2812          
2813          
2814          void datapath_hostTransmitFrame(u8* TxByteArr, u16 frameSize)
2815          {
2816   1          u16              dataIdx;
2817   1          u16              curFrmLen;
2818   1          u16              crc16 = 0;
2819   1          u8               cpIdx;
2820   1          eStatus          status;
2821   1          sSwFrmDesc  hostTxFrmSwDesc;
2822   1          u8 ethhdr[14];
2823   1          u8              firstCp = 0;
2824   1          u8 i;
2825   1      
2826   1          if (frameSize == 0 || hostIntf == HOST_INTF_NO)
2827   1          {
2828   2              return;
2829   2          }
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 47  

2830   1          //EHT_FillEtherHeader(TxByteArr);
2831   1          if(hostIntf == HOST_INTF_SPI)
2832   1          {
2833   2      #ifdef HYBRII_SPI
2834   2              curFrmLen              = frameSize + sizeof(hybrii_tx_req_t) + SPI_CRC_LEN;
2835   2              EHT_FillEtherHeader(ethhdr);
2836   2              curFrmLen              += sizeof(sEth2Hdr);
2837   2      
2838   2      #endif   //HYBRII_SPI
2839   2          }
2840   1          else if(hostIntf == HOST_INTF_ETH)
2841   1          {
2842   2              EHT_FillEtherHeader(ethhdr);
2843   2              curFrmLen              = frameSize + sizeof(sEth2Hdr);    
2844   2          }
2845   1      #ifdef UART_HOST_INTF 
                else if(hostIntf == HOST_INTF_UART)
                  {
                      curFrmLen              = frameSize ;//+ sizeof(sEth2Hdr);    
                  }//Kiran
              #endif// UART_16550
2851   1          dataIdx                = 0;
2852   1          cpIdx                  = 0;
2853   1          hostTxFrmSwDesc.frmLen  = curFrmLen;
2854   1          hostTxFrmSwDesc.cpCount = 0;
2855   1      
2856   1          while (curFrmLen)
2857   1          {
2858   2              u8                  cp;
2859   2              volatile u8 xdata * cellAddr;
2860   2              u8                  actualDescLen;
2861   2      
2862   2              status = CHAL_RequestCP(&cp);
2863   2              if (status != STATUS_SUCCESS)
2864   2              {
2865   3                  return;
2866   3              }
2867   2              cellAddr = CHAL_GetAccessToCP(cp);
2868   2              if (curFrmLen > HYBRII_CELLBUF_SIZE)
2869   2              {
2870   3                  actualDescLen = HYBRII_CELLBUF_SIZE;
2871   3              }
2872   2              else
2873   2              {
2874   3                  actualDescLen = curFrmLen;
2875   3              }
2876   2              //memcpy(cellAddr, &TxByteArr[dataIdx], actualDescLen);
2877   2              if(firstCp == 0)
2878   2              {
2879   3                //  hostHdr_t *pHybrii;
2880   3                  u8 hdrLen;
2881   3                  if(hostIntf == HOST_INTF_SPI)
2882   3                  {
2883   4      #ifdef HYBRII_SPI
2884   4                      hdrLen = sizeof(hybrii_tx_req_t);
2885   4                      actualDescLen = hdrLen;
2886   4      
2887   4      #endif  //HYBRII_SPI
2888   4                  }
2889   3                  else if(hostIntf == HOST_INTF_ETH)
2890   3                  {
2891   4                      hdrLen = (sizeof(sEth2Hdr));                
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 48  

2892   4                      memcpy(cellAddr, ethhdr, sizeof(sEth2Hdr));
2893   4                      memcpy( (cellAddr + hdrLen), &TxByteArr[dataIdx], (actualDescLen - hdrLen));
2894   4                  }
2895   3      #ifdef UART_HOST_INTF 
                    else if(hostIntf == HOST_INTF_UART)
                      {
                        hdrLen = 0;//UART driver creates required header for Formatted mode   
                              memcpy(cellAddr, &TxByteArr[dataIdx], actualDescLen);
                      }//Kiran
              #endif// UART_16550
2902   3                  firstCp = 1;
2903   3                  dataIdx += (actualDescLen - hdrLen);
2904   3      
2905   3              }
2906   2              else
2907   2              {
2908   3                  if(hostIntf == HOST_INTF_SPI)
2909   3                  {
2910   4                      u8 ethHdrLen = sizeof(sEth2Hdr);
2911   4                      memcpy(cellAddr, ethhdr, ethHdrLen);                
2912   4                      memcpy(&cellAddr[ethHdrLen], &TxByteArr[dataIdx], actualDescLen);
2913   4                  }
2914   3                  else if(hostIntf == HOST_INTF_ETH)
2915   3                  {
2916   4                      memcpy(cellAddr, &TxByteArr[dataIdx], actualDescLen);
2917   4                  }
2918   3            else// For UART 
2919   3                  {
2920   4                      memcpy(cellAddr, &TxByteArr[dataIdx], actualDescLen);
2921   4                  }
2922   3                  dataIdx += actualDescLen;
2923   3                  if(hostIntf == HOST_INTF_SPI)
2924   3                  {
2925   4                      if(curFrmLen <= HYBRII_CELLBUF_SIZE && curFrmLen > 1)
2926   4                      {
2927   5                          actualDescLen -= SPI_CRC_LEN;               }
2928   4                      else if(curFrmLen == (HYBRII_CELLBUF_SIZE + 1))
2929   4                      {
2930   5                          actualDescLen -= 1;
2931   5                      }
2932   4                      else if(curFrmLen == 1)
2933   4                      {
2934   5                          actualDescLen -= 1;
2935   5                      }
2936   4                      for (i = 0; i < actualDescLen; i++) {
2937   5                          crc16 = crc_ccitt_update(crc16, cellAddr[i]);
2938   5                      }
2939   4                  
2940   4                      if(curFrmLen <= HYBRII_CELLBUF_SIZE && curFrmLen > 1)
2941   4                      {
2942   5                          cellAddr[i] = crc16 & 0xFF;
2943   5                          i++;
2944   5                          cellAddr[i] = (crc16 >> 8) & 0xFF;
2945   5                          actualDescLen += SPI_CRC_LEN;
2946   5                      }
2947   4                      else if(curFrmLen == (HYBRII_CELLBUF_SIZE + 1))
2948   4                      {
2949   5                          cellAddr[i] = crc16 & 0xFF;
2950   5                          actualDescLen += 1;
2951   5                      }
2952   4                      else if(curFrmLen == 1)
2953   4                      {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 49  

2954   5                          cellAddr[i] = (crc16 >> 8) & 0xFF;
2955   5                          actualDescLen += 1;
2956   5                      }
2957   4                  }
2958   3              }
2959   2              hostTxFrmSwDesc.cpArr[cpIdx].offsetU32 = 0;
2960   2              hostTxFrmSwDesc.cpArr[cpIdx].len  = actualDescLen;
2961   2              hostTxFrmSwDesc.cpArr[cpIdx].cp = cp;
2962   2              cpIdx++;
2963   2              hostTxFrmSwDesc.cpCount++;
2964   2              curFrmLen -= actualDescLen;
2965   2          }
2966   1          
2967   1          numHostCPs += hostTxFrmSwDesc.cpCount;
2968   1          if(hostIntf == HOST_INTF_SPI)
2969   1          {
2970   2      #ifdef HYBRII_SPI
2971   2      
2972   2              hostTxFrmSwDesc.frmLen -= sizeof(hybrii_tx_req_t);
2973   2      #endif  //HYBRII_SPI
2974   2          }
2975   1      
2976   1      
2977   1        datapath_writeHostIntf(&hostTxFrmSwDesc);
2978   1        
2979   1        status = STATUS_SUCCESS;
2980   1        
2981   1      
2982   1      
2983   1      /*    if(hostIntf == HOST_INTF_SPI)
2984   1          {
2985   1      #ifdef HYBRII_SPI
2986   1              
2987   1              hal_spi_tx_cleanup ();
2988   1              hal_spi_rx_cleanup ();
2989   1              hostTxFrmSwDesc.frmLen -= sizeof(hybrii_tx_req_t);
2990   1              status = hal_spi_tx_dma_cp(hostTxFrmSwDesc.frmLen, &hostTxFrmSwDesc);
2991   1      #endif
2992   1          }
2993   1          else if(hostIntf == HOST_INTF_ETH)
2994   1          {
2995   1              status = EHAL_EthTxQWrite(&hostTxFrmSwDesc);
2996   1          }
2997   1          */
2998   1          if (status == STATUS_FAILURE)
2999   1          {
3000   2              for (cpIdx = 0; cpIdx < hostTxFrmSwDesc.cpCount; cpIdx++)
3001   2              {
3002   3                  CHAL_DecrementReleaseCPCnt(hostTxFrmSwDesc.cpArr[cpIdx].cp);
3003   3              }
3004   2              //FM_Printf(FM_ERROR, "\nCannot send Eth/SPI packet");
3005   2          }
3006   1          else
3007   1          {
3008   2              gEthHalCB.CurTxTestFrmCnt++;
3009   2              gEthHalCB.CurTxTestBytesCnt+= frameSize;
3010   2          }
3011   1      }
3012          
3013          
3014          bool datapath_transmitMgmtPlc()
3015          {
C51 COMPILER V9.52.0.0   DATAPATH                                                          12/02/2014 14:35:36 PAGE 50  

3016   1        
3017   1        if (HAL_Proc(HOMEPLUG_GetHal()))
3018   1              return TRUE;
3019   1          else
3020   1              return FALSE;
3021   1      
3022   1      }
3023          
3024          
3025          #endif
3026          
3027          
*** WARNING C294 IN LINE 2295 OF ..\..\..\common\datapath\datapath.c: unreachable code
*** WARNING C294 IN LINE 2350 OF ..\..\..\common\datapath\datapath.c: unreachable code
*** WARNING C294 IN LINE 2358 OF ..\..\..\common\datapath\datapath.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7107    ----
   CONSTANT SIZE    =    102    ----
   XDATA SIZE       =   4263     643
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
