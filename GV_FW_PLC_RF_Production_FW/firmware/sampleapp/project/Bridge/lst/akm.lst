C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE AKM
OBJECT MODULE PLACED IN .\obj\akm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\link\akm.c LARGE OBJECTADVANCED OPTIMIZE(9
                    -,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..
                    -\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\h
                    -al;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\fi
                    -rmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbe
                    -e;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\in
                    -c;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\i
                    -nc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;
                    -..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers
                    -\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..
                    -\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\
                    -components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers
                    -\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilitie
                    -s;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\n
                    -wk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..
                    -\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII
                    -_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC
                    -,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DET
                    -ECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUP
                    -T,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REG
                    -ISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\akm.lst) TABS(2) OBJE
                    -CT(.\obj\akm.obj)

line level    source

   1          /** ========================================================
   2           *
   3           *  @file akm.c
   4           * 
   5           *  @brief Authentication and Key Manager 
   6           &*
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * ==========================================================*/
  11          
  12          
  13          #ifdef RTX51_TINY_OS
  14          #include <rtx51tny.h>
  15          #endif
  16          #include <assert.h>
  17          #include <stdlib.h>
  18          #include <string.h>
  19          #include "papdef.h"
  20          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  23          #include "fm.h"
  24          #include "list.h"
  25          #include "timer.h"
  26          #include "stm.h"
  27          #include "hpgpdef.h"
  28          #include "event.h"
  29          #include "nma.h"
  30          #include "nma_fw.h"
  31          #include "hpgpapi.h"
  32          #include "pbkdf1.h"
  33          #include "crc32.h"
  34          #include "linkl.h"
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 2   

  35          #include "nam.h"
  36          #include "akm.h"
  37          #include "mmsg.h"
  38          #include "muxl.h"
  39          #ifdef UKE
              #include "Sha2.h"
              #endif
  42          #ifdef AUTH_AES
              #include "aes.h"
              #endif
  45          #include "dmm.h"
  46          #include "green.h"
  47          #ifdef HPGP_HAL
  48          #include "hal_hpgp.h"
  49          #endif
  50          #include "hybrii_tasks.h"
  51          #include "sys_common.h"
  52          #include "event_fw.h"
  53          
  54          #define MSG_PADDING_LEN(x) ( (x)&0xF ? 0x10 - ((x)&0xF) : 0)
  55          /* PID(1 byte) + PRN(2 bytes) + PMN(1 byte) + RFLen(1 byte) */
  56          #define HPGP_ENC_MM_TAIL_LEN   5     
  57          #define CRC_SIZE               4
  58          /* Padding: RF (<=15 bytes) + Padding  (<=15 bytes) */
  59          #define HPGP_ENC_MM_PAD_MAX    30    
  60          
  61          
  62          #define HPGP_TIME_KEY          1000     /* 100 ms */
  63          #define HPGP_MMTYPE_ALL        0xFFFF
  64          
  65          enum {
  66              AKM_NEK_NO,
  67              AKM_KEY_NEW_NEK,
  68          };
  69          #ifdef MULTIDEV
              extern void HTM_ResetNsm(void);
              extern u8 devNum;
              #endif
  73          
  74          #ifdef UKE
              u8 *hashKey = NULL;
              u8 genTek = 0;
              #endif
  78          
  79          /* encryption protocol info */
  80          typedef struct encProtoInfo
  81          {
  82              u8          pid;
  83              u16         prn;
  84              u8          pmn;
  85          } __PACKED__ sEncProtoInfo, *psEncProtoInfo;
  86          
  87          
  88          extern void LINKL_TimerHandler(u16 type, void *cookie);
  89          
  90          /* --------------------------
  91           * Auth and Key  manager
  92           * ------------------------- */
  93          
  94          void FillRandomNumber(u8 *buff, u16 len)
  95          {
  96   1          u16 i;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 3   

  97   1      
  98   1          for (i = 0; i < len; i++)
  99   1          {
 100   2              buff[i] = rand() & 0xFF;
 101   2          }
 102   1      }
 103          
 104          
 105          void LINKL_FillHpgpHdr(sHpgpHdr *hpgpHdr, u8 tei, u8 *macAddr, u8 snid, u8 mnbc,
 106                                    u8 eks)
 107          {
 108   1          
 109   1          hpgpHdr->tei = tei;
 110   1          hpgpHdr->macAddr = macAddr;
 111   1          hpgpHdr->snid = snid;
 112   1      
 113   1          hpgpHdr->mnbc = mnbc;
 114   1          hpgpHdr->eks = eks;
 115   1      
 116   1      }
 117          
 118          #ifdef UKE
              
              eStatus AKM_GenerateTek()
              {
              
                  sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sAkm  *akm = &linkl->akm;
              
                  u8 digest[32];
                  
                  sha256(digest, hashKey, HASH_KEY_LEN * 2 * 8);
                  memcpy(akm->tek, digest, 16);
                  DMM_Free(hashKey);
                  hashKey = NULL;
               //   FM_HexDump(FM_HINFO,"TEK: ",akm->tek,16);
                  akm->tekPeks = 2;
                  return STATUS_SUCCESS;
              }
              
              
              u8* AKM_GetTek()
              {
                  sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
              
              
                  return (&linkl->akm.tek);
              
              }
              
              #endif
 148          
 149          eStatus GenerateKey(u8 *pwd, u8 pwdlen, u8 *key)
 150          {
 151   1          u8 salt[8] = {0x08, 0x85, 0x6D, 0xAF, 0x7C, 0xF5, 0x81, 0x85};
 152   1          /*Compiler warning suppression*/
 153   1          pwd = pwd;
 154   1          pwdlen = pwdlen;
 155   1          
 156   1          /* FIXME: for test only */
 157   1          memcpy(key, salt, 8);
 158   1          return STATUS_SUCCESS;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 4   

 159   1      //    return pbkdf1(pwd, pwdlen, salt, 8, 1000, key, ENC_KEY_LEN);
 160   1      }
 161          
 162          
 163          u8 AKM_GetNewEks(sAkm *akm) 
 164          {
 165   1          akm->eks = 0;//(++(akm->eks))%0x8;
 166   1          return (akm->eks & 0x0F);
 167   1      }
 168          
 169          
 170          
 171          sDb *AKM_BuildEncPayload(sAkm *akm, u16 mmtype, void *param) 
 172          {
 173   1          u8           rfLen = 0;
 174   1          u8           padLen = 0;
 175   1          u16          buffLen = 0;
 176   1          u8           size = 0;
 177   1          u8 crc2[4];// = {0x1a,0x21, 0xd5, 0x8b };// 0xD 5 5 3 0 8F } //
 178   1          u8          *pos = NULL;
 179   1          u32          crc = 0;
 180   1          u8          *crct;
 181   1          sDb         *db = NULL;
 182   1          sEth2Hdr    *ethII = NULL;
 183   1          sMmHdr      *mmh = NULL;
 184   1          sEncProtoInfo *tail = NULL;
 185   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 186   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
 187   1      
 188   1          /*Compiler warning suppression*/
 189   1          param = param;
 190   1        
 191   1          /* allocate a buffer for encrypted payload */
 192   1          if (((mmtype == MMTYPE_CM_GET_KEY_CNF) && (akm->keyType == KEY_TYPE_NEK)) ||
 193   1              ((mmtype == MMTYPE_CM_SET_KEY_REQ) && (akm->keyType == KEY_TYPE_NMK)))
 194   1          {
 195   2              size = ENC_KEY_LEN;
 196   2          }
 197   1          buffLen = HPGP_MM_HEADER_LEN + sizeof(uEncMgmtMsg) + size +
 198   1                    CRC_SIZE + HPGP_ENC_MM_TAIL_LEN + HPGP_ENC_MM_PAD_MAX;
 199   1          db = DB_Alloc(buffLen, 0);
 200   1          if (db == NULL)
 201   1          {
 202   2              FM_Printf(FM_ERROR, "DBfail\n");
 203   2              return NULL;
 204   2          }
 205   1      
 206   1          /* may align the buffer on 128 bits (16 bytes) boundary */
 207   1          pos = db->buffDesc.dataptr;
 208   1          /* random filler */
 209   1          rfLen = rand() & 0xF;
 210   1          FillRandomNumber(pos, rfLen);
 211   1          pos += rfLen;
 212   1          /* ethernet header */
 213   1          ethII = (sEth2Hdr *)pos;
 214   1          memcpy(ethII->srcaddr, staInfo->macAddr, MAC_ADDR_LEN);
 215   1          memcpy(ethII->dstaddr, akm->peerMacAddr, MAC_ADDR_LEN);
 216   1          ethII->ethtype = HTONS(ETH_TYPE_HPGP);//SWAP_FIX;
 217   1          pos += sizeof(sEth2Hdr);  
 218   1          /* mgmt msg header */
 219   1          mmh = (sMmHdr *)pos; 
 220   1          mmh->mmv = 0x1;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 5   

 221   1          mmh->mmtype = cpu_to_le16(mmtype);//SWAP_FIX ;
 222   1          mmh->nfmi = 0;
 223   1          mmh->fnmi = 0;
 224   1          mmh->fmsn = 0;
 225   1          pos += sizeof(sMmHdr);
 226   1      
 227   1          switch(mmtype)
 228   1          {
 229   2              case MMTYPE_CM_GET_KEY_REQ:
 230   2              {
 231   3                  /* Get KEY REQ msg body */
 232   3                  sCmGetKeyReq *req = (sCmGetKeyReq *)pos;
 233   3                  req->reqType = 0;    /* direct */
 234   3                  req->reqKeyType = akm->keyType;
 235   3      #ifdef KEY_SPEC
                          memcpy(req->myNonce, akm->myNonce, 4);
                          memcpy(req->nid, staInfo->nid, NID_LEN);
              #endif
 239   3                  req->pid = akm->pid; 
 240   3                  req->prn = akm->prn;
 241   3                  req->pmn = akm->pmn; 
 242   3                  pos += sizeof(sCmGetKeyReq);
 243   3                  padLen = rfLen + HPGP_MM_HEADER_LEN + sizeof(sCmGetKeyReq) + size +
 244   3                           CRC_SIZE + HPGP_ENC_MM_TAIL_LEN;
 245   3                  padLen = MSG_PADDING_LEN(padLen);
 246   3      #ifdef P8051
 247   3      //FM_Printf(FM_ERROR, "AKM: tx rf len = %bu, pad len = %bu.\n", rfLen, padLen);
 248   3      #else
              //FM_Printf(FM_ERROR, "AKM: tx rf len = %d, pad len = %d.\n", rfLen, padLen);
              #endif
 251   3                  break;
 252   3              }
 253   2              case MMTYPE_CM_GET_KEY_CNF:
 254   2              {
 255   3                  /* Get KEY CNF msg body */
 256   3                  sCmGetKeyCnf * cnf = (sCmGetKeyCnf *)pos;
 257   3                  cnf->result = 0;    /* key granted */
 258   3                  cnf->reqKeyType = akm->keyType;
 259   3      #ifdef KEY_SPEC
                          memcpy(cnf->myNonce, akm->myNonce, 4);
                          memcpy(cnf->yourNonce, akm->yourNonce, 4);
                          memcpy(cnf->nid, staInfo->nid, NID_LEN);
              #endif
 264   3                  cnf->pid = akm->pid; 
 265   3                  cnf->prn = akm->prn;
 266   3                  cnf->pmn = akm->pmn; 
 267   3                  cnf->eks = staInfo->nekEks;
 268   3                  pos += sizeof(sCmGetKeyCnf);
 269   3                  memcpy(pos, staInfo->nek, ENC_KEY_LEN);
 270   3                  pos += ENC_KEY_LEN;
 271   3                  padLen = rfLen + HPGP_MM_HEADER_LEN + sizeof(sCmGetKeyCnf) + size +
 272   3                           CRC_SIZE + HPGP_ENC_MM_TAIL_LEN;
 273   3                  padLen = MSG_PADDING_LEN(padLen);
 274   3                  break;
 275   3              }
 276   2      #ifdef UKE
                  
                      case MMTYPE_CM_SET_KEY_REQ:
                      {
                          /* Set KEY Req msg body */
                          sCmSetKeyReq* req = (sCmSetKeyReq *)pos;
                          req->keyType = akm->keyType;    /* key granted */
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 6   

              #ifdef KEY_SPEC
                          memcpy(req->myNonce, akm->myNonce, 4);
                          memcpy(req->yourNonce, akm->yourNonce, 4);
                          memcpy(req->nid, staInfo->nid, NID_LEN);
              #endif
                          req->pid = akm->pid; 
                          req->prn = akm->prn;
                          req->pmn = akm->pmn; 
                          req->ccoCap = staInfo->ccoScb->staCap.fields.ccoCap;
                          req->newEks = PEKS_NMK;
                          memcpy(req->pNewKey, staInfo->nmk, ENC_KEY_LEN);            
                          pos += sizeof(sCmSetKeyReq);
                          padLen = rfLen + HPGP_MM_HEADER_LEN + sizeof(sCmSetKeyReq) +
                                   CRC_SIZE + HPGP_ENC_MM_TAIL_LEN;
                          padLen = MSG_PADDING_LEN(padLen);
                          break;
                      }
                      case MMTYPE_CM_SET_KEY_CNF:
                      {
                          /* Set KEY cnf msg body */
                          sCmSetKeyCnf* cnf = (sCmSetKeyCnf*)pos;
                          cnf->result= 0;    /* key granted */
              #ifdef KEY_SPEC
                          memcpy(cnf->myNonce, akm->myNonce, 4);
                          memcpy(cnf->yourNonce, akm->yourNonce, 4);
              #endif
                          cnf->pid = akm->pid; 
                          cnf->prn = akm->prn;
                          cnf->pmn = akm->pmn; 
                          cnf->ccoCapability = staInfo->ccoScb->staCap.fields.ccoCap;
                          pos += sizeof(sCmSetKeyCnf);
                          padLen = rfLen + HPGP_MM_HEADER_LEN + sizeof(sCmSetKeyCnf) +
                                   CRC_SIZE + HPGP_ENC_MM_TAIL_LEN;
                          padLen = MSG_PADDING_LEN(padLen);
                          break;
                      }
              #endif    
 320   2              default:
 321   2              {
 322   3              }
 323   2          }
 324   1          /* CRC */
 325   1          crc = chksum_crc32(db->buffDesc.dataptr + rfLen, 
 326   1                             pos - db->buffDesc.dataptr - rfLen);
 327   1      
 328   1          crct = (u8*)&crc;
 329   1      
 330   1          crc2[0] = crct[3];
 331   1      
 332   1          crc2[1] = crct[2];
 333   1      
 334   1          crc2[2] = crct[1];
 335   1      
 336   1          crc2[3] = crct[0];
 337   1      
 338   1      
 339   1          
 340   1          memcpy(pos, &crc2, sizeof(u32));  
 341   1      
 342   1          pos += CRC_SIZE;
 343   1          /* cm encrypted payload ind msg tail */
 344   1          tail = (sEncProtoInfo *)pos;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 7   

 345   1          tail->pid = akm->pid; 
 346   1          tail->prn = akm->prn;
 347   1          tail->pmn = akm->pmn; 
 348   1          pos += sizeof(sEncProtoInfo);
 349   1          /* padding */
 350   1          FillRandomNumber(pos, padLen);
 351   1          pos += padLen;
 352   1          *pos = rfLen;
 353   1          pos ++;
 354   1          db->buffDesc.datalen = pos - db->buffDesc.dataptr;
 355   1          akm->pad = rfLen + padLen;
 356   1          if(db->buffDesc.datalen % 16) 
 357   1          {
 358   2              FM_Printf(FM_ERROR, "NAal\n");
 359   2          }
 360   1          
 361   1          return db;
 362   1      }
 363          
 364          extern sHomePlugCb HomePlug;
 365          eStatus AKM_SendEncPayloadInd(sAkm *akm, u16 mmType, sDb *db, 
 366                                        u8 peks, u8 avlnStatus)
 367          {
 368   1          u8          *pos = NULL;
 369   1          sCmEncryPayloadInd *ind = NULL;
 370   1          sHpgpHdr    *hpgpHdr = NULL;
 371   1          sEvent     xdata *event = NULL;
 372   1          eStatus     ret = STATUS_SUCCESS;
 373   1      
 374   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 375   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
 376   1        u16 size=0; 
 377   1      
 378   1          /*Compiler warning suppression*/
 379   1          mmType = mmType;
 380   1        size = sizeof(sCmEncryPayloadInd) + db->buffDesc.datalen;
 381   1         // event =  EVENT_Alloc(sizeof(sCmEncryPayloadInd) + db->buffDesc.datalen, 
 382   1                             //  EVENT_HPGP_MSG_HEADROOM);//kiran stack optimization
 383   1      
 384   1        event = (sEvent *) DMM_Alloc(MGMT_POOL_ID,sizeof(sEvent) + size + EVENT_HPGP_MSG_HEADROOM);
 385   1        if(event == NULL)
 386   1          {
 387   2              FM_Printf(FM_ERROR, "EAF\n");
 388   2              return STATUS_FAILURE;
 389   2          }
 390   1        else
 391   1        {
 392   2          memset(event, 0, sizeof(sEvent) + size + EVENT_HPGP_MSG_HEADROOM);
 393   2          event->buffDesc.buff = (u8 *)event + sizeof(sEvent);
 394   2          event->buffDesc.dataptr = event->buffDesc.buff + EVENT_HPGP_MSG_HEADROOM;
 395   2          event->buffDesc.datalen = 0;
 396   2          event->buffDesc.bufflen = size + EVENT_HPGP_MSG_HEADROOM;
 397   2          event->eventHdr.status = EVENT_STATUS_COMPLETE;
 398   2          SLINK_Init(&event->link);
 399   2        }
 400   1      
 401   1          event->eventHdr.eventClass = EVENT_CLASS_MSG;
 402   1          event->eventHdr.type = EVENT_TYPE_CM_ENCRY_PAYLOAD_IND;
 403   1          
 404   1          LINKL_FillHpgpHdr((sHpgpHdr *)event->buffDesc.buff,
 405   1                          akm->peerTei,
 406   1                          akm->peerMacAddr,
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 8   

 407   1                          staInfo->snid,
 408   1                          0,
 409   1                          HPGP_EKS_NONE);
 410   1      
 411   1          pos = event->buffDesc.dataptr;
 412   1          ind = (sCmEncryPayloadInd *)pos;
 413   1          ind->peks = peks;
 414   1          ind->pid = akm->pid; 
 415   1          ind->prn = akm->prn;
 416   1          ind->pmn = akm->pmn; 
 417   1          ind->avlnStatus = avlnStatus;
 418   1          memcpy(ind->iv, akm->nmkIv, ENC_IV_LEN);
 419   1          ind->len = cpu_to_le16(db->buffDesc.datalen - akm->pad 
 420   1                     - HPGP_ENC_MM_TAIL_LEN - CRC_SIZE);
 421   1      #ifdef P8051
 422   1      //FM_Printf(FM_ERROR, "AKM: tx msg len = %d, pad len = %bu.\n", ind->len, akm->pad);
 423   1      #else
              //FM_Printf(FM_ERROR, "AKM: tx msg len = %d, pad len = %d.\n", ind->len, akm->pad);
              #endif
 426   1      
 427   1          pos += sizeof(sCmEncryPayloadInd); 
 428   1          /*  encrypt of payload  done in HAL Task*/
 429   1      
 430   1        memcpy(pos, db->buffDesc.dataptr, db->buffDesc.datalen);
 431   1      
 432   1          pos += db->buffDesc.datalen; 
 433   1          event->buffDesc.datalen = pos - event->buffDesc.dataptr;
 434   1      
 435   1        assert((event->buffDesc.dataptr >= event->buffDesc.buff)&&
 437   1                 ((event->buffDesc.dataptr - event->buffDesc.buff + 
 437   1                   event->buffDesc.datalen) <= event->buffDesc.bufflen));
 438   1      
 439   1          //ret = MUXL_TransmitMgmtMsg(event);
 440   1      
 441   1        //sMmHdr    *mmh = NULL;
 442   1          //sHpgpHdr *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
 443   1      
 444   1          if( event->eventHdr.eventClass != EVENT_CLASS_MSG)
 445   1          {
 446   2          EVENT_Free(event);
 447   2              return STATUS_FAILURE;
 448   2          }
 449   1      
 450   1          /* add the mgmt msg header */
 451   1          if(event->buffDesc.buff+sizeof(sMmHdr) > event->buffDesc.dataptr)
 452   1          {
 453   2          EVENT_Free(event);
 454   2              return STATUS_FAILURE;
 455   2          }
 456   1      
 457   1          if (((((sHpgpHdr *)event->buffDesc.buff)->mnbc)&&(event->buffDesc.datalen > HPGP_MNBC_PAYLOAD_MAX)) ||
 458   1               (event->buffDesc.datalen > HPGP_DATA_PAYLOAD_MAX))
 459   1          {
 460   2              /* perform the msg fragment */
 461   2      //        FM_Printf(FM_ERROR,"MUXL:need frag\n");
 462   2          }
 463   1      
 464   1          event->buffDesc.dataptr -= sizeof(sMmHdr);  
 465   1          event->buffDesc.datalen += sizeof(sMmHdr);  
 466   1         // mmh = (sMmHdr *) (event->buffDesc.dataptr);  
 467   1                
 468   1          //add mgmt msg header
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 9   

 469   1          //fragment is not supported at present
 470   1          //  mmh->mmv = 0x1;
 471   1          //mmh->mmtype = cpu_to_le16(event->eventHdr.type);
 472   1          //mmh->nfmi = 0;
 473   1          //mmh->fnmi = 0;
 474   1          //mmh->fmsn = 0;
 475   1        ((sMmHdr *)(event->buffDesc.dataptr))->mmv = 0x1;
 476   1          ((sMmHdr *)(event->buffDesc.dataptr))->mmtype = cpu_to_le16(event->eventHdr.type);
 477   1        ((sMmHdr *)(event->buffDesc.dataptr))->nfmi = 0;
 478   1        ((sMmHdr *)(event->buffDesc.dataptr))->fnmi = 0;
 479   1        ((sMmHdr *)(event->buffDesc.dataptr))->fmsn = 0;
 480   1        
 481   1         // ret = HAL_Transmit(HOMEPLUG_GetHal(), event);
 482   1         ret = HAL_Transmit(&HomePlug.haLayer, event);
 483   1         
 484   1       
 485   1          /* note: the event is freed by MUXL if the TX is successful */
 486   1          if(ret == STATUS_FAILURE)
 487   1          {
 488   2              EVENT_Free(event);
 489   2          }
 490   1          
 491   1          return ret;
 492   1      }
 493          
 494                 
 495          eStatus AKM_SendEncPayloadRsp(sAkm *akm, u8 result) 
 496          {
 497   1         u8          *pos = NULL;
 498   1         sCmEncryPayloadRsp *rsp = NULL;
 499   1         sHpgpHdr    *hpgpHdr = NULL;
 500   1         sEvent    xdata  *event = NULL;
 501   1         eStatus     ret = STATUS_SUCCESS;
 502   1      
 503   1         sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 504   1         sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
 505   1      
 506   1         //event =  EVENT_Alloc(sizeof(sCmEncryPayloadRsp), 
 507   1           //                   EVENT_HPGP_MSG_HEADROOM);
 508   1      
 509   1        event = (sEvent *) DMM_Alloc(MGMT_POOL_ID,sizeof(sEvent) + sizeof(sCmEncryPayloadRsp) + EVENT_HPGP_MSG_HE
             -ADROOM);
 510   1        if(event == NULL)
 511   1          {
 512   2              FM_Printf(FM_ERROR, "EAF\n");
 513   2              return STATUS_FAILURE;
 514   2          }
 515   1        else
 516   1        {
 517   2          memset(event, 0, sizeof(sEvent) + sizeof(sCmEncryPayloadRsp) + EVENT_HPGP_MSG_HEADROOM);
 518   2          event->buffDesc.buff = (u8 *)event + sizeof(sEvent);
 519   2          event->buffDesc.dataptr = event->buffDesc.buff + EVENT_HPGP_MSG_HEADROOM;
 520   2          event->buffDesc.datalen = 0;
 521   2          event->buffDesc.bufflen = sizeof(sCmEncryPayloadRsp) + EVENT_HPGP_MSG_HEADROOM;
 522   2          event->eventHdr.status = EVENT_STATUS_COMPLETE;
 523   2          SLINK_Init(&event->link);
 524   2        }
 525   1      
 526   1         event->eventHdr.eventClass = EVENT_CLASS_MSG;
 527   1         event->eventHdr.type = EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP;
 528   1         
 529   1         LINKL_FillHpgpHdr((sHpgpHdr *)event->buffDesc.buff,
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 10  

 530   1                         akm->peerTei,
 531   1                         akm->peerMacAddr,
 532   1                         staInfo->snid,
 533   1                 0,
 534   1                 HPGP_EKS_NONE);
 535   1      
 536   1         pos = event->buffDesc.dataptr;
 537   1         rsp = (sCmEncryPayloadRsp*)pos;
 538   1         rsp->pid = akm->pid; 
 539   1         rsp->prn = akm->prn;
 540   1         rsp->result = result;
 541   1      
 542   1         pos += sizeof(sCmEncryPayloadInd); 
 543   1      
 544   1       
 545   1         assert((event->buffDesc.dataptr >= event->buffDesc.buff)&&
 547   1              ((event->buffDesc.dataptr - event->buffDesc.buff + 
 547   1              event->buffDesc.datalen) <= event->buffDesc.bufflen));
 548   1      
 549   1        if( event->eventHdr.eventClass != EVENT_CLASS_MSG)
 550   1        {
 551   2          DMM_Free((u8 *)event);//Kiran Stack Optimization
 552   2            return STATUS_FAILURE;
 553   2        }
 554   1      
 555   1        /* add the mgmt msg header */
 556   1        if(event->buffDesc.buff+sizeof(sMmHdr) > event->buffDesc.dataptr)
 557   1        {
 558   2        //    FM_Printf(FM_ERROR,"MUXL:Databuff small\n");
 559   2            return STATUS_FAILURE;
 560   2        }
 561   1      
 562   1        if (((((sHpgpHdr *)event->buffDesc.buff)->mnbc)&&(event->buffDesc.datalen > HPGP_MNBC_PAYLOAD_MAX)) ||
 563   1             (event->buffDesc.datalen > HPGP_DATA_PAYLOAD_MAX))
 564   1        {
 565   2            /* perform the msg fragment */
 566   2          //  FM_Printf(FM_ERROR,"MUXL:need frag\n");
 567   2        }
 568   1      
 569   1        event->buffDesc.dataptr -= sizeof(sMmHdr);  
 570   1        event->buffDesc.datalen += sizeof(sMmHdr);  
 571   1      
 572   1        ((sMmHdr *)(event->buffDesc.dataptr))->mmv = 0x1;
 573   1        ((sMmHdr *)(event->buffDesc.dataptr))->mmtype = cpu_to_le16(event->eventHdr.type);
 574   1        ((sMmHdr *)(event->buffDesc.dataptr))->nfmi = 0;
 575   1        ((sMmHdr *)(event->buffDesc.dataptr))->fnmi = 0;
 576   1        ((sMmHdr *)(event->buffDesc.dataptr))->fmsn = 0;
 577   1      
 578   1        ret = HAL_Transmit(HOMEPLUG_GetHal(), event);
 579   1      
 580   1      
 581   1         /* note: the event is freed by MUXL if the TX is successful */
 582   1         if(ret == STATUS_FAILURE)
 583   1         {
 584   2             //EVENT_Free(event);
 585   2           DMM_Free((u8 *)event);//Kiran Stack Optimization
 586   2         }
 587   1         
 588   1         return ret;
 589   1      }
 590                        
 591          
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 11  

 592          
 593          eStatus AKM_SendMgmtMsg(sAkm *akm, u16 mmType)
 594          {
 595   1          sDb    *db = NULL;
 596   1          u8 peks, avlnStatus;
 597   1          eStatus ret;
 598   1      
 599   1          /* encode CM_GET_KEY.REQ */
 600   1          db = AKM_BuildEncPayload(akm, mmType, NULL); 
 601   1      
 602   1        if (db == NULL)
 603   1        {
 604   2          return STATUS_FAILURE;
 605   2        }
 606   1      
 607   1          switch(mmType)
 608   1          {
 609   2              case MMTYPE_CM_GET_KEY_REQ:
 610   2              {
 611   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CM_GET_KEY_REQ, NULL, 0);
              #endif
 614   3                  FM_Printf(FM_MMSG, "AKM>>CM_GET_KEY.REQ\n");
 615   3                  peks = PEKS_NMK;
 616   3                  avlnStatus =AVLN_STATUS_ASSOC_NO_PCO_CAP;
 617   3                  break;
 618   3              }
 619   2              case MMTYPE_CM_GET_KEY_CNF:
 620   2              {
 621   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CM_GET_KEY_CNF, NULL, 0);
              #endif
 624   3                  FM_Printf(FM_MMSG, "AKM>>CM_GET_KEY.CNF\n");
 625   3                  peks = PEKS_NMK;
 626   3                  avlnStatus =AVLN_STATUS_ASSOC_NO_PCO_CAP;
 627   3                  break;
 628   3              }
 629   2      #ifdef UKE
                      case MMTYPE_CM_SET_KEY_REQ:
                      {
                          FM_Printf(FM_MMSG, "AKM>>CM_SET_KEY.REQ\n");
                          peks = akm->tekPeks;
                          break;
                      }
                      case MMTYPE_CM_SET_KEY_CNF:
                      {
                          FM_Printf(FM_MMSG, "AKM>>CM_SET_KEY.CNF\n");
                          peks = PEKS_NMK;
                          break;
                      }
              #endif    
 643   2              default:
 644   2              {
 645   3              }
 646   2          }
 647   1          
 648   1          ret = AKM_SendEncPayloadInd(akm, mmType, db, peks, avlnStatus); 
 649   1          /* free the db */
 650   1        DMM_Free((u8 *)db);// Kiran Stack optimization
 651   1          return ret;
 652   1      }
 653          #ifdef UKE
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 12  

              
              eStatus AKM_SendUnEncMgmtMsg(sAkm *akm, u16 mmType)
              {    
                  u8          *pos = NULL;
                  sCmGetKeyReq *req = NULL;
                  sCmGetKeyCnf*cnf = NULL;
                  sHpgpHdr    *hpgpHdr = NULL;
                  sEvent     xdata *event = NULL;
                  u16 eventSize;
                  eStatus     ret = STATUS_SUCCESS;
              
                  sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
              
                  switch(mmType)
                  {
                      case EVENT_TYPE_CM_GET_KEY_REQ:
                      {
                          FM_Printf(FM_MMSG, "AKM>>CM_GET_KEY.REQ-HASH\n");
              
                          
                          eventSize = MAX(sizeof(sCmGetKeyReq), HPGP_DATA_PAYLOAD_MIN); 
                                      
                          event =  EVENT_MgmtAlloc(sizeof(sCmGetKeyReq) + HASH_KEY_LEN,
                                 EVENT_HPGP_MSG_HEADROOM);
                          if(event == NULL)
                          {
                              FM_Printf(FM_ERROR, "EAF\n");
                              return STATUS_FAILURE;
                          }
                          event->eventHdr.eventClass = EVENT_CLASS_MSG;
                          event->eventHdr.type = mmType;
              
                          LINKL_FillHpgpHdr((sHpgpHdr *)event->buffDesc.buff,
                                          akm->peerTei,
                                          akm->peerMacAddr,
                                          staInfo->snid,
                            0,
                            HPGP_EKS_NONE);
                          
                          pos = event->buffDesc.dataptr;
                          req = (sCmGetKeyReq *)pos;
                          req->reqType = 0; // Direct
                          req->reqKeyType = akm->keyType;
              #ifdef KEY_SPEC
                          memcpy(req->nid, staInfo->nid, NID_LEN);
                          memcpy(req->myNonce, akm->myNonce, 4);
              #endif
                          req->pid = akm->pid; 
                          req->prn = akm->prn;
                          req->pmn = akm->pmn; 
                          pos += sizeof(sCmGetKeyReq);
                          // Generate hash key - 384 Len
                          // Store 1st hash key
                          FillRandomNumber(pos, HASH_KEY_LEN);
                          memcpy(&hashKey[0], pos, HASH_KEY_LEN);
                          
                          
                          FM_HexDump(FM_ERROR,"hashKeytx", hashKey, 20);
                          
                          pos += HASH_KEY_LEN;
                          break;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 13  

                      }
                      case EVENT_TYPE_CM_GET_KEY_CNF:
                      {            
                          FM_Printf(FM_MMSG, "AKM>>CM_GET_KEY.CNF-HASH\n");
                      
                          
                          eventSize = MAX(sizeof(sCmGetKeyCnf), HPGP_DATA_PAYLOAD_MIN); 
                          
                          event =  EVENT_MgmtAlloc(sizeof(sCmGetKeyCnf) + HASH_KEY_LEN, EVENT_HPGP_MSG_HEADROOM);
                          if(event == NULL)
                          {
                              FM_Printf(FM_ERROR, "EAF\n");
                              return STATUS_FAILURE;
                          }
              
                      
                      
                          event->eventHdr.eventClass = EVENT_CLASS_MSG;
                          event->eventHdr.type = mmType;
              
                          
                          LINKL_FillHpgpHdr((sHpgpHdr *)event->buffDesc.buff,
                                          akm->peerTei,
                                          akm->peerMacAddr,
                                          staInfo->snid,
                                          0,
                                          HPGP_EKS_NONE);
              
                          pos = event->buffDesc.dataptr;
                          cnf = (sCmGetKeyCnf *)pos;
                          cnf->result = 0; // Key Confirm
                          cnf->reqKeyType = akm->keyType;
              #ifdef KEY_SPEC
                          memcpy(cnf->nid, staInfo->nid, NID_LEN);
                          memcpy(cnf->myNonce, akm->myNonce, 4);            
                          memcpy(cnf->yourNonce, akm->yourNonce, 4);
              #endif
                          cnf->pid = akm->pid; 
                          cnf->prn = akm->prn;
                          cnf->pmn = akm->pmn;
              #if 1
              
                          cnf->eks = akm->tekPeks;
              
              #else
                          if(akm->eks < 2)
                          {
                              akm->eks = 2;
                          }
                          else
                          {
                              akm->eks++;
                          }
              
              
                          cnf->eks = akm->eks;
              
              #endif            
                          
                          pos += sizeof(sCmGetKeyCnf);
                          // Generate hash key - 384 Len
                          // Store 2nd hash key
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 14  

                          FillRandomNumber(pos, HASH_KEY_LEN);
                          memcpy(&hashKey[HASH_KEY_LEN], pos, HASH_KEY_LEN);
                          
                         // FM_HexDump(FM_ERROR,"hashKeytx", &hashKey[HASH_KEY_LEN], 20);
                          
                          // Generate tek
                          genTek = 1;
                          pos += HASH_KEY_LEN;
                          break;
                      }
                      default:
                          return ret; 
                          break;
                        
                  }
              
                  
              
                  //event->buffDesc.datalen = eventSize;
              
                  event->buffDesc.datalen = pos - event->buffDesc.dataptr;
              
                 // EVENT_Assert(event);//kiran stack optimization
                assert((event->buffDesc.dataptr >= event->buffDesc.buff)&&
                         ((event->buffDesc.dataptr - event->buffDesc.buff + 
                           event->buffDesc.datalen) <= event->buffDesc.bufflen));
                  
                  ret = MUXL_TransmitMgmtMsg(event);
                  /* note: the event is freed by MUXL if the TX is successful */
                  if(ret == STATUS_FAILURE)
                  {
                      //EVENT_Free(event);
                      DMM_Free((u8 *)event);//KIran stack optimization
                  }
                  
                  return ret;    
              }
              
              #endif
 817          
 818          eStatus AKM_DeliverEvent(u16 eventType, uEventParam *eventParam)
 819          {
 820   1          sEvent    xdata   *event = NULL;
 821   1          sLinkLayer   *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 822   1          u8           *pos; 
 823   1      
 824   1          event = EVENT_Alloc(sizeof(uEventBody), 0);
 825   1          if(event == NULL)
 826   1          {
 827   2              FM_Printf(FM_ERROR, "AKM:EAF\n");
 828   2              return STATUS_FAILURE;
 829   2          }
 830   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 831   1          event->eventHdr.type = eventType;
 832   1      
 833   1          switch(eventType)
 834   1          {
 835   2              case EVENT_TYPE_AUTH_RSP:
 836   2              {
 837   3                  pos = event->buffDesc.dataptr;
 838   3                  memcpy(pos, &eventParam->authRsp, sizeof(eventParam->authRsp));
 839   3                  event->buffDesc.datalen = sizeof(eventParam->authRsp);
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 15  

 840   3                  break;
 841   3              }
 842   2              case EVENT_TYPE_AUTH_IND:
 843   2              {
 844   3                  pos = event->buffDesc.dataptr;
 845   3                  memcpy(pos, &eventParam->authInd, sizeof(eventParam->authInd));
 846   3                  event->buffDesc.datalen = sizeof(eventParam->authInd);
 847   3                  break;
 848   3              }
 849   2              default:
 850   2              {
 851   3              }
 852   2          }
 853   1          
 854   1          /* deliver the event to the upper layer */
 855   1      #ifdef CALLBACK
                  linkl->deliverEvent(linkl->eventcookie, event);
              #else
 858   1          CTRLL_ReceiveEvent(linkl->eventcookie, event);
 859   1      #endif
 860   1          
 861   1          return STATUS_SUCCESS;
 862   1      }
 863          
 864          #ifdef UKE
              
              eStatus AKM_ProcGetKeyReq(sAkm *akm, sEvent *event)
              {
                  sCmGetKeyReq       *req = NULL;
                  u8                 *pos = NULL;
                  
                sHpgpHdr           *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                  eStatus             ret;
                sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
                  
                  pos = event->buffDesc.dataptr;
                  req = (sCmGetKeyReq *)pos;
              
                  if ((req->pmn != 1) && (req->pmn != 0xFF)) {
                      /* perform the basic verification */
                      if( (akm->pid != req->pid) ||
                          (akm->prn != req->prn) ||
                          ((akm->pmn+1) != req->pmn) )
                      {
              
                          return STATUS_FAILURE;
                      }
                  }
                          
                  akm->pid = req->pid;
                  akm->prn = req->prn;
              
              #if 0
                  ukePeer = LinkL_GetUKEPeer(linkl);
                     
                  if ((ukePeer, hpgpHdr->macAddr, MAC_ADDR_LEN) ||
                      (akm->pid != AUTH_PID_NMK_WITH_UKE))
                  {
                      return STATUS_FAILURE;
                  }
                  
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 16  

              #endif
              
                  akm->peerTei = hpgpHdr->tei;
                  akm->peerMacAddr = hpgpHdr->macAddr;
              
                  if ((req->reqType == 0) &&(req->reqKeyType == KEY_TYPE_HASH_KEY))
                  {
                      akm->pmn = 2;
                      akm->keyType = KEY_TYPE_HASH_KEY;
              #ifdef KEY_SPEC
                      memcpy(akm->yourNonce, req->myNonce, 4)
              #endif
                      FillRandomNumber(akm->myNonce, 4);
                      pos += sizeof(sCmGetKeyReq);
                      memcpy(&hashKey[0], pos, HASH_KEY_LEN);
                      
                      STM_StartTimer(akm->TekTimer, HPGP_TEK_LIFETIME);
                                  
                      /* Send CM_GET_KEY.CNF */
                      ret = AKM_SendUnEncMgmtMsg(akm, MMTYPE_CM_GET_KEY_CNF); 
                            
                  }
              
                  return ret;
              }
              
              #endif
 929          
 930          void AKM_SendAuthInd (sAkm *akm, u8 keyType, u8 status)
 931          {
 932   1      
 933   1        uEventParam eventParam;
 934   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 935   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
 936   1      
 937   1          /*Compiler warning suppression*/
 938   1          akm = akm;
 939   1      #ifdef UKE
                  
                  // Stop TEK life timer
                  STM_StopTimer(akm->TekTimer);
                 // rajan STM_FreeTimer(akm->TekTimer);
                  // Make TEK invalid
                  memset(akm->tek, 0, 16);
              
              #endif
 948   1      
 949   1          eventParam.authInd.keyType = keyType;
 950   1      
 951   1          eventParam.authInd.secMode  = staInfo->secMode;
 952   1      
 953   1          eventParam.authInd.result = status;
 954   1      
 955   1          if(keyType == KEY_TYPE_NMK)
 956   1          {
 957   2              LINKL_SetSecurityMode(linkl, SEC_MODE_SC);    
 958   2      
 959   2          }
 960   1      #ifdef UKE
              
                  if ((status == STATUS_FAILURE) &&
                      (hashKey != NULL))
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 17  

                      
                  {
                      DMM_Free(hashKey);
                      hashKey = NULL;
                  }
              
              #endif
 971   1      
 972   1          AKM_DeliverEvent(EVENT_TYPE_AUTH_IND, &eventParam);
 973   1      
 974   1      
 975   1      
 976   1      }
 977          
 978          eStatus AKM_ProcEncPayload(sAkm *akm, u16 mmType, sDb *db, sScb *scb) 
 979          {
 980   1          u8          *pos = NULL;
 981   1          sMmHdr      *mmh = NULL;
 982   1          sCmGetKeyReq * req = NULL;
 983   1          sCmSetKeyReq * setReq = NULL;
 984   1          sCmGetKeyCnf *cnf = NULL;
 985   1          sCmSetKeyCnf *setCnf = NULL;
 986   1          eStatus      ret = STATUS_FAILURE;
 987   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 988   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
 989   1      
 990   1          db->buffDesc.dataptr += sizeof(sEth2Hdr);
 991   1          db->buffDesc.datalen -= sizeof(sEth2Hdr);
 992   1          mmh = (sMmHdr *) db->buffDesc.dataptr;
 993   1          
 994   1      
 995   1          if ((mmType != HPGP_MMTYPE_ALL) && (le16_to_cpu(mmh->mmtype) != mmType))
 996   1              return STATUS_FAILURE;
 997   1          
 998   1          db->buffDesc.dataptr += sizeof(sMmHdr);
 999   1          db->buffDesc.datalen -= sizeof(sMmHdr);
1000   1          pos = db->buffDesc.dataptr;
1001   1          switch(le16_to_cpu(mmh->mmtype))
1002   1          {
1003   2              case MMTYPE_CM_GET_KEY_REQ:
1004   2              {
1005   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CM_GET_KEY_REQ, &scb->tei, 1);
              #endif
1008   3                  FM_Printf(FM_MMSG, "AKM<<CM_GET_KEY.REQ\n");
1009   3                  /* Get KEY REQ msg body */
1010   3                  req = (sCmGetKeyReq *)pos;
1011   3                  if ((req->reqType == 0) &&(req->reqKeyType == KEY_TYPE_NEK))
1012   3                  {
1013   4                      /* TODO: check if the device is in CCo mode */
1014   4                     
1015   4                      
1016   4                      akm->pmn = 0xFF; 
1017   4                      akm->keyType = KEY_TYPE_NEK;
1018   4      #ifdef KEY_SPEC
                              memcpy(akm->yourNonce, req->myNonce, 4);
                              FillRandomNumber(akm->myNonce, 4);
              #endif
1022   4                      /* encode CM_GET_KEY.CNF */
1023   4                      ret = AKM_SendMgmtMsg(akm, MMTYPE_CM_GET_KEY_CNF); 
1024   4                      if ( (ret == STATUS_SUCCESS ) && scb)
1025   4                      {
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 18  

1026   5                          scb->staStatus.fields.authStatus = 1; 
1027   5      
1028   5                          /*TODO: call the nsm to broadcast */
1029   5                      }
1030   4                      else
1031   4                      {
1032   5            //              FM_Printf(FM_ERROR, "authStatus failed:%bu\n", 
1033   5              //                        scb->staStatus.fields.authStatus);
1034   5                      }
1035   4                  }
1036   3                  break;
1037   3              }
1038   2              case MMTYPE_CM_GET_KEY_CNF:
1039   2              {
1040   3                  sEvent xdata * cpltEvent = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
1041   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CM_GET_KEY_CNF, &scb->tei, 1);
              #endif
1044   3                  FM_Printf(FM_MMSG, "AKM<<CM_GET_KEY.CNF\n");
1045   3                  /* Get KEY CNF msg body */
1046   3                  cnf = (sCmGetKeyCnf *)pos;
1047   3                  if (cnf->result == 0)
1048   3                  {
1049   4                      if (cnf->reqKeyType == KEY_TYPE_NEK) 
1050   4                      {
1051   5      
1052   5      #ifdef KEY_SPEC
                                   if(memcmp(akm->myNonce, cnf->yourNonce, 4) != 0)
                                   {
              //                         FM_Printf(FM_ERROR, "Unmatched nonce\n");
                                       break;
              
                                   }
              #endif
1060   5                           staInfo->nekEks = cnf->eks; 
1061   5                           pos += sizeof(sCmGetKeyCnf);
1062   5                           memcpy(staInfo->nek, pos, ENC_KEY_LEN);
1063   5      #ifndef RELEASE
1064   5      //                     FM_Printf(FM_HINFO, "NEK EKS:%bu\n", staInfo->nekEks);
1065   5        //                   FM_HexDump(FM_HINFO, "NEK:", staInfo->nek, ENC_KEY_LEN);
1066   5      #endif
1067   5      #ifdef HPGP_HAL
1068   5                           /* set the NEK to the LMAC for the STA */
1069   5                           HHAL_AddNEK(staInfo->nekEks, staInfo->nek);
1070   5      #endif
1071   5                           staInfo->staStatus.fields.authStatus = 1; 
1072   5      
1073   5      
1074   5                           AKM_SendAuthInd(akm, KEY_TYPE_NEK, STATUS_SUCCESS);
1075   5                           if(cpltEvent != NULL)
1076   5                           {
1077   6                               cpltEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1078   6                               cpltEvent->eventHdr.type = EVENT_TYPE_AUTH_CPLT;
1079   6                               LINKL_SendEvent(linkl,cpltEvent);
1080   6                           }                     
1081   5      #ifdef MULTIDEV                 
                                   if(devNum != 0)
                                   {
                                      sHaLayer *hal = HOMEPLUG_GetHal();
                                      hal->macAddr[5] = hal->macAddr[5] + 1;
                                      devNum--;
                               
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 19  

                                      HTM_ResetNsm();
                                   }
              #endif
1091   5                           ret = STATUS_SUCCESS;
1092   5                      }
1093   4                  }
1094   3                  break;
1095   3              }
1096   2      #ifdef UKE
                  
                      case MMTYPE_CM_SET_KEY_REQ:
                      {
                                          
                          FM_Printf(FM_MMSG, "AKM<<CM_SET_KEY.REQ\n");
                          /* Get KEY REQ msg body */
                          setReq = (sCmSetKeyReq *)pos;
                          if ((setReq->keyType == KEY_TYPE_NMK))
                          {             
                              akm->pid = AUTH_PID_NMK_WITH_UKE;
                              akm->pmn = 0xFF; 
                              akm->keyType = KEY_TYPE_NMK;
              #ifdef KEY_SPEC
                              memcpy(akm->yourNonce, setReq->myNonce, 4);
                              FillRandomNumber(akm->myNonce, 4);
              #endif
                              /* encode CM_SET_KEY.CNF */
                              ret = AKM_SendMgmtMsg(akm, MMTYPE_CM_SET_KEY_CNF); 
                              if (ret == STATUS_SUCCESS )
                              {
                                  // Set NMK   
                                  staInfo->nmkPeks = setReq->newEks;
                                  memcpy(staInfo->nmk, setReq->pNewKey, ENC_KEY_LEN);                    
                              }
                              else
                              {
                                  FM_Printf(FM_ERROR, "Set NMK Failed\n");
                              }
                          }
                          FM_HexDump(FM_HINFO, "NMK:", staInfo->nmk, ENC_KEY_LEN);
                          //os_switch_task();
                          // Send out get key req
              #if 0            
                          akm->keyType = KEY_TYPE_NEK;
                          akm->pid = AUTH_PID_NEW_STA; 
                          akm->prn = rand() & 0xFFFF;
                          akm->pmn = 1; 
                          ret = AKM_SendMgmtMsg(akm, MMTYPE_CM_GET_KEY_REQ);
                          /* start the key timer for a response */
                          STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
                          akm->state = AKM_STATE_WAITFOR_GET_NEK_CNF;
              #else
              
                          akm->state = AKM_STATE_READY;
              
                          AKM_SendAuthInd(akm, KEY_TYPE_NMK, STATUS_SUCCESS);
                                               
              
              
              #endif
              
              
                          ret = STATUS_SUCCESS;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 20  

                          break;
                      }
                      case MMTYPE_CM_SET_KEY_CNF:
                      {
                       
                          FM_Printf(FM_MMSG, "AKM<<CM_SET_KEY.CNF\n");
              
                          /* Get KEY CNF msg body */
              
                          setCnf = (sCmSetKeyCnf *)pos;
              #ifdef KEY_SPEC
                          if(memcmp(akm->myNonce, setCnf->yourNonce, 4) != 0)
                          {
                              FM_Printf(FM_ERROR, "Unmatched nonce\n");
                              break;
              
                          }
                          else
              #endif
                          {
                                
                              ret = STATUS_SUCCESS;                    
                              
                              AKM_SendAuthInd(akm, KEY_TYPE_NMK, setCnf->result);
                          }
                          
                          break;
                      }
              #endif    
1179   2              default:
1180   2              {
1181   3              }
1182   2          }
1183   1          return ret;
1184   1      }
1185          
1186          
1187          
1188          sDb *AKM_DecodeEncPayloadInd(sAkm *akm, sEvent *event) 
1189          {
1190   1          sCmEncryPayloadInd *ind = NULL;
1191   1          sDb                *db = NULL;
1192   1        u8 crc2[4];
1193   1          u8                 *pos = NULL;
1194   1          u8                  rfLen = 0;
1195   1          u32                 crc = 0;
1196   1          u8              *crct;
1197   1          sHpgpHdr           *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1198   1      #ifdef UKE  
                  sScb               * scb;
              #endif
1201   1          u8 ret;
1202   1      #ifdef AUTH_AES
              
                sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
              
              #ifdef DELAY_HACK
                  u8 XDATA  *decbuf;
              #endif
                  u8 XDATA  iv[20];
                  AES_KEY   key;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 21  

                
                  
              #ifdef DELAY_HACK
                  decbuf = DMM_Alloc(256);
                  if ((decbuf == NULL)){
                //    FM_Printf(FM_ERROR, "Can't alloc mem\n");
                    return STATUS_FAILURE;
                  }
              #endif
              #endif
1222   1        /*Compiler warning suppression*/    
1223   1        ret = ret;
1224   1      
1225   1          akm->peerTei = hpgpHdr->tei;
1226   1          akm->peerMacAddr = hpgpHdr->macAddr;
1227   1      
1228   1          pos = event->buffDesc.dataptr;
1229   1          ind = (sCmEncryPayloadInd *)pos;
1230   1      
1231   1          if ((ind->pmn != 1) && (ind->pmn != 0xFF)) {
1232   2              /* perform the basic verification */
1233   2              if( (akm->pid != ind->pid) ||
1234   2                  (akm->prn != ind->prn) ||
1235   2                  ((akm->pmn+1) != ind->pmn) )
1236   2              {
1237   3      //            FM_Printf(FM_ERROR, "Unmatched prn\n");
1238   3                  return NULL;
1239   3              }
1240   2          }
1241   1          
1242   1      
1243   1          akm->peerTei = hpgpHdr->tei;
1244   1          akm->peerMacAddr = hpgpHdr->macAddr;
1245   1      
1246   1          akm->pid = ind->pid;
1247   1          akm->prn = ind->prn;
1248   1          akm->pmn = ind->pmn; 
1249   1      
1250   1      
1251   1          pos += sizeof(sCmEncryPayloadInd);
1252   1          
1253   1          db = DB_Alloc(le16_to_cpu(ind->len) + HPGP_ENC_MM_TAIL_LEN + CRC_SIZE  
1254   1                        + HPGP_ENC_MM_PAD_MAX, 0); 
1255   1          if (db == NULL)
1256   1          {
1257   2              FM_Printf(FM_ERROR, "dbfail\n");
1258   2              return NULL;
1259   2          }
1260   1          /* TODO: decrypt the payload */
1261   1      
1262   1          db->buffDesc.datalen = event->buffDesc.datalen - sizeof(sCmEncryPayloadInd);
1263   1      #ifdef AUTH_AES
                  if(ind->peks == KEY_TYPE_NMK)
                  {
                      //FM_Printf(FM_HINFO, "decode KEY_TYPE_NMK\n");
                      //AES_set_encrypt_key((unsigned char*)staInfo->nmk, 8*AES_BLOCK_SIZE, &key);
                      aes_set_key((unsigned char*)staInfo->nmk, AES_BLOCK_SIZE, &key );//kiran code optimization. Caller
             - multiplies by 8 and called function divide by 8
                  //To reduce stack aes_set_key is directly called
                  }
              #ifdef UKE  
                  else
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 22  

                 // tek
                  {
                      scb = (sScb*)hpgpHdr->scb;
                      //AES_set_encrypt_key(akm->tek, 8*AES_BLOCK_SIZE, &key);
                  aes_set_key( akm->tek, AES_BLOCK_SIZE, key );//kiran code optimization. Caller multiplies by 8 and calle
             -d function divide by 8
                  //To reduce stack aes_set_key is directly called
                  }
              #endif
                memcpy(iv, ind->iv, ENC_IV_LEN);
              #ifdef DELAY_HACK
                if(db->buffDesc.datalen > 256)
                {
                  FM_Printf(FM_ERROR, "Excess Buff len\n");
                      return STATUS_FAILURE;
                } 
                  AES_cbc_encrypt((unsigned char*)pos, 
                        (unsigned char*)decbuf, 
                        db->buffDesc.datalen, 
                        &key, 
                        (unsigned char*)iv,
                        AES_DECRYPT);
                  
                memcpy(db->buffDesc.dataptr, decbuf, db->buffDesc.datalen);
                DMM_Free (decbuf);
              #else
                  ret = AES_cbc_encrypt((unsigned char*)pos, 
                          (unsigned char*)db->buffDesc.dataptr, 
                          db->buffDesc.datalen, 
                          &key, 
                          (unsigned char*)iv,
                          AES_DECRYPT);
                  if(ret != STATUS_SUCCESS)
                  {
                      //DB_Free(db);
                      DMM_Free((u8 *)db);// Kiran stack optimization
                      return NULL;
                  }
              #endif  
              #else
1312   1          memcpy(db->buffDesc.dataptr, pos, db->buffDesc.datalen);
1313   1      #endif
1314   1         
1315   1          /* rf length */
1316   1          rfLen = *(db->buffDesc.dataptr + db->buffDesc.datalen - 1);
1317   1      
1318   1      
1319   1          db->buffDesc.dataptr += rfLen;
1320   1          db->buffDesc.datalen = le16_to_cpu(ind->len);
1321   1      #ifdef P8051
1322   1      //FM_Printf(FM_ERROR, "AKM: recv rf len = %bu, msg len = %bu.\n", rfLen, ind->len);
1323   1      #else
              //FM_Printf(FM_ERROR, "AKM: recv rf len = %d, msg len = %d.\n", rfLen, ind->len);
              #endif
1326   1          /* perform crc verification */
1327   1          crc = chksum_crc32(db->buffDesc.dataptr, db->buffDesc.datalen);
1328   1         crct = (u8*)&crc;
1329   1      
1330   1          crc2[0] = crct[3];
1331   1          crc2[1] = crct[2];
1332   1          crc2[2] = crct[1];
1333   1          crc2[3] = crct[0];
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 23  

1334   1          pos = db->buffDesc.dataptr + db->buffDesc.datalen; 
1335   1          if (memcmp(pos, &crc2, sizeof(u32))) 
1336   1          {    
1337   2      #ifndef RELEASE
1338   2      //        FM_Printf(FM_ERROR, "crcissue no match(tx:0x%08x,rx:0x%08x)\n", *(u32*)pos, crc);
1339   2          FM_Printf(FM_ERROR, "crcissue\n");
1340   2      
1341   2      #endif
1342   2          }
1343   1          return db;
1344   1      }
1345          
1346          
1347          
1348          u8 AKM_ProcReady(sAkm *akm, sEvent *event)
1349          {
1350   1          sDb *db = NULL;
1351   1          sHpgpHdr *hpgpHdr = NULL;
1352   1          u8  state = AKM_STATE_READY;
1353   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1354   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
1355   1      
1356   1      
1357   1          if( event->eventHdr.eventClass == EVENT_CLASS_MSG)
1358   1          {
1359   2              switch(event->eventHdr.type)
1360   2              {
1361   3      
1362   3                  case EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP:
1363   3                      
1364   3                      //FM_Printf(FM_ERROR, "AKM:EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP\n");
1365   3      
1366   3                      break;
1367   3                      
1368   3                  case EVENT_TYPE_CM_ENCRY_PAYLOAD_IND:
1369   3                  {
1370   4      //FM_Printf(FM_ERROR, "AKM: recv the Enc Payload Ind\n");
1371   4                      /* decrpt the messsage */
1372   4                      db = AKM_DecodeEncPayloadInd(akm, event);
1373   4                      if (db != NULL)
1374   4                      {
1375   5                          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1376   5                          /* Process a request */
1377   5                          AKM_ProcEncPayload(akm, HPGP_MMTYPE_ALL, db, hpgpHdr->scb);
1378   5                          /* free the db */
1379   5                         // DB_Free(db);
1380   5                 DMM_Free((u8 *)db);// Kiran stack optimization
1381   5                      }
1382   4                      else
1383   4                      {
1384   5                          //send EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP with fail code
1385   5                          AKM_SendEncPayloadRsp(akm, 1);
1386   5                      }
1387   4                      
1388   4                     
1389   4                      break;
1390   4                   }
1391   3      #ifdef UKE      
                          case EVENT_TYPE_CM_GET_KEY_REQ:
                          {                  
              
                              if ((staInfo->secMode != SEC_MODE_SC_ADD) &&
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 24  

                                  (staInfo->secMode != SEC_MODE_SC_JOIN))
                              {
              
                                //  FM_Printf(FM_ERROR, "CM_GET_KEY_REQ drop\n");
                                  break;
                              }
                                  
                              if(hashKey == NULL)
                              {
                                  hashKey = DMM_Alloc(768); // TODO release this memory
                              }
                              if(hashKey == NULL)
                              {
                                 // FM_Printf(FM_ERROR, "Hash key alloc fail\n");
                                  break;
                              }
                              
              
                              FM_Printf(FM_MMSG, "AKM<<CM_GET_KEY.REQ-HASH\n");
                  
                              AKM_ProcGetKeyReq(akm, event);
                           
                              break;
                          }
              #endif      
1421   3                  default:
1422   3                  {
1423   4                  }
1424   3              }
1425   2          }
1426   1          else if( event->eventHdr.eventClass == EVENT_CLASS_CTRL)
1427   1          {
1428   2              switch(event->eventHdr.type)
1429   2              {
1430   3      #ifdef UKE
                  
                          case EVENT_TYPE_ASSOC_IND:
                          {
                              if(staInfo->secMode == SEC_MODE_SC_ADD)
                              {
                                  // UKE
                                  
                                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;                    
              
                                  if(hashKey == NULL)
                                  {
                                      hashKey = DMM_Alloc(768); // TODO release this memory
                                  }
                                  if(hashKey == NULL)
                                  {
                                      FM_Printf(FM_ERROR, "Hash key alloc fail\n");
                                      break;
                                  }
                                  /* start a new UKE authentication */                     
              
                                  akm->peerTei = ((sScb*)hpgpHdr->scb)->tei;
                                  
                                  akm->peerMacAddr = ((sScb*)hpgpHdr->scb)->macAddr;
                                  
                                  akm->keyType = KEY_TYPE_HASH_KEY;
                                  akm->pid = AUTH_PID_NMK_WITH_UKE; 
                                  akm->prn = rand() & 0xFFFF;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 25  

                                  akm->pmn = 1; 
              #ifdef KEY_SPEC
                                  FillRandomNumber(akm->myNonce, 4);                
              #endif                   
                                      // start UKE  timer
                                      
                                  STM_StartTimer(akm->TekTimer, HPGP_TEK_LIFETIME);
                                      
                                  /* send CM_GET_KEY.REQ */
                                  AKM_SendUnEncMgmtMsg(akm, MMTYPE_CM_GET_KEY_REQ);
                                  /* start the key timer for a response */
                                  STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
                                  // UKE: Send out AKM get key req                    
                                  //os_switch_task();
                                  akm->txRetryCnt++;
                                  state = AKM_STATE_WAITFOR_HASH_GET_CNF;
                              }
              
                              break;
                          }
              #endif          
1479   3                  case EVENT_TYPE_AUTH_REQ:
1480   3                  {
1481   4                      sAuthReq *authreq = (sAuthReq *)event->buffDesc.dataptr;
1482   4      
1483   4                      if( authreq->authType == AUTH_TYPE_NEK) 
1484   4                      {
1485   5                          /* start a new NEK authentication */ 
1486   5                          akm->peerTei = staInfo->ccoScb->tei;
1487   5                          akm->peerMacAddr = staInfo->ccoScb->macAddr;
1488   5                          akm->keyType = KEY_TYPE_NEK;
1489   5                          akm->pid = AUTH_PID_NEW_STA; 
1490   5                          akm->prn = rand() & 0xFFFF;
1491   5                          akm->pmn = 1; 
1492   5      #ifdef KEY_SPEC
                                  FillRandomNumber(akm->myNonce, 4);
              #endif
1495   5                          FillRandomNumber(akm->nmkIv, ENC_IV_LEN);
1496   5      
1497   5                          /* send CM_GET_KEY.REQ */
1498   5                          AKM_SendMgmtMsg(akm, MMTYPE_CM_GET_KEY_REQ);
1499   5                          /* start the key timer for a response */
1500   5                          STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
1501   5                          akm->txRetryCnt++;
1502   5                          state = AKM_STATE_WAITFOR_GET_NEK_CNF;
1503   5                      }
1504   4                      break;
1505   4                  }
1506   3                  case EVENT_TYPE_AKM_STOP:
1507   3                  {
1508   4      #ifdef HPGP_HAL
1509   4                      /* remvoe the NEK from the LMAC for the STA */
1510   4                      HHAL_RemoveNEK(staInfo->nekEks);
1511   4      #endif
1512   4                      state = AKM_STATE_INIT;
1513   4                      break;
1514   4                  }
1515   3                  default:
1516   3                  {
1517   4                  }
1518   3              }
1519   2          }
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 26  

1520   1          return state;
1521   1      }
1522          
1523          
1524          
1525          
1526          void AKM_ProcEvent(sAkm *akm, sEvent *event)
1527          {
1528   1      
1529   1          u8         *pos = NULL;
1530   1          sDb        *db = NULL;
1531   1          uEventParam eventParam;
1532   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1533   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
1534   1          
1535   1      #ifdef UKE
                  if ((event->eventHdr.eventClass == EVENT_CLASS_CTRL) && 
                      (event->eventHdr.type == EVENT_TYPE_TIMER_TEK_IND))
                  {
                      FM_Printf(FM_HINFO, "AKM:UKE Timeout\n");
                      // Make tek invalid
                      memset(akm->tek, 0, 16);
                             
                      if ((staInfo->secMode == SEC_MODE_SC_JOIN) ||
                          (staInfo->secMode == SEC_MODE_SC_ADD))
                      {
                          staInfo->secMode = SEC_MODE_SC;
                          AKM_SendAuthInd(akm, KEY_TYPE_NMK, STATUS_FAILURE);
              
                          akm->state = AKM_STATE_INIT;
                          
                      }
              
                      return;
              
                  }
              
              #endif
1558   1       
1559   1          switch(akm->state)
1560   1          {
1561   2              case AKM_STATE_INIT:
1562   2              {
1563   3                  if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) && 
1564   3                      (event->eventHdr.type == EVENT_TYPE_AKM_START) )
1565   3                  {
1566   4                      pos = event->buffDesc.dataptr;
1567   4                      akm->akmMode = *pos;
1568   4                      pos++; 
1569   4      #ifndef RELEASE
1570   4      #ifdef P8051
1571   4      FM_Printf(FM_ERROR, "AKM:AKM_START(%bu,%bu)\n", akm->akmMode, *pos);
1572   4      #else
              FM_Printf(FM_ERROR, "AKM:AKM_START(%d)\n", *pos);
              #endif
1575   4      #endif
1576   4       
1577   4                      akm->state = AKM_STATE_READY;
1578   4                  }
1579   3                  break;
1580   3              }
1581   2              case AKM_STATE_READY:
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 27  

1582   2              {
1583   3                  akm->state = AKM_ProcReady(akm, event);
1584   3                  break;
1585   3              }
1586   2              case AKM_STATE_WAITFOR_GET_NEK_CNF:
1587   2              {
1588   3                  if( event->eventHdr.eventClass == EVENT_CLASS_MSG)
1589   3                  {
1590   4                      if (event->eventHdr.type ==  EVENT_TYPE_CM_ENCRY_PAYLOAD_IND)
1591   4                      {
1592   5                          /* decrpt the messsage */
1593   5                          db = AKM_DecodeEncPayloadInd(akm, event);
1594   5                          if (db != NULL)
1595   5                          {
1596   6                              if (AKM_ProcEncPayload(akm, MMTYPE_CM_GET_KEY_CNF, db, NULL)
1597   6                                      == STATUS_SUCCESS)
1598   6                              {
1599   7                                  STM_StopTimer(akm->akmTimer);
1600   7                                  akm->txRetryCnt = 0;
1601   7                                  eventParam.authRsp.authType = AUTH_TYPE_NEK;
1602   7                                  eventParam.authRsp.result = STATUS_SUCCESS;
1603   7                                  AKM_DeliverEvent(EVENT_TYPE_AUTH_RSP, &eventParam);
1604   7      #ifdef AKM
                                  SNAM_StartTEIRenew();
              #endif
1607   7                                  akm->state = AKM_STATE_READY;
1608   7                              }
1609   6                              /* free the db */
1610   6                              DB_Free(db);                     
1611   6                          }
1612   5                          else
1613   5                          {
1614   6                              //send EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP with fail code    
1615   6                              AKM_SendEncPayloadRsp(akm, 1);
1616   6                          }
1617   5                      }
1618   4                  }
1619   3                  else if( event->eventHdr.eventClass == EVENT_CLASS_CTRL)
1620   3                  {
1621   4                      if (event->eventHdr.type == EVENT_TYPE_TIMER_KEY_IND)
1622   4                      {
1623   5                          if( akm->txRetryCnt <= HPGP_TX_RETRY_MAX)
1624   5                          {
1625   6                              /* resend the message */
1626   6                              AKM_SendMgmtMsg(akm, MMTYPE_CM_GET_KEY_REQ); 
1627   6                              /* start the key timer for a response */
1628   6                              STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
1629   6                              akm->txRetryCnt++;
1630   6                              //stay in the same state
1631   6                          }
1632   5                          else
1633   5                          {
1634   6                              akm->txRetryCnt = 0;
1635   6                              /* retry exhausted */
1636   6                              eventParam.authRsp.authType = AUTH_TYPE_NEK;
1637   6                              eventParam.authRsp.result = STATUS_FAILURE;
1638   6                              /* deliver the event to the upper layer */
1639   6                  AKM_SendAuthInd(akm, KEY_TYPE_NEK, STATUS_FAILURE);
1640   6                          }
1641   5                      }
1642   4                  }
1643   3                  break;
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 28  

1644   3              }
1645   2      #ifdef UKE    
                      case AKM_STATE_WAITFOR_HASH_GET_CNF:
                      {
                          if( event->eventHdr.eventClass == EVENT_CLASS_MSG)
                          {
                              if (event->eventHdr.type ==  EVENT_TYPE_CM_GET_KEY_CNF)
                              {
                                  sCmGetKeyCnf *cnf;
                                  pos = event->buffDesc.dataptr;
                                  FM_Printf(FM_MMSG, "AKM<<CM_GET_KEY.CNF-HASH\n");
                                  /* Get KEY CNF msg body */
                                  cnf = (sCmGetKeyCnf *)pos;
                                  if (cnf->result == 0)
                                  {
                                      if (cnf->reqKeyType == KEY_TYPE_HASH_KEY) 
                                      {                 
                                       
                                           /* perform the basic verification */
                                           if((akm->pid != cnf->pid) ||
                                               (akm->prn != cnf->prn) ||
                                               ((akm->pmn+1) != cnf->pmn) ||
                                               (cnf->pmn == 0xFF))
                                           {
                //                               FM_Printf(FM_ERROR, "Unmatched pmn\n");
                                               break;
                                           }
              #ifdef KEY_SPEC
                                           if(memcmp(akm->myNonce, cnf->yourNonce, 4) != 0)
                                           {
              //                                 FM_Printf(FM_ERROR, "Unmatched nonce\n");
                                               break;
               
                                           }
              #endif
                                           akm->txRetryCnt = 0;
                                           STM_StopTimer(akm->akmTimer);
              #ifdef KEY_SPEC
                                           memcpy(akm->yourNonce, cnf->myNonce, 4);
              #endif
                                           pos += sizeof(sCmGetKeyCnf);
                                           memcpy(&hashKey[HASH_KEY_LEN], pos, HASH_KEY_LEN);
                                           /* Generate TEK usinf Hash1 and Hash2 */
                                           genTek = 1;
                                           // TODO Send NMK using SET_KEY.REQ
                                           /* send CM_SET_KEY.REQ */
                                           akm->keyType = KEY_TYPE_NMK;
                                           akm->pid = AUTH_PID_NMK_WITH_UKE;
                                           akm->pmn = 3; 
                                  
                                           AKM_SendMgmtMsg(akm, MMTYPE_CM_SET_KEY_REQ);
                                           /* start the key timer for a response */
                                           STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
                                           akm->txRetryCnt++;
                                           akm->state = AKM_STATE_WAITFOR_NMK_SET_CNF;
                                      }
                                  }
                              }
                          }
                          else if( event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                          {
                              switch(event->eventHdr.type)
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 29  

                              {
                                  case EVENT_TYPE_TIMER_KEY_IND:
                                  {
                                      if( akm->txRetryCnt <= HPGP_TX_RETRY_MAX)
                                      {
                                          /* resend the message */
                                          AKM_SendUnEncMgmtMsg(akm, MMTYPE_CM_GET_KEY_REQ); 
                                          /* start the key timer for a response */
                                          STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
                                          akm->txRetryCnt++;
                                          //stay in the same state
                                      }
                                      else
                                      {
                                          akm->txRetryCnt = 0;
                                          /* retry exhausted */
              
                                          AKM_SendAuthInd(akm, KEY_TYPE_NMK, STATUS_FAILURE);
                                                          
              
                                      }
                                      break;
                                  }
                                  default:
                                  {
                                  }
                              }
                          }
                          break;
                      }
                      case AKM_STATE_WAITFOR_NMK_SET_CNF:
                      {            
                          if( event->eventHdr.eventClass == EVENT_CLASS_MSG)
                          {
                              if (event->eventHdr.type ==  EVENT_TYPE_CM_ENCRY_PAYLOAD_IND)
                              {
                                  /* decrpt the messsage */
                                  db = AKM_DecodeEncPayloadInd(akm, event);
                                  if (db != NULL)
                                  {
                                   
                                      if (AKM_ProcEncPayload(akm, MMTYPE_CM_SET_KEY_CNF, db, NULL)
                                              == STATUS_SUCCESS)
                                      {
                                          STM_StopTimer(akm->akmTimer);
                                         
                                          akm->txRetryCnt = 0;
              
                                          akm->state = AKM_STATE_READY;                            
              
                                          AKM_SendAuthInd(akm, KEY_TYPE_NMK, STATUS_SUCCESS);
                                          
                                          
                                      }
                                      /* free the db */
                                      DB_Free(db);
                                  }
                                  else
                                  {
                                      //send EVENT_TYPE_CM_ENCRY_PAYLOAD_RSP with fail code    
                                      AKM_SendEncPayloadRsp(akm, 1);
                                  }
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 30  

                              }
                          }
                          else if( event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                          {
                              switch(event->eventHdr.type)
                              {
                                  case EVENT_TYPE_TIMER_KEY_IND:
                                  {
                                      if( akm->txRetryCnt <= HPGP_TX_RETRY_MAX)
                                      {
                                          /* resend the message */
                                          AKM_SendMgmtMsg(akm, MMTYPE_CM_SET_KEY_REQ); 
                                          /* start the key timer for a response */
                                          STM_StartTimer(akm->akmTimer, HPGP_TIME_KEY);
                                          akm->txRetryCnt++;
                                          //stay in the same state
                                      }
                                      else
                                      {
                                          akm->txRetryCnt = 0;
                                          /* retry exhausted */
              
                                          AKM_SendAuthInd(akm, KEY_TYPE_NMK, STATUS_FAILURE);
                                          
                                      }
                                      break;
                                  }
                                  default:
                                  {
                                  }
                              }
                          }
                          break;
                      }
              #endif
1803   2          
1804   2              default:
1805   2              {
1806   3              }
1807   2          }
1808   1      }
1809          
1810          
1811          
1812          eStatus AKM_Start(sAkm *akm, u8 mode, u8 newNek )
1813          {
1814   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1815   1          sEvent xdata *event = NULL;
1816   1          u8 *pos = NULL;
1817   1          sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
1818   1      
1819   1         
1820   1          event = EVENT_Alloc(2, EVENT_HPGP_CTRL_HEADROOM);
1821   1          if(event == NULL)
1822   1          {
1823   2              FM_Printf(FM_ERROR, "EAF\n");
1824   2              return STATUS_FAILURE;
1825   2          }
1826   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1827   1          event->eventHdr.type = EVENT_TYPE_AKM_START;
1828   1          pos = event->buffDesc.dataptr;
1829   1          *pos = mode; 
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 31  

1830   1          pos++;
1831   1          *pos = newNek; 
1832   1          event->buffDesc.datalen = 2;
1833   1      //FM_Printf(FM_ERROR, "AKM: Start (%bu).\n", newNek);
1834   1      
1835   1          akm->state = AKM_STATE_READY;
1836   1      
1837   1          if (newNek && (linkl->mode == LINKL_STA_MODE_CCO))
1838   1          {
1839   2              u8 i;
1840   2              u8          pwd[32];
1841   2                 
1842   2              for (i = 0; i < 32; i++)
1843   2              {
1844   3                  pwd[i] = rand() & 0xFF;
1845   3              }
1846   2              /* generate a NEK */            
1847   2              GenerateKey(pwd, 32, staInfo->nek);
1848   2              staInfo->nekEks = AKM_GetNewEks(&linkl->akm); 
1849   2      #ifdef P8051
1850   2      //                    FM_Printf(FM_HINFO, "AKM: NEK EKS: %bu.\n", staInfo->nekEks);
1851   2      #else
              //                    FM_Printf(FM_HINFO, "AKM: NEK EKS: %.2x.\n", staInfo->nekEks);
              #endif
1854   2              FM_HexDump(FM_HINFO, "AKM:NEK:", staInfo->nek, ENC_KEY_LEN);
1855   2      #ifdef HPGP_HAL
1856   2              /* set the NEK to the LMAC for the CCo */
1857   2             HHAL_AddNEK(staInfo->nekEks, staInfo->nek);
1858   2      #endif
1859   2      
1860   2          }  
1861   1                      
1862   1      
1863   1          LINKL_SendEvent(linkl, event);
1864   1          return STATUS_SUCCESS;
1865   1      }
1866          
1867          
1868          eStatus AKM_Stop(sAkm *akm)
1869          {
1870   1        
1871   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1872   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
1873   1        
1874   1      #if 0
              
              
                  sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sEvent *event = NULL;
                  event = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
                  if(event == NULL)
                  {
                      FM_Printf(FM_ERROR, "EAllocErr\n");
                      return STATUS_FAILURE;
                  }
                  event->eventHdr.eventClass = EVENT_CLASS_CTRL;
                  event->eventHdr.type = EVENT_TYPE_AKM_STOP;
                  LINKL_SendEvent(linkl, event);
              
              #else
1890   1        /* remvoe the NEK from the LMAC for the STA */
1891   1        HHAL_RemoveNEK(staInfo->nekEks);
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 32  

1892   1      
1893   1        akm->state = AKM_STATE_INIT;
1894   1      
1895   1      #endif
1896   1        return STATUS_SUCCESS;
1897   1      }
1898          
1899          
1900          void LINKL_AkmTimerHandler(void* cookie)
1901          {
1902   1          sEvent xdata *event = NULL;
1903   1          sLinkLayer * linkl = (sLinkLayer *)cookie;
1904   1      
1905   1          /* Generate a time event */
1906   1          event = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
1907   1          if(event == NULL)
1908   1          {
1909   2              FM_Printf(FM_ERROR, "EAF\n");
1910   2              return;
1911   2          }
1912   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1913   1          event->eventHdr.type = EVENT_TYPE_TIMER_KEY_IND;
1914   1          /* post the event to the event queue */
1915   1          LINKL_SendEvent(linkl, event);
1916   1      }
1917              
1918          
1919          
1920          eStatus AKM_Init(sAkm *akm)
1921          {
1922   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1923   1      #ifdef CALLBACK
                  akm->akmTimer = STM_AllocTimer(LINKL_TimerHandler,
                                      EVENT_TYPE_TIMER_KEY_IND, linkl);
              #else
1927   1          akm->akmTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
1928   1                              EVENT_TYPE_TIMER_KEY_IND, linkl);
1929   1      #endif
1930   1          if(akm->akmTimer == STM_TIMER_INVALID_ID)
1931   1          {
1932   2              return STATUS_FAILURE;
1933   2          }
1934   1      #ifdef UKE  
                  akm->TekTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
                                      EVENT_TYPE_TIMER_TEK_IND, linkl);
                  if(akm->TekTimer == STM_TIMER_INVALID_ID)
                  {
                      return STATUS_FAILURE;
                  }
              #endif
1942   1      #ifdef AKM_PRINT
              #ifdef P8051
              //  FM_Printf(FM_ERROR, "AKM: akm timer id: %bu\n", akm->akmTimer);
              #else
                //FM_Printf(FM_ERROR, "AKM: akm timer id: %d\n", akm->akmTimer);
              #endif
              #endif
1949   1          akm->txRetryCnt = 0;
1950   1      
1951   1          srand(STM_GetTick());
1952   1      
1953   1          chksum_crc32gentab ();
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 33  

1954   1      
1955   1          akm->state = AKM_STATE_INIT;
1956   1          return STATUS_SUCCESS;
1957   1      }
1958          
1959          
1960          
1961          /** =========================================================
1962           *
1963           * Edit History
1964           *
1965           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/link/akm.c,v $
1966           *
1967           * $Log: akm.c,v $
1968           * Revision 1.18  2015/01/02 14:55:36  kiran
1969           * 1) Timer Leak fixed while freeing SCB fixed
1970           * 2) Software broadcast supported for LG
1971           * 3) UART Loopback supported for LG
1972           * 4) Keep Alive feature to ageout defunctional STA
1973           * 5) Improved flash API's for NO Host Solution
1974           * 6) Imporved PLC Hang recovery mechanism
1975           * 7) Reduced nested call tree of common path functions
1976           * 8) Code optimization and cleanup (unused arguments, unused local variables)
1977           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
1978           * 10) Use of memory specific pointers instead of generic pointers
1979           *
1980           * Revision 1.17  2014/11/11 14:52:58  ranjan
1981           * 1.New Folder Architecture espically in /components
1982           * 2.Modular arrangment of functionality in new files
1983           *    anticipating the need for exposing them as FW App
1984           *    development modules
1985           * 3.Other improvisation in code and .h files
1986           *
1987           * Revision 1.16  2014/10/28 16:27:43  kiran
1988           * 1) Software recovery using Watchdog Timer
1989           * 2) Hardware recovery monitor and policies
1990           * 3) Timer Polling in Control Task and Frame task for better accuracy
1991           * 4) Common memory optimized by reducing prints
1992           * 5) Discovered netlist corruption fixed
1993           * 6) VCO fix in HHAL_AFEInit()
1994           * 7) Idata optimized by removing floating point operation
1995           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
1996           * 9) Beacon processing protected from interrupts
1997           * 10) Corrupted Beacons are dropped
1998           * 11) Some unused arguments removed to improve code size
1999           *
2000           * Revision 1.15  2014/10/15 10:42:51  ranjan
2001           * small fixes in um
2002           *
2003           * Revision 1.14  2014/09/25 10:57:42  prashant
2004           * 1. GPIO API swapping issue fixed.
2005           * 2. Supported 1 to 512 frame length for uart.
2006           * 3. list.h file cleanup (code deleted).
2007           * 4. Supporting minirobo for mgmt frames.
2008           *
2009           * Revision 1.13  2014/09/05 09:28:18  ranjan
2010           * 1. uppermac cco-sta switching feature fix
2011           * 2. general stability fixes for many station associtions
2012           * 3. changed mgmt memory pool for many STA support
2013           *
2014           * Revision 1.12  2014/08/25 07:37:34  kiran
2015           * 1) RSSI & LQI support
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 34  

2016           * 2) Fixed Sync related issues
2017           * 3) Fixed timer 0 timing drift for SDK
2018           * 4) MMSG & Error Logging in Flash
2019           *
2020           * Revision 1.11  2014/07/22 10:03:52  kiran
2021           * 1) SDK Supports Power Save
2022           * 2) Uart_Driver.c cleanup
2023           * 3) SDK app memory pool optimization
2024           * 4) Prints from STM.c are commented
2025           * 5) Print messages are trimmed as common no memory left in common
2026           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
2027           *
2028           * Revision 1.10  2014/07/05 09:16:27  prashant
2029           * 100 Devices support- only association tested, memory adjustments
2030           *
2031           * Revision 1.9  2014/06/19 17:13:19  ranjan
2032           * -uppermac fixes for lvnet and reset command for cco and sta mode
2033           * -backup cco working
2034           *
2035           * Revision 1.8  2014/06/12 13:15:43  ranjan
2036           * -separated bcn,mgmt,um event pools
2037           * -fixed datapath issue due to previous checkin
2038           * -work in progress. neighbour cco detection
2039           *
2040           * Revision 1.7  2014/06/11 13:17:47  kiran
2041           * UART as host interface and peripheral interface supported.
2042           *
2043           * Revision 1.6  2014/05/28 10:58:59  prashant
2044           * SDK folder structure changes, Uart changes, removed htm (UI) task
2045           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
2046           *
2047           * Revision 1.5  2014/05/12 08:09:57  prashant
2048           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
2049           *
2050           * Revision 1.4  2014/03/10 05:58:10  ranjan
2051           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
2052           *
2053           * Revision 1.3  2014/02/27 10:42:47  prashant
2054           * Routing code added
2055           *
2056           * Revision 1.2  2014/01/10 17:17:53  yiming
2057           * check in Rajan 1/8/2014 code release
2058           *
2059           * Revision 1.6  2014/01/08 10:53:54  ranjan
2060           * Changes for LM OS support.
2061           * New Datapath FrameTask
2062           * LM and UM  datapath, feature verified.
2063           *
2064           * known issues : performance numbers needs revisit
2065           *
2066           * review : pending.
2067           *
2068           * Revision 1.5  2013/10/16 07:43:38  prashant
2069           * Hybrii B Upper Mac compiling issues and QCA fix, added default eks code
2070           *
2071           * Revision 1.4  2013/09/04 14:51:01  yiming
2072           * New changes for Hybrii_A code merge
2073           *
2074           * Revision 1.21  2013/07/12 08:56:36  ranjan
2075           * -UKE Push Button Security Feature.
2076           * Verified : DirectEntry Security Works.Datapath Works.
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 35  

2077           *                 command SetSecMode for UKE works.
2078           * Added against bug-160
2079           *
2080           * Revision 1.20  2013/03/22 12:21:49  prashant
2081           * default FM_MASK and FM_Printf modified for USER INFO
2082           *
2083           * Revision 1.19  2012/12/18 12:17:46  prashant
2084           * Stability checkin
2085           *
2086           * Revision 1.18  2012/11/06 05:05:26  ranjan
2087           * -moved AES encryption to Hal Task
2088           * - verified link establishment is very stable
2089           *
2090           * Revision 1.17  2012/10/25 11:38:48  prashant
2091           * Sniffer code added for MAC_SAP, Added new commands in MAC_SAP for sniffer, bridge,
2092           *  hardware settings and peer information.
2093           *
2094           * Revision 1.16  2012/10/11 06:21:00  ranjan
2095           * ChangeLog:
2096           * 1. Added HPGP_MAC_SAP to support linux host data and command path.
2097           *     define HPGP_MAC_SAP, NMA needs to be added in project.
2098           *
2099           * 2. Added 'p ping' command in htm.c . Feature is under AUTO_PING macro.
2100           *
2101           * 3. Extended  'p key' command to include PPEK support.
2102           *
2103           * verified :
2104           *   1. Datapath ping works overnite after association,auth
2105           *   2. HAL TEST project is intact
2106           *
2107           * Revision 1.15  2012/07/15 17:31:07  yuanhua
2108           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
2109           *
2110           * Revision 1.14  2012/07/08 18:42:20  yuanhua
2111           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
2112           *
2113           * Revision 1.13  2012/06/30 23:36:26  yuanhua
2114           * return the success status for LINKL_SendEvent() when RTX51 OS is used.
2115           *
2116           * Revision 1.12  2012/06/05 07:25:59  yuanhua
2117           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
2118           *
2119           * Revision 1.11  2012/06/04 23:34:02  son
2120           * Added RTX51 OS support
2121           *
2122           * Revision 1.10  2012/05/19 20:32:17  yuanhua
2123           * added non-callback option for the protocol stack.
2124           *
2125           * Revision 1.9  2012/05/19 05:05:15  yuanhua
2126           * optimized the timer handlers in CTRL and LINK layers.
2127           *
2128           * Revision 1.8  2012/05/17 05:05:58  yuanhua
2129           * (1) added the option for timer w/o callback (2) added task id and name.
2130           *
2131           * Revision 1.7  2012/05/12 04:11:46  yuanhua
2132           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
2133           *
2134           * Revision 1.6  2012/04/30 04:05:57  yuanhua
2135           * (1) integrated the HAL mgmt Tx. (2) various updates
2136           *
C51 COMPILER V9.53.0.0   AKM                                                               11/04/2015 20:09:39 PAGE 36  

2137           * Revision 1.5  2012/04/13 06:15:11  yuanhua
2138           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
2139           *
2140           * Revision 1.4  2012/03/11 17:02:24  yuanhua
2141           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
2142           *
2143           * Revision 1.3  2011/09/18 01:32:08  yuanhua
2144           * designed the AKM for both STA and CCo.
2145           *
2146           * Revision 1.2  2011/09/09 07:02:31  yuanhua
2147           * migrate the firmware code from the greenchip to the hybrii.
2148           *
2149           * Revision 1.3  2011/07/22 18:51:04  yuanhua
2150           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
2151           *
2152           * Revision 1.2  2011/07/02 22:09:01  yuanhua
2153           * Implemented both SNAM and CNAM modules, including network join and leave procedures, systemm resource (
             -such as TEI) allocation and release, TEI renew/release timers, and TEI reuse timer, etc.
2154           *
2155           * Revision 1.1  2011/05/28 06:31:19  kripa
2156           * Combining corresponding STA and CCo modules.
2157           *
2158           * Revision 1.1  2011/05/06 19:10:12  kripa
2159           * Adding link layer files to new source tree.
2160           *
2161           * Revision 1.1  2011/04/08 21:42:45  yuanhua
2162           * Framework
2163           *
2164           *
2165           * =========================================================*/
2166          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8108    ----
   CONSTANT SIZE    =    627    ----
   XDATA SIZE       =   ----     395
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
