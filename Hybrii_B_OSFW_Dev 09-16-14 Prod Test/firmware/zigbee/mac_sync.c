/**
 * @file
 *
 * Handle MLME-SYNC.request
 *
 * $Id: mac_sync.c,v 1.4 2014/06/09 13:19:46 kiran Exp $
 *
 * Copyright (c) 2012, Greenvity Communication All rights reserved.
 *
 */

/* === Includes ============================================================ */

#include "papdef.h"
#include "return_val.h"
#include "bmm.h"
#include "qmm.h"
#include "mac_msgs.h"
#include "mac_hal.h"
#include "mac_const.h"
#include "mac_api.h"
#include "mac_data_structures.h"
#include "mac_internal.h"
#include "mac.h"
#include "utils.h"
#include "timer.h"
#include "stm.h"

/* === Macros =============================================================== */


/* === Globals ============================================================= */

/* === Prototypes ========================================================== */

/* === Implementation ====================================================== */

/*
 * This function is a callback from the missed beacon timer and implements the
 * generation of sync loss if required.
 *
 * callback_parameter - Callback parameter of the expired missed beacon
 */
void mac_sync_missed_beacons_cb (void *callback_parameter)
{
    if (MAC_SYNC_NEVER != mac_sync_state) {
        /* Since the node lost sync with it's parent, it reports sync loss. */
        mac_sync_loss(MAC_BEACON_LOSS);
    }

    callback_parameter = callback_parameter;  /* Keep compiler happy. */
}

/*
 * Start missed beacon timer
 */
void mac_sync_start_missed_beacon_timer (void)
{
    uint32_t sync_loss_time;

    /* Stop the missed beacon timer. */
    STM_StopTimer(beacon_missed_timer);

    /* Calculate the time allowed for missed beacons. */
    if (hal_pib_BeaconOrder < NON_BEACON_NWK) {
        /*
         * This the regualar case where we already have a Beacon Order.
         * In this case the Sync Loss time is a function of the actual
         * Beacon Order.
         */
        sync_loss_time = HAL_GET_BEACON_INTERVAL_TIME(hal_pib_BeaconOrder);
    } else {
        /*
         * No Beacon Order
         * This happens regularly in case of synchronization before association
         * if the Beacon Order was not set be the network layer or application.
         *
         * In this case the Sync Loss time is based on the highest possible
         * Beacon Order, which is 15 - 1, since 15 means no Beacon network.
         */
        sync_loss_time = HAL_GET_BEACON_INTERVAL_TIME(NON_BEACON_NWK - 1);
    }

    sync_loss_time *= aMaxLostBeacons;

    sync_loss_time = HAL_CONVERT_SYMBOLS_TO_US(sync_loss_time) / 1000;

    if (STATUS_SUCCESS != STM_StartTimer(beacon_missed_timer, 
                                         sync_loss_time )) {
        /* Sync timer could not be started hence report sync-loss */
        mac_sync_loss(MAC_BEACON_LOSS);
    }
}

/*
 * The MLME-SYNC.request primitive requests to synchronize with the
 * coordinator by acquiring and, if specified, tracking its beacons.
 * The MLME-SYNC.request primitive is generated by the next higher layer of a
 * device on a beacon-enabled PAN and issued to its MLME to synchronize with
 * the coordinator.
 *
 * Enable receiver and search for beacons for at most an interval of
 * [aBaseSuperframeDuration * ((2 ^ (n))+ 1)] symbols where n is the value of
 * macBeaconOrder. If a beacon frame containing the current PAN identifier of
 * the device is not received, the MLME shall repeat this search. Once the
 * number of missed beacons reaches aMaxLostBeacons, the MLME shall notify
 * the next higher layer by issuing the MLME-SYNC-LOSS.indication primitive
 * with a loss reason of BEACON_LOSS.
 *
 * @param m Pointer to the MLME sync request parameters.
 */
void mlme_sync_request (buffer_t *buf_p)
{

    mlme_sync_req_t *msr_p = (mlme_sync_req_t *)buf_p;

    /*
     * Sync is only allowed for nodes that are:
     * 1) Devices (also before association.) or coordinators
     *    (no PAN coordinators),
     * 2) Currently NOT polling, and
     * 3) Currently NOT scanning.
     */
    if ((MAC_PAN_COORD_STARTED == mac_state)      ||
        (MAC_POLL_IDLE         != mac_poll_state) ||
        (MAC_SCAN_IDLE         != mac_scan_state)) {

        /* Free the buffer allocated for MLME-SYNC-Request */
        bmm_buffer_free(buf_p);

        mac_sync_loss(MAC_BEACON_LOSS);

        return;
    }

    /* Stop the beacon tracking period timer. */
    STM_StopTimer(beacon_tracking_timer);


    /* Set MAC Sync state properly. */
    if (MAC_IDLE == mac_state) {
        /*
         * We try to sync before association.
         * This is a special sync state that checks beacon frames similar to
         * MAC_SYNC_TRACKING_BEACON while being associated.
         *
         * Before this state can be entered successfully a number of PIB
         * attributes have to be set properly:
         * 1) PAN-Id (macPANId)
         * 2) Coordinator Short or Long address (depending upon which type
         *    of addressing the coordinator is using)
         *    (macCoordShortAddress or mac macCoordExtendedAddress)
         *
         * Furthermore it is strongly recommended to set the Beacon order and
         * Superframe order (macBeaconOrder, macSuperframeOrder).
         * If these parameters are not set and the node tries to sync with a
         * network, where it never receives a beacon from, the missed beacon
         * timer (required for reporting a sync loss condition) will start
         * with a huge time value (based on a beacon order = 15).
         * If finally a beacon is received from the desired network, the timer
         * will be updated.
         * Nevertheless setting the PIB attributes before sync is safer.
         */
        mac_sync_state = MAC_SYNC_BEFORE_ASSOC;
    } else {
        if (msr_p->TrackBeacon) {
            mac_sync_state = MAC_SYNC_TRACKING_BEACON;
        } else {
            mac_sync_state = MAC_SYNC_ONCE;
        }
    }

    /* Wake up radio first */
    mac_trx_wakeup();

    set_hal_pib_internal(phyCurrentPage, (void *)&(msr_p->ChannelPage));

    set_hal_pib_internal(phyCurrentChannel, (void *)&(msr_p->LogicalChannel));

    mac_sync_start_missed_beacon_timer();

     /* Start synching by switching ON the receiver. */
    mac_hal_hw_control(PHY_RX_ON);

    /* Free the buffer allocated by the higher layer */
    bmm_buffer_free(buf_p);
}

/*
 * This function is a callback from the tracking beacon timer and implements
 * the RX timer service  function during sync and enables the receiver before
 * the next beacon reception is expected.
 *
 * callback_parameter - Callback parameter of the expired beacon tracking timer
 */
void mac_sync_tracking_beacons_cb (void *callback_parameter)
{
    /* Wake up radio first */
    mac_trx_wakeup();

     /* Turn the radio on */
    mac_hal_hw_control(PHY_RX_ON);

    callback_parameter = callback_parameter;  /* Keep compiler happy. */
}

/*
 * This function is a callback from the superframe beacon timer for an
 * end deviceand implements the functionality required for entering the
 * inactive portion for an end device.
 *
 * callback_parameter - Callback parameter of the superframe timer
 */
void mac_sync_start_inactive_device_cb (void *callback_parameter)
{
    /*
     * Go to sleep (independent of the value of macRxOnWhenIdle)
     * because we enter the incative portion now.
     * Note: Do not use mac_sleep_trans() here, because this would check
     * macRxOnWhenIdle first.
     */
    mac_trx_init_sleep();

    callback_parameter = callback_parameter;  /* Keep compiler happy. */
}

/**
 * loss_reason - MAC_REALIGNMENT if sync loss is due to receiving
 * coordinator realignment command and MAC_BEACON_LOSS if beacon was
 * lost following a sync request.
 */
void mac_sync_loss (uint8_t loss_reason)
{
    /*
     * Static buffer used to give sync loss indication.
     * This buffer is used
     * 1) when the device looses sync with the parents beacons
     * 2) when the device receives a coordinator realignment command from his
     *    parent
     * The buffer pointer is stored into the begin of the same static buffer.
     */
    static uint8_t mac_sync_loss_buffer[sizeof(buffer_t) +
                                        sizeof(mlme_sync_loss_ind_t)];
    mlme_sync_loss_ind_t *sync_loss_ind;
    buffer_t *msg_ptr;

    /* Update static buffer allocated for sync loss indication. */
    msg_ptr = (buffer_t *)mac_sync_loss_buffer;
    msg_ptr->body = &mac_sync_loss_buffer[sizeof(buffer_t)];
    sync_loss_ind = (mlme_sync_loss_ind_t *)(msg_ptr->body);

    sync_loss_ind->cmdcode = MLME_SYNC_LOSS_INDICATION;;
    sync_loss_ind->LossReason = loss_reason;

    if (MAC_SCAN_IDLE != mac_scan_state) {
        sync_loss_ind->PANId = mac_scan_orig_panid;
        sync_loss_ind->LogicalChannel = mac_scan_orig_channel;
        sync_loss_ind->ChannelPage = mac_scan_orig_page;
    } else {
        sync_loss_ind->PANId = hal_pib_PANId;
        sync_loss_ind->LogicalChannel = hal_pib_CurrentChannel;
        sync_loss_ind->ChannelPage = hal_pib_CurrentPage;
    }

    /* Send Sync Loss Indication message */
    mlme_sync_loss_ind(msg_ptr);

    /* A device that is neither scanning nor polling shall go to sleep now. */
    if ((MAC_IDLE == mac_state) || (MAC_ASSOCIATED == mac_state)) {
        if ((MAC_SCAN_IDLE == mac_scan_state) &&
            (MAC_POLL_IDLE == mac_poll_state)) {
            /* Set radio to sleep if allowed */
            mac_trx_sleep();
        }
    }

    mac_sync_state = MAC_SYNC_NEVER;
}

/**
 * This function processes a coordinator realignment command frame received
 * from the coordinator (while NOT being in the middle of an Orphan scan, but
 * rather after initiation of a start request primitive from the coordinator
 * indicating realingment.
 * The PAN ID, coord. short address, logical channel, and the device's new
 * short address will be written to the PIB.
 *
 * ind_p - coordinatoe realignment indication 
 */
void mac_sync_process_coord_realign (buffer_t *ind_p)
{
    /*
     * The coordinator realignment command is received without the orphan
     * notification. Hence a sync loss indication is given to NHLE.
     */
    mac_sync_loss(MAC_REALIGNMENT);

    /*
     * The buffer in which the coordinator realignment is received is
     * freed up
     */
    bmm_buffer_free((buffer_t *)ind_p);

    /* Set the appropriate PIB entries */

    set_hal_pib_internal(macPANId,
                         (void *)&mac_parse_data.\
                         mac_payload_data.coord_realign_data.pan_id);


    if (BROADCAST !=
        mac_parse_data.mac_payload_data.coord_realign_data.short_addr) {
        /* Short address only to be set if not broadcast address */
        set_hal_pib_internal(macShortAddress,
                             (void *)&mac_parse_data.\
                             mac_payload_data.coord_realign_data.short_addr);

    }

    mac_pib_macCoordShortAddress =
            mac_parse_data.mac_payload_data.coord_realign_data.coord_short_addr;

    /*
     * If frame version subfield indicates a 802.15.4-2006 compatible frame,
     * the channel page is appended as additional information element.
     */
    if (mac_parse_data.fcf & FCF_FRAME_VERSION_2006) {
        set_hal_pib_internal(phyCurrentPage,
                             (void *)&mac_parse_data.\
                             mac_payload_data.coord_realign_data.channel_page);
    }

    set_hal_pib_internal(phyCurrentChannel,
                         (void *)&mac_parse_data.\
                         mac_payload_data.coord_realign_data.logical_channel);

}

