C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE HAL_HPGP_RESET
OBJECT MODULE PLACED IN .\obj\hal_hpgp_reset.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\project\hal\src\hal_hpgp_reset.c LARGE OBJECTADVANC
                    -ED OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\inc
                    -lude;..\..\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmwa
                    -re\hpgp\src\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;.
                    -.\..\..\..\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\f
                    -irmware\zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utili
                    -ties\event\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\comp
                    -onents\hpgp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware
                    -\app_support;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\compo
                    -nents\drivers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\
                    -components;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc
                    -;..\..\..\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\compo
                    -nents\drivers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\compon
                    -ents\utilities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\compone
                    -nts\drivers\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..
                    -\inc;..\..\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HP
                    -GP_HAL,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP
                    -,NMA,NEW_SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABL
                    -E,B2,FREQ_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_
                    -GPIO_INTERRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,
                    -RTOPO_APP,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\hal_hpgp
                    -_reset.lst) TABS(2) OBJECT(.\obj\hal_hpgp_reset.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include "papdef.h"
   4          #include "hal.h"
   5          #include "hal_common.h"
   6          #include "fm.h"
   7          #include "hal_reg.h"
   8          #include "hpgpevt.h"
   9          #include "hal_regs_def.h"
  10          #include "hal_reg.h"
  11          #include "hal_hpgp_reset.h"
  12          #include "linkl.h"
  13          #include "hpgpctrl.h"
  14          #include "hybrii_tasks.h"
  15          #include "gv701x_gpiodriver.h"
  16          #include "datapath.h"
  17          
  18          extern u8 gHtmDefKey[10][16];
  19          
  20          extern eStatus CHAL_freeCP(u8 cp);
  21          #ifdef Hybrii_B
  22          
  23          extern void* HPGPCTRL_GetLayer(u8 layer);
  24          
  25          void disable_plc_txrx()
  26          {
  27   1      
  28   1        uPlcStatusReg         plcStatus;
  29   1      
  30   1          plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);// Disable Tx Rx
  31   1          plcStatus.s.plcRxEnSwCtrl = 1 ;
  32   1          plcStatus.s.nTxEn  = 1;
  33   1          plcStatus.s.nRxEn = 1;
  34   1          
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 2   

  35   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
  36   1      
  37   1      }
  38          void enable_plc_txrx()
  39          {
  40   1        uPlcStatusReg     plcStatus;
  41   1      
  42   1        plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
  43   1        plcStatus.s.nTxEn  = 0;
  44   1      
  45   1          
  46   1        // below is sequence to re-enable RxEn
  47   1        /*plcStatus.s.rxSoftReset = 1;
  48   1        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
  49   1        CHAL_DelayTicks(10);
  50   1        plcStatus.s.rxSoftReset = 0; */
  51   1      
  52   1          plcStatus.s.nRxEn = 0;
  53   1          //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
  54   1          
  55   1          plcStatus.s.plcRxEnSwCtrl = 0;
  56   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
  57   1      
  58   1         
  59   1      }
  60          
  61          void purge_plc_rx_queue()
  62          {
  63   1        u8 desc_cnt;
  64   1        //u8 rx_processing;
  65   1        //u8 i; 
  66   1        //u16 frmLen;
  67   1        //sSwFrmDesc rxFrmSwDesc;
  68   1        //uRxFrmHwDesc rxFrmHwDesc;
  69   1        //uRxCpDesc    rxCpDesc;
  70   1        //printf("Purge\n");
  71   1        desc_cnt = CHAL_GetCPUTxQDescCount();
  72   1        //printf("desc_cnt %bu\n",desc_cnt);
  73   1        while (desc_cnt) 
  74   1        {
  75   2      //    u8          last_desc_len;
  76   2          uRxPktQDesc1    rx_q_desc;
  77   2          uRxPktQCPDesc   q_desc_cp;
  78   2          u32 dump;
  79   2          //sCommonRxFrmSwDesc  rx_frame_info;
  80   2        
  81   2            // Request for right to read the CPU TX QD
  82   2          if (HHAL_Req_Gnt_Read_CPU_QD() == STATUS_FAILURE)
  83   2          {
  84   3            break;
  85   3          }
  86   2            // Always expect a first descriptor here
  87   2            // else error cases
  88   2          //memset(&q_desc_cp, 0x00, sizeof(uRxPktQCPDesc)); // Kiran Optimization updated before accessed
  89   2          rx_q_desc.reg = ReadU32Reg(CPU_TXQDESC_REG);
  90   2          if (NO_DESCRIPTOR == rx_q_desc.reg) 
  91   2          {
  92   3            break;
  93   3          }
  94   2         
  95   2          if (rx_q_desc.s.bFirstDesc) 
  96   2          {
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 3   

  97   3            q_desc_cp.reg = ReadU32Reg(CPU_TXQDESC_REG);
  98   3            dump = ReadU32Reg(PLC_RSSILQI_REG);
  99   3            if (NO_DESCRIPTOR != q_desc_cp.reg) 
 100   3            {
 101   4              // Store first CP desciptor and the associate CP
 102   4           
 103   4                // Read until the last descriptor
 104   4              CHAL_DecrementReleaseCPCnt(q_desc_cp.s.cp);
 105   4              while (q_desc_cp.s.lastDesc == 0) 
 106   4              {
 107   5                q_desc_cp.reg = ReadU32Reg(CPU_TXQDESC_REG);
 108   5                if (NO_DESCRIPTOR == q_desc_cp.reg) 
 109   5                {
 110   6                  //printf("No Desc2\n");
 111   6                  break;
 112   6                }
 113   5                // Error. Don't expect this many descriptor
 114   5                //printf("Free %bu\n",q_desc_cp.s.cp);
 115   5                CHAL_DecrementReleaseCPCnt(q_desc_cp.s.cp);     
 116   5              }
 117   4            }
 118   3        
 119   3            desc_cnt = CHAL_GetCPUTxQDescCount();
 120   3            HHAL_Rel_Gnt_Read_CPU_QD();   // Release CPQD Grant after finish reading a frame
 121   3          } 
 122   2          else 
 123   2          {
 124   3            // Error case - don't see the 1st descriptor
 125   3            // Free all CP's of the frame
 126   3            q_desc_cp.reg = rx_q_desc.reg;
 127   3            do
 128   3            {
 129   4              //printf("Free %bu\n",q_desc_cp.s.cp);
 130   4              CHAL_DecrementReleaseCPCnt(q_desc_cp.s.cp);         
 131   4              q_desc_cp.reg = ReadU32Reg(CPU_TXQDESC_REG);
 132   4              if (NO_DESCRIPTOR == q_desc_cp.reg) 
 133   4              {
 134   5                  break;
 135   5              }
 136   4            } while (q_desc_cp.s.lastDesc == 0);
 137   3          }
 138   2        }
 139   1        HHAL_Rel_Gnt_Read_CPU_QD();
 140   1      }
 141          void plc_reset_tx()
 142          {
 143   1        uPlcStatusReg    plcStatus;
 144   1          uhang_reset_reg reg_val;
 145   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 146   1          sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
 147   1      //    u8 freecp;
 148   1          
 149   1        //u32 reg_val;
 150   1          u32 hangIntRegRead;
 151   1          u8                  cpNum;
 152   1        u8 mpirxHang;
 153   1          u8 cpuQdHang;
 154   1      //    u32 i,j;
 155   1      //  u8 cmdqsize;
 156   1      //  u8 capqsize;
 157   1      
 158   1        __CRIT_SECTION_BEGIN__ //CP loss issue with interrupts 
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 4   

 159   1          hold_reset_phy_tx();
 160   1        hold_reset_phy_rx();
 161   1          disable_plc_txrx();
 162   1      
 163   1        hangIntRegRead = hal_common_reg_32_read(PLC_SM_HANG_INT);
 164   1          //printf("\n intr b4= %lx\n",hangIntRegRead);
 165   1        purge_plc_rx_queue();
 166   1          purge_cmdQ();
 167   1       
 168   1          
 169   1          //freecp = CHAL_GetFreeCPCnt();
 170   1          //printf("\n freecp1 = %bu",freecp);
 171   1               
 172   1          //WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x80000000)); // CP Free 
 173   1          //WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000000)); 
 174   1      
 175   1          WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000001));  
 176   1          WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000000));  
 177   1      
 178   1           //WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000001));  //bit 31
 179   1          // WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000000));  //bit 31
 180   1      
 181   1           
 182   1      
 183   1         // freecp = CHAL_GetFreeCPCnt();
 184   1         // printf("\n freecp2 = %bu",freecp);  
 185   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
 186   1         // printf("\n ready bit1 = %bu",plcStatus.s.plcTxQRdy );
 187   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 188   1          reg_val.s.txdma = 1;
 189   1          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset txdma
 190   1          
 191   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 192   1          reg_val.s.mpitx = 1;
 193   1          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset mpi Tx State Machine
 194   1      
 195   1        
 196   1      #if 0
                  reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.mpirx = 1;
                WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset mpiRx
              #endif  
 201   1      
 202   1        mpirxHang = (hangIntRegRead & (u32)PLC_MPIRX_HANG);
 203   1        cpuQdHang = (hangIntRegRead & (u32)PLC_CPUQD_HANG);
 204   1      
 205   1        if((mpirxHang > 0) || (cpuQdHang > 0))
 206   1        {
 207   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 208   2            reg_val.s.q_controller = 1;
 209   2          reg_val.s.mpirx = 1;
 210   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset mpiRx
 211   2        }
 212   1      
 213   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 214   1          reg_val.s.csma = 1;
 215   1          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// Reset CSMA   
 216   1         
 217   1      
 218   1        if(hal_common_reg_32_read(PLC_SM_HANG_INT) & PLC_AES_HANG)// reset aes if aes is hung
 219   1        {
 220   2        
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 5   

 221   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 222   2          reg_val.s.aes = 1;
 223   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// Reset AES 
 224   2      
 225   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 226   2          reg_val.s.aes = 0;
 227   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// release AES from reset
 228   2      
 229   2        }
 230   1      
 231   1      #if 0  
                reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.q_controller = 1;
                WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset q controller
                
                reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.q_controller = 0;
                WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release q controller from reset
              #endif
 240   1      
 241   1          hangIntRegRead = hal_common_reg_32_read(PLC_SM_HANG_INT);
 242   1        
 243   1          if(hangIntRegRead & PLC_SEGMENT_HANG)// reset segment if aes is hung
 244   1        {
 245   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 246   2          reg_val.s.seg_sm = 1;
 247   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset segment state machine
 248   2          
 249   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 250   2          reg_val.s.seg_sm = 0;
 251   2          WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release segment state machine from reset
 252   2        }
 253   1          
 254   1        if((hangIntRegRead & PLC_SOF_HANG) || (hangIntRegRead & PLC_BCN2_HANG)
 255   1                                 || (hangIntRegRead & PLC_BCN3_HANG) 
 256   1                                 || (hangIntRegRead & PLC_SOUND_HANG))        // if other flag is set then reset whole PLC
 257   1        {
 258   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 259   2          reg_val.s.warm = 1;
 260   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);
 261   2          
 262   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 263   2          reg_val.s.warm = 0;
 264   2          WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);
 265   2          //FM_Printf(FM_USER,"PLC_warm\n");
 266   2        }
 267   1           
 268   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 269   1        reg_val.s.txdma = 0;
 270   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release txdma from reset state
 271   1      
 272   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 273   1        reg_val.s.mpitx = 0;
 274   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpi tx from reset state
 275   1      #if 0
              
                  reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.mpirx = 0;
                WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpiRx from reset
              #endif
 281   1        if((mpirxHang > 0) || (cpuQdHang > 0))
 282   1        {   
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 6   

 283   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);  
 284   2          reg_val.s.mpirx = 0;
 285   2          reg_val.s.q_controller = 0;
 286   2          WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpiRx from reset
 287   2        }
 288   1      
 289   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 290   1        reg_val.s.csma = 0;
 291   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// release csma from reset state
 292   1        
 293   1          set_plc_paramter(PLC_EIFS_SEL, PLC_EIFS_INIT_VALUE);// write eifs parameters
 294   1         
 295   1          //HHAL_Init();
 296   1        datapath_resetQueue(PLC_DATA_QUEUE);
 297   1        datapath_resetQueue(HOST_DATA_QUEUE);
 298   1      #if 1  
 299   1          for (cpNum=0 ; cpNum<HYBRII_CPCOUNT_MAX ; cpNum++)
 300   1          {
 301   2              CHAL_DecrementReleaseCPCnt(cpNum);
 302   2          }
 303   1      #endif  
 304   1      #if 0
                reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.cp = 1;
                WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset cp
                
                reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
                reg_val.s.cp = 0;
                WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release cp from reset
              #endif
 313   1        HHAL_AddNEK(staInfo->nekEks, staInfo->nek);
 314   1          release_reset_phy_tx();
 315   1        release_reset_phy_rx();
 316   1          enable_plc_txrx();
 317   1            
 318   1          //HHAL_Init();   
 319   1          //WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000100));  //bit 31
 320   1          //WriteU32Reg(PLC_HYBRII_RESET, ctorl(0x00000000));  //bit 31 
 321   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
 322   1         // printf("\n ready bit = %bu",plcStatus.s.plcTxQRdy );
 323   1         // WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
 324   1          hangIntRegRead = hal_common_reg_32_read(PLC_SM_HANG_INT);
 325   1         //printf("\n intr after1= %lx\n",hangIntRegRead);
 326   1         //HHAL_AddNEK(1, gHtmDefKey[1]); 
 327   1        __CRIT_SECTION_END__ //CP loss issue with interrupts 
 328   1      }
 329          
 330          
 331          
 332          void plc_reset_rx()
 333          {
 334   1        uhang_reset_reg reg_val;
 335   1      
 336   1           //hold_reset_phy_tx();
 337   1        hold_reset_phy_rx();
 338   1      
 339   1         
 340   1          
 341   1          disable_plc_txrx();
 342   1        
 343   1        /*
 344   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 7   

 345   1          reg_val.s.free_cp = 1;
 346   1          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg); // free cp counter
 347   1      
 348   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 349   1          reg_val.s.free_cp = 0;
 350   1          WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release cp counter from reset state
 351   1        */
 352   1        
 353   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 354   1        reg_val.s.csma = 1;
 355   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// Reset CSMA  
 356   1      
 357   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 358   1        reg_val.s.mpirx = 1;
 359   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg); //set MPI rx
 360   1       
 361   1      
 362   1        //if(hal_common_reg_32_read(PLC_SM_HANG_INT) & PLC_AES_HANG)// reset aes if aes is hung
 363   1        {
 364   2          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 365   2          reg_val.s.aes = 1;
 366   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// Reset AES 
 367   2      
 368   2            reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 369   2          reg_val.s.aes = 0;
 370   2          WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// release AES from reset 
 371   2        }
 372   1        //plc_reset_qcontroller();
 373   1        
 374   1          reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 375   1        reg_val.s.mpirx = 0;
 376   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpi Rx from reset state
 377   1      
 378   1        
 379   1      
 380   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 381   1        reg_val.s.csma = 0;
 382   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// release csma from reset state
 383   1        
 384   1          set_plc_paramter(PLC_EIFS_SEL, PLC_EIFS_INIT_VALUE);// write eifs parameters
 385   1      
 386   1          enable_plc_txrx();
 387   1           //release_reset_phy_tx();
 388   1        release_reset_phy_rx();
 389   1      }
 390          
 391          void plc_reset_cold()// incomplete 
 392          {
 393   1        uhang_reset_reg reg_val;
 394   1        
 395   1        disable_plc_txrx();
 396   1        
 397   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 398   1        reg_val.s.cold = 1;
 399   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);
 400   1        
 401   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 402   1        reg_val.s.cold = 0;
 403   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);
 404   1        // add whole plc init code here
 405   1        enable_plc_txrx();
 406   1      }
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 8   

 407          
 408          void plc_reset_warm()
 409          {
 410   1        uhang_reset_reg reg_val;
 411   1        
 412   1        disable_plc_txrx();
 413   1        
 414   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 415   1        reg_val.s.warm = 1;
 416   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);
 417   1        
 418   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 419   1        reg_val.s.warm = 0;
 420   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);
 421   1        
 422   1        enable_plc_txrx();
 423   1      }
 424          
 425          void plc_reset_aes()
 426          {
 427   1        uhang_reset_reg reg_val;
 428   1        
 429   1        disable_plc_txrx();
 430   1        
 431   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 432   1        reg_val.s.aes = 1;
 433   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// Reset AES 
 434   1      
 435   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 436   1        reg_val.s.aes = 0;
 437   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// release AES from reset
 438   1        
 439   1        enable_plc_txrx();
 440   1      }
 441          
 442          void plc_reset_mpitx()
 443          {
 444   1        uhang_reset_reg reg_val;
 445   1        
 446   1        disable_plc_txrx();
 447   1        
 448   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 449   1        reg_val.s.mpitx = 1;
 450   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset mpiTx
 451   1        
 452   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 453   1        reg_val.s.mpitx = 0;
 454   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpiTx from reset
 455   1      
 456   1        enable_plc_txrx();
 457   1      }
 458          
 459          void plc_reset_seg_sm()
 460          {
 461   1        uhang_reset_reg reg_val;
 462   1        
 463   1        disable_plc_txrx();
 464   1        
 465   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 466   1        reg_val.s.seg_sm = 1;
 467   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset segment state machine
 468   1        
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 9   

 469   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 470   1        reg_val.s.seg_sm = 0;
 471   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release segment state machine from reset
 472   1        
 473   1        enable_plc_txrx();
 474   1      }
 475          
 476          void plc_reset_mpirx_cpuqd()
 477          {
 478   1        uhang_reset_reg reg_val;
 479   1        
 480   1          disable_plc_txrx();
 481   1        
 482   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 483   1          reg_val.s.q_controller = 1;
 484   1        reg_val.s.mpirx = 1;
 485   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset mpiRx
 486   1        
 487   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 488   1         
 489   1        reg_val.s.mpirx = 0;
 490   1           reg_val.s.q_controller = 0;
 491   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release mpiRx from reset
 492   1      
 493   1          enable_plc_txrx();
 494   1      }
 495          
 496          void plc_reset_txdma()
 497          {
 498   1        uhang_reset_reg reg_val;
 499   1        
 500   1          disable_plc_txrx();
 501   1        
 502   1        reg_val.reg= ReadU32Reg(PLC_HYBRII_RESET);
 503   1        reg_val.s.free_cp = 1;
 504   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg); // free cp counter
 505   1      
 506   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 507   1        reg_val.s.free_cp = 0;
 508   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release cp counter from reset state
 509   1        
 510   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 511   1        reg_val.s.txdma = 1;
 512   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset txdma
 513   1        
 514   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 515   1        reg_val.s.txdma = 0;
 516   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release txdma from reset
 517   1      
 518   1        enable_plc_txrx();
 519   1      } 
 520          
 521          void plc_hung_monitor_init()
 522          {
 523   1        //u32 reg_val;
 524   1        //reg_val = hal_common_reg_32_read(PLC_SM_MAXCNT);
 525   1        hal_common_reg_32_write(PLC_SM_MAXCNT,0x800C0000);
 526   1      }
 527          
 528          void plc_reset_qcontroller()
 529          {
 530   1        uhang_reset_reg reg_val;  
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 10  

 531   1         // disable_plc_txrx();
 532   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 533   1        reg_val.s.q_controller = 1;
 534   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset q controller
 535   1        
 536   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 537   1        reg_val.s.q_controller = 0;
 538   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release q controller from reset
 539   1      
 540   1         // enable_plc_txrx();
 541   1      }
 542          
 543          void plc_reset_cp()
 544          {
 545   1        uhang_reset_reg reg_val;
 546   1          
 547   1        disable_plc_txrx();
 548   1        
 549   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 550   1        reg_val.s.cp = 1;
 551   1        WriteU32Reg(PLC_HYBRII_RESET,reg_val.reg);// reset cp
 552   1        
 553   1        reg_val.reg = ReadU32Reg(PLC_HYBRII_RESET);
 554   1        reg_val.s.cp = 0;
 555   1        WriteU32Reg(PLC_HYBRII_RESET, reg_val.reg);// release cp from reset
 556   1      
 557   1        enable_plc_txrx();
 558   1      }
 559          
 560          
 561          void purge_capQ_direct(u8 id)
 562          {
 563   1      
 564   1        u8  i, size;
 565   1        u32 dump;
 566   1        //uPlcTxPktQCAP_Write     cap_write;
 567   1        
 568   1        size = get_capQ_size(id);
 569   1        //cap_write.capw.Cap = id;
 570   1        hal_common_reg_32_write(PLC_CAP_REG, (u32)id);// selects required cap
 571   1      
 572   1        for(i=0;i<size;i++)
 573   1        {
 574   2          dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 575   2          dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 576   2          printf("capq size 1 = %bu\n",get_capQ_size(1));
 577   2          printf("capq size 2 = %bu\n",get_capQ_size(2));
 578   2          printf("capq size 3 = %bu\n",get_capQ_size(3));
 579   2          printf("capq size 0 = %bu\n",get_capQ_size(0));
 580   2        }
 581   1      
 582   1      }
 583          
 584          void purge_capQ(u8 id)// dangerous function. Unnecessory call may generate undesired effects
 585          {
 586   1      
 587   1        uTxFrmHwDesc      txfrmHwDesc;
 588   1        uPlcTxPktQCAP_Write     cap_write;
 589   1        u8            i,j,cmdq_count,cp_count;
 590   1        u32           dump;
 591   1        u16           frm_len;
 592   1        uTxCpDesc             txCpDesc;
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 11  

 593   1      
 594   1        cap_write.capw.Cap = id;
 595   1        cmdq_count = get_cmdQ_size();
 596   1        //printf("cmd q count = %bu\n",cmdq_count);
 597   1        WriteU32Reg(PLC_CAP_REG, cap_write.reg);// selects required cap
 598   1        if(cmdq_count >0)
 599   1        {
 600   2          for(i=0;i<cmdq_count;i++)
 601   2          {
 602   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 603   3            txfrmHwDesc.reg = ReadU32Reg(PLC_QUEUEDATA_REG);
 604   3            frm_len = (u16) (rtocl(txfrmHwDesc.reg) & (u32) 0x7ff);
 605   3            //printf("frm_len = %u\n",frm_len);
 606   3            cp_count = frm_len/128;
 607   3            if(frm_len > cp_count * 128)
 608   3            {
 609   4              cp_count += 1;
 610   4            }
 611   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 612   3            gHpgpHalCB.plcTx10FC.reg = ReadU32Reg(PLC_QUEUEDATA_REG);
 613   3      
 614   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 615   3            dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 616   3      
 617   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 618   3            dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 619   3      
 620   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 621   3            dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 622   3      
 623   3            dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 624   3            dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 625   3      
 626   3            for(j=0;j<cp_count;j++)
 627   3            {
 628   4      
 629   4              dump = ReadU32Reg(PLC_QUEUEWRITE_REG);
 630   4              txCpDesc.reg = ReadU32Reg(PLC_QUEUEDATA_REG);
 631   4              CHAL_freeCP(txCpDesc.plc.cp);
 632   4            }
 633   3            
 634   3          }
 635   2        }
 636   1      }
 637          
 638          void purge_cmdQ()
 639          {
 640   1        uTxCMDQueueWrite txCmdQueueWrite;
 641   1        u32 dump;
 642   1        u16 i,qsize;
 643   1        //txCmdQueueWrite.s.cap = 0;
 644   1      
 645   1        //WriteU32Reg(PLC_CMDQ_REG, txCmdQueueWrite.reg);
 646   1        qsize = get_cmdQ_size();
 647   1        if(qsize != 0)
 648   1        {
 649   2          for(i=0;i<qsize;i++)
 650   2          {
 651   3            dump = ReadU32Reg(PLC_CMDQ_REG);
 652   3            //dump = ReadU32Reg(PLC_QUEUEDATA_REG);
 653   3            txCmdQueueWrite.reg= hal_common_reg_32_read(PLC_QUEUEDATA_REG);
 654   3          //  printf("Cap val in CmdQ = %lx", txCmdQueueWrite.reg);
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 12  

 655   3          }
 656   2        }
 657   1      
 658   1      }
 659          
 660          u8 get_capQ_size(u8 id)
 661          {
 662   1        //uPlcTxPktQCAP_Write   cap_write;
 663   1        u8 CapQueueStatus;
 664   1      
 665   1        //cap_write.capw.Cap = id;
 666   1        //cap_write.capw.CapRdy = 0;// to avoid any possible corruption or any unknown issues
 667   1        hal_common_reg_32_write(PLC_CAP_REG, (u32)id);// select required CAP from 0 to 3
 668   1        CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG);
 669   1      
 670   1        return CapQueueStatus;
 671   1      }
 672          
 673          u8 get_cmdQ_size()
 674          {
 675   1      return ReadU8Reg(PLC_CMDQ_STAT_);
 676   1      }
 677          
 678          void hold_reset_phy_tx()
 679          {
 680   1        uphytx_reset tx_reset;
 681   1          tx_reset.reg  = ReadU32Reg(REG_PHY_TX_RESET);
 682   1        tx_reset.s.tx = 1;
 683   1        WriteU32Reg(REG_PHY_TX_RESET,tx_reset.reg);
 684   1      }
 685          
 686          void hold_reset_phy_rx()
 687          {
 688   1        uphyrx_reset rx_reset;
 689   1          rx_reset.reg  = ReadU32Reg(REG_PHY_RX_RESET);
 690   1        rx_reset.s.rx = 1;
 691   1        WriteU32Reg(REG_PHY_RX_RESET,rx_reset.reg);
 692   1      }
 693          
 694          void release_reset_phy_tx()
 695          {
 696   1        uphytx_reset tx_reset;
 697   1          tx_reset.reg  = ReadU32Reg(REG_PHY_TX_RESET);
 698   1        tx_reset.s.tx = 0;
 699   1        WriteU32Reg(REG_PHY_TX_RESET,tx_reset.reg);
 700   1      }
 701          
 702          void release_reset_phy_rx()
 703          {
 704   1        uphyrx_reset rx_reset;
 705   1          rx_reset.reg  = ReadU32Reg(REG_PHY_RX_RESET);
 706   1        rx_reset.s.rx = 0;
 707   1        WriteU32Reg(REG_PHY_RX_RESET,rx_reset.reg);
 708   1      }
 709          
 710          
 711          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2972    ----
   CONSTANT SIZE    =     76    ----
C51 COMPILER V9.53.0.0   HAL_HPGP_RESET                                                    11/04/2015 20:09:41 PAGE 13  

   XDATA SIZE       =   ----     146
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
