C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_DISASSOCIATE
OBJECT MODULE PLACED IN .\obj\mac_disassociate.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_disassociate.c LARGE OBJECTADVANCED OPTI
                    -MIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..
                    -\..\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp
                    -\src\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..
                    -\..\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware
                    -\zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\ev
                    -ent\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\
                    -hpgp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_su
                    -pport;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\d
                    -rivers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\compone
                    -nts;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\
                    -..\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\d
                    -rivers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\ut
                    -ilities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\dri
                    -vers\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..
                    -\..\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,
                    -HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NE
                    -W_SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FR
                    -EQ_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_IN
                    -TERRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_A
                    -PP,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_disassociat
                    -e.lst) TABS(2) OBJECT(.\obj\mac_disassociate.obj)

line level    source

   1          /**
   2           * @file mac_disassociate.c
   3           *
   4           * MLME-DISASSOCIATION functionality
   5           *
   6           * $Id: mac_disassociate.c,v 1.3 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2012, Greenvity Communication All rights reserved. 
   9           *
  10           */
  11          #ifdef HYBRII_802154
  12          
  13          /* === Includes ============================================================ */
  14          
  15          #include <string.h>
  16          #include "papdef.h"
  17          #include "timer.h"
  18          #include "return_val.h"
  19          #include "bmm.h"
  20          #include "qmm.h"
  21          #include "mac_msgs.h"
  22          #include "mac_hal.h"
  23          #include "mac_const.h"
  24          #include "mac_api.h"
  25          #include "mac_data_structures.h"
  26          #include "mac_internal.h"
  27          #include "mac.h"
  28          #include "utils_fw.h"
  29          
  30          /* === Macros =============================================================== */
  31          
  32          /*
  33           * Disassociation payload length
  34           */
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 2   

  35          #define DISASSOC_PAYLOAD_LEN             (2)
  36          
  37          /* === Globals ============================================================= */
  38          
  39          
  40          /* === Prototypes ========================================================== */
  41          
  42          
  43          /* === Implementation ====================================================== */
  44          
  45          /*
  46           *
  47           * This function sends the disassociation request information to HAL. On
  48           * sending the disassociation request all information about its parent device
  49           * is cleared.
  50           *
  51           * buf_p Pointer to the buffer to be sent to TAL.
  52           *
  53           * return True if the frame is transmitted successfully, false otherwise.
  54           */
  55          static bool mac_awake_disassociate (buffer_t *buf_p)
  56          {
  57   1          frame_info_t *transmit_frame_p;
  58   1          retval_t  tx_status;
  59   1          tx_mode_t tx_mode;
  60   1      
  61   1          transmit_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
  62   1      
  63   1          if (NON_BEACON_NWK == hal_pib_BeaconOrder) {
  64   2              /* In Nonbeacon network the frame is sent with unslotted CSMA-CA. */
  65   2              tx_mode = CSMA_UNSLOTTED;
  66   2          } else {
  67   2              /* In Beacon network the frame is sent with slotted CSMA-CA. */
  68   2              tx_mode = CSMA_SLOTTED;
  69   2          }
  70   1      
  71   1          /*
  72   1           * FIXME - Need to handle encrypttion of dis-association packet
  73   1           */
  74   1          tx_status = mac_hal_tx_frame(transmit_frame_p, tx_mode, false);
  75   1      
  76   1          if (MAC_SUCCESS == tx_status) {
  77   2              MAC_BUSY();
  78   2          } else {
  79   2              return (FALSE);
  80   2          }
  81   1      
  82   1          return (TRUE);
  83   1      }
  84          
  85          /**
  86           *
  87           * This function creates and appends a MLME disassociate confirm message
  88           * into the  internal event queue.
  89           *
  90           * buf_p  - Buffer for sending MLME disassociate confirm message to NHLE
  91           * status - Status of disassociation
  92           * dev_addr_mode - Addressing mode of the device that has either requested
  93           *                 disassociation or been instructed to disassociate by
  94           *                 its coordinator.
  95           * dev_panid - PAN identifier of the device that has either requested
  96           *              disassociation or been instructed to disassociate by its
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 3   

  97           *              coordinator.
  98           * dev_addr - Address of the device that has either requested
  99           *            disassociation or been instructed to disassociate by its
 100           *            coordinator.
 101           */
 102          static void mac_gen_mlme_disassociate_conf (buffer_t *buf_p,
 103                                                      uint8_t status,
 104                                                      uint8_t dev_addr_mode,
 105                                                      uint16_t dev_panid,
 106                                                      address_field_t *dev_addr)
 107          {
 108   1          mlme_disassociate_conf_t *mdc;
 109   1      
 110   1          mdc = (mlme_disassociate_conf_t *)BMM_BUFFER_POINTER(buf_p);
 111   1      
 112   1          mdc->cmdcode = MLME_DISASSOCIATE_CONFIRM;
 113   1          mdc->status = status;
 114   1          mdc->DeviceAddrMode = dev_addr_mode;
 115   1          mdc->DevicePANId = dev_panid;
 116   1      
 117   1          if (FCF_SHORT_ADDR == dev_addr_mode) {
 118   2              EXT_ADDR_CLEAR(mdc->DeviceAddress.long_address);
 119   2              ADDR_COPY_DST_SRC_16(mdc->DeviceAddress.short_address,
 120   2                                   dev_addr->short_address);
 121   2          } else {
 122   2              ADDR_COPY_DST_SRC_64(mdc->DeviceAddress.long_address,
 123   2                                   dev_addr->long_address);
 124   2      
 125   2          }
 126   1      
 127   1      #if (defined UM) && (!defined ZBMAC_DIAG)
 128   1        mlme_send_to_host(buf_p);
 129   1      #else
                mlme_associate_conf(buf_p);
              #endif
 132   1      }
 133          
 134          
 135          
 136          /**
 137           * Handles the MLME disassociate request command from the NWK layer
 138           *
 139           * The MLME-DISASSOCIATE.request primitive is generated by the next
 140           * higher layer of an associated device and issued to its MLME to
 141           * request disassociation from the PAN. It is also generated by the
 142           * next higher layer of the coordinator and issued to its MLME to
 143           * instruct an associated device to leave the PAN.
 144           *
 145           * Pointer to the MLME-DISASSOCIATION.Request message passed by NHLE
 146           */
 147          void mlme_disassociate_request (buffer_t *buf_p)
 148          {
 149   1          mlme_disassociate_req_t disassoc_req;
 150   1          frame_info_t *transmit_frame_p;
 151   1          uint8_t frame_len;
 152   1          uint8_t *frame_ptr;
 153   1          uint8_t *temp_frame_ptr;
 154   1          uint16_t fcf;
 155   1      
 156   1          transmit_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
 157   1      
 158   1          /* Store the disassociation request received from NHLE. */
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 4   

 159   1          memcpy((uint8_t *)&disassoc_req, (uint8_t *)transmit_frame_p,
 160   1                  sizeof(mlme_disassociate_req_t));
 161   1      
 162   1          if (disassoc_req.DevicePANId != hal_pib_PANId) {
 163   2              mac_gen_mlme_disassociate_conf(buf_p,
 164   2                                             MAC_INVALID_PARAMETER,
 165   2                                             disassoc_req.DeviceAddrMode,
 166   2                                             disassoc_req.DevicePANId,
 167   2                                             &disassoc_req.DeviceAddress);
 168   2              return;
 169   2          }
 170   1      
 171   1          /* Build disassociation command frame. */
 172   1          transmit_frame_p->buffer_header_p = buf_p;
 173   1          transmit_frame_p->msg_type = DISASSOCIATIONNOTIFICATION;
 174   1      
 175   1          /* Get the payload pointer. */
 176   1          temp_frame_ptr = (uint8_t *)transmit_frame_p +
 177   1                                      BUFFER_SIZE -
 178   1                                      DISASSOC_PAYLOAD_LEN; 
 179   1          frame_ptr = temp_frame_ptr;
 180   1      
 181   1          /* Update the payload field. */
 182   1          *frame_ptr++ = DISASSOCIATIONNOTIFICATION;
 183   1      
 184   1          /* Set up the disassociation reason code. */
 185   1          *frame_ptr = disassoc_req.DisassociateReason;
 186   1      
 187   1          /* Get the payload pointer again to add the MHR. */
 188   1          frame_ptr = temp_frame_ptr;
 189   1      
 190   1          /* Update the length. */
 191   1          frame_len = DISASSOC_PAYLOAD_LEN +
 192   1                      PAN_ID_LEN           +
 193   1                      SHORT_ADDR_LEN       +
 194   1                      EXT_ADDR_LEN         +    /* Source Ext Address */
 195   1                      FCF_LEN              +
 196   1                      SEQ_NUM_LEN;
 197   1      
 198   1      
 199   1          /* Source address */
 200   1          frame_ptr -= EXT_ADDR_LEN;
 201   1          mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 202   1      
 203   1          /* Destination address */
 204   1          if (FCF_SHORT_ADDR == disassoc_req.DeviceAddrMode) {
 205   2              frame_ptr -= SHORT_ADDR_LEN;
 206   2              mac_utils_16_bit_to_byte_array(disassoc_req.DeviceAddress.short_address, frame_ptr);
 207   2          } else {
 208   2              frame_ptr -= EXT_ADDR_LEN;
 209   2              frame_len += EXT_ADDR_LEN;
 210   2              mac_utils_64_bit_to_byte_array(disassoc_req.DeviceAddress.long_address, frame_ptr);
 211   2          }
 212   1      
 213   1          /* Destination PAN-Id */
 214   1          frame_ptr -= PAN_ID_LEN;
 215   1          mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 216   1      
 217   1      
 218   1          /* Set DSN. */
 219   1          frame_ptr--;
 220   1          *frame_ptr = mac_pib_macDSN++;
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 5   

 221   1      
 222   1      
 223   1          /* Construct FCF. */
 224   1          /* 802.15.4-2006 sets the PAN-Id compression) bit. */
 225   1           fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
 226   1                 FCF_SET_DEST_ADDR_MODE(disassoc_req.DeviceAddrMode) |
 227   1                 FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
 228   1                 FCF_PAN_ID_COMPRESSION |
 229   1                 FCF_ACK_REQUEST;
 230   1      
 231   1           /* Set the FCF. */
 232   1           frame_ptr -= FCF_LEN;
 233   1           mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
 234   1      
 235   1          /* First element shall be length of PHY frame. */
 236   1          frame_ptr--;
 237   1          *frame_ptr = frame_len;
 238   1      
 239   1          /* Finished building of frame. */
 240   1          transmit_frame_p->mpdu_p = frame_ptr;
 241   1      
 242   1          /* Indirect transmission not ongoing yet. */
 243   1          transmit_frame_p->indirect_in_transit = false;
 244   1      
 245   1          if (((MAC_PAN_COORD_STARTED == mac_state) ||
 246   1               (MAC_COORDINATOR == mac_state)) &&
 247   1               (disassoc_req.TxIndirect)) {
 248   2              /*
 249   2               * The current device is a coordinator, and if the DeviceAddress
 250   2               * is not ours, then send via indirect transmission.
 251   2               */
 252   2              if (((disassoc_req.DeviceAddrMode == WPAN_ADDRMODE_SHORT) &&
 253   2                   (disassoc_req.DeviceAddress.short_address != macCoordShortAddress)) ||
 254   2                  ((disassoc_req.DeviceAddrMode == WPAN_ADDRMODE_LONG) &&
 255   2                   (EXT_ADDR_NOMATCH(disassoc_req.DeviceAddress.long_address,
 256   2                                     mac_pib_macCoordExtendedAddress)))) {
 257   3                  /* Append the data into indirect queue. */
 258   3                  if (TRUE == qmm_queue_append(&indirect_data_q,
 259   3                                               buf_p)) {
 260   4                      /*
 261   4                       * If there is no capacity to store the transaction, the MLME
 262   4                       * will discard the MSDU and issue the MLME-DISASSOCIATE.
 263   4                       * confirm primitive with a status of TRANSACTION_OVERFLOW.
 264   4                       */
 265   4                      mac_gen_mlme_disassociate_conf(buf_p,
 266   4                                                     MAC_TRANSACTION_OVERFLOW,
 267   4                                                     disassoc_req.DeviceAddrMode,
 268   4                                                     disassoc_req.DevicePANId,                              
 269   4                                                     &disassoc_req.DeviceAddress);
 270   4                      return;
 271   4                  }
 272   3      
 273   3                  /*
 274   3                   * If an FFD does have pending data,
 275   3                   * the MAC persistence timer needs to be started.
 276   3                   */
 277   3                  transmit_frame_p->persistence_time = 
 278   3                                           mac_pib_macTransactionPersistenceTime;
 279   3                  mac_start_persistence_timer();
 280   3              } else {
 281   3                  mac_gen_mlme_disassociate_conf(buf_p,
 282   3                                                 MAC_INVALID_PARAMETER,
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 6   

 283   3                                                 disassoc_req.DeviceAddrMode,
 284   3                                                 disassoc_req.DevicePANId,
 285   3                                                 &disassoc_req.DeviceAddress);
 286   3                  return;
 287   3              }
 288   2          } else    /* Device */ {
 289   2              bool transmission_status;
 290   2      
 291   2              /* Wake up the radio first */
 292   2              mac_trx_wakeup();
 293   2      
 294   2              transmission_status = mac_awake_disassociate(buf_p);
 295   2      
 296   2              if (!transmission_status) {
 297   3                  /* Create the MLME DISASSOCIATION confirmation message */
 298   3                  mac_gen_mlme_disassociate_conf(buf_p,
 299   3                                                 MAC_CHANNEL_ACCESS_FAILURE,
 300   3                                                 disassoc_req.DeviceAddrMode,
 301   3                                                 disassoc_req.DevicePANId,
 302   3                                                 &disassoc_req.DeviceAddress);
 303   3      
 304   3                  /* Set radio to sleep if allowed */
 305   3                  mac_trx_sleep();
 306   3              }
 307   2          }
 308   1      }
 309          
 310          
 311          /**
 312           * Process a disassociation notification command
 313           *
 314           * This functions processes a received disassociation notification
 315           * command frame.
 316           * Actual data are taken from the incoming frame in mac_parse_buffer.
 317           *
 318           * msg_p - Frame buffer to be filled in
 319           */
 320          void mac_process_disassociate_notification (buffer_t *buf_p)
 321          {
 322   1          mlme_disassociate_ind_t *dai =
 323   1              (mlme_disassociate_ind_t *)BMM_BUFFER_POINTER(buf_p);
 324   1      
 325   1          /* Set up the header portion of the mlme_disassociate_ind_t. */
 326   1          dai->cmdcode = MLME_DISASSOCIATE_INDICATION;
 327   1      
 328   1          /* Build the indication parameters. */
 329   1      
 330   1          /*
 331   1           * Set the DeviceAddress first. The device address is the address
 332   1           * of the device requesting the disassociaton which is always
 333   1           * contained in the source address.
 334   1           */
 335   1          ADDR_COPY_DST_SRC_64(dai->DeviceAddress,
 336   1                               mac_parse_data.src_addr.long_address);
 337   1      
 338   1          dai->DisassociateReason = 
 339   1              mac_parse_data.mac_payload_data.disassoc_req_data.disassoc_reason;
 340   1      
 341   1      #if (defined UM) && (!defined ZBMAC_DIAG)
 342   1        mlme_send_to_host(buf_p);
 343   1      #else
                mlme_disassociate_ind(buf_p);
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 7   

              #endif
 346   1          /*
 347   1           * Once a device is disassociated from a coordinator, the coordinator's
 348   1           * address info should be cleared.
 349   1           */
 350   1          EXT_ADDR_CLEAR(mac_pib_macCoordExtendedAddress);
 351   1      
 352   1          /* The default short address is 0xFFFF. */
 353   1          mac_pib_macCoordShortAddress = INVALID_SHORT_ADDRESS;
 354   1      }
 355          
 356          /**
 357           * Prepares a disassociation confirm message with device address information
 358           *
 359           * This functions prepares a disassociation confirm message in case the device
 360           * address information needs to be extracted.
 361           *
 362           * buf_p - Buffer pointer for sending MLME disassociate confirm message to NHLE
 363           * status - Status of disassociation
 364           */
 365          void mac_prep_disassoc_conf (buffer_t *buf_p, uint8_t status)
 366          {
 367   1      
 368   1          uint8_t dis_dest_addr_mode;
 369   1          uint64_t temp_dev_addr;
 370   1          frame_info_t *frame_ptr = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
 371   1      
 372   1          EXT_ADDR_CLEAR(temp_dev_addr);
 373   1          dis_dest_addr_mode = (((frame_ptr->mpdu_p[PL_POS_FCF_2]) >>
 374   1                                FCF_2_DEST_ADDR_OFFSET) & 3);
 375   1      
 376   1          if ((FCF_SHORT_ADDR == dis_dest_addr_mode) ||
 377   1              (FCF_LONG_ADDR  == dis_dest_addr_mode)) {
 378   2              temp_dev_addr =
 379   2                    mac_utils_byte_array_to_64_bit(
 380   2                         &(frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]));
 381   2          }
 382   1      
 383   1          if (MAC_PAN_COORD_STARTED == mac_state) {
 384   2              /*
 385   2               * For PAN coordinator fill parameters of device that
 386   2               * we requested to disassociate into the disassociation confirm
 387   2               * message.
 388   2               * Since we have transmitted the disassociation notification frame
 389   2               * ourvelves, the destination address information is to be used here.
 390   2               */
 391   2              if (FCF_SHORT_ADDR == dis_dest_addr_mode) {
 392   3                  mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 393   3                                                  status,
 394   3                                                  dis_dest_addr_mode,
 395   3                                                  hal_pib_PANId,
 396   3                                                  (address_field_t *)&temp_dev_addr);
 397   3              } else {
 398   3                  mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 399   3                                                 status,
 400   3                                                 dis_dest_addr_mode,
 401   3                                                 hal_pib_PANId,
 402   3                                                 (address_field_t *)&temp_dev_addr);
 403   3      
 404   3              }
 405   2          } else if (MAC_COORDINATOR == mac_state) {
 406   2              uint16_t mac_coor_short_addr;
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 8   

 407   2              uint64_t mac_coor_long_addr;
 408   2      
 409   2              /*
 410   2               * We are the coordinator.
 411   2               * We have requested ourselves to disassociate with our own parent.
 412   2               * Or we have requested one of our children (other coordinators or
 413   2               * end devices) to leave the network.
 414   2               */
 415   2               mac_coor_short_addr = mac_utils_byte_array_to_16_bit(
 416   2                                   &frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]);
 417   2               mac_coor_long_addr  = mac_utils_byte_array_to_64_bit(
 418   2                                   &frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]); 
 419   2              if (((FCF_SHORT_ADDR == dis_dest_addr_mode) &&
 420   2                   (mac_coor_short_addr == mac_pib_macCoordShortAddress)) ||
 421   2                   ((FCF_LONG_ADDR == dis_dest_addr_mode) &&
 422   2                    EXT_ADDR_MATCH(mac_coor_long_addr,
 423   2                                   mac_pib_macCoordExtendedAddress))) {
 424   3                  /*
 425   3                   * We are acting as a child here, so we need to fill in our
 426   3                   * own device parameter into the disassociation confirm message.
 427   3                   */
 428   3                  if ((BROADCAST == hal_pib_ShortAddress) ||
 429   3                      (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress)) {
 430   4                      mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 431   4                                                     status,
 432   4                                                     FCF_LONG_ADDR,
 433   4                                                     hal_pib_PANId,
 434   4                                                     (address_field_t *)
 435   4                                                     &hal_pib_IeeeAddress);
 436   4                  } else {
 437   4                      mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 438   4                                                     status,
 439   4                                                     FCF_SHORT_ADDR,
 440   4                                                     hal_pib_PANId,
 441   4                                                     (address_field_t *)
 442   4                                                     &hal_pib_ShortAddress);
 443   4                  }
 444   3              } else {
 445   3                  /*
 446   3                   * We are acting as a parent here and have requested one of our
 447   3                   * children to leave the network.
 448   3                   * For coordinators that are disassociating their children.
 449   3                   * fill parameters of device/child that we requested to
 450   3                   * disassociate into the disassociation confirm message.
 451   3                   * Since we have transmitted the disassociation notification frame
 452   3                   * ourvelves, the destination address information is to be used
 453   3                   * here.
 454   3                   */
 455   3                  mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 456   3                                                 status,
 457   3                                                 dis_dest_addr_mode,
 458   3                                                 hal_pib_PANId,
 459   3                                                 (address_field_t *)&temp_dev_addr);
 460   3              }
 461   2          } else {
 462   2              /*
 463   2               * We are an end device. Fill in our own device parameters into the
 464   2               * disassociation confirm message.
 465   2               */
 466   2              if ((BROADCAST == hal_pib_ShortAddress) ||
 467   2                  (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress)) {
 468   3                  mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
C51 COMPILER V9.53.0.0   MAC_DISASSOCIATE                                                  11/04/2015 20:09:52 PAGE 9   

 469   3                                                 status,
 470   3                                                 FCF_LONG_ADDR,
 471   3                                                 hal_pib_PANId,
 472   3                                                 (address_field_t *)
 473   3                                                 &hal_pib_IeeeAddress);
 474   3              } else {
 475   3                  mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
 476   3                                                 status,
 477   3                                                 FCF_SHORT_ADDR,
 478   3                                                 hal_pib_PANId,
 479   3                                                 (address_field_t *)
 480   3                                                 &hal_pib_ShortAddress);
 481   3              }
 482   2          }
 483   1      }
 484          #endif //HYBRII_802154


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1623    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      85
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
