C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE HAL_HPGPTX
OBJECT MODULE PLACED IN .\obj\hal_hpgpTx.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hal\hal_hpgpTx.c LARGE OBJECTADVANCED OPTIMIZE(9,SP
                    -EED) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\.
                    -.\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal
                    -;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firm
                    -ware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;
                    -..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;
                    -..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc
                    -;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..
                    -\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\h
                    -pgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\.
                    -.\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\co
                    -mponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\f
                    -lash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;
                    -..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk
                    -\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\.
                    -.\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8
                    -051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,U
                    -M,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETEC
                    -T,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,
                    -MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIS
                    -TER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\hal_hpgpTx.lst) TABS(2)
                    - OBJECT(.\obj\hal_hpgpTx.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgpTx.c,v 1.30 2014/12/09 07:09:08 ranjan Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgpTx.c,v $
   5          *
   6          * Description : HPGP HAL Transmit module.
   7          *
   8          * Copyright (c) 2010-2011 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines beacon and data trasmit functions for HPGP.
  13          *
  14          *
  15          */
  16          #include <stdio.h>
  17          #include <string.h>
  18          #include "papdef.h"
  19          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  22          #include "hal_common.h"
  23          #include "fm.h"
  24          #include "hal.h"
  25          #include "hpgpdef.h"
  26          #include "hal_hpgp.h" 
  27          #include "hal_reg.h"
  28          #include "frametask.h" 
  29          #include "datapath.h"
  30          #include "hal_cfg.h"
  31          #include "hal_hpgp_reset.h"
  32          #ifdef PLC_TEST
              #include "hal_tst.h" 
              #endif
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 2   

  35          #include "utils_fw.h"
  36          #include "nma.h"
  37          #include "nma_fw.h"
  38          #include "mmsg.h"
  39          #ifdef UM
  40          #include "linkl.h"
  41          #include "hpgpapi.h"
  42          #endif
  43          #include "uart.h"
  44          #include "gv701x_gpiodriver.h"
  45          
  46          u8 gsendBcn;
  47          
  48          #ifdef DEBUG_DATAPATH
  49          extern u8 pktDbg;
  50          extern u8 sigDbg;
  51          extern u8 ethQueueDebug;
  52          #endif
  53          #ifdef PLC_TEST
              u16 gBcnSent;
              extern u8 gCCOTest;
              extern u8 gSTA_TEI;
              u8 gHeaderBytes[3] = {'/', '?', '!'};
              #endif
  59          
  60          #ifdef UM
  61          #ifdef CCO_FUNC
  62          extern void LINKL_UpdateBeacon();
  63          #endif
  64          #endif
  65          #ifdef HPGP_HAL_TEST
              extern void HHT_SendBcn(u8 bcnType);
              #endif
  68          #ifdef FREQ_DETECT
  69          extern u32 PLC_MIN_AC_BPLEN;
  70          extern u32 PLC_AC_BP_LEN; 
  71          extern u32 PLC_MAX_AC_BPLEN; 
  72          #endif
  73          
  74          extern uCSMARegionReg   csmaRegArr[HYBRII_MAXSMAREGION_CNT]; 
  75          //u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0x1E8, 0xF43,0x00 ,0x00, 0x00, 0x00 };  //first regi
             -on is 5ms and sec is 35 ms(so we have to program as 40), start point is 00
  76          //u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0xCA, 0xF43, 0xFFF , 0xFFF, 0xFFF, 0xFFF };  //CSMA 
             -reg. 0 is 2.068ms, reg. 1 is 40 ms, 2 and .. are set at 41.9ms with Rx Only
  77          //u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0xCA, 0xD5A, 0xFFF , 0xFFF, 0xFFF, 0xFFF };  //CSMA 
             -reg. 0 is 2.068ms, reg. 1 is 40 ms, 2 and .. are set at 41.9ms with Rx Only
  78          u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0x30, 0xF11, 0xFFF , 0xFFF, 0xFFF, 0xFFF };  //CSMA re
             -g. 0 is 2.068ms, reg. 1 is 40 ms, 2 and .. are set at 41.9ms with Rx Only
  79          u16 CSMA_REGIONS_VAL_DC_STA[HYBRII_MAXSMAREGION_CNT] = {52, 3907,  0xFFF, 0xFFF, 0xFFF, 0xFFF };
  80          //u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0xCA, 0xF43, 0xFFF , 0xFFF, 0xFFF, 0xFFF }; // TRI's
             -  //first region is 5ms and sec is 35 ms(so we have to program as 40), start point is 00
  81          //u16 CSMA_REGIONS_VAL_DC[HYBRII_MAXSMAREGION_CNT] = {0x98, 0xF43,0x00 ,0x00, 0x00, 0x00 };  //first regio
             -n is 5ms and sec is 35 ms(so we have to program as 40), start point is 00
  82          
  83          //STA regions
  84          //u16 CSMA_REGIONS_VAL_AC[HYBRII_MAXSMAREGION_CNT] = {0xC3, 0xBF1,0xCB6 ,0x00, 0x00, 0x00 };  //STA region
             -s this is sent in bcn so this is STA regions for AC
  85          u16 CSMA_REGIONS_VAL_AC[HYBRII_MAXSMAREGION_CNT] = {0x61, 0xc65 ,0xFFF,0xFFF, 0xFFF, 0xFFF };  //STA regio
             -ns this is sent in bcn so this is STA regions for AC
  86          //u16 CSMA_REGIONS_VAL_AC_CCO[HYBRII_MAXSMAREGION_CNT] = {0xCA, 0xaf0,0xd75,0xd75,0xd75,0xd75};
  87          #ifdef ETH_BRDG_DEBUG
              extern u8 myDebugFlag;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 3   

              extern u32 numTxFrms;
              #endif
  91          
  92          extern u8 opMode;
  93          extern u32 host_intf_max_cp;
  94          
  95          #ifndef CALLBACK
  96          extern void LINKL_BcnTxHandler(void* cookie);
  97          #endif
  98          #ifdef HPGP_HAL_TEST
              extern void Host_RxHandler(sCommonRxFrmSwDesc* pRxFrmDesc);
              #else
 101          extern void Host_RxHandler(sHaLayer *pHal, sCommonRxFrmSwDesc* pRxFrmDesc);
 102          #endif
 103          
 104          #ifdef PLC_TEST
              void HHT_SimulateTx(sPlcSimTxTestParams *);
              
              void broadcast_CCOTEI()
              {
               
                  u8 dataBuff[8];
                  
                  //send broad cast frame to each sta 
                  strncpy(&dataBuff[0], &gHeaderBytes[0], sizeof(gHeaderBytes));
                  dataBuff[3] = BROADCAST_CCO_TEI_TESTID;
                  dataBuff[4] = gNumOfSTAAssignedTEI;
                  
                  Send_SinglePLCFrame(5, &dataBuff[0], DEFAULT_CCO_TEI, 0xFF);//broadcast CCO TEI
              
              }
              
              void sendRobomodeFrames(u16 frmLen, u32 numFrames)
              {
                  
                  sPlcSimTxTestParams testParams; 
                  memset(&testParams, 0, sizeof(testParams));
                  testParams.numFrames      = numFrames;
                  testParams.contMode = 0;
              
                  testParams.frmLen         = frmLen;
                  testParams.lenTestMode    = FIXED_LEN;
                  //testParams.roboTestMode   = 0;//roboTestMode
                  testParams.frmType        = 1;
                  testParams.altFrmTypeTest = 0;
                  testParams.altMcstTest    = 0;
                  testParams.plid           = 0;
                  testParams.altPlidTest    = 0;
                  //testParams.stdModeSel     = stdModeSel;
                  testParams.mcstMode       = 0;//unicast
                  testParams.offsetDW       = 0;
                  testParams.descLen        = HYBRII_CELLBUF_SIZE;
                  testParams.secTestMode    = UNENCRYPTED;
                  testParams.eks            = HPGP_UNENCRYPTED_EKS;
                  testParams.altOffsetDescLenTest = 0;
                  testParams.delay          = 4;  // I have changed this because Tri changed the delay ticks definition
               
                  
                  printf("\n >>> Transmitting %lu  Frames of Each of  Length  %d \n",numFrames, frmLen);
                  // Trigger the tx test
                  HHT_SimulateTx(&testParams);
                
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 4   

              }
              
              
              void Send_SinglePLCFrame(u16 frmLen, u8 *dataBuff, u8 stei,u8 dtei)//pass dataBuf and frameLen
              {
                  //broadcast TEI to STAs with num of TEIS assigns to STAs
                     
                  
                      u16 index = 0;
                  u16 tmpFrmLen;
                  eStatus status;
                  u8 i;
                  u8 j;
                  u8 quit = 0; 
                  u8 c;
                  u16 tmpPayloadLen;
              #ifndef HPGP_HAL_TEST
                  sHaLayer *hal = (sHaLayer*)HOMEPLUG_GetHal();
              #endif
                     
                   sTxFrmSwDesc    plcTxFrmSwDesc; 
                  
                  quit              = 0;
                   memset((u8*)&plcTxFrmSwDesc, 0x00, sizeof(plcTxFrmSwDesc));
                   plcTxFrmSwDesc.frmInfo.plc.eks            = 0x0F;
                  plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                  plcTxFrmSwDesc.frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_RSV;//HPGP_CONVLYRSAPTYPE_ETH; 
              
                  
                  
                  plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;
                 plcTxFrmSwDesc.frmInfo.plc.dtei = 0xFF; //dtei;
                  plcTxFrmSwDesc.frmInfo.plc.plid = 0;    
                  plcTxFrmSwDesc.frmInfo.plc.stei            = stei;//CCO TEI
                  plcTxFrmSwDesc.frmInfo.plc.snid = HYBRII_DEFAULT_SNID;
                  
                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;//HPGP_ROBOMD_MINI;
                  gHpgpHalCB.halStats.CurTxTestFrmCnt = 0; 
                   plcTxFrmSwDesc.frmLen         =  frmLen;
                  plcTxFrmSwDesc.cpCount        = 0;        
                    
                  plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
                  plcTxFrmSwDesc.frmInfo.plc.mcstMode       = 1;   //mcstcastmode 
              
                  
                  tmpFrmLen   = 0;
                  tmpPayloadLen = 0;
                  // create cp descriptors
                   while(tmpFrmLen < plcTxFrmSwDesc.frmLen)//thisw while loop will write the data to MAC buff address
                   {      
                      u8        cp;
                      u8        tmpOffsetDW;
                      u8        tmpOffsetByte;
                      u8        tmpDescLen;
                      u8        remDescLen;
                      u8        actualDescLen;
                      
                      volatile u8 xdata *       cellAddr;
                      
                     
                      // Fetch CP
              
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 5   

                      do
                      {
                              status = CHAL_RequestCP(&cp);
              
                      }while (status != STATUS_SUCCESS);
                      // check for user initiated exit task
                      if(quit)
                      {
                              break;
                      }
                       
              
                    
                      i = plcTxFrmSwDesc.cpCount;
                      // test offset and desc len - only for first CPs
              
                      tmpOffsetDW = 0;
                      tmpDescLen  = HYBRII_CELLBUF_SIZE;
                      actualDescLen =  (plcTxFrmSwDesc.frmLen-tmpFrmLen)>tmpDescLen ? tmpDescLen : (plcTxFrmSwDesc.frmLe
             -n-tmpFrmLen);
                      remDescLen    =  actualDescLen;
              
                      // Fill Buffer with pattern
                      cellAddr = CHAL_GetAccessToCP(cp);
              //        FM_Printf(FM_LINFO,"cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.halStat
             -s.TxSeqNum);
              
                 
                      for( j= 0 ; j< remDescLen ; j++)
                      {
              
                              cellAddr[j] = dataBuff[index++];
              
                      }
                      plcTxFrmSwDesc.cpArr[i].offsetU32 = tmpOffsetDW;
                      plcTxFrmSwDesc.cpArr[i].len       = actualDescLen; 
                      tmpFrmLen                        += plcTxFrmSwDesc.cpArr[i].len; 
                      plcTxFrmSwDesc.cpArr[i].cp        = cp;
              
                      plcTxFrmSwDesc.cpCount++;
                      tmpPayloadLen += (plcTxFrmSwDesc.cpArr[i].len - tmpOffsetByte);
              
              
                   }    
                      // check for user initiated exit task
                  if(status == STATUS_SUCCESS)//this will wrire swdesc to hw desc
                  {
                          do
                          {
                              // Transmit the frame
                              //status = HHAL_IsPlcIdle();
                              //if(status == STATUS_FAILURE)
                              {
                                  //HHAL_PlcPendingTx();
                              }
                             // else
                              {
              #ifdef HPGP_HAL_TEST
                                  status = HHAL_PlcTxQWrite(&plcTxFrmSwDesc);
              #else
                                  status = HHAL_PlcTxQWrite(hal, &plcTxFrmSwDesc);
              #endif
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 6   

                              }
                              // check for user initiated exit task from infinite loop
              #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')               
                              {
                                      // if TxQWrite failed, release CPs for current frame -- tbd
                                      quit = 1;
                                      break;
                              }
                          } while(status == STATUS_FAILURE);
                  }
                  gHpgpHalCB.halStats.TotalTxFrmCnt--;
                  gHpgpHalCB.halStats.TxDataCnt--;
              
                
                  if((gHpgpHalCB.halStats.CurTxTestFrmCnt & (u32)(0xFF)) == 0)
                  {  
                      printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b
             -\b");
                      printf("Sent %ld, Received %ld HPGP frames.", gHpgpHalCB.halStats.CurTxTestFrmCnt, gHpgpHalCB.halS
             -tats.TotalRxGoodFrmCnt - gHpgpHalCB.halStats.RxGoodBcnCnt);
                  }
              
                    
                  
              }
              #endif
 302          
 303              
 304          void setCSMA_onSTA()
 305          {
 306   1      
 307   1          uCSMARegionReg   *pCSMARgn;
 308   1          u16 csma0, csma1, csma2, csma3, csma4, csma5;
 309   1      
 310   1      
 311   1      
 312   1      pCSMARgn = &csmaRegArr[0];
 313   1      pCSMARgn->s.csma_start_time_lo = 0; //start_time;
 314   1      pCSMARgn->s.csma_start_time_hi = 0;
 315   1      pCSMARgn->s.csma_rxOnly = 0;
 316   1      pCSMARgn->s.csma_hybrid = 1;
 317   1      /*  pCSMARgn->s.csma_endtime_lo = CSMA_REGIONS_VAL[0] & 0x00FF;
 318   1      pCSMARgn->s.csma_endtime_hi = ((CSMA_REGIONS_VAL[0]  & 0xFF00) >> 8);
 319   1      WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);     //since this address is not continuous we cant use fo
             -r loop
 320   1      
 321   1      pCSMARgn->s.csma_start_time_lo = 0; //start_time;
 322   1      pCSMARgn->s.csma_start_time_hi = 0;
 323   1      pCSMARgn->s.csma_rxOnly = 0;
 324   1      pCSMARgn->s.csma_hybrid = 1;  */
 325   1      
 326   1      if(gHpgpHalCB.lineFreq == FREQUENCY_50HZ)
 327   1      {
 328   2      csma0 = CSMA_REGIONS_VAL_DC_STA[0];  
 329   2      csma1 = CSMA_REGIONS_VAL_DC_STA[1]; 
 330   2      csma2 = CSMA_REGIONS_VAL_DC_STA[2];
 331   2      
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 7   

 332   2      csma3 = CSMA_REGIONS_VAL_DC_STA[3]; 
 333   2      csma4 = CSMA_REGIONS_VAL_DC_STA[4]; 
 334   2      csma5 = CSMA_REGIONS_VAL_DC_STA[5];       
 335   2      }
 336   1      
 337   1      else if(gHpgpHalCB.lineFreq == FREQUENCY_60HZ)
 338   1      {
 339   2      csma0 = CSMA_REGIONS_VAL_AC[0];  
 340   2      csma1 = CSMA_REGIONS_VAL_AC[1];
 341   2      
 342   2      csma2 = CSMA_REGIONS_VAL_AC[2];
 343   2      
 344   2      csma3 = CSMA_REGIONS_VAL_AC[3]; 
 345   2      csma4 = CSMA_REGIONS_VAL_AC[4]; 
 346   2      csma5 = CSMA_REGIONS_VAL_AC[5];     
 347   2      }
 348   1      
 349   1      pCSMARgn->s.csma_rxOnly = TRUE;
 350   1      pCSMARgn->s.csma_endtime_lo =  csma0 & 0x00FF;
 351   1      pCSMARgn->s.csma_endtime_hi = (( csma0 & 0xFF00) >> 8);
 352   1      WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);
 353   1      
 354   1      pCSMARgn->s.csma_rxOnly = FALSE;
 355   1      
 356   1      
 357   1      pCSMARgn->s.csma_hybrid = 1;
 358   1      
 359   1      pCSMARgn->s.csma_endtime_lo =  csma1 & 0x00FF;
 360   1      pCSMARgn->s.csma_endtime_hi = (( csma1 & 0xFF00) >> 8);
 361   1      WriteU32Reg(PLC_CSMAREGION1_REG, pCSMARgn->reg);
 362   1      
 363   1      pCSMARgn->s.csma_rxOnly = TRUE;
 364   1      
 365   1      
 366   1      pCSMARgn->s.csma_hybrid = 1;
 367   1      
 368   1      // need to take of AC later. TRI
 369   1      if(gHpgpHalCB.lineMode == LINE_MODE_DC)
 370   1      {
 371   2      pCSMARgn->s.csma_endtime_lo =  csma2 & 0x00FF;
 372   2      pCSMARgn->s.csma_endtime_hi = (( csma2 & 0xFF00) >> 8);
 373   2      pCSMARgn->s.csma_rxOnly = TRUE;
 374   2      WriteU32Reg(PLC_CSMAREGION2_REG, pCSMARgn->reg);
 375   2      #if 1
 376   2      pCSMARgn->s.csma_endtime_lo =  csma3 & 0x00FF;
 377   2      pCSMARgn->s.csma_endtime_hi = (( csma3 & 0xFF00) >> 8);
 378   2      pCSMARgn->s.csma_rxOnly = TRUE;
 379   2      WriteU32Reg(PLC_CSMAREGION3_REG, pCSMARgn->reg);
 380   2          
 381   2      pCSMARgn->s.csma_endtime_lo =  csma4 & 0x00FF;
 382   2      pCSMARgn->s.csma_endtime_hi = (( csma4 & 0xFF00) >> 8);
 383   2      pCSMARgn->s.csma_rxOnly = TRUE;
 384   2      WriteU32Reg(PLC_CSMAREGION4_REG, pCSMARgn->reg);    
 385   2      
 386   2      pCSMARgn->s.csma_endtime_lo =  csma5 & 0x00FF;
 387   2      pCSMARgn->s.csma_endtime_hi = (( csma5 & 0xFF00) >> 8);
 388   2      pCSMARgn->s.csma_rxOnly = TRUE;
 389   2      WriteU32Reg(PLC_CSMAREGION5_REG, pCSMARgn->reg);    
 390   2      
 391   2      #endif
 392   2      }
 393   1      
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 8   

 394   1      
 395   1      }
 396          
 397          
 398          #if 0
              void setCSMA_onCCO1()
              {
              
                uCSMARegionReg   *pCSMARgn;
                u16 csma0, csma1, csma2, csma3, csma4, csma5;
              
              
                  
                    pCSMARgn = &csmaRegArr[0];
                      pCSMARgn->s.csma_start_time_lo = 0; //start_time;
                    pCSMARgn->s.csma_start_time_hi = 0;
                      pCSMARgn->s.csma_rxOnly = 0;
                    pCSMARgn->s.csma_hybrid = 1;
                  /*  pCSMARgn->s.csma_endtime_lo = CSMA_REGIONS_VAL[0] & 0x00FF;
                    pCSMARgn->s.csma_endtime_hi = ((CSMA_REGIONS_VAL[0]  & 0xFF00) >> 8);
                      WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);     //since this address is not continuous we can
             -t use for loop
                     
                      pCSMARgn->s.csma_start_time_lo = 0; //start_time;
                    pCSMARgn->s.csma_start_time_hi = 0;
                      pCSMARgn->s.csma_rxOnly = 0;
                    pCSMARgn->s.csma_hybrid = 1;  */
                      
                      if(gHpgpHalCB.lineMode == LINE_MODE_DC)
                      {
                          csma0 = CSMA_REGIONS_VAL_DC[0];  
                          csma1 = CSMA_REGIONS_VAL_DC[1]; 
                          csma2 = CSMA_REGIONS_VAL_DC[2]; 
                          csma3 = CSMA_REGIONS_VAL_DC[3]; 
                          csma4 = CSMA_REGIONS_VAL_DC[4]; 
                          csma5 = CSMA_REGIONS_VAL_DC[5]; 
                      }
                      else if(gHpgpHalCB.lineMode == LINE_MODE_AC)
                      {
                         csma0 = CSMA_REGIONS_VAL_AC[0];  
                         csma1 = CSMA_REGIONS_VAL_AC[1]; 
                         csma2 = CSMA_REGIONS_VAL_AC[2]; 
                         csma3 = CSMA_REGIONS_VAL_AC[3]; 
                         csma4 = CSMA_REGIONS_VAL_AC[4]; 
                         csma5 = CSMA_REGIONS_VAL_AC[5]; 
                      }
                    pCSMARgn->s.csma_endtime_lo =  csma0 & 0x00FF;
                    pCSMARgn->s.csma_endtime_hi = (( csma0 & 0xFF00) >> 8);
                      pCSMARgn->s.csma_rxOnly = 1;
                      WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);
              
                      pCSMARgn->s.csma_rxOnly = 0;
                      pCSMARgn->s.csma_endtime_lo =  csma1 & 0x00FF;
                    pCSMARgn->s.csma_endtime_hi = (( csma1 & 0xFF00) >> 8);
                      WriteU32Reg(PLC_CSMAREGION1_REG, pCSMARgn->reg);
              
                  // need to take of AC later. TRI
                      //if(gHpgpHalCB.lineMode == LINE_MODE_DC)
                      {
                    pCSMARgn->s.csma_endtime_lo =  csma2 & 0x00FF;
                      pCSMARgn->s.csma_endtime_hi = (( csma2 & 0xFF00) >> 8);
                        pCSMARgn->s.csma_rxOnly = TRUE;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 9   

                    WriteU32Reg(PLC_CSMAREGION2_REG, pCSMARgn->reg);
                        
                    pCSMARgn->s.csma_endtime_lo =  csma3 & 0x00FF;
                      pCSMARgn->s.csma_endtime_hi = (( csma3 & 0xFF00) >> 8);
                        pCSMARgn->s.csma_rxOnly = TRUE;
                    WriteU32Reg(PLC_CSMAREGION3_REG, pCSMARgn->reg);
                        
                    pCSMARgn->s.csma_endtime_lo =  csma4 & 0x00FF;
                      pCSMARgn->s.csma_endtime_hi = (( csma4 & 0xFF00) >> 8);
                        pCSMARgn->s.csma_rxOnly = TRUE;
                    WriteU32Reg(PLC_CSMAREGION4_REG, pCSMARgn->reg);    
              
                    pCSMARgn->s.csma_endtime_lo =  csma5 & 0x00FF;
                      pCSMARgn->s.csma_endtime_hi = (( csma5 & 0xFF00) >> 8);
                        pCSMARgn->s.csma_rxOnly = TRUE;
                    WriteU32Reg(PLC_CSMAREGION5_REG, pCSMARgn->reg);    
                  }
              
              
              }
              #endif
 476          void setCSMA_onCCO()
 477          {
 478   1      
 479   1        uCSMARegionReg   *pCSMARgn;
 480   1        u16 csma0, csma1, csma2, csma3, csma4, csma5;
 481   1      
 482   1      
 483   1          
 484   1            pCSMARgn = &csmaRegArr[0];
 485   1              pCSMARgn->s.csma_start_time_lo = 0; //start_time;
 486   1            pCSMARgn->s.csma_start_time_hi = 0;
 487   1              pCSMARgn->s.csma_rxOnly = 0;
 488   1            pCSMARgn->s.csma_hybrid = 1;
 489   1          /*  pCSMARgn->s.csma_endtime_lo = CSMA_REGIONS_VAL[0] & 0x00FF;
 490   1            pCSMARgn->s.csma_endtime_hi = ((CSMA_REGIONS_VAL[0]  & 0xFF00) >> 8);
 491   1              WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);     //since this address is not continuous we can
             -t use for loop
 492   1             
 493   1              pCSMARgn->s.csma_start_time_lo = 0; //start_time;
 494   1            pCSMARgn->s.csma_start_time_hi = 0;
 495   1              pCSMARgn->s.csma_rxOnly = 0;
 496   1            pCSMARgn->s.csma_hybrid = 1;  */
 497   1              
 498   1              if(gHpgpHalCB.lineFreq == FREQUENCY_50HZ)
 499   1              {
 500   2                  csma0 = CSMA_REGIONS_VAL_DC[0];  
 501   2                  csma1 = CSMA_REGIONS_VAL_DC[1]; 
 502   2                  csma2 = CSMA_REGIONS_VAL_DC[2]; 
 503   2                  csma3 = CSMA_REGIONS_VAL_DC[3]; 
 504   2                  csma4 = CSMA_REGIONS_VAL_DC[4]; 
 505   2                  csma5 = CSMA_REGIONS_VAL_DC[5]; 
 506   2              }
 507   1              else  if(gHpgpHalCB.lineFreq == FREQUENCY_60HZ)
 508   1              {
 509   2                 csma0 = CSMA_REGIONS_VAL_AC[0];  
 510   2                 csma1 = CSMA_REGIONS_VAL_AC[1]; 
 511   2                 csma2 = CSMA_REGIONS_VAL_AC[2]; 
 512   2                 csma3 = CSMA_REGIONS_VAL_AC[3]; 
 513   2                 csma4 = CSMA_REGIONS_VAL_AC[4]; 
 514   2                 csma5 = CSMA_REGIONS_VAL_AC[5]; 
 515   2              }
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 10  

 516   1            pCSMARgn->s.csma_endtime_lo =  csma0 & 0x00FF;
 517   1            pCSMARgn->s.csma_endtime_hi = (( csma0 & 0xFF00) >> 8);
 518   1              WriteU32Reg(PLC_CSMAREGION0_REG, pCSMARgn->reg);
 519   1      
 520   1              pCSMARgn->s.csma_endtime_lo =  csma1 & 0x00FF;
 521   1            pCSMARgn->s.csma_endtime_hi = (( csma1 & 0xFF00) >> 8);
 522   1              WriteU32Reg(PLC_CSMAREGION1_REG, pCSMARgn->reg);
 523   1      
 524   1          // need to take of AC later. TRI
 525   1              //if(gHpgpHalCB.lineMode == LINE_MODE_DC)
 526   1              {
 527   2            pCSMARgn->s.csma_endtime_lo =  csma2 & 0x00FF;
 528   2              pCSMARgn->s.csma_endtime_hi = (( csma2 & 0xFF00) >> 8);
 529   2                pCSMARgn->s.csma_rxOnly = TRUE;
 530   2            WriteU32Reg(PLC_CSMAREGION2_REG, pCSMARgn->reg);
 531   2                
 532   2            pCSMARgn->s.csma_endtime_lo =  csma3 & 0x00FF;
 533   2              pCSMARgn->s.csma_endtime_hi = (( csma3 & 0xFF00) >> 8);
 534   2                pCSMARgn->s.csma_rxOnly = TRUE;
 535   2            WriteU32Reg(PLC_CSMAREGION3_REG, pCSMARgn->reg);
 536   2                
 537   2            pCSMARgn->s.csma_endtime_lo =  csma4 & 0x00FF;
 538   2              pCSMARgn->s.csma_endtime_hi = (( csma4 & 0xFF00) >> 8);
 539   2                pCSMARgn->s.csma_rxOnly = TRUE;
 540   2            WriteU32Reg(PLC_CSMAREGION4_REG, pCSMARgn->reg);    
 541   2      
 542   2            pCSMARgn->s.csma_endtime_lo =  csma5 & 0x00FF;
 543   2              pCSMARgn->s.csma_endtime_hi = (( csma5 & 0xFF00) >> 8);
 544   2                pCSMARgn->s.csma_rxOnly = TRUE;
 545   2            WriteU32Reg(PLC_CSMAREGION5_REG, pCSMARgn->reg);    
 546   2          }
 547   1      
 548   1      
 549   1      }
 550          
 551          /*******************************************************************
 552          * NAME :            HHAL_PlcBcnWrite
 553          *
 554          * DESCRIPTION :     Transmits beacon - writes to TxBcnFifo.
 555          *                   TxBcn format = { 16 bytes AVFC, 12 Byte Bcn Hdr, NBE, BENTRY's ..., ZeroPadding}
 556          *                   TxBcn has to be 152 bytes array, that is zero padded.
 557          *                
 558          *                   
 559          *
 560          * INPUTS :
 561          *       PARAMETERS:
 562          *           u8* pTxBcn    - 152 bytes , zero padded beacon.
 563          *           u8 bcnType    - Discover, proxy or central beacon selectio.
 564          *           u8 bpstoValueOffset - offset within the bcn where HW should isnert BPSTO ( min value is 33, co
             -unting from byte 0)
 565          *
 566          * OUTPUTS :
 567          *       None
 568          *
 569          */
 570          eStatus HHAL_PlcBcnWrite(u8* pTxBcn, u8 bcnType, u8 bpstoValueOffset)
 571          {
 572   1          uBcnStatusReg         bcnStatus;
 573   1      //    uPlcMedStatReg        plcMedStat;  
 574   1      //    uPlcStatusReg         plcStatus;
 575   1          uBpstoReg             bpstoReg;
 576   1          eStatus               status;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 11  

 577   1          u32                   tempU32;
 578   1          u8*                   ptempU8Ptr;
 579   1          u32                   BcnFifoWrRegAddr;
 580   1          u32                   BPSTORegAddr;
 581   1          sFrmCtrlBlk*          pAvFcBlk;
 582   1          u8                    i;    
 583   1      
 584   1          /*Compiler warning suppression*/
 585   1          bcnType = bcnType;
 586   1        
 587   1          status          = STATUS_SUCCESS;
 588   1          ptempU8Ptr      = (u8 *)&tempU32; 
 589   1          bpstoValueOffset -= sizeof(sFrmCtrlBlk) ;
 590   1      
 591   1          // Check if the previous beacon has been sent out.
 592   1          // A sanity check only - UL could make sure beacon 
 593   1          // sent interrupt is received prior to calling this API.
 594   1      
 595   1          bcnStatus.reg   = ReadU32Reg(PLC_BCNSTATUS_REG);
 596   1        
 597   1        //[YM] -- underline if condition should be changed, base on what kind of beacon is tx. Different type of 
             -beacon frame should check different bit field
 598   1          /*if(  bcnStatus.s.valid3 ||  bcnStatus.s.valid2 || gHpgpHalCB.bBcnTxPending || gHpgpHalCB.bBcnNotSent
             -)
 599   1          { 
 600   1              status     = STATUS_FAILURE;
 601   1          //[YM] If HW is busy on Beacon transmission, SW can not trigger anyther Beacon Tx.  --> skip current Bea
             -con Tx??
 602   1              //printf("Bcn valid not cleared - cannot write beacon\n");
 603   1          } */
 604   1          // Write HP10 FC followed by AV Bcn MPDU to Bcn Tx Fifo.
 605   1          // [YM] Beacon frame construction should be separated with Beacon Tx control. 
 606   1      
 607   1      
 608   1        //FM_HexDump(FM_ERROR,"\nTxBcn:",pTxBcn, PLC_BCN_LEN);
 609   1      
 610   1        
 611   1          if(status == STATUS_SUCCESS) 
 612   1          {
 613   2         
 614   2         
 615   2      #ifdef UM
 616   2          sLinkLayer *linkl = HPGPCTRL_GetLayer(2);   
 617   2      
 618   2          sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
 619   2      #endif
 620   2             
 621   2            pAvFcBlk = (sFrmCtrlBlk*) pTxBcn;
 622   2          // AV Frame Control 
 623   2          pAvFcBlk->access = 0;
 624   2      #ifdef UM
 625   2      
 626   2      
 627   2          pAvFcBlk->snid  = staInfo->snid;
 628   2      #else
                  pAvFcBlk->snid  = gHpgpHalCB.snid;
              
              #endif
 632   2      
 633   2      
 634   2      
 635   2      #if (PLC_BCNDATA_TXHANG_TEST  && PLC_BCNDATA_FIXED_PATTERN)
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 12  

                    pAvFcBlk->dtav   = HPGP_DTAV_SOF;
              #else
 638   2            pAvFcBlk->dtav   = HPGP_DTAV_BCN;
 639   2              pAvFcBlk->bto[0] = cpu_to_le16(gHpgpHalCB.curBcnPer - PLC_AC_BP_LEN);
 640   2      #endif
 641   2               // Determine which BPST Offset register to program
 642   2               /*Compiler warning suppression*/
 643   2      #if 1        
 644   2               if(1)//(bcnType == BEACON_TYPE_CENTRAL) || (bcnType == BEACON_TYPE_PROXY))
 645   2               {
 646   3                  BcnFifoWrRegAddr = PLC_CAP3BCNFIFO_REG;
 647   3                  BPSTORegAddr = PLC_CAP3BPSTOADDR_REG;
 648   3               }
 649   2      #else        
                       else 
                       {
                          BcnFifoWrRegAddr = PLC_CAP2BCNFIFO_REG;
                          BPSTORegAddr = PLC_CAP2BPSTOADDR_REG;
                       }
              #endif         
 656   2      
 657   2               // Write BPSTOAddress Register
 658   2               bpstoReg.s.bpsto0 = bpstoValueOffset ;
 659   2               bpstoReg.s.bpsto1 = bpstoValueOffset + 1;
 660   2               bpstoReg.s.bpsto2 = bpstoValueOffset + 2;
 661   2               WriteU32Reg(BPSTORegAddr, bpstoReg.reg);
 662   2      
 663   2               if(!gHpgpHalCB.halStats.TxBcnCnt)  //[YM] purpose of checking this counter??
 664   2               {
 665   3                   //printf("Wrote Bpsto0 Offset = %lX\n", rtocl(bpstoReg.reg));
 666   3               }
 667   2      
 668   2               // Write HP10 FC
 669   2               WriteU32Reg(BcnFifoWrRegAddr, gHpgpHalCB.plcTx10FC.reg);
 670   2               //memcpy(bcnMPDU, &gHpgpHalCB.plcTx10FC.reg, HPGP_HP10FC_LEN);
 671   2      
 672   2               // Write rest of the beacon payload. 
 673   2               //printf("BcnPld: ");
 674   2               for( i=0 ; i<PLC_BCN_LEN ; i+=4)
 675   2               {
 676   3                    ptempU8Ptr[0] = pTxBcn[i];
 677   3                    ptempU8Ptr[1] = pTxBcn[i+1];
 678   3                    ptempU8Ptr[2] = pTxBcn[i+2];
 679   3                    ptempU8Ptr[3] = pTxBcn[i+3]; 
 680   3                    WriteU32Reg(BcnFifoWrRegAddr, tempU32);
 681   3                    if(!gHpgpHalCB.halStats.TxBcnCnt)
 682   3                    {
 683   4                        if((i & 0x0f) == 0 )
 684   4                        {
 685   5                            //printf("\n");
 686   5                        }
 687   4                        //printf("0x%02bX 0x%02bX 0x%02bX 0x%02bX ", pTxBcn[i], pTxBcn[i+1], pTxBcn[i+2], pTxBcn
             -[i+3]);
 688   4                    } 
 689   3               }
 690   2               //printf("\n");
 691   2               bcnStatus.reg  = ReadU32Reg(PLC_BCNSTATUS_REG);
 692   2           
 693   2               if(!gHpgpHalCB.halStats.TxBcnCnt)  //[YM] purpose of checking this counter??
 694   2               {
 695   3               //printf("\nWrote %bu bytes to bcn fifo\n\n",i+HPGP_HP10FC_LEN);
 696   3               }
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 13  

 697   2      
 698   2               /*******Critical Section Starts **********/
 699   2      #ifdef Hybrii_A_PLC_SW_CSMA  //Only for Hybrii_A
                       {
                          // Critical section from now till writing bcn valid bit,                
                          // disable Interrupts.
              //            u32     bcnTxWaitTimer;
                          IRQ_DISABLE_INTERRUPT();
                          //EA = 0;
                          plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                          plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
                      
                  /*        bcnTxWaitTimer = gHalCB.timerIntCnt;
                          while(plcMedStat.s.phyActive || !plcStatus.s.plcMacIdle || plcMedStat.s.crsMac || plcStatus.s.
             -plcTxQRdy)
                          {
                              {
                                  //gHpgpHalCB.bcnTxWaitTimer++;
                                  //if(gHpgpHalCB.bcnTxWaitTimer >= PLC_BCNTX_WAIT_TIMEOUT)
                                  if(gHalCB.timerIntCnt >= (bcnTxWaitTimer + PLC_BCNTX_WAIT_TIMEOUT)
                                   || gHalCB.timerIntCnt < bcnTxWaitTimer)  // Wrap around case
                                  {
                                      // flush bcn fifo and return
                                      bcnStatus.reg = 0;
                                      if((bcnType == BEACON_TYPE_CENTRAL) || (bcnType == BEACON_TYPE_PROXY))
                                      {
                                          bcnStatus.s.flush3 = 1;
                                      }
                                      else
                                      {
                                          bcnStatus.s.flush2 = 1;
                                      }
                                      WriteU32Reg(PLC_BCNSTATUS_REG, bcnStatus.reg);
                                      gHpgpHalCB.BcnTxWaitTimeoutCnt ++;
                                      //IRQ_ENABLE_INTERRUPT();
                                      //EA = 1;
                                      return STATUS_FAILURE;
                                  }
                              }
                              plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                              plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
                          }
                     */
                         /* if(plcMedStat.s.phyActive || !plcStatus.s.plcMacIdle || plcMedStat.s.crsMac || plcStatus.s.p
             -lcTxQRdy)
                          {
                             gHpgpHalCB.pendBcnType   = bcnType;
                             //gHpgpHalCB.bBcnTxPending = 1;
                             IRQ_ENABLE_INTERRUPT();
              
                             printf("\n pa = %bu",plcMedStat.s.phyActive);
                             printf("\n macI = %bu",plcStatus.s.plcMacIdle);
                              printf("\n crs = %bu",plcMedStat.s.crsMac);
                               printf("\n plcTxQ = %bu",plcStatus.s.plcTxQRdy);
              
                             return STATUS_SUCCESS; 
                          } */
              
              
                          {
                              // Critical section from now till writing bcn valid                
                              // Disable Rx 
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 14  

                              plcStatus.s.nRxEn = 1;
                              WriteU32Reg(PLC_STATUS_REG, plcStatus.reg); 
              
                            plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
                              plcStatus.s.crsBypass = 1;
                              WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                              plcStatus.s.crsBypass = 0;
                              WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                          }
                       }
              #endif  //Hybrii_A_PLC_SW_CSMA
 768   2      
 769   2               //[YM] this line should add extra protection with device role. And, the else condition make sense
             -??
 770   2              /*Compiler warning suppression*/
 771   2      #if 1        
 772   2           if(1)//(bcnType == BEACON_TYPE_CENTRAL) || (bcnType == BEACON_TYPE_PROXY))
 773   2               {
 774   3                  bcnStatus.s.valid3 = 1;  
 775   3               }
 776   2      #else        
                       else 
                       {
                          bcnStatus.s.valid2 = 1;  //??
                       }
              #endif         
 782   2               //gHpgpHalCB.bBcnNotSent = 1;
 783   2               WriteU32Reg(PLC_BCNSTATUS_REG, bcnStatus.reg);
 784   2               gHpgpHalCB.halStats.TxBcnCnt++;
 785   2               gHpgpHalCB.halStats.TotalTxFrmCnt++;
 786   2               //IRQ_ENABLE_INTERRUPT();// no one is disabling interrupts
 787   2      //         EA = 1;
 788   2               /*******Critical Section Ends **********/
 789   2               
 790   2          }
 791   1          //printf("BPST = %lx\n", rtocl(ReadU32Reg(PLC_BPST_REG)));
 792   1          if (status == STATUS_FAILURE)
 793   1          {
 794   2               gHpgpHalCB.halStats.macTxStuckCnt++;  
 795   2          }
 796   1          else
 797   1          {
 798   2               gHpgpHalCB.halStats.macTxStuckCnt = 0;
 799   2               gHpgpHalCB.halStats.smTxStuckCnt = 0;
 800   2          }
 801   1          return status;
 802   1      }
 803          
 804          #ifndef HPGP_HAL_TEST
 805          
 806          void HHAL_BcnTxIntHandler()
 807          {
 808   1          uPlcMedStatReg  plcMedStat;   
 809   1          uPlcStatusReg   plcStatus;
 810   1          static u32 prevBPInt_TimerCnt;
 811   1          static u32 curBPInt_TimerCnt;
 812   1          static u8  bpInit;
 813   1        sHpgpHalCB *hhalCb;
 814   1      #ifndef HPGP_HAL_TEST
 815   1          sHaLayer *hal = (sHaLayer*)HOMEPLUG_GetHal();
 816   1      #endif
 817   1          
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 15  

 818   1      #ifdef HPGP_HAL_TEST
                  hhalCb = &gHpgpHalCB;
              #else
 821   1          hhalCb = hal->hhalCb;
 822   1      #endif
 823   1          // [YM] For Beacon sync timing adjust
 824   1          
 825   1          // Determine time gap between 2  consecutive HPGP BP interrupts.
 826   1          if( hhalCb->halStats.bpIntCnt )
 827   1          {
 828   2                bpInit = 1;
 829   2          } 
 830   1          if( bpInit )
 831   1          {
 832   2              prevBPInt_TimerCnt = curBPInt_TimerCnt;
 833   2          }
 834   1          curBPInt_TimerCnt   = gHalCB.timerIntCnt;
 835   1          hhalCb->bpIntGap = curBPInt_TimerCnt - prevBPInt_TimerCnt;
 836   1        hhalCb->halStats.bpIntCnt++;
 837   1      
 838   1          // Compute running average of prev 64 ZeroCrossing periods
 839   1          // and write to Bcn Period Average register.
 840   1          if( hhalCb->devMode == DEV_MODE_CCO && hhalCb->lineMode == LINE_MODE_AC )
 841   1          {
 842   2              //printf("HW Bcn PER = %lx\n",rtocl(ReadU32Reg(PLC_HWBCNPERLEN_REG)));
 843   2              hhalCb->curBcnPer = rtocl(ReadU32Reg(PLC_HWBCNPERCUR_REG));
 844   2              if( hhalCb->curBcnPer < PLC_MIN_AC_BPLEN )
 845   2              {
 846   3                  hhalCb->curBcnPer = PLC_MIN_AC_BPLEN;
 847   3              }
 848   2              else if( hhalCb->curBcnPer > PLC_MAX_AC_BPLEN )
 849   2              {
 850   3                  hhalCb->curBcnPer = PLC_MAX_AC_BPLEN;
 851   3              }
 852   2      
 853   2              hhalCb->bcnPerSum += hhalCb->curBcnPer;
 854   2              hhalCb->perSumCnt ++;
 855   2      
 856   2              if( hhalCb->perSumCnt >= PLC_BCNPERAVG_CNT )
 857   2              {
 858   3                  hhalCb->bPerAvgInitDone = 1;
 859   3              }
 860   2              if( hhalCb->bPerAvgInitDone )
 861   2              {
 862   3                  hhalCb->curBcnPer       = hhalCb->bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
 863   3                  hhalCb->bcnPerSum      -= hhalCb->curBcnPer;
 864   3              }
 865   2             // WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(hhalCb->curBcnPer));
 866   2              //WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(0xCB735));
 867   2              //printf("SW Bcn PER = %lx\n",gHpgpHalCB.curBcnPer);
 868   2          }
 869   1      
 870   1        WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1)));
 871   1          // Prepare and send beacon here for now.
 872   1          // This will eventually be done by hpgp nsm module.
 873   1      #ifdef HPGP_HAL_TEST
                  HHT_BPIntHandler();
              #else
 876   1      #ifdef CALLBACK
                  hal->xmitBcn(hal->txBcnCookie);
              #else
 879   1        //LINKL_BcnTxHandler(hal->txBcnCookie);
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 16  

 880   1          if(hhalCb->lmBcn.txBitmap & (1 << BEACON_TYPE_CENTRAL))
 881   1          {
 882   2            HHAL_PlcBcnWrite(hhalCb->lmBcn.cBcn.bcnBuff, BEACON_TYPE_CENTRAL,
 883   2                         hhalCb->lmBcn.cBcn.bpstoOffset);
 884   2          }
 885   1      #endif  //CALLBACK
 886   1      #endif  //HPGP_HAL_TEST
 887   1      
 888   1          //[YM] Expect to remove from Hybrii-B
 889   1          
 890   1          // PHY Active Hang workaround
 891   1          plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
 892   1          plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
 893   1          if( plcMedStat.s.phyActive && plcMedStat.s.mpiRxEn )
 894   1          {
 895   2              if(hhalCb->halStats.paRxEnHiCnt > PLC_RXPHYACT_HANG_THRES )
 896   2              {
 897   3      #ifdef _RX_RECOVERY_                        
                          plcStatus.s.nRxEn = 1;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                          CHAL_DelayTicks(5);
                          
                          plcStatus.s.plcRxEnSwCtrl  = 0;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                          plcStatus.s.plcRxEnSwCtrl  = 1;
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg); 
              #endif  //  _RX_RECOVERY_            
 908   3                  hhalCb->halStats.paRxEnHiCnt = 0;   
 909   3                  hhalCb->halStats.phyActHangRstCnt++;                    
 910   3              }
 911   2              else if( hhalCb->halStats.prevBPTotalRxCnt == hhalCb->halStats.TotalRxGoodFrmCnt )
 912   2              {
 913   3                  hhalCb->halStats.paRxEnHiCnt ++;
 914   3              } 
 915   2              else
 916   2              {
 917   3                  hhalCb->halStats.paRxEnHiCnt = 0;  
 918   3              }                
 919   2          }
 920   1          hhalCb->halStats.prevBPTotalRxCnt = hhalCb->halStats.TotalRxGoodFrmCnt;  
 921   1      
 922   1      #ifdef CCO_FUNC
 923   1          LINKL_UpdateBeacon();
 924   1      #endif    
 925   1      }
 926          
 927          #endif
 928          
 929          
 930          eStatus HHAL_IsPlcIdle()
 931          {
 932   1          
 933   1          uBcnStatusReg         bcnStatus;
 934   1          uPlcStatusReg         plcStatus;
 935   1          uPlcMedStatReg        plcMedStat;
 936   1          //uCpuSwStatusReg       cpuSwStat;   //[YM] redefine cpuSwStat structure and fields
 937   1          uPlcLineControlReg    plcLineCtrl; 
 938   1      
 939   1      
 940   1          plcStatus.reg   = ReadU32Reg(PLC_STATUS_REG); 
 941   1          plcMedStat.reg  = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 17  

 942   1      
 943   1          bcnStatus.reg   = ReadU32Reg(PLC_BCNSTATUS_REG);
 944   1          //cpuSwStat.reg = ReadU32Reg(CPU_SWSTATUS_REG);  //[YM] Hybrii_B changes setting register to 0xFDA4-PL
             -C Line Cycle Control register 
 945   1          plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
 946   1          //redefine cpuSwStat structure and fields
 947   1                 
 948   1          if((plcStatus.s.plcTxQRdy && plcStatus.s.plcTxQSwCtrl)  \
 949   1          //    || cpuSwStat.s.reqScan || gHpgpHalCB.bTxPending )        //[YM] redefine cpuSwStat structure and
             - fields
 950   1               || plcLineCtrl.s.reqScanning || gHpgpHalCB.bTxPending || (!gHpgpHalCB.syncComplete)) //||( gTxDon
             -e == 0) )
 951   1          {
 952   2      #if 0
                 
                  FM_Printf(FM_ERROR, "\n txdone p\%bu , %bu , %bu, %bu, %bu,%bu , %bu , %bu, %bu \n", plcStatus.s.plcTx
             -QRdy,plcStatus.s.plcTxQSwCtrl,
                              cpuSwStat.s.reqScan,    plcMedStat.s.phyActive, plcStatus.s.plcMacIdle,
                              plcMedStat.s.crsMac , plcMedStat.s.txWindow, gHpgpHalCB.bBcnTxPending,
                              gHpgpHalCB.bBcnNotSent);
              
              #endif
 960   2      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                  {
                    printf("HHAL_IsPlcIdle: return FALSE, plcTxQRdy=%bu,plcTxQSwCtrl=%bu,reqScanning=%bu,gHpgpHalCB.bTxPend
             -ing=%bu\n", 
                      plcStatus.s.plcTxQRdy,plcStatus.s.plcTxQSwCtrl,plcLineCtrl.s.reqScanning,gHpgpHalCB.bTxPending);
                      printf("    phyActive=%bu, plcMacIdle=%bu,crsMac=%bu , txWindow=%bu\n",
                                plcMedStat.s.phyActive, plcStatus.s.plcMacIdle,
                                plcMedStat.s.crsMac , plcMedStat.s.txWindow);
                  }
              #endif
 970   2              return STATUS_FAILURE;
 971   2          }
 972   1      
 973   1      #if 0
                 
                  FM_Printf(FM_ERROR, "\n txdone p\%bu , %bu , %bu, %bu, %bu,%bu , %bu , %bu, %bu \n", plcStatus.s.plcTx
             -QRdy,plcStatus.s.plcTxQSwCtrl,
                              cpuSwStat.s.reqScan,    plcMedStat.s.phyActive, plcStatus.s.plcMacIdle,
                              plcMedStat.s.crsMac , plcMedStat.s.txWindow, gHpgpHalCB.bBcnTxPending,
                              gHpgpHalCB.bBcnNotSent);
              
              #endif
 981   1          
 982   1          return STATUS_SUCCESS;        
 983   1      }
 984          
 985          
 986                   
 987          /*******************************************************************
 988          * NAME :            HHAL_PlcTxQWrite
 989          *
 990          * DESCRIPTION :     Transmits data/mgmt frames - writes Hdr & CP desc. to PLCTxQ.
 991          *
 992          * INPUTS :
 993          *       PARAMETERS:
 994          *           sPlcTxFrmSwDesc     Data structure with info about tx frame.
 995          *
 996          * OUTPUTS :
 997          *       None
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 18  

 998          *
 999          */
1000          
1001          
1002          #ifdef HPGP_HAL_TEST
              eStatus HHAL_PlcTxQWrite(sSwFrmDesc* txFrmSwDesc)
              #else
1005          eStatus HHAL_PlcTxQWrite(sHaLayer *hal, sSwFrmDesc* txFrmSwDesc)
1006          #endif
1007          
1008          {
1009   1          u8                    frmDescCnt;
1010   1      //    u8                    plcTxFreeDescCnt;
1011   1          eStatus               status;
1012   1          uBcnStatusReg         bcnStatus;
1013   1          uPlcStatusReg         plcStatus;
1014   1          uPlcMedStatReg        plcMedStat;
1015   1          //uCpuSwStatusReg       cpuSwStat;   //[YM] redefine cpuSwStat structure and fields
1016   1          uPlcLineControlReg    plcLineCtrl;
1017   1      //    uCapTxQStatusReg      capTxQStat;
1018   1          uTxFrmHwDesc          txfrmHwDesc;
1019   1          uPlcTxPktQDescVF0     vofDesc0;
1020   1          uPlcTxPktQDescVF1     vofDesc1;
1021   1          uPlcTxPktQDescVF2     vofDesc2;
1022   1          uPlcTxPktQDescVF3     vofDesc3;
1023   1          uPlcTxPktQCAP_Write   cap_write;
1024   1          uTxCpDesc             txCpDesc;
1025   1          uTxCMDQueueWrite      txCmdQueueWrtie;
1026   1          eHpgpRoboMod         roboMode;
1027   1          ePlcNumPBs            numPBs;
1028   1          u16                   flAv;
1029   1          u16                   miniRoboFrmLenMax;
1030   1          u16                   stdRoboFrmLenMax;
1031   1          u16                   hsRobo2PbFrmLenMax;
1032   1          u16                   hsRobo3PbFrmLenMax;
1033   1        u8                    CapQueueStatus;
1034   1          u8                    mfsCmd;
1035   1          u8                    i, *tmpPtr;
1036   1      //    u32                   medChkB4;
1037   1        u32           val_32;
1038   1      
1039   1          status     = STATUS_SUCCESS;
1040   1          frmDescCnt = PLC_HDR_DESC_COUNT + txFrmSwDesc->cpCount; 
1041   1      
1042   1          bcnStatus.reg   = ReadU32Reg(PLC_BCNSTATUS_REG);  //[YM] Reason to check Beacon Status register?? 
1043   1          //cpuSwStat.reg = ReadU32Reg(CPU_SWSTATUS_REG);     //[YM] redefine cpuSwStat structure and fields
1044   1          plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1045   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1046   1          plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
1047   1        
1048   1      #if 1 //def HPGP_HAL_TEST  
1049   1          if((plcStatus.s.plcTxQRdy && plcStatus.s.plcTxQSwCtrl) || (1 == eth_plc_sniffer)) //[YM] Tx one packet
             - at a time
1050   1        //if(1 == eth_plc_sniffer)     //[YM] For Throughput Improvement
1051   1        /*
1052   1          //if(((plcStatus.s.plcTxQRdy && plcStatus.s.plcTxQSwCtrl)  \
1053   1        //     || plcLineCtrl.s.reqScanning )|| gHpgpHalCB.bTxPending )
1054   1             // || cpuSwStat.s.reqScan )|| gHpgpHalCB.bTxPending )    //[YM] redefine cpuSwStat structure and fi
             -elds
1055   1        //if(((plcStatus.s.plcTxQRdy && plcStatus.s.plcTxQHwCtrl)  \
1056   1            //   || plcLineCtrl.s.reqScanning )|| gHpgpHalCB.bTxPending )
1057   1                                         */
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 19  

1058   1          {
1059   2              return STATUS_FAILURE;  //[YM] what to do after checking status = Failure?? Retry? or drop packet?
1060   2          }
1061   1        else  
1062   1      #endif
1063   1          {
1064   2          
1065   2          if (txFrmSwDesc->frmInfo.plc.plid == 0)
1066   2        {
1067   3        //printf("txFrmSwDesc->frmInfo.plc.plid is %bu\n", txFrmSwDesc->frmInfo.plc.plid);
1068   3          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG);
1069   3        //printf("assigned 1 to CapRdy\n");
1070   3        }
1071   2        else if (txFrmSwDesc->frmInfo.plc.plid == 1)
1072   2        {
1073   3          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+1);
1074   3        //printf("assigned 2 to CapRdy\n");
1075   3        }
1076   2        else if (txFrmSwDesc->frmInfo.plc.plid == 2)
1077   2        {
1078   3          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+2);
1079   3        //printf("assigned 4 to CapRdy\n");
1080   3        }
1081   2        else if (txFrmSwDesc->frmInfo.plc.plid == 3)
1082   2        {
1083   3          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+3);
1084   3        //printf("assigned 8 to CapRdy\n");
1085   3        }     
1086   2      
1087   2          if ((PLC_TXQ_DEPTH - CapQueueStatus)< PLC_TX_DESC_QUEUE_TH)
1088   2          {
1089   3         //     printf("\n 1:NOT enough descriptor space for next packet\n");
1090   3        //  printf("\n 1:PLC_Queue_Descriptor_Status = %lx\n", ReadU32Reg(PLC_QDSTATUS_REG));
1091   3          status = STATUS_FAILURE;
1092   3          }
1093   2          else 
1094   2          {
1095   3          //FM_Printf(FM_MINFO, "TxQWrite:1\n");
1096   3          /* 1.Create frame descriptor */
1097   3          memset(&txfrmHwDesc, 0x00, sizeof(txfrmHwDesc));
1098   3          memset(&vofDesc0, 0x00, sizeof(vofDesc0));
1099   3          memset(&vofDesc1, 0x00, sizeof(vofDesc1));
1100   3          memset(&vofDesc2, 0x00, sizeof(vofDesc2));
1101   3          memset(&vofDesc3, 0x00, sizeof(vofDesc3));
1102   3          memset(&txCpDesc, 0x00, sizeof(txCpDesc));
1103   3          // So frameLen/type is used to determine roboMode, PB Count,
1104   3          if(txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
1105   3          {
1106   4              miniRoboFrmLenMax             = HYBRII_MINIROBO_MGMTLEN_MAX;
1107   4              stdRoboFrmLenMax              = HYBRII_STD1PBHSROBO_MGMTLEN_MAX;
1108   4              hsRobo2PbFrmLenMax            = HYBRII_2PBHSROBO_MGMTLEN_MAX;
1109   4              hsRobo3PbFrmLenMax            = HYBRII_3PBHSROBO_MGMTLEN_MAX;
1110   4      
1111   4          }
1112   3          else
1113   3          {
1114   4              miniRoboFrmLenMax             = HYBRII_MINIROBO_DATALEN_MAX;
1115   4              stdRoboFrmLenMax              = HYBRII_STD1PBHSROBO_DATALEN_MAX;
1116   4              hsRobo2PbFrmLenMax            = HYBRII_2PBHSROBO_DATALEN_MAX;
1117   4              hsRobo3PbFrmLenMax            = HYBRII_3PBHSROBO_DATALEN_MAX; 
1118   4          } 
1119   3      #ifdef ETH_BRDG_DEBUG
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 20  

              //  if (myDebugFlag)
              //    printf("PLCTXQWRITE: frame Len: %d\n",txFrmSwDesc->frmLen);
              #endif
1123   3          if(txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1124   3          {
1125   4             if(txFrmSwDesc->frmLen > 122)
1126   4             {
1127   5               roboMode    = HPGP_ROBOMD_STD;
1128   5               flAv        = HPGP_STDROBO_FLAV;
1129   5           numPBs      = PLC_ONE_PB;
1130   5             }
1131   4             else
1132   4             {
1133   5               roboMode       = HPGP_ROBOMD_MINI;
1134   5               flAv           = HPGP_MINIROBO_FLAV;
1135   5           numPBs         = PLC_ONE_PB;
1136   5             }
1137   4          }
1138   3          else
1139   3          { 
1140   4          if(txFrmSwDesc->frmLen <= miniRoboFrmLenMax)  //frmLen <= 122 or 118 bytes
1141   4          {
1142   5              roboMode       = HPGP_ROBOMD_MINI;
1143   5              flAv           = HPGP_MINIROBO_FLAV;
1144   5              numPBs         = PLC_ONE_PB;
1145   5          }
1146   4          else if( (txFrmSwDesc->frmLen > miniRoboFrmLenMax) && (txFrmSwDesc->frmLen <= stdRoboFrmLenMax))  // 1
             -22 or 118 Bytes < frmLen <= 506/502 bytes
1147   4          {
1148   5      //#ifdef HPGP_HAL_TEST        
1149   5              if(txFrmSwDesc->frmInfo.plc.stdModeSel)
1150   5              {
1151   6                  roboMode    = HPGP_ROBOMD_STD;
1152   6                  flAv        = HPGP_STDROBO_FLAV;
1153   6              }
1154   5              else
1155   5      //#endif
1156   5              {   
1157   6                  roboMode    = HPGP_ROBOMD_HS;                
1158   6                  flAv        = HPGP_1PBHSROBO_FLAV;             
1159   6              }
1160   5              numPBs  = PLC_ONE_PB;           
1161   5          }
1162   4          else  //FrmLen > 506/502 Bytes
1163   4          {
1164   5              roboMode       = HPGP_ROBOMD_HS;
1165   5              if( (txFrmSwDesc->frmLen > stdRoboFrmLenMax) && (txFrmSwDesc->frmLen <= hsRobo2PbFrmLenMax))  //50
             -6/502 bytes < FrmLen <= 1018/1014 bytes
1166   5              {
1167   6                  flAv   = HPGP_2PBHSROBO_FLAV;
1168   6                  numPBs = PLC_TWO_PB;
1169   6              }
1170   5              else if(txFrmSwDesc->frmLen <= hsRobo3PbFrmLenMax)  // 1018/1014 bytes < FrmLen <= 1530/1526 bytes
1171   5              {
1172   6                  flAv   = HPGP_3PBHSROBO_FLAV;
1173   6                  numPBs = PLC_THREE_PB;
1174   6              }   
1175   5              else  //FrmLen > 1530/1526 bytes
1176   5              {
1177   6                  // Unsupported frm len
1178   6      #ifdef ETH_BRDG_DEBUG
                //    if (myDebugFlag)
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 21  

                //      printf("PLCTXQWRITE: unsupported frame: %d\n",txFrmSwDesc->frmLen);
              #endif 
1182   6                  status = STATUS_FAILURE;
1183   6              }
1184   5          }
1185   4          }
1186   3      #ifdef ETH_BRDG_DEBUG
                //if (myDebugFlag)
                //  printf("flAv=0x%x\n", flAv);
              #endif
1190   3           /********************************/
1191   3          /*0.  Create Cap_write register value to HW   */
1192   3          cap_write.reg = 0;
1193   3      #ifdef ETH_BRDG_DEBUG
                if (myDebugFlag)
                {
                  printf("txFrmSwDesc->frmInfo.plc.dtei=%bx, txFrmSwDesc->frmInfo.plc.stei=%bx\n", txFrmSwDesc->frmInfo.pl
             -c.dtei, txFrmSwDesc->frmInfo.plc.stei);
                  printf("txFrmSwDesc->frmInfo.plc.mcstMode=%bx, txFrmSwDesc->frmInfo.plc.roboMode=%bx, txFrmSwDesc->frmIn
             -fo.plc.eks=%bx\n", 
                    txFrmSwDesc->frmInfo.plc.mcstMode, txFrmSwDesc->frmInfo.plc.roboMode, txFrmSwDesc->frmInfo.plc.eks);
                  printf("clst=%bx, plid=%bx, pbsz=%bx,mfstart=%bx, mfend=%bx, bcnDetectFlag=%bx, scf=%bx\n", 
                    txFrmSwDesc->frmInfo.plc.clst, txFrmSwDesc->frmInfo.plc.plid, txFrmSwDesc->frmInfo.plc.pbsz, txFrmSwDes
             -c->frmInfo.plc.mfStart,
                    txFrmSwDesc->frmInfo.plc.mfEnd, txFrmSwDesc->frmInfo.plc.bcnDetectFlag,txFrmSwDesc->frmInfo.plc.scf);
                }
              #endif
1204   3        tmpPtr = (u8 *) &txFrmSwDesc->frmInfo.plc;
1205   3        //printf("tmpPtr[] is:\n    ");
1206   3        //for (i=0;i<20;i++)
1207   3        //  printf("%bx ", tmpPtr[i]);
1208   3        //printf("\n");
1209   3        //printf("txFrmSwDesc->frmInfo.plc.plid=%bx\n", txFrmSwDesc->frmInfo.plc.plid);
1210   3        cap_write.capw.Cap = txFrmSwDesc->frmInfo.plc.plid;
1211   3        if (txFrmSwDesc->frmInfo.plc.plid == 0)
1212   3        {
1213   4        //printf("txFrmSwDesc->frmInfo.plc.plid is %bu\n", txFrmSwDesc->frmInfo.plc.plid);
1214   4          cap_write.capw.CapRdy = 1;
1215   4      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                    printf("assigned 1 to CapRdy\n");
              #endif
1219   4        }
1220   3        else if (txFrmSwDesc->frmInfo.plc.plid == 1)
1221   3        {
1222   4          cap_write.capw.CapRdy = 2;
1223   4      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                    printf("assigned 2 to CapRdy\n");
              #endif
1227   4        }
1228   3        else if (txFrmSwDesc->frmInfo.plc.plid == 2)
1229   3        {
1230   4          cap_write.capw.CapRdy = 4;
1231   4      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                    printf("assigned 4 to CapRdy\n");
              #endif
1235   4        }
1236   3        else if (txFrmSwDesc->frmInfo.plc.plid == 3)
1237   3        {
1238   4          cap_write.capw.CapRdy = 8;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 22  

1239   4      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                    printf("assigned 8 to CapRdy\n");
              #endif
1243   4        }
1244   3      #ifdef ETH_BRDG_DEBUG
                else
                  if (myDebugFlag)
                    printf("nothing\n");
              #endif
1249   3          
1250   3        //printf("2. cap_write.reg=0x%lX\n", cap_write.reg);
1251   3        //printf("cap_write.capw.CapRdy=%bu\n", cap_write.capw.CapRdy); 
1252   3      
1253   3          
1254   3          /********************************/
1255   3          /*1.  Create first descriptor to HW              */
1256   3      
1257   3          txfrmHwDesc.reg = 0;
1258   3          
1259   3          /************************************/
1260   3          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1261   3          {
1262   4              /* 1.1 Write Frame Length */
1263   4              txfrmHwDesc.sound.frmLenLo = txFrmSwDesc->frmLen & PKTQDESC1_FRMLENLO_MASK;
1264   4              txfrmHwDesc.sound.frmLenHi = (txFrmSwDesc->frmLen & PKTQDESC1_FRMLENHI_MASK) >> PKTQDESC1_FRMLENHI
             -_POS;
1265   4      
1266   4              txfrmHwDesc.sound.bcst = 1;
1267   4          txfrmHwDesc.sound.mcst = 1;
1268   4              /* 1.3 Set Channel Access Priority (same as PLID) */
1269   4              txfrmHwDesc.sound.cap = txFrmSwDesc->frmInfo.plc.plid;
1270   4          
1271   4              /* 1.4 Set Frame Type and get corres. max frame length values */
1272   4              txfrmHwDesc.sound.frmType = HPGP_HW_FRMTYPE_SOUND;
1273   4                  
1274   4              // 1.5 Set security Enable bit and Key Idx(EKS)
1275   4              //txfrmHwDesc.sound.secKeyIdx    = 0xF;  
1276   4          
1277   4              /* 1.6 Set dtei */
1278   4          txfrmHwDesc.sound.dteiLo1 =  txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEILO1_MASK;
1279   4              txfrmHwDesc.sound.dteiLo2 = (txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEILO2_MASK) >> PKTQDESC1_
             -DTEILO2_POS;
1280   4              txfrmHwDesc.sound.dteiHi = (txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEIHI_MASK) >> PKTQDESC1_DT
             -EIHI_POS;
1281   4          
1282   4              /* 1.7 Set First Descriptor Flag */
1283   4              txfrmHwDesc.sound.bFirstDesc = 1;    
1284   4          }
1285   3          else // Sof
1286   3          {
1287   4      
1288   4              /* 1.1 Write Frame Length */
1289   4              txfrmHwDesc.sof.frmLenLo = txFrmSwDesc->frmLen & PKTQDESC1_FRMLENLO_MASK;
1290   4              txfrmHwDesc.sof.frmLenHi = (txFrmSwDesc->frmLen & PKTQDESC1_FRMLENHI_MASK) >> PKTQDESC1_FRMLENHI_P
             -OS;
1291   4      
1292   4              // 1.2 Set mcst/bcst mode bits
1293   4              if(txFrmSwDesc->frmInfo.plc.mcstMode == HPGP_MNBCST)
1294   4              {
1295   5                  txfrmHwDesc.sof.bcst     = 1;
1296   5              }
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 23  

1297   4              else if(txFrmSwDesc->frmInfo.plc.mcstMode == HPGP_MCST)
1298   4              {
1299   5                  txfrmHwDesc.sof.mcst     = 1;           
1300   5              }
1301   4              // 1.3 Set security Enable bit and Key Idx(EKS)
1302   4                  txfrmHwDesc.sof.secKeyIdx    = txFrmSwDesc->frmInfo.plc.eks;    
1303   4      
1304   4          /* 1.4 Set Channel Access Priority (same as PLID) */
1305   4          txfrmHwDesc.sof.cap = txFrmSwDesc->frmInfo.plc.plid;
1306   4      
1307   4          /* 1.5 Set Frame Type and get corres. max frame length values */
1308   4          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
1309   4          {
1310   5              txfrmHwDesc.sof.frmType = HPGP_HW_FRMTYPE_MGMT;
1311   5          } 
1312   4          else
1313   4          {
1314   5              txfrmHwDesc.sof.frmType = HPGP_HW_FRMTYPE_MSDU;
1315   5          } 
1316   4      
1317   4          /* 1.6 Set dtei */
1318   4          txfrmHwDesc.sof.dteiLo1 =  txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEILO1_MASK;
1319   4          txfrmHwDesc.sof.dteiLo2 = (txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEILO2_MASK) >> PKTQDESC1_DTEILO
             -2_POS;
1320   4          txfrmHwDesc.sof.dteiHi = (txFrmSwDesc->frmInfo.plc.dtei & PKTQDESC1_DTEIHI_MASK) >> PKTQDESC1_DTEIHI_P
             -OS;
1321   4      
1322   4          /* 1.7 Set First Descriptor Flag */
1323   4          txfrmHwDesc.sof.bFirstDesc = 1;    
1324   4          }
1325   3      
1326   3          /* 2. Create VOF descriptor 0 */
1327   3          vofDesc0.reg     = 0;
1328   3          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1329   3          {
1330   4              vofDesc0.s.dt_av = HPGP_DTAV_SOUND;
1331   4          }
1332   3        else if (txFrmSwDesc->frmInfo.plc.dt_av == HPGP_DTAV_RTS_CTS)
1333   3        {
1334   4            vofDesc0.s.dt_av = HPGP_DTAV_RTS_CTS;
1335   4        }
1336   3        else if (txFrmSwDesc->frmInfo.plc.dt_av == HPGP_DTAV_RSOF)
1337   3          {
1338   4              vofDesc0.s.dt_av = HPGP_DTAV_RSOF;
1339   4          }
1340   3        else
1341   3            vofDesc0.s.dt_av = HPGP_DTAV_SOF;
1342   3      
1343   3      #ifdef HPGP_HAL_TEST
              
                  vofDesc0.s.snid  = gHpgpHalCB.snid;
              #else
1347   3      
1348   3      //    vofDesc0.s.snid  = hal->hhalCb->snid;
1349   3          vofDesc0.s.snid  = txFrmSwDesc->frmInfo.plc.snid;
1350   3      
1351   3      
1352   3      #endif
1353   3          vofDesc0.s.dtei  = txFrmSwDesc->frmInfo.plc.dtei;
1354   3          vofDesc0.s.stei  = txFrmSwDesc->frmInfo.plc.stei;
1355   3          vofDesc0.s.plid  = txFrmSwDesc->frmInfo.plc.plid;
1356   3      
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 24  

1357   3          /* 3. Create VOF descriptor 1 */
1358   3          vofDesc1.reg     = 0;        
1359   3      
1360   3          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1361   3          {
1362   4              if (roboMode == HPGP_ROBOMD_MINI)
1363   4                 vofDesc1.sound.pbSz = HPGP_PHYBLKSIZE_136;
1364   4              else
1365   4                 vofDesc1.sound.pbSz = HPGP_PHYBLKSIZE_520;
1366   4      
1367   4      #ifdef HPGP_HAL_TEST
                      vofDesc1.sound.bdf = gHpgpHalCB.bcnDetectFlag;
              
              #else
1371   4              vofDesc1.sound.bdf  = hal->hhalCb->bcnDetectFlag;
1372   4      #endif
1373   4      
1374   4      
1375   4              vofDesc1.sound.saf  = txFrmSwDesc->frmInfo.plc.saf;
1376   4              vofDesc1.sound.scf  = txFrmSwDesc->frmInfo.plc.scf;
1377   4              vofDesc1.sound.flAvLo = flAv & PKTQDESCVF2_FRMLENAVLO_MASK;
1378   4              vofDesc1.sound.flAvHi = (flAv & PKTQDESCVF2_FRMLENAVHI_MASK) >>
1379   4              PKTQDESCVF2_FRMLENAVHI_POS;
1380   4      
1381   4              vofDesc1.sound.ppb   = txFrmSwDesc->frmInfo.plc.phyPendBlks;       
1382   4      
1383   4          }
1384   3          else  //SOF packet
1385   3          {
1386   4      #if 1 //For RTS/CTS Tx Test
1387   4             if (txFrmSwDesc->frmInfo.plc.dt_av == HPGP_DTAV_RTS_CTS)
1388   4              vofDesc1.sof.cfs = 0;
1389   4           
1390   4           // No RTS/CTS Flag in SOF VOF1 Descriptor  
1391   4      #endif
1392   4        
1393   4      #ifdef HPGP_HAL_TEST
                      vofDesc1.sof.bdf = gHpgpHalCB.bcnDetectFlag;
              
              #else
1397   4              vofDesc1.sof.bdf  = hal->hhalCb->bcnDetectFlag;
1398   4      #endif
1399   4              vofDesc1.sof.eks  = txFrmSwDesc->frmInfo.plc.eks;
1400   4              vofDesc1.sof.pbSz = (roboMode == HPGP_ROBOMD_MINI) ?
1401   4              HPGP_PHYBLKSIZE_136 : HPGP_PHYBLKSIZE_520;
1402   4              //pktQDescVF1.s.numSym    = // - tbd    
1403   4      #ifdef QCA
                      vofDesc1.sof.numSym = 3;
                      vofDesc1.sof.ble = 0x39;
              #endif
1407   4      
1408   4              // Set Pb Size in frame control.  
1409   4        //      txFrmSwDesc->frmInfo.plc.phyPendBlks;
1410   4      #if 1        
1411   4          //for DBC Test, if MCF bit = 1, ppb field should be set to 0xFF
1412   4          if (txFrmSwDesc->frmInfo.plc.plid == 0)
1413   4            vofDesc1.sof.ppb        = 0xDF;
1414   4          else
1415   4                vofDesc1.sof.ppb        = 0xEF; 
1416   4      #endif    
1417   4           
1418   4          
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 25  

1419   4              // tmiAv value is same as roboMode value  
1420   4              vofDesc1.sof.tmiAV      = roboMode; 
1421   4          }
1422   3      #ifdef ETH_BRDG_DEBUG
                if (myDebugFlag)
                    printf("vofDesc1.sof.tmiAV = roboMode =0x%bu, pbsize = 0x%bu, ppb = 0x%bu\n", vofDesc1.sof.tmiAV, vof
             -Desc1.sof.bdf, vofDesc1.sof.ppb);
              #endif
1426   3      
1427   3      
1428   3          /* 4. Create VOF descriptor 2 */
1429   3          vofDesc2.reg     = 0;
1430   3      
1431   3          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1432   3          {
1433   4              switch (txFrmSwDesc->frmInfo.plc.src)
1434   4              {
1435   5                  case 0:
1436   5                      vofDesc2.s1.sndRsnCd = HPGP_SRC_TONE_MAP_ERROR;
1437   5                      break; 
1438   5                  case 1:
1439   5                      vofDesc2.s1.sndRsnCd = HPGP_SRC_NO_AC_LINE_TM;
1440   5                      break; 
1441   5                  case 2:
1442   5                  default:
1443   5                      vofDesc2.s1.sndRsnCd = HPGP_SRC_UNUSABLE_INTERVAL;
1444   5                      break; 
1445   5              }
1446   4          }   
1447   3          else
1448   3          {
1449   4      
1450   4              vofDesc2.s.clst  = txFrmSwDesc->frmInfo.plc.clst;
1451   4      
1452   4              vofDesc2.s.flAvLo = flAv & PKTQDESCVF2_FRMLENAVLO_MASK;
1453   4              vofDesc2.s.flAvHi = (flAv  & PKTQDESCVF2_FRMLENAVHI_MASK) >>
1454   4                                            PKTQDESCVF2_FRMLENAVHI_POS;
1455   4      
1456   4              // Set MCST & MNBCST
1457   4              if(txFrmSwDesc->frmInfo.plc.mcstMode  == HPGP_MNBCST)
1458   4              {
1459   5                  vofDesc2.s.mnbf   = 1;
1460   5                  vofDesc2.s.mcf    = 1;
1461   5              }
1462   4              else if(txFrmSwDesc->frmInfo.plc.mcstMode  == HPGP_MCST)
1463   4              {
1464   5                  vofDesc2.s.mcf    = 1;
1465   5              }
1466   4              // Set mfsCmdData or mfsCmdMgmt
1467   4              mfsCmd =  (vofDesc2.s.mcf ? HPGP_MFSCMD_NOP : HPGP_MFSCMD_INIT);     
1468   4              if(txfrmHwDesc.sof.frmType == HPGP_HW_FRMTYPE_MSDU)
1469   4              {
1470   5                  vofDesc2.s.mfsCmdData =  mfsCmd;
1471   5              }
1472   4              else if(txfrmHwDesc.sof.frmType == HPGP_HW_FRMTYPE_MGMT)
1473   4              {
1474   5                  vofDesc2.s.mfsCmdMgmt =  mfsCmd;
1475   5              }
1476   4      #ifdef QCA
                      vofDesc2.s.mfsCmdData =  HPGP_MFSCMD_NOP;
              
              //    vofDesc2.s.mfsCmdMgmt =  HPGP_MFSCMD_NOP;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 26  

              
              #endif
1482   4          }
1483   3      
1484   3          /* Set mfsCmdData or mfsCmdMgmt */
1485   3      
1486   3          /* 5. Create VOF descriptor 3 */
1487   3          /* MMQF and PHY side band info */
1488   3          vofDesc3.reg = 0;
1489   3          
1490   3          vofDesc3.s.bmSackI  = 0xF;;
1491   3          vofDesc3.s.phySdBdRoboMd = roboMode;;
1492   3          vofDesc3.s.phySdBdNumPBs = numPBs;
1493   3          if(txfrmHwDesc.sof.frmType == HPGP_HW_FRMTYPE_MGMT)
1494   3          {
1495   4              vofDesc3.s.mmqf = 1;
1496   4          }
1497   3      
1498   3      /*
1499   3          
1500   3          FM_HexDump(FM_ERROR, "PLC Write HW Spec " ,(u8*)&txfrmHwDesc, sizeof(txfrmHwDesc));
1501   3          FM_HexDump(FM_ERROR, "PLC Write vofDesc0 " ,(u8*)&vofDesc0, sizeof(vofDesc0));
1502   3          FM_HexDump(FM_ERROR, "PLC Write vofDesc1 " ,(u8*)&vofDesc1, sizeof(vofDesc1));
1503   3          FM_HexDump(FM_ERROR, "PLC Write vofDesc2 " ,(u8*)&vofDesc2, sizeof(vofDesc2));
1504   3           FM_HexDump(FM_ERROR, "PLC Write vofDesc3 " ,(u8*)&vofDesc3, sizeof(vofDesc3));
1505   3      
1506   3      */
1507   3      
1508   3          //FM_Printf(FM_MINFO, "TxQWrite:2\n");
1509   3      
1510   3          /* 6. Write first descriptor to the queue */
1511   3          //WriteU32Reg(PLC_CAP_REG, ctorl(txFrmSwDesc->frmInfo.plc.plid));
1512   3          // [YM] check CAP queue status before push more test packet in to PLC CAP queue
1513   3          
1514   3      
1515   3          if (txFrmSwDesc->frmInfo.plc.plid == 0)
1516   3        {
1517   4        //printf("txFrmSwDesc->frmInfo.plc.plid is %bu\n", txFrmSwDesc->frmInfo.plc.plid);
1518   4          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG);
1519   4        //printf("assigned 1 to CapRdy\n");
1520   4        }
1521   3        else if (txFrmSwDesc->frmInfo.plc.plid == 1)
1522   3        {
1523   4          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+1);
1524   4        //printf("assigned 2 to CapRdy\n");
1525   4        }
1526   3        else if (txFrmSwDesc->frmInfo.plc.plid == 2)
1527   3        {
1528   4          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+2);
1529   4        //printf("assigned 4 to CapRdy\n");
1530   4        }
1531   3        else if (txFrmSwDesc->frmInfo.plc.plid == 3)
1532   3        {
1533   4          CapQueueStatus = ReadU8Reg(PLC_QDSTATUS_REG+3);
1534   4        //printf("assigned 8 to CapRdy\n");
1535   4        }
1536   3        //else printf("nothing\n");
1537   3          if ((PLC_TXQ_DEPTH - CapQueueStatus)< PLC_TX_DESC_QUEUE_TH)
1538   3          {
1539   4           //   printf("\n2:NOT enough descriptor space for next packet\n");
1540   4        //  printf("\n2:PLC_Queue_Descriptor_Status = %lx\n", ReadU32Reg(PLC_QDSTATUS_REG));
1541   4          status = STATUS_FAILURE;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 27  

1542   4          }
1543   3          else
1544   3          {
1545   4            IRQ_DISABLE_INTERRUPT();
1546   4              WriteU32Reg(PLC_CAP_REG, cap_write.reg);
1547   4          IRQ_ENABLE_INTERRUPT();
1548   4      #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                  {
                        printf("PLC_CAP_W = %lx\n",cap_write.reg);
                        printf("PLC_Queue_Descriptor_Status = %lx\n", ReadU32Reg(PLC_QDSTATUS_REG));
                  }
              #endif
1555   4        IRQ_DISABLE_INTERRUPT();
1556   4          WriteU32Reg(PLC_QUEUEDATA_REG, txfrmHwDesc.reg);
1557   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1558   4      
1559   4          /* Write HP10 FC to the queue */
1560   4          WriteU32Reg(PLC_QUEUEDATA_REG, gHpgpHalCB.plcTx10FC.reg);
1561   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1562   4      
1563   4          /* Write VOF descriptor 0 to the queue */
1564   4          WriteU32Reg(PLC_QUEUEDATA_REG, vofDesc0.reg);
1565   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1566   4      
1567   4          /* Write VOF descriptor 1 to the queue */
1568   4          WriteU32Reg(PLC_QUEUEDATA_REG, vofDesc1.reg);       
1569   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1570   4      
1571   4          /* Write VOF descriptor 2 to the queue */
1572   4          WriteU32Reg(PLC_QUEUEDATA_REG, vofDesc2.reg);
1573   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1574   4      
1575   4          /* Write VOF descriptor 3 to the queue */
1576   4          WriteU32Reg(PLC_QUEUEDATA_REG, vofDesc3.reg);
1577   4          WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1578   4        IRQ_ENABLE_INTERRUPT();
1579   4      
1580   4      
1581   4      //  FM_Printf(FM_USER, "tx\n");
1582   4          
1583   4      
1584   4          //FM_Printf(FM_MINFO, "TxQWrite:3 %bu\n",txFrmSwDesc->cpCount);
1585   4      
1586   4          /* 6. Create CP Descriptors are write one by one */
1587   4          for( i=0; i<txFrmSwDesc->cpCount; i++)
1588   4          {
1589   5              txCpDesc.reg            = 0;
1590   5              txCpDesc.plc.cp         = txFrmSwDesc->cpArr[i].cp;
1591   5              txCpDesc.plc.descLenLo  = txFrmSwDesc->cpArr[i].len & PKTQDESCCP_DESCLENLO_MASK;
1592   5              txCpDesc.plc.descLenHi  = (txFrmSwDesc->cpArr[i].len & PKTQDESCCP_DESCLENHI_MASK)>> PKTQDESCCP_DES
             -CLENHI_POS;
1593   5      
1594   5              if( i == 0 )
1595   5              {
1596   6                  txCpDesc.plc.roboMd = roboMode;
1597   6              }
1598   5              if( i == txFrmSwDesc->cpCount-1 )
1599   5              {
1600   6                  txCpDesc.plc.lastDesc = 1;
1601   6              }
1602   5              txCpDesc.plc.offset = txFrmSwDesc->cpArr[i].offsetU32;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 28  

1603   5          IRQ_DISABLE_INTERRUPT();
1604   5              /* Write CP descriptor to the queue */
1605   5              WriteU32Reg(PLC_QUEUEDATA_REG, txCpDesc.reg);         
1606   5              WriteU32Reg(PLC_QUEUEWRITE_REG ,1);
1607   5              //FM_Printf(FM_LINFO,"CPn  = %lX\n",rtocl(txCpDesc.reg)); 
1608   5          IRQ_ENABLE_INTERRUPT();
1609   5          }
1610   4          //FM_Printf(FM_MINFO, "TxQWrite:4\n");
1611   4      #if 0
                  printf("Desc1= %lX\n",rtocl(txfrmHwDesc.reg));
                  printf("HP10FCDesc = %08lX\n",rtocl(gHpgpHalCB.plcTx10FC.reg));
                  printf("VF0  = %lX\n",rtocl(vofDesc0.reg));
                  printf("VF1  = %lX\n",rtocl(vofDesc1.reg));
                  printf("VF2  = %lX\n",rtocl(vofDesc2.reg));
                  printf("VF3  = %lX\n",rtocl(vofDesc3.reg));
              #endif  
1619   4      /*
1620   4          FM_Printf(FM_LINFO,"Desc1= %lX\n",rtocl(txfrmHwDesc.reg));
1621   4          //FM_Printf(FM_LINFO," HP10FCDesc = %08lX\n",rtocl(gHpgpHalCB.plcTx10FC.reg));
1622   4          FM_Printf(FM_LINFO,"VF0  = %lX\n",rtocl(vofDesc0.reg));
1623   4          FM_Printf(FM_LINFO,"VF1  = %lX\n",rtocl(vofDesc1.reg));
1624   4          FM_Printf(FM_LINFO,"VF2  = %lX\n",rtocl(vofDesc2.reg));
1625   4          FM_Printf(FM_LINFO,"VF3  = %lX\n",rtocl(vofDesc3.reg));
1626   4      */
1627   4      
1628   4      //#ifdef Packet_grouping0
1629   4      //    if (gHpgpHalCB.plcMultiPktTest <= 1)  //[YM] multiple packet grouping is not supported in Hybrii_B
1630   4      //#endif    
1631   4          {
1632   5      
1633   5          /* 7. Write PLC Command Queue Write Register to trigger HW Tx */
1634   5          txCmdQueueWrtie.reg = 0;
1635   5          txCmdQueueWrtie.s.txQ = txfrmHwDesc.sof.cap;
1636   5        txCmdQueueWrtie.s.txCap = txfrmHwDesc.sof.cap;
1637   5        txCmdQueueWrtie.s.txRobo = roboMode;
1638   5        //printf("txCmdQueueWrtie.s.txQ = %bu\n", txCmdQueueWrtie.s.txQ);
1639   5        //printf("txCmdQueueWrtie.s.txCap = %bu\n", txCmdQueueWrtie.s.txCap);
1640   5        //printf("txCmdQueueWrtie.s.txRobo = %bu\n", txCmdQueueWrtie.s.txRobo);
1641   5        IRQ_DISABLE_INTERRUPT();
1642   5        WriteU32Reg(PLC_CMDQ_REG, txCmdQueueWrtie.reg);
1643   5        IRQ_ENABLE_INTERRUPT();
1644   5      #ifdef ETH_BRDG_DEBUG
                if (myDebugFlag)
                    printf("txCmdQueueWrtie.reg = %lx\n",txCmdQueueWrtie.reg);
              #endif
1648   5          }
1649   4        
1650   4          val_32 =  ReadU32Reg(0xEF0);
1651   4          //printf("REG 0xEF0 = 0X%lx\n", val_32);
1652   4          val_32 =  ReadU32Reg(0xEF4);
1653   4          //printf("REG 0xEF4 = 0X%lx\n", val_32);
1654   4      
1655   4      #ifdef DEBUG_DATAPATH
1656   4          
1657   4              if (pktDbg || sigDbg)
1658   4                  FM_Printf(FM_ERROR,"p tx \n");
1659   4              
1660   4              if (pktDbg)
1661   4              {
1662   5                  for (i=0 ; i<txFrmSwDesc->cpCount ; i++)
1663   5                  {
1664   6                      u8 j; 
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 29  

1665   6                      u8 byteOffset = (u8)txFrmSwDesc->cpArr[i].offsetU32<< 2;                 
1666   6                      volatile u8 xdata * cellAddr = CHAL_GetAccessToCP(txFrmSwDesc->cpArr[i].cp);
1667   6                      for (j=byteOffset; j < (byteOffset+txFrmSwDesc->cpArr[i].len); j++)
1668   6                      {
1669   7                          FM_Printf(FM_ERROR,"0x%02bX ", cellAddr[j]);
1670   7                      }
1671   6                      FM_Printf(FM_ERROR,"\n");
1672   6                  }             
1673   5          
1674   5                  FM_Printf(FM_ERROR,"\n end \n");
1675   5              }
1676   4          
1677   4      #endif
1678   4      
1679   4      
1680   4      
1681   4      
1682   4          // Trigger Tx if Status is success
1683   4          if(status == STATUS_SUCCESS)
1684   4          {
1685   5          // Recovery for CRS stuck case - if RxEn goes low during early phyActive.
1686   5          plcStatus.s.crsBypass = 1;
1687   5      
1688   5          // Check Tx window again and  Trigger Tx.
1689   5          plcStatus.s.plcTxQRdy = 1;   
1690   5      /*     
1691   5          if (txFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
1692   5          {
1693   5               plcStatus.s.soundEnable = 1;
1694   5          }
1695   5      */
1696   5      #ifdef DEBUG_DATAPATH
1697   5      
1698   5          if (sigDbg)
1699   5              FM_Printf(FM_ERROR,"plc txRdySet \n");
1700   5          
1701   5      #endif
1702   5      
1703   5      #ifdef _AES_SW_
                  plcStatus.s.aesReset  = 0;
              #endif
1706   5      IRQ_DISABLE_INTERRUPT();
1707   5          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1708   5          plcStatus.s.crsBypass = 0;
1709   5      
1710   5          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1711   5      IRQ_ENABLE_INTERRUPT();
1712   5          //gHpgpHalCB.halStats.TotalTxFrmCnt++;
1713   5         
1714   5          /*******Critical Section Ends **********/
1715   5      
1716   5      #if PLC_PAYLOAD_DBGPRINT
                  for (i=0 ; i<txFrmSwDesc->cpCount ; i++)
                  {
                      u8 j; 
                      u8 byteOffset = (u8)txFrmSwDesc->cpArr[i].offsetU32<< 2;                 
                      volatile u8 xdata * cellAddr = CHAL_GetAccessToCP(txFrmSwDesc->cpArr[i].cp);
              
                      FM_Printf(FM_ERROR,"PktBuf%bu :\n", i+1);
                      for (j=byteOffset; j < (byteOffset+txFrmSwDesc->cpArr[i].len); j++)
                      {
                          FM_Printf(FM_ERROR,"0x%02bX ", cellAddr[j]);
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 30  

                      }
                      FM_Printf(FM_ERROR,"\n");
                  }             
                  
                  FM_Printf(FM_ERROR,"\n");
              #endif
1733   5          }
1734   4          }
1735   3          if(status == STATUS_SUCCESS || status == STATUS_DEFERRED)
1736   3          {
1737   4      
1738   4      #ifdef ETH_BRDG_DEBUG
                  if(status == STATUS_SUCCESS)
                  {
                    numTxFrms++;
                    if (myDebugFlag)
                      printf("PLCTXQWRITE: SUCCESS\n");
                  }
              #endif
1746   4              status = STATUS_SUCCESS;
1747   4              gHpgpHalCB.halStats.TotalTxFrmCnt++;
1748   4              // update statistics
1749   4              gHpgpHalCB.halStats.TotalTxBytesCnt+=txFrmSwDesc->frmLen;
1750   4              if(txfrmHwDesc.sof.frmType == HPGP_HW_FRMTYPE_MGMT)
1751   4              {
1752   5                  gHpgpHalCB.halStats.TxMgmtCnt++;     
1753   5              }
1754   4              else
1755   4              {
1756   5                  gHpgpHalCB.halStats.TxDataCnt++;
1757   5              }
1758   4      
1759   4          }                           
1760   3          //FM_Printf(FM_MINFO, "<<<TxQWrite:\n");                 
1761   3          }
1762   2          }
1763   1          return status;
1764   1      
1765   1      }
1766          
1767          
1768          void HHAL_Bcn3SentIntHandler()
1769          {
1770   1          gHpgpHalCB.halStats.BcnSentIntCnt++;
1771   1          gHpgpHalCB.bBcnNotSent = 0;
1772   1      }
1773          
1774          void HHAL_PlcPendingTx()
1775          {
1776   1      //    uBcnStatusReg         bcnStatus;
1777   1      //    uPlcStatusReg         plcStatus;
1778   1      //    uPlcMedStatReg        plcMedStat;
1779   1          //uCpuSwStatusReg       cpuSwStat;  //[YM] redefine software structure
1780   1      //    uPlcLineControlReg    plcLineCtrl;  
1781   1      
1782   1      #if 0    
                  if(gHpgpHalCB.bTxPending)
                  {
                      IRQ_DISABLE_INTERRUPT();
                      bcnStatus.reg   = ReadU32Reg(PLC_BCNSTATUS_REG);
                      //cpuSwStat.reg   = ReadU32Reg(CPU_SWSTATUS_REG);     //[YM] redefine cpuSwStat structure and fiel
             -ds
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 31  

                      plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
                      plcStatus.reg   = ReadU32Reg(PLC_STATUS_REG);           
              
                  {
                      //ReadSwapU32Reg(&csmaRegAtuCtr, PLC_CSMAREGATUCTR_REG);     //[YM] Relocate register to 0xFDDC-PL
             -C Parameter Write Data Register
                      //plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
                      //plcStatus.reg   = ReadU32Reg(PLC_STATUS_REG);
                      plcMedStat.reg  = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
              #ifdef ETH_BRDG_DEBUG
                  if (myDebugFlag)
                        printf("HHAL_PlcPendingTx: phyActive=%bu,plcMacIdle=%bu, crsMac=%bu,plcMacIdle=%bu,crsMac=%bu,txW
             -indow=%bu \n",
                      plcMedStat.s.phyActive,plcStatus.s.plcMacIdle,plcMedStat.s.crsMac,plcMedStat.s.crsMac,plcMedStat.s.txW
             -indow);
              #endif
                      if (!plcMedStat.s.phyActive && plcStatus.s.plcMacIdle && 
                          !plcMedStat.s.crsMac && plcMedStat.s.txWindow )
                      //    if( !plcMedStat.s.phyActive && plcStatus.s.plcMacIdle && !plcMedStat.s.crsMac && csmaRegAtuC
             -tr > 350 )
                      {   
              #ifdef ETH_BRDG_DEBUG
                    if (myDebugFlag)
                                printf("HHAL_PlcPendingTx: Forcing recovery...\n");
              #endif
                          plcStatus.s.nRxEn = 1;
              #ifdef _AES_SW_
                          plcStatus.s.aesReset  = 1;
              #endif
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
              
                          // Recovery for CRS stuck case - if RxEn goes low during early phyActive.
                          plcStatus.s.crsBypass = 1;
                      
                          // Trigger Tx.
                          plcStatus.s.plcTxQRdy = 1;
              
              #ifdef DEBUG_DATAPATH
              
                          if (sigDbg)
                              FM_Printf(FM_ERROR,"plc txRdySet \n");
              
              #endif
              
              #ifdef _AES_SW_
                          plcStatus.s.aesReset  = 0;
              #endif
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                          plcStatus.s.crsBypass = 0;
                      
                          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                          gHpgpHalCB.bTxPending = 0;
              
              
                      }
                  }
                  IRQ_ENABLE_INTERRUPT();
                  }
              #endif
1845   1      }
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 32  

1846          
1847          #ifdef Z_P_BRIDGE
              void hpgp_pkt_bridge (sCommonRxFrmSwDesc* pRxFrmDesc, u8 frmLen)
              {
                  sSwFrmDesc   plcTxFrmSwDesc;
                  sHpgpHalCB*    hhalCb;
                  u8             i;
                  u16            tmpFrmLen;
                  u8             tmpdescLen;
                  u8             wrapBit;
                  u8             indexHd;
              
                  hhalCb = &gHpgpHalCB;
              
                  memset(&plcTxFrmSwDesc, 0x00, sizeof(sSwFrmDesc));
              
                  if (datapath_IsQueueFull(PLC_DATA_QUEUE) 
                    == TRUE)
                {
                  /*
                  * Drop the frame if Q is full
                  */
                    
                          hal_common_free_frame(pRxFrmDesc);
                          return;
                      
                  }
              
                  if(frmLen < HYBRII_CELLBUF_SIZE) {
                      tmpdescLen = frmLen;
                  } else {
                      tmpdescLen = HYBRII_CELLBUF_SIZE;
                  }
                  tmpFrmLen = tmpdescLen;
              
                  plcTxFrmSwDesc.cpArr[0].offsetU32         = 0;
                  plcTxFrmSwDesc.cpArr[0].len               = tmpdescLen;
                  plcTxFrmSwDesc.cpArr[0].cp                = pRxFrmDesc->cpArr[0];
                  plcTxFrmSwDesc.cpCount                    = 1;
              
                  plcTxFrmSwDesc.frmInfo.plc.eks            = HPGP_UNENCRYPTED_EKS;
                  plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;
                  plcTxFrmSwDesc.frmInfo.plc.clst           = HPGP_CONVLYRSAPTYPE_RSV;
              
                  plcTxFrmSwDesc.frmType                    = HPGP_HW_FRMTYPE_MSDU;
                  plcTxFrmSwDesc.frmInfo.plc.dtei           = hhalCb->remoteTei;
                  plcTxFrmSwDesc.frmInfo.plc.stei           = hhalCb->selfTei;
                  plcTxFrmSwDesc.frmLen                     = frmLen;
              
                  plcTxFrmSwDesc.frmInfo.plc.plid           = 0;
                  plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
                  plcTxFrmSwDesc.frmInfo.plc.mcstMode       = HPGP_UCST; 
                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel     = 1;
              
                  plcTxFrmSwDesc.frmInfo.plc.dt_av          = HPGP_DTAV_SOF;
                  plcTxFrmSwDesc.frmInfo.plc.saf            = 1;
                  plcTxFrmSwDesc.frmInfo.plc.clst           = 1;
                  plcTxFrmSwDesc.frmInfo.plc.status         = 0;
              
                  for (i = 1 ; i < pRxFrmDesc->cpCount ; i++) {
                      if((frmLen - tmpFrmLen) > HYBRII_CELLBUF_SIZE) {
                          tmpdescLen = HYBRII_CELLBUF_SIZE;
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 33  

                      } else {
                          tmpdescLen = frmLen - tmpFrmLen;
                      }
                      plcTxFrmSwDesc.cpArr[i].offsetU32 = 0;
                      plcTxFrmSwDesc.cpArr[i].len       = (u8)tmpdescLen;
                      plcTxFrmSwDesc.cpArr[i].cp        = pRxFrmDesc->cpArr[i];
                      plcTxFrmSwDesc.cpCount++;
                      tmpFrmLen += tmpdescLen;
                  }
              
                  //HHAL_PlcPendingTx();
              
                  /*
                      * Queue the packet for later TX
                     */
              
                plcTxFrmSwDesc.txPort = pRxFrmDesc->hdrDesc.s.dstPort;
                plcTxFrmSwDesc.rxPort = pRxFrmDesc->hdrDesc.s.srcPort;
              
                fwdAgent_handleData(&plcTxFrmSwDesc);
              }
              #endif
1930          
1931          
1932          void HHAL_BPIntHandler()
1933          {
1934   1        
1935   1        uPlcMedStatReg  plcMedStat;   
1936   1          uPlcStatusReg   plcStatus;
1937   1        static u32 prevBPInt_TimerCnt;
1938   1          static u32 curBPInt_TimerCnt;
1939   1          static u8  bpInit;
1940   1          
1941   1      
1942   1        if(gHpgpHalCB.bPerAvgInitDone && gHpgpHalCB.bcnInitDone)
1943   1        {
1944   2      
1945   2      #ifdef MISS_BCN
                    gbcnsent++;
                    if((gbcnsent == 5) || (gbcnsent == 6) || (gbcnsent == 7) || (gbcnsent == 8) || (gbcnsent == 9) || (gb
             -cnsent == 10))// || (gbcnsent == 11))// || (gbcnsent == 10))
                    {
                        return;
                    }
                     if(gbcnsent == 11)
                     {
                         gbcnsent = 0;
                     } 
              #endif
1956   2              // Determine time gap between 2  consecutive HPGP BP interrupts.
1957   2            if( gHpgpHalCB.halStats.bpIntCnt )
1958   2            {
1959   3                  bpInit = 1;
1960   3            } 
1961   2            if( bpInit )
1962   2            {
1963   3                prevBPInt_TimerCnt = curBPInt_TimerCnt;
1964   3            }
1965   2            curBPInt_TimerCnt   = gHalCB.timerIntCnt;
1966   2            gHpgpHalCB.bpIntGap = curBPInt_TimerCnt - prevBPInt_TimerCnt; 
1967   2          gHpgpHalCB.halStats.bpIntCnt++;
1968   2            // Compute running average of prev 64 ZeroCrossing periods
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 34  

1969   2             // and write to Bcn Period Average register.
1970   2      
1971   2           
1972   2            // Prepare and send beacon here for now.
1973   2            // This will eventually be done by hpgp nsm module.
1974   2            //HHT_BPIntHandler();
1975   2            if( ( (gHpgpHalCB.devMode == DEV_MODE_CCO)
1976   2      #ifdef MCCO     
1977   2            ||(gHpgpHalCB.devMode == DEV_MODE_PCCO)
1978   2      
1979   2      #endif
1980   2            )&&
1981   2             gHpgpHalCB.bcnInitDone )
1982   2          {
1983   3      #ifdef HPGP_HAL_TEST
                        HHT_SendBcn(BEACON_TYPE_CENTRAL);
              #else
1986   3                if(gHpgpHalCB.lmBcn.txBitmap & (1 << BEACON_TYPE_CENTRAL))
1987   3      #endif
1988   3                {
1989   4                    HHAL_PlcBcnWrite(gHpgpHalCB.lmBcn.cBcn.bcnBuff, BEACON_TYPE_CENTRAL,
1990   4                                 gHpgpHalCB.lmBcn.cBcn.bpstoOffset);
1991   4                }
1992   3          }
1993   2      
1994   2            // PHY Active Hang workaround
1995   2            plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
1996   2            plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
1997   2            if( plcMedStat.s.phyActive && plcMedStat.s.mpiRxEn )
1998   2            {
1999   3                if(gHpgpHalCB.halStats.paRxEnHiCnt > PLC_RXPHYACT_HANG_THRES )
2000   3                {
2001   4      #ifdef _RX_RECOVERY_                        
                            plcStatus.s.nRxEn = 1;
                            WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                            CHAL_DelayTicks(5);
                            
                            plcStatus.s.plcRxEnSwCtrl  = 0;
                            WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                            plcStatus.s.plcRxEnSwCtrl  = 1;
                            WriteU32Reg(PLC_STATUS_REG, plcStatus.reg); 
              #endif             
2012   4                    gHpgpHalCB.halStats.paRxEnHiCnt = 0;   
2013   4                    gHpgpHalCB.halStats.phyActHangRstCnt++;                    
2014   4                }
2015   3                else if( gHpgpHalCB.halStats.prevBPTotalRxCnt == gHpgpHalCB.halStats.TotalRxGoodFrmCnt )
2016   3                {
2017   4                    gHpgpHalCB.halStats.paRxEnHiCnt ++;
2018   4                } 
2019   3                else
2020   3                {
2021   4                    gHpgpHalCB.halStats.paRxEnHiCnt = 0;  
2022   4                }                
2023   3            }
2024   2            gHpgpHalCB.halStats.prevBPTotalRxCnt = gHpgpHalCB.halStats.TotalRxGoodFrmCnt;
2025   2      #ifndef HPGP_HAL_TEST
2026   2      #ifdef CCO_FUNC
2027   2            LINKL_UpdateBeacon();
2028   2      #endif    
2029   2      #endif
2030   2      
C51 COMPILER V9.53.0.0   HAL_HPGPTX                                                        11/04/2015 20:09:44 PAGE 35  

2031   2      
2032   2          }
2033   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7393    ----
   CONSTANT SIZE    =     41    ----
   XDATA SIZE       =     55     185
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
