C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CTRLL
OBJECT MODULE PLACED IN .\obj\ctrll.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\src\ctrl\ctrll.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100)
                    - INCDIR(..\..\..\common\datapath;..\..\..\common\include;..\..\..\hal;..\..\src\crypto;..\..\src\ctrl;..\..\src\hal;..\.
                    -.\src\link;..\..\src\mux;..\..\src\nma;..\..\src\route;..\..\src\sap;..\..\src\test;..\..\..\project\hal\src;..\..\..\zi
                    -gbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event
                    -\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\sampleapp\src;
                    -..\..\..\..\sampleapp\inc;..\..\..\common;..\..\..\hpgp;..\..\src;..\..\..\..\components\hpgp\inc;..\..\..\app_support;.
                    -.\..\..\HybriiB_configuration_rw\src) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC
                    -,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HYBRII_ETH,HPGP_MAC_SAP,NMA,HYBRII_SPI,NEW_SYNC,UM,HYBRII_B,
                    -Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,AUTH_AES,PLC_TEST,B_ASICPLC,UART_HOST_INTF_,UART_RAW,MPER_,FREQ_DETECT,SW_RECOVERY,
                    -PROD_TEST) DEBUG PRINT(.\lst\ctrll.lst) TABS(2) OBJECT(.\obj\ctrll.obj)

line level    source

   1          /** =========================================================
   2           *
   3           *  @file ctrll.c
   4           * 
   5           *  @brief Control Layer
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * ===========================================================*/
  11          #ifdef RTX51_TINY_OS
  12          #include <rtx51tny.h>
  13          #endif
  14          #include <string.h>
  15          #include "papdef.h"
  16          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  19          #include "green.h"
  20          #include "fm.h"
  21          #include "timer.h"
  22          #include "stm.h"
  23          #include "hpgpdef.h"
  24          #include "hpgpevt.h"
  25          #include "hpgpapi.h"
  26          #include "ctrll.h"
  27          #include "frametask.h"
  28          
  29          #include "nma.h"
  30          #ifdef UM
  31          #include "mac_intf_common.h"
  32          #endif
  33          #include "hybrii_tasks.h"
  34          #include "sys_common.h"
  35          
  36          #define HPGP_TIME_DISC                 1000   //2 seconds
  37          enum {
  38              CTRL_ACC_NEW,
  39              CTRL_ACC_HO,
  40          }; 
  41          extern eStatus NMA_SendNetExitCnf(sNma *nma, u8 result);
  42          
  43          
  44          void CTRLL_TimerHandler(u16 type, void *cookie);
  45          
  46          /* post an event into the internal event queue */
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 2   

  47          eStatus CTRLL_PostEvent(sCtrlLayer *ctrlLayer, enum eventType evtType, 
  48                                  void *param)
  49          {
  50   1          sEvent * event= EVENT_Alloc(0, 0);
  51   1          if(event== NULL)
  52   1          {
  53   2              FM_Printf(FM_ERROR, "EAllocErr\n");
  54   2              return STATUS_FAILURE;
  55   2          }
  56   1      
  57   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
  58   1          event->eventHdr.type = evtType;
  59   1      
  60   1          /* enqueue the event to the internal event queue */
  61   1          SLIST_Put(&ctrlLayer->intEventQueue, &event->link);
  62   1      
  63   1          return STATUS_SUCCESS;
  64   1      }
*** WARNING C280 IN LINE 48 OF ..\..\src\ctrl\ctrll.c: 'param': unreferenced local variable
  65          
  66          
  67          
  68          eStatus CTRLL_SendEventToLinkLayer( sCtrlLayer *ctrlLayer, 
  69                      enum eventType evtType, 
  70                      void *param)
  71          {
  72   1          u16          size = 0;
  73   1          sEvent      *event = NULL;
  74   1          sAuthReq    *authreq = NULL;
  75   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
  76   1      
  77   1          if (evtType == EVENT_TYPE_AUTH_REQ)
  78   1          {
  79   2              size = sizeof(sAuthReq);
  80   2              event = EVENT_Alloc(size, EVENT_HPGP_CTRL_HEADROOM);
  81   2          }
  82   1          else
  83   1          {
  84   2              event = EVENT_Alloc(size, 0);
  85   2          }
  86   1          if(event == NULL)
  87   1          {
  88   2              FM_Printf(FM_ERROR, "EAllocErr\n");
  89   2              return STATUS_FAILURE;
  90   2          }
  91   1      
  92   1          if (evtType == EVENT_TYPE_AUTH_REQ)
  93   1          {
  94   2              authreq = (sAuthReq *)(event->buffDesc.dataptr);
  95   2              authreq->authType = AUTH_TYPE_NEK;
  96   2              event->buffDesc.datalen = sizeof(sAuthReq);
  97   2          }
  98   1          
  99   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 100   1          event->eventHdr.type = evtType;
 101   1      
 102   1          return LINKL_SendEvent(linkl, event);
 103   1      }
*** WARNING C280 IN LINE 68 OF ..\..\src\ctrl\ctrll.c: 'ctrlLayer': unreferenced local variable
*** WARNING C280 IN LINE 70 OF ..\..\src\ctrl\ctrll.c: 'param': unreferenced local variable
 104          
 105          
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 3   

 106          
 107          #ifdef STA_FUNC
 108          /* ==================================
 109           * Network Discovery Controller (NDC)
 110           * ================================== */
 111          
 112          eStatus NDC_Init(sNdc *ndc)
 113          {
 114   1      //    sCtrlLayer *ctrlLayer = (sCtrlLayer *)HOMEPLUG_GetLayer(HP_LAYER_TYPE_CTRL);
 115   1          memset(ndc, 0, sizeof(sNdc));
 116   1      //    ndc->bbtTimer = STM_AllocTimer(CTRLL_BbtTimerHandler, ctrlLayer);
 117   1      //    if(ndc->bbtTimer == STM_TIMER_INVALID_ID)
 118   1      //    {
 119   1      //        return STATUS_FAILURE;
 120   1      //    }
 121   1          ndc->state = NDC_STATE_INIT; 
 122   1          return STATUS_SUCCESS;
 123   1      
 124   1      }
 125          
 126          void NDC_Start(sNdc *ndc)
 127          {
 128   1          // If NDC restart then stop sta free cco scb
 129   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 130   1          
 131   1          LINKL_StopSta(linkLayer);    
 132   1          LINKL_SetStaMode(linkLayer);
 133   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_NETDISC);
 134   1          ndc->state = NDC_STATE_READY; 
 135   1      }
 136          
 137          
 138          
 139          
 140          
 141          eStatus NDC_SetStaRole(sCtrlLayer *ctrlLayer, u8 staRole)
 142          {
 143   1          u16 eventType;
 144   1          switch(staRole)
 145   1          {
 146   2              case STA_ROLE_USTA:
 147   2              {
 148   3                  eventType = EVENT_TYPE_USTA_IND;
 149   3                  break;
 150   3              }
 151   2              case STA_ROLE_UCCO:
 152   2              {            
 153   3                  eventType = EVENT_TYPE_UCCO_IND;
 154   3                  break;
 155   3              }
 156   2              case STA_ROLE_ACCO:
 157   2              {
 158   3                  eventType = EVENT_TYPE_ACCO_IND;
 159   3                  break;
 160   3              }
 161   2              default:
 162   2              {
 163   3                  //FM_Printf(FM_ERROR, "Unknown Sta Role.\n");
 164   3                  return STATUS_FAILURE;
 165   3              }
 166   2          }
 167   1      
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 4   

 168   1          return CTRLL_PostEvent(ctrlLayer, eventType, NULL); 
 169   1      }
 170          
 171          
 172          
 173          
 174          void NDC_ProcEvent(sNdc *ndc, sEvent *event)
 175          {
 176   1          u8          staRole = STA_ROLE_UNKNOWN;
 177   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 178   1          switch(ndc->state)
 179   1          {
 180   2              case NDC_STATE_READY:
 181   2              {
 182   3                  //process events
 183   3                  if(event->eventHdr.type == EVENT_TYPE_CCO_DISC_IND)
 184   3                  {
 185   4                      CTRLL_SendEventToLinkLayer(ctrlLayer, 
 186   4                                                 EVENT_TYPE_NET_ACC_REQ,
 187   4                                                 NULL);
 188   4      //FM_Printf(FM_ERROR, "NDC: send NET_ACC_REQ.\n");
 189   4      
 190   4                      ndc->state = NDC_STATE_WAITFOR_NET_ACC_RSP;
 191   4      
 192   4                  }
 193   3                  else if(event->eventHdr.type == EVENT_TYPE_NET_DISC_IND)
 194   3                  {
 195   4                      staRole = *(event->buffDesc.dataptr);
 196   4      
 197   4                      FM_Printf(FM_CTRL|FM_MINFO, "CTRLL: Rx NET_DISC_IND.\n");
 198   4      #ifdef P8051
 199   4                      FM_Printf(FM_CTRL|FM_MINFO, "STA Role: %bu.\n", staRole);
 200   4      #else
                              FM_Printf(FM_CTRL|FM_MINFO, "STA Role: %d.\n", staRole);
              #endif
 203   4                      
 204   4                      NDC_SetStaRole(ctrlLayer, staRole); 
 205   4                      ndc->state = NDC_STATE_INIT;
 206   4                  }
 207   3                  else if(event->eventHdr.type == EVENT_TYPE_CCO_SLCT_IND)
 208   3                  {
 209   4              /* 
 210   4              * receive a CCO_SLCT_IND event, which indicates 
 211   4              * that the device will become the CCO.
 212   4              */
 213   4                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 214   4                      ndc->state = NDC_STATE_INIT;
 215   4                  }
 216   3                  
 217   3                  break;
 218   3              }
 219   2              case NDC_STATE_WAITFOR_NET_ACC_RSP:
 220   2              {
 221   3                  /* process events (Note: BTT timer has been stopped) */
 222   3                  if(event->eventHdr.type == EVENT_TYPE_NET_ACC_RSP)
 223   3                  {
 224   4                      if(*(event->buffDesc.dataptr) == 0)
 225   4                      {
 226   5                          /* the assocation is successful */
 227   5                          CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL); 
 228   5                          ndc->state = NDC_STATE_INIT;
 229   5                      }
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 5   

 230   4                      else 
 231   4                      {
 232   5      
 233   5                          /* start the network discovery */
 234   5                          NDC_Start(ndc);
 235   5                          ndc->restart += 1;
 236   5                          if(ndc->restart > 6)
 237   5                          {
 238   6                              //TODO: call the NMA to alert the user
 239   6                          }
 240   5                      }
 241   4                  }
 242   3                  break;
 243   3              }
 244   2              default:
 245   2              {
 246   3                  //perform no operation
 247   3              }
 248   2          }
 249   1      }
 250          
 251          
 252          
 253          /* ===================================
 254           *  Unassociated STA Controller (USC)    
 255           * =================================== */
 256          
 257          eStatus USC_Init(sUsc *usc)
 258          {
 259   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 260   1          memset(usc, 0, sizeof(sUsc));
 261   1      #ifdef CALLBACK
                  usc->discTimer = STM_AllocTimer(CTRLL_TimerHandler, 
                                       EVENT_TYPE_TIMER_DISC_IND, ctrlLayer);
              #else
 265   1          usc->discTimer = STM_AllocTimer(HP_LAYER_TYPE_CTRL, 
 266   1                               EVENT_TYPE_TIMER_DISC_IND, ctrlLayer);
 267   1          FM_Printf(FM_MINFO,"CTRL: Starting EVENT_TYPE_TIMER_DISC_IND\n");
 268   1      #endif
 269   1      
 270   1          if(usc->discTimer == STM_TIMER_INVALID_ID)
 271   1          {
 272   2              return STATUS_FAILURE;
 273   2          }
 274   1      
 275   1          usc->state = USC_STATE_INIT; 
 276   1          usc->maxDiscoverPeriod = HPGP_TIME_DISC;
 277   1          return STATUS_SUCCESS;
 278   1      }
 279          
 280          
 281          
 282          void USC_Start(sUsc *usc)
 283          {
 284   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);    
 285   1      
 286   1          LINKL_StopSta(linkLayer);    
 287   1          LINKL_SetStaMode(linkLayer);
 288   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_UNASSOC);
 289   1          STM_StartTimer(usc->discTimer, usc->maxDiscoverPeriod);
 290   1          usc->state = USC_STATE_READY; 
 291   1      }
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 6   

 292          
 293          
 294          
 295          
 296          void USC_Stop(sUsc *usc)
 297          {
 298   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 299   1      
 300   1          STM_StopTimer(usc->discTimer);
 301   1          LINKL_StopSta(linkLayer);
 302   1          usc->state = USC_STATE_INIT;
 303   1      }
 304          
 305          
 306          
 307          
 308          void  USC_ProcReadyState(sUsc *usc, sEvent *event)
 309          {
 310   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 311   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 312   1          sNma       *nma = HOMEPLUG_GetNma(); 
 313   1      
 314   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 315   1          
 316   1          switch(event->eventHdr.type)
 317   1          {
 318   2              case EVENT_TYPE_CCO_DISC_IND:
 319   2                  /* 
 320   2                   * receive a CCO_DISC_IND event, which indicates 
 321   2                   * that the CCO is discovered. Thus, associate the network 
 322   2                   */
 323   2                  FM_Printf(FM_CTRL|FM_MINFO, "USC: CCO_DISC_IND event\n");
 324   2      
 325   2                  STM_StopTimer(usc->discTimer);
 326   2                  if (CTRLL_SendEventToLinkLayer(ctrlLayer,EVENT_TYPE_NET_ACC_REQ, 
 327   2                          NULL) ==  STATUS_SUCCESS)
 328   2                  {
 329   3                      /* stop the discover timer for simplicity */
 330   3                      FM_Printf(FM_CTRL|FM_MINFO, "USC: Wait for ACC Rsp\n");
 331   3                      usc->state = USC_STATE_WAITFOR_NET_ACC_RSP;
 332   3                  }
 333   2                  else
 334   2                  {
 335   3                      /* restart for retrigger */
 336   3                      USC_Start(usc);
 337   3                      /* stay in the ready state */
 338   3                  }
 339   2                  break;
 340   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
                      {            
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_JOIN);
               
                          break;
                      }
              #endif
 348   2              case EVENT_TYPE_TIMER_DISC_IND:
 349   2                  if (LINKL_QueryAnyAlvn(linkLayer))
 350   2                  {
 351   3      #ifdef CCO_FUNC
 352   3                      /* There is an other AVLN */
 353   3                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_UCCO_IND, NULL);
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 7   

 354   3                      usc->state = USC_STATE_INIT;
 355   3      #endif
 356   3                  }
 357   2                  else
 358   2                  {
 359   3                      STM_StartTimer(usc->discTimer, usc->maxDiscoverPeriod);
 360   3                      /* stay in the ready state */
 361   3                  }
 362   2                  break;
 363   2              case EVENT_TYPE_CCO_SLCT_IND:
 364   2                  /* 
 365   2                   * receive a CCO_SLCT_IND event, which indicates 
 366   2                   * that the device will become the CCO after net discovery
 367   2                   */
 368   2                  STM_StopTimer(usc->discTimer);
 369   2                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 370   2                  usc->state = USC_STATE_INIT;
 371   2                  break;
 372   2              case EVENT_TYPE_NET_EXIT_REQ:
 373   2          case EVENT_TYPE_RESTART_REQ:
 374   2                  USC_Stop(usc);
 375   2      
 376   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 377   2            {       
 378   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 379   3            }
 380   2            else
 381   2            {
 382   3      #ifdef NMA
 383   3              /* respond to the NMA */
 384   3              NMA_SendNetExitCnf(nma, 0);   /* success result */
 385   3      #endif
 386   3              mctrl->nextState = MCTRL_STATE_INIT;
 387   3            
 388   3            }
 389   2            
 390   2            /* send a NET EXIT IND to the MCTRL */
 391   2            CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 392   2            usc->state = UCC_STATE_INIT;
 393   2      
 394   2                  break;
 395   2      
 396   2                  case EVENT_TYPE_AUTH_IND:
 397   2                  {
 398   3                      sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;               
 399   3                                                      
 400   3                      if(pAuthInd->keyType == KEY_TYPE_NEK)
 401   3                      {
 402   4                          FM_Printf(FM_HINFO,"GOT NEK\n");
 403   4                      }
 404   3                      else
 405   3                      {
 406   4                          FM_Printf(FM_HINFO,"GOT NMK\n");
 407   4                       
 408   4                      }
 409   3      
 410   3                      break;
 411   3      
 412   3                  }
 413   2      
 414   2              default:
 415   2              {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 8   

 416   3                  /* ignore all other events */
 417   3                  FM_Printf(FM_ERROR, " USC: Unexpected event!\n");
 418   3              }
 419   2          }
 420   1      }
 421          
 422          
 423          
 424          void USC_ProcEvent(sUsc *usc, sEvent *event)
 425          {
 426   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 427   1          switch(usc->state)
 428   1          {
 429   2              case USC_STATE_READY:
 430   2              {
 431   3                  USC_ProcReadyState(usc, event);
 432   3                  break;
 433   3              }
 434   2              case USC_STATE_WAITFOR_NET_ACC_RSP:
 435   2              {
 436   3                  //process events
 437   3                  if(event->eventHdr.type == EVENT_TYPE_NET_ACC_RSP)
 438   3                  {
 439   4                      if(*(event->buffDesc.dataptr) == 0)
 440   4                      {
 441   5                          FM_Printf(FM_CTRL|FM_MINFO, " USC: receive an NET_ACC_RSP\n");  
 442   5                         /* success */
 443   5                          CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL); 
 444   5                          usc->state = USC_STATE_INIT;
 445   5                      }
 446   4                      else
 447   4                      {
 448   5                          /* restart for retrigger */
 449   5                          USC_Start(usc);
 450   5                      }
 451   4                  }
 452   3                  else
 453   3                  {
 454   4                      /* ignore all other events */
 455   4                      FM_Printf(FM_ERROR, " USC: Unexpected event (%d)!\n", event->eventHdr.type);
 456   4                  }
 457   3                  break;
 458   3              }
 459   2              default:
 460   2              {
 461   3                  //perform no operation
 462   3              }
 463   2          }
 464   1      }
 465          
 466          #endif /* STA_FUNC */
 467          
 468          
 469          #ifdef CCO_FUNC
 470          /* =================================
 471           * Unassociated CCO Controller (UCC)
 472           * ================================= */
 473          
 474          eStatus UCC_Init(sUcc *ucc)
 475          {
 476   1          memset(ucc, 0, sizeof(sUcc));
 477   1          ucc->state = UCC_STATE_INIT; 
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 9   

 478   1          return STATUS_SUCCESS;
 479   1      }
 480          
 481          void UCC_Start(sUcc *ucc)
 482          {
 483   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 484   1          LINKL_SetBcnInit();
 485   1          LINKL_SetCcoMode(linkLayer);
 486   1          LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_UNASSOC);
 487   1          ucc->state = UCC_STATE_READY; 
 488   1      }
 489          
 490          void UCC_ProcEvent(sUcc *ucc, sEvent *event)
 491          {
 492   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 493   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 494   1          sNma       *nma = HOMEPLUG_GetNma(); 
 495   1      
 496   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 497   1          
 498   1      
 499   1      
 500   1          if(ucc->state != UCC_STATE_READY)
 501   1              return;
 502   1      
 503   1          switch(event->eventHdr.type)
 504   1          {
 505   2      #if 0    
                      case EVENT_TYPE_NET_DISC_IND:
                      {
                          //other AVLN is found
                          LINKL_StopCco(linkLayer);
                    mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
                   
                          ucc->state = UCC_STATE_INIT;
                          break;
                      }
              #endif    
 516   2              case EVENT_TYPE_NET_ACC_IND:
 517   2              {
 518   3                  /* Some STA has associated with the CCo */
 519   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 520   3                  ucc->state = UCC_STATE_INIT;
 521   3                  break;
 522   3              }
 523   2          case EVENT_TYPE_NET_DISC_IND:
 524   2          case EVENT_TYPE_NCO_IND:  //test
 525   2          {
 526   3            
 527   3            LINKL_StopCco(linkLayer);   
 528   3            ucc->state = UCC_STATE_INIT;      
 529   3      
 530   3            if (event->eventHdr.type == EVENT_TYPE_NCO_IND)
 531   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 532   3            else
 533   3              mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
 534   3              
 535   3              
 536   3              break;
 537   3          } 
 538   2              case EVENT_TYPE_AUTH_IND:
 539   2              {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 10  

 540   3      
 541   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
 542   3      
 543   3                 /*
 544   3      
 545   3                              Here, we notify Host of Authentication event
 546   3                 */
 547   3                          
 548   3                                                  
 549   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
 550   3                  {
 551   4                      FM_Printf(FM_HINFO, "Sent NEK\n");
 552   4                  }
 553   3                  else
 554   3                  {
 555   4                      FM_Printf(FM_HINFO, "Sent NMK\n");
 556   4                  }
 557   3      
 558   3              }
 559   2              break;
 560   2      #ifdef UKE    
                      case EVENT_TYPE_SET_SEC_MODE:
                      {
              
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
              
                                      
                          break;
                      }
              #endif    
 570   2              case EVENT_TYPE_NET_EXIT_REQ:
 571   2              case EVENT_TYPE_RESTART_REQ:    
 572   2            
 573   2            LINKL_StopCco(linkLayer);
 574   2            
 575   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 576   2            {       
 577   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 578   3            }
 579   2            else
 580   2            {
 581   3              mctrl->nextState = MCTRL_STATE_INIT;
 582   3      #ifdef NMA
 583   3                    /* respond to the NMA */
 584   3                    NMA_SendNetExitCnf(nma, 0);   /* success result */
 585   3      #endif    
 586   3      
 587   3            }
 588   2            
 589   2                ucc->state = UCC_STATE_INIT;
 590   2                break;
 591   2          
 592   2              default:
 593   2              {
 594   3              }
 595   2          }
 596   1      }
 597          
 598          #endif /* CCO_FUNC */
 599          
 600          
 601          #ifdef STA_FUNC
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 11  

 602          /* ================================
 603           * Associated STA Controller (ASC)
 604           * ================================ */
 605          
 606          eStatus ASC_Init(sAsc *asc)
 607          {
 608   1          memset(asc, 0, sizeof(sAsc));
 609   1          asc->state = ASC_STATE_INIT; 
 610   1          return STATUS_SUCCESS;
 611   1      }
 612          
 613          
 614          
 615          
 616          void ASC_Start(sAsc *asc, u8 auth)
 617          {
 618   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 619   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 620   1          
 621   1          LINKL_SetStaMode(linkLayer);
 622   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_ASSOC);
 623   1          asc->state = ASC_STATE_READY; 
 624   1      
 625   1          if(auth == 1)
 626   1          {
 627   2              CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, NULL);
 628   2          }
 629   1      #ifdef P8051
 630   1          FM_Printf(FM_CTRL|FM_MINFO, "ASC: start. (%bu)\n", auth);
 631   1      #else
                  FM_Printf(FM_CTRL|FM_MINFO, "ASC: start. (%d)\n", auth);
              #endif
 634   1      }
 635          
 636          void ASC_ProcEvent(sAsc *asc, sEvent *event)
 637          {
 638   1          sNetLeaveIndEvent  *netLeaveInd = NULL;
 639   1          sCcoLostIndEvent   *ccoLostInd =  NULL;
 640   1          sNma       *nma = HOMEPLUG_GetNma(); 
 641   1      
 642   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 643   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 644   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 645   1        
 646   1      
 647   1          if(asc->state != ASC_STATE_READY)
 648   1              return;
 649   1      
 650   1          switch(event->eventHdr.type)
 651   1          {
 652   2              case EVENT_TYPE_CCO_HO_IND:
 653   2              {
 654   3                  // become the CCo. Send EVENT_TYPE_ACCO_IND to Main Controller
 655   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 656   3                  asc->state = ASC_STATE_INIT;
 657   3                  break;
 658   3              }
 659   2              case EVENT_TYPE_NET_LEAVE_IND:
 660   2              {
 661   3                  netLeaveInd = (sNetLeaveIndEvent *)event->buffDesc.dataptr;       
 662   3                  //TODO: call the NMA API to notify the user
 663   3                  
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 12  

 664   3                  // Send EVENT_TYPE_USTA_IND to Main Controller
 665   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL); 
 666   3                  asc->state = ASC_STATE_INIT;
 667   3                  break;
 668   3              }
 669   2              case EVENT_TYPE_CCO_LOST_IND:
 670   2              {
 671   3                  ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;       
 672   3                  if(ccoLostInd->reason == 0) //really lost
 673   3                  {
 674   4                      //restart the network discovery
 675   4                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_RESTART_IND, NULL); 
 676   4                      asc->state = ASC_STATE_INIT;
 677   4                  }
 678   3                  else //become the CCo due to backup
 679   3                  {
 680   4                      
 681   4                      // Send EVENT_TYPE_ACCO_IND to Main Controller
 682   4                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL);
 683   4                      asc->state = ASC_STATE_INIT;
 684   4                  }
 685   3                  break;
 686   3              }
 687   2      #if 0   
                      case EVENT_TYPE_SET_NETWORK_REQ:
                      {
                          if(*(event->buffDesc.dataptr) != NETWORK_LEAVE)
                          {
                              break;
                          }
                      }
              #endif
 696   2      
 697   2              case EVENT_TYPE_NET_EXIT_REQ:
 698   2          case EVENT_TYPE_RESTART_REQ:
 699   2      
 700   2                  CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_LEAVE_REQ, 
 701   2                                             NULL);
 702   2            
 703   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 704   2            {       
 705   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 706   3            }
 707   2            else
 708   2            {
 709   3              mctrl->nextState = MCTRL_STATE_INIT;
 710   3            }
 711   2            
 712   2                  /* stay in the same state to wait for a response */
 713   2                  break;
 714   2              case EVENT_TYPE_NET_LEAVE_RSP:
 715   2                  LINKL_StopSta(linkLayer);
 716   2      #ifdef NMA
 717   2                  /* respond to the NMA */
 718   2                  NMA_SendNetExitCnf(nma, STATUS_SUCCESS);   /* success result */
 719   2      #endif
 720   2                  /* send a NET EXIT IND to the MCTRL */
 721   2                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);   
 722   2                  asc->state = ASC_STATE_INIT;
 723   2                  break;
 724   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 13  

                      {
                         
                           LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
                          
                          break;
                      }
              #endif
 733   2              case EVENT_TYPE_AUTH_IND:
 734   2              {
 735   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
 736   3      
 737   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
 738   3                  {
 739   4                      FM_Printf(FM_ERROR,"GOT NEK\n");
 740   4              Host_SendIndication(HOST_EVENT_AUTH_COMPLETE, NULL, 0);
 741   4                  }
 742   3                  else
 743   3                  {
 744   4      #ifdef UKE                
              
                              u8 secMode = pAuthInd->secMode;
              
                              if (secMode == SEC_MODE_SC_JOIN)
                              {                   
                                  
                                  FM_Printf(FM_HINFO,"GOT NMK\n");
              
              //                    CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, 
                //                                                 linkLayer->staInfo.ccoScb);             
                                  CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, 
                                                                 NULL);
                              }
                              else
                              {
                                  FM_Printf(FM_HINFO,"SENT NMK\n");
                              }
              #endif
 763   4      
 764   4                  }
 765   3              
 766   3      
 767   3                  
 768   3                  break;
 769   3      
 770   3              }
 771   2              
 772   2              default:
 773   2              {
 774   3              }
 775   2          }
 776   1      }
 777          
 778          #endif /* STA_FUNC */
 779          
 780          
 781          #ifdef CCO_FUNC
 782          /* ===============================
 783           * Associated CCO Controller (ACC)
 784           * =============================== */
 785          
 786          eStatus ACC_Init(sAcc *acc)
 787          {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 14  

 788   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 789   1          memset(acc, 0, sizeof(sAcc));
 790   1      #ifdef CALLBACK
                  acc->joinTimer = STM_AllocTimer(CTRLL_TimerHandler, 
                                       EVENT_TYPE_TIMER_JOIN_IND, ctrlLayer);
              #else
 794   1          acc->joinTimer = STM_AllocTimer(HP_LAYER_TYPE_CTRL,
 795   1                               EVENT_TYPE_TIMER_JOIN_IND, ctrlLayer);
 796   1      #endif
 797   1          if(acc->joinTimer == STM_TIMER_INVALID_ID)
 798   1          {
 799   2              return STATUS_FAILURE;
 800   2          }
 801   1          acc->state = ACC_STATE_INIT; 
 802   1          acc->maxDiscoverPeriod = HPGP_TIME_DISC;
 803   1          return STATUS_SUCCESS;
 804   1      }
 805          
 806          void ACC_Start(sAcc *acc, u8 reason)
 807          {
 808   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 809   1      
 810   1          LINKL_SetBcnInit();
 811   1          LINKL_SetCcoMode(linkLayer);
 812   1          if (reason == CTRL_ACC_NEW)
 813   1             LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_ASSOC);
 814   1          else
 815   1             LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_HO);
 816   1          STM_StartTimer(acc->joinTimer, acc->maxDiscoverPeriod);
 817   1          acc->state = ACC_STATE_READY;
 818   1      #ifdef P8051
 819   1          FM_Printf(FM_CTRL|FM_MINFO, "ACC: start. (%bu)\n", reason);
 820   1      #else
                  FM_Printf(FM_CTRL|FM_MINFO, "ACC: start. (%d)\n", reason);
              #endif 
 823   1      }
 824          
 825          
 826          
 827          void ACC_BecomeUnassociated(sCtrlLayer *ctrlLayer)
 828          {
 829   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 830   1          
 831   1          if (LINKL_QueryAnyAlvn(linkLayer))
 832   1          {
 833   2              
 834   2              CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL);
 835   2          }
 836   1          else
 837   1          {
 838   2              CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_UCCO_IND, NULL);
 839   2          }
 840   1      }
 841          
 842          
 843          
 844          void ACC_ProcEvent(sAcc *acc, sEvent *event)
 845          {
 846   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 847   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 848   1          sNma       *nma = HOMEPLUG_GetNma(); 
 849   1      
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 15  

 850   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 851   1          
 852   1      
 853   1          if(acc->state != ACC_STATE_READY)
 854   1              return;
 855   1      
 856   1          switch(event->eventHdr.type)
 857   1          {
 858   2              case EVENT_TYPE_TIMER_ACC_IND:
 859   2              {
 860   3                  if (LINKL_QueryAnySta(linkLayer))
 861   3                  {
 862   4                      // stay here
 863   4                      acc->state = ACC_STATE_READY;
 864   4                  }
 865   3                  else
 866   3                  {
 867   4                      ACC_BecomeUnassociated(ctrlLayer);
 868   4                      acc->state = ACC_STATE_INIT;
 869   4                  }
 870   3                  break;
 871   3              }
 872   2              case EVENT_TYPE_NO_STA_IND:
 873   2              {
 874   3                  LINKL_StopCco(linkLayer);
 875   3                  acc->state = ACC_STATE_INIT;
 876   3            mctrl->nextState = MCTRL_STATE_UNASSOC_CCO;
 877   3      
 878   3                  break;
 879   3              }
 880   2              case EVENT_TYPE_AUTH_IND:
 881   2              {
 882   3      
 883   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
 884   3      
 885   3                  /*
 886   3      
 887   3                              Here, we notify Host of Authentication event
 888   3                          */
 889   3                                                  
 890   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
 891   3                  {
 892   4                      FM_Printf(FM_ERROR," SENT NEK\n");
 893   4                  }
 894   3                  else
 895   3                  {
 896   4                     
 897   4                      FM_Printf(FM_ERROR,"SENT NMK\n");
 898   4                  }
 899   3      
 900   3              }
 901   2              break;
 902   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
                      {
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
                                  
                          break;
                      }
              #endif    
 910   2              case EVENT_TYPE_CCO_HO_IND:
 911   2              {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 16  

 912   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL);
 913   3                  acc->state = ACC_STATE_INIT;
 914   3                  break;
 915   3              }
 916   2          case EVENT_TYPE_NCO_IND:
 917   2          {
 918   3            LINKL_StopCco(linkLayer);
 919   3            acc->state = ACC_STATE_INIT;      
 920   3            mctrl->nextState = MCTRL_STATE_NET_DISC;            
 921   3              
 922   3              break;
 923   3          }     
 924   2              case EVENT_TYPE_NET_EXIT_REQ:
 925   2              case EVENT_TYPE_RESTART_REQ:
 926   2      
 927   2                  LINKL_StopCco(linkLayer);     
 928   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 929   2            {       
 930   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 931   3            }
 932   2            else
 933   2            {
 934   3      #ifdef NMA
 935   3              /* respond to the NMA */
 936   3              NMA_SendNetExitCnf(nma, 0);   /* success result */
 937   3      #endif    
 938   3              mctrl->nextState = MCTRL_STATE_INIT;
 939   3            }
 940   2                  acc->state = ACC_STATE_INIT;
 941   2                  break;
 942   2              default:
 943   2              {
 944   3              }
 945   2          }
 946   1      }
 947          
 948          #endif /* CCO_FUNC */
 949          
 950          /* =========================
 951           * Main Controller (MCTRL)
 952           * ========================= */
 953          
 954          eStatus MCTRL_Init(sMctrl *mctrl)
 955          {
 956   1          memset(mctrl, 0, sizeof(sMctrl));
 957   1          mctrl->state = MCTRL_STATE_INIT;
 958   1          return STATUS_SUCCESS;
 959   1      }
 960          
 961          void MCTRL_PreProcEvent(sMctrl *mctrl, sEvent *event)
 962          {
 963   1          //set event destination transaction to MCTRL
 964   1          event->eventHdr.trans = CTRLL_TRANS_MCTRL;
 965   1      }
*** WARNING C280 IN LINE 961 OF ..\..\src\ctrl\ctrll.c: 'mctrl': unreferenced local variable
 966          
 967          bool MCTRL_IsAssociated()
 968          {
 969   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 970   1          if(ctrlLayer->mainCtrl.state == MCTRL_STATE_ASSOC_STA || ctrlLayer->mainCtrl.state == MCTRL_STATE_ASSO
             -C_CCO)
 971   1          {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 17  

 972   2              return TRUE;
 973   2          }
 974   1          return FALSE;
 975   1      }
 976          
 977          void MCTRL_ProcEvent(sMctrl *mctrl, sEvent *event)
 978          {
 979   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 980   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 981   1          sHaLayer *hal = HOMEPLUG_GetHal();
 982   1        u8 stateOld = mctrl->state;
 983   1          
 984   1          switch(mctrl->state)
 985   1          {
 986   2              case MCTRL_STATE_INIT:
 987   2              {
 988   3                  switch(event->eventHdr.type)
 989   3                  {
 990   4      #ifdef STA_FUNC
 991   4                      case EVENT_TYPE_RESTART_REQ:
 992   4                      {
 993   5                          /* start the network discovery */
 994   5                          NDC_Start(&ctrlLayer->netDiscCtrl);
 995   5      FM_Printf(FM_CTRL|FM_MINFO, "MCTRL: transit to NET_DISC state.\n");
 996   5                          mctrl->state = MCTRL_STATE_NET_DISC;
 997   5                          break;
 998   5                      }
 999   4      #endif
1000   4                      case EVENT_TYPE_SET_NETWORK_REQ:
1001   4                      {
1002   5                                      
1003   5                          if(*(event->buffDesc.dataptr) == NETWORK_START)
1004   5                          {
1005   6      #ifdef CCO_FUNC
1006   6                              /* start the unassociated CCo */
1007   6                              UCC_Start(&ctrlLayer->uCcoCtrl );
1008   6                              mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1009   6      #endif
1010   6                          }
1011   5                          else if(*(event->buffDesc.dataptr) == NETWORK_JOIN)
1012   5                          {
1013   6      #ifdef STA_FUNC
1014   6                              /* start the unassociated STA */
1015   6                              USC_Start(&ctrlLayer->uStaCtrl );
1016   6                              mctrl->state = MCTRL_STATE_UNASSOC_STA;
1017   6      #endif
1018   6                          }
1019   5                          else
1020   5                          {
1021   6                          }
1022   5                          break;
1023   5                      }
1024   4                      default:
1025   4                          FM_HexDump(FM_CTRL|FM_MINFO, "MCTRL: received an unexpected event (%d) at the INIT sta
             -te.\n", (u8*)&event->eventHdr.type,2);
1026   4                  }
1027   3                  break;
1028   3              }
1029   2      #ifdef STA_FUNC
1030   2              case MCTRL_STATE_NET_DISC:
1031   2              {
1032   3      FM_HexDump(FM_CTRL|FM_MINFO, "MCTRL: Get an event \n", (u8*)&event->eventHdr.type, 2);
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 18  

1033   3                  switch(event->eventHdr.type)
1034   3                  {
1035   4                      case EVENT_TYPE_USTA_IND:
1036   4                      {
1037   5                          USC_Start(&ctrlLayer->uStaCtrl );
1038   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1039   5                          break;
1040   5                      }
1041   4                      case EVENT_TYPE_ASTA_IND:
1042   4                      {
1043   5      
1044   5      #ifdef UKE                    
                                  u8 secMode;
              
                                  LINKL_GetSecurityMode(linkl, &secMode);
              
                                  if(secMode  == SEC_MODE_SC_JOIN)
                                  {
                                      ASC_Start(&ctrlLayer->aStaCtrl, 0);
                                  }
                                  else                        
              #endif          
1055   5                          {
1056   6                              ASC_Start(&ctrlLayer->aStaCtrl, 1);
1057   6                          }
1058   5                          mctrl->state = MCTRL_STATE_ASSOC_STA;
1059   5                          break;
1060   5                      }
1061   4      #ifdef CCO_FUNC
1062   4                      case EVENT_TYPE_UCCO_IND:
1063   4                      {
1064   5                          UCC_Start(&ctrlLayer->uCcoCtrl );
1065   5                          mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1066   5                          break;
1067   5                      }
1068   4                      case EVENT_TYPE_ACCO_IND:
1069   4                      {
1070   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1071   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1072   5                          break;
1073   5                      }
1074   4      #endif /* CCO_FUNC */
1075   4                      case EVENT_TYPE_NET_EXIT_IND:
1076   4                          /* start the network discovery */
1077   4                          NDC_Start(&ctrlLayer->netDiscCtrl);
1078   4                          break;
1079   4                      default:
1080   4                      {
1081   5                          //stay in the same state
1082   5                          NDC_ProcEvent(&ctrlLayer->netDiscCtrl, event);
1083   5                      }
1084   4                  }
1085   3                  break;
1086   3              }
1087   2              case MCTRL_STATE_UNASSOC_STA:
1088   2              {
1089   3                  switch(event->eventHdr.type)
1090   3                  {
1091   4                      case EVENT_TYPE_ASTA_IND:
1092   4                      {
1093   5      #ifdef UKE
                          u8 secMode;
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 19  

              
                                  LINKL_GetSecurityMode(linkl, &secMode);
              
                                  if(secMode == SEC_MODE_SC_JOIN)
                                  {
                                      ASC_Start(&ctrlLayer->aStaCtrl, 0);
                                  }
                                  else
              #endif          
1104   5                
1105   5                          {
1106   6                              ASC_Start(&ctrlLayer->aStaCtrl, 1);
1107   6                          }
1108   5                          mctrl->state = MCTRL_STATE_ASSOC_STA;
1109   5                          break;
1110   5                      }
1111   4      #ifdef CCO_FUNC
1112   4                      case EVENT_TYPE_UCCO_IND:
1113   4                      {
1114   5                          UCC_Start(&ctrlLayer->uCcoCtrl);
1115   5                          mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1116   5                          break;
1117   5                      }
1118   4                      case EVENT_TYPE_ACCO_IND:
1119   4                      {
1120   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1121   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1122   5                          break;
1123   5                      }
1124   4      #endif /* CCO_FUNC */
1125   4                      case EVENT_TYPE_NET_EXIT_IND:
1126   4                      case EVENT_TYPE_SET_NETWORK_REQ:
1127   4                          mctrl->state = MCTRL_STATE_NET_DISC;
1128   4                          /* start the network discovery */
1129   4                          NDC_Start(&ctrlLayer->netDiscCtrl);
1130   4                          break;
1131   4                      default:
1132   4                      {
1133   5                          //stay in the same state
1134   5                          USC_ProcEvent(&ctrlLayer->uStaCtrl, event);
1135   5                      }
1136   4                  }
1137   3                  break;
1138   3              }
1139   2              case MCTRL_STATE_ASSOC_STA:
1140   2              {
1141   3                  switch(event->eventHdr.type)
1142   3                  {
1143   4      #ifdef CCO_FUNC
1144   4                      case EVENT_TYPE_ACCO_IND:
1145   4                      {
1146   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_HO);
1147   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1148   5                          break;
1149   5                      }
1150   4      #endif /* CCO_FUNC */
1151   4                      case EVENT_TYPE_USTA_IND:
1152   4                      {
1153   5                          
1154   5                          USC_Start(&ctrlLayer->uStaCtrl );
1155   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1156   5                          break;
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 20  

1157   5                      }
1158   4                      case EVENT_TYPE_RESTART_IND:
1159   4                      {
1160   5                          
1161   5                          NDC_Start(&ctrlLayer->netDiscCtrl);
1162   5                          mctrl->state = MCTRL_STATE_NET_DISC;
1163   5                          break;
1164   5                      }
1165   4                      case EVENT_TYPE_NET_EXIT_IND:
1166   4      
1167   4                if (mctrl->nextState == MCTRL_STATE_INIT)
1168   4                {
1169   5                  mctrl->state = MCTRL_STATE_INIT;
1170   5                }
1171   4                else
1172   4                {
1173   5                  mctrl->state = MCTRL_STATE_NET_DISC;
1174   5                  
1175   5                            /* start the network discovery */
1176   5                            NDC_Start(&ctrlLayer->netDiscCtrl);
1177   5                
1178   5                }
1179   4                          break;
1180   4                      default:
1181   4                      {
1182   5                          
1183   5                          //stay in the same state
1184   5                          ASC_ProcEvent(&ctrlLayer->aStaCtrl, event);
1185   5                      }
1186   4                  } 
1187   3                  break;
1188   3              }
1189   2      #endif /* STA_FUNC */
1190   2      #ifdef CCO_FUNC
1191   2              case MCTRL_STATE_UNASSOC_CCO:
1192   2              {
1193   3                  switch(event->eventHdr.type)
1194   3                  {
1195   4      #ifdef STA_FUNC
1196   4                      case EVENT_TYPE_USTA_IND:
1197   4                      {
1198   5                          USC_Start(&ctrlLayer->uStaCtrl );
1199   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1200   5                          break;
1201   5                      }
1202   4      #endif
1203   4                      case EVENT_TYPE_ACCO_IND:
1204   4                      {
1205   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1206   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1207   5                          break;
1208   5                      }
1209   4                      case EVENT_TYPE_NET_EXIT_IND:
1210   4                
1211   4          //        HHAL_SetDevMode(linkLayer->hal, 
1212   4          //                DEV_MODE_STA,gHpgpHalCB.lineMode);
1213   4              
1214   4        
1215   4                    LINKL_PostStopCCo(linkl);
1216   4      
1217   4                if (mctrl->nextState == MCTRL_STATE_UNASSOC_STA)
1218   4                {
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 21  

1219   5                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL);      
1220   5      
1221   5                }
1222   4                else if (mctrl->nextState == MCTRL_STATE_NET_DISC)
1223   4                {
1224   5                  mctrl->state = MCTRL_STATE_NET_DISC;
1225   5                  /* start the network discovery */
1226   5                  NDC_Start(&ctrlLayer->netDiscCtrl);
1227   5      
1228   5                }
1229   4                else
1230   4                {
1231   5                  mctrl->state = MCTRL_STATE_INIT;
1232   5                }
1233   4                
1234   4                          break;
1235   4                
1236   4                      case EVENT_TYPE_SET_NETWORK_REQ:
1237   4                          mctrl->state = MCTRL_STATE_NET_DISC;
1238   4                          /* start the network discovery */
1239   4                          NDC_Start(&ctrlLayer->netDiscCtrl);
1240   4                          break;
1241   4                      default:
1242   4                      {
1243   5                          //stay in the same state
1244   5                          UCC_ProcEvent(&ctrlLayer->uCcoCtrl, event);
1245   5                      }               
1246   4                  }
1247   3                  break;
1248   3              }
1249   2              case MCTRL_STATE_ASSOC_CCO:
1250   2              {
1251   3                  switch(event->eventHdr.type)
1252   3                  {
1253   4      #ifdef STA_FUNC
1254   4                      case EVENT_TYPE_USTA_IND:
1255   4                      {
1256   5                          USC_Start(&ctrlLayer->uStaCtrl );
1257   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1258   5                          break;
1259   5                      }
1260   4                      case EVENT_TYPE_ASTA_IND:
1261   4                      {
1262   5                          //from the Assoc CCo to Assoc STA due to handover
1263   5                          //ASC_Start(&ctrlLayer->aStaCtrl);
1264   5                          ASC_Start(&ctrlLayer->aStaCtrl, 0);
1265   5                          mctrl->state = MCTRL_STATE_ASSOC_STA;
1266   5                          break;
1267   5                      }
1268   4      #endif
1269   4                      case EVENT_TYPE_UCCO_IND:
1270   4                      {
1271   5                          UCC_Start(&ctrlLayer->uCcoCtrl );
1272   5                          mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1273   5                          break;
1274   5                      }
1275   4                      case EVENT_TYPE_NET_EXIT_IND:
1276   4                         
1277   4                          /* start the network discovery */
1278   4                LINKL_PostStopCCo(linkl);
1279   4                
1280   4                if (mctrl->nextState == MCTRL_STATE_NET_DISC)
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 22  

1281   4                { 
1282   5                  mctrl->state = MCTRL_STATE_NET_DISC;
1283   5                  NDC_Start(&ctrlLayer->netDiscCtrl);
1284   5                }
1285   4                else
1286   4                if (mctrl->nextState == MCTRL_STATE_UNASSOC_CCO)
1287   4                {
1288   5                  ACC_BecomeUnassociated(ctrlLayer);
1289   5                }
1290   4                else
1291   4                {
1292   5                  mctrl->state = MCTRL_STATE_INIT;
1293   5                }
1294   4      
1295   4          
1296   4                          break;
1297   4                      default:
1298   4                      {
1299   5                          //stay in the same state
1300   5                          ACC_ProcEvent(&ctrlLayer->aCcoCtrl, event);
1301   5                      }
1302   4                  }
1303   3                  break;
1304   3              }
1305   2      #endif /* CCO_FUNC */
1306   2              default:
1307   2              {
1308   3              }
1309   2          }
1310   1      
1311   1        if (mctrl->state != stateOld)
1312   1        {
1313   2          hostEvent_NetworkId nwId;
1314   2      
1315   2          nwId.state = (nwIdState_e)mctrl->state;
1316   2          nwId.reason = 0xFF;
1317   2      #ifdef LOG_FLASH
                      logEvent(INDICATION, 0, HOST_EVENT_NETWORK_IND, &nwId, sizeof(nwId));
              #endif
1320   2          Host_SendIndication(HOST_EVENT_NETWORK_IND, (u8*)&nwId, sizeof(nwId));
1321   2        }
1322   1      }
1323          
1324          
1325          eStatus CTRLL_GetKey(sCtrlLayer *ctrlLayer, u8 *nmk, u8 *nid)
1326          {
1327   1         sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1328   1      
1329   1         LINKL_GetKey(linkl, nmk, nid);
1330   1         return STATUS_SUCCESS;
1331   1      }
*** WARNING C280 IN LINE 1325 OF ..\..\src\ctrl\ctrll.c: 'ctrlLayer': unreferenced local variable
1332          
1333          eStatus CTRLL_SetKey(sCtrlLayer *ctrlLayer, u8 *nmk, u8 *nid)
1334          {
1335   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1336   1      
1337   1          LINKL_SetKey(linkl, nmk, nid);
1338   1        
1339   1        //  CTRLL_NetExit(ctrlLayer);
1340   1      
1341   1         return STATUS_SUCCESS;
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 23  

1342   1      }
*** WARNING C280 IN LINE 1333 OF ..\..\src\ctrl\ctrll.c: 'ctrlLayer': unreferenced local variable
1343          
1344          
1345          
1346          /* The function starts the network discovery */
1347          eStatus CTRLL_StartNetDisc(sCtrlLayer *ctrlLayer)
1348          {
1349   1          sEvent    *event = NULL;
1350   1          eStatus    ret = STATUS_FAILURE;
1351   1        sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1352   1        sStaInfo *staInfo = LINKL_GetStaInfo(linkl); 
1353   1        
1354   1      
1355   1          event = EVENT_Alloc(0, 0);
1356   1          if(event)
1357   1          {
1358   2              event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1359   2              event->eventHdr.type = EVENT_TYPE_RESTART_REQ;
1360   2      
1361   2          staInfo->lastUserAppCCOState = 0;
1362   2          staInfo->staCap.fields.backupCcoCap = 0;      
1363   2      
1364   2              CTRLL_SendEvent(ctrlLayer, event);
1365   2              ret = STATUS_SUCCESS;
1366   2          }
1367   1      
1368   1          return ret;
1369   1      }
1370          
1371          /* The function starts either an unassociated Cco or  unassociated sta */
1372          eStatus CTRLL_StartNetwork(sCtrlLayer *ctrlLayer, u8 type, u8 *nid)
1373          {
1374   1          sEvent    *event = NULL;
1375   1          eStatus    ret = STATUS_FAILURE;
1376   1          u8        *dataptr = NULL;
1377   1      
1378   1          event = EVENT_Alloc(1, 0);
1379   1          if(event)
1380   1          {
1381   2              event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1382   2              event->eventHdr.type = EVENT_TYPE_SET_NETWORK_REQ;
1383   2              dataptr = event->buffDesc.dataptr;
1384   2              *dataptr = type;
1385   2              CTRLL_SendEvent(ctrlLayer, event);
1386   2              ret = STATUS_SUCCESS;
1387   2          }
1388   1      
1389   1          return ret;
1390   1      }
*** WARNING C280 IN LINE 1372 OF ..\..\src\ctrl\ctrll.c: 'nid': unreferenced local variable
1391          
1392          
1393          eStatus CTRLL_NetExit(sCtrlLayer *ctrlLayer)
1394          {
1395   1          sEvent *event = NULL;
1396   1          //Generate a time event
1397   1          event = EVENT_Alloc(0, 0);
1398   1          if(event == NULL)
1399   1          {
1400   2              FM_Printf(FM_ERROR, "EAllocErr\n");
1401   2              return STATUS_FAILURE;
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 24  

1402   2          }
1403   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1404   1          event->eventHdr.type = EVENT_TYPE_NET_EXIT_REQ;
1405   1      
1406   1          /* place the event into the external queue */
1407   1          return CTRLL_SendEvent(ctrlLayer, event);
1408   1      
1409   1      }
1410          #ifdef UKE
              eStatus CTRLL_setSecMode(sCtrlLayer *ctrlLayer, u8 secMode)
              {
                  sEvent *event = NULL;
                  u8     *dataptr = NULL;
                  //Generate a time event
                  event = EVENT_Alloc(1, 0);
                  if(event == NULL)
                  {
                      FM_Printf(FM_ERROR, "EAllocErr\n");
                      return STATUS_FAILURE;
                  }
                  event->eventHdr.eventClass = EVENT_CLASS_CTRL;
                  event->eventHdr.type = EVENT_TYPE_SET_SEC_MODE;
                  dataptr = event->buffDesc.dataptr;
                  *dataptr = secMode;
              
                  /* place the event into the external queue */
                  return CTRLL_SendEvent(ctrlLayer, event);
              }
              #endif
1431          
1432          eStatus CTRLL_SendAssocReq(sCtrlLayer *ctrlLayer)
1433          {                                                
1434   1         CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_ACC_REQ, NULL); 
1435   1         return STATUS_SUCCESS;
1436   1      }
1437          
1438          #if 1
1439          
1440          
1441          u8 CTRLL_Proc(void *cookie)
1442          {
1443   1          sEvent *event = NULL;
1444   1          sSlink *slink = NULL;
1445   1          u8      ret = 0;
1446   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
1447   1      
1448   1          while(!SLIST_IsEmpty(&ctrlLayer->eventQueue) )
1449   1          {
1450   2      #ifdef P8051
1451   2      __CRIT_SECTION_BEGIN__
1452   2      #else
                  SEM_WAIT(&ctrlLayer->ctrlSem);
              #endif
1455   2      
1456   2              slink = SLIST_Pop(&ctrlLayer->eventQueue);
1457   2      #ifdef P8051
1458   2      __CRIT_SECTION_END__
1459   2      #else
                  SEM_POST(&ctrlLayer->ctrlSem);
              #endif
1462   2              event = SLIST_GetEntry(slink, sEvent, link);
1463   2      
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 25  

1464   2              if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
1465   2              {
1466   3                  //FM_Printf(FM_CTRL|FM_MINFO, "CTRLL: Get an event (%d)\n", event->eventHdr.type);
1467   3                  MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
1468   3                  MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
1469   3              }
1470   2           
1471   2              if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
1472   2              {
1473   3                  EVENT_Free(event);
1474   3              }
1475   2      
1476   2              while(!SLIST_IsEmpty(&ctrlLayer->intEventQueue))
1477   2              {
1478   3                  //no need for sync protection
1479   3                  slink = SLIST_Pop(&ctrlLayer->intEventQueue);
1480   3                  event = SLIST_GetEntry(slink, sEvent, link);
1481   3      
1482   3                  
1483   3      //            FM_HexDump(FM_ERROR, "C type", (u8*)&event->eventHdr.type, 2);
1484   3                  if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
1485   3                  {
1486   4                      MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
1487   4                      MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
1488   4                  }
1489   3           
1490   3                  if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
1491   3                  {
1492   4                      EVENT_Free(event);
1493   4                  }
1494   3              }
1495   2          }
1496   1          return ret;
1497   1      }
1498          
1499          
1500          #else
              
              extern u8 LINKL_Proc(void *cookie);
              u8 CTRLL_Proc(void *cookie)
              
              {
                  sEvent *event = NULL;
                  sSlink *slink = NULL;
                  u8      ret = 0;  
                  sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
                sLinkLayer *linkLayer = (sLinkLayer*)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
              
                  while((!SLIST_IsEmpty(&ctrlLayer->eventQueue) 
              #ifndef RTX51_TINY_OS
                  && !(ret = SCHED_IsPreempted(&ctrlLayer->task))
              #endif
                  ) || ((!SLIST_IsEmpty(&linkLayer->eventQueue))))
                  { 
              #if 1
                  if((!SLIST_IsEmpty(&linkLayer->eventQueue)))
                  {
                    LINKL_Proc(HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK));
              
                    return ret;
                  }
              
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 26  

                  
              
                  if (SLIST_IsEmpty(&ctrlLayer->eventQueue))
                    return ret;
              #endif
              
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                    SEM_WAIT(&ctrlLayer->ctrlSem);
              #endif
              
                      slink = SLIST_Pop(&ctrlLayer->eventQueue);
              #ifdef P8051
              __CRIT_SECTION_END__
              #else
                  SEM_POST(&ctrlLayer->ctrlSem);
              #endif
                  if (slink == NULL)
                    return ret;
                    
                      event = SLIST_GetEntry(slink, sEvent, link);
              
                      if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                      {
                     //     FM_HexDump(FM_CTRL|FM_MINFO, "CTRLL: \n", (u8*)&event->eventHdr.type,2);
                          MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
                          MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
                      }
                   
                      if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
                      {
                          EVENT_Free(event);
                      }
              
                      while(!SLIST_IsEmpty(&ctrlLayer->intEventQueue))
                      {
                          //no need for sync protection
                          slink = SLIST_Pop(&ctrlLayer->intEventQueue);
                          event = SLIST_GetEntry(slink, sEvent, link);
              
                          
              //            FM_HexDump(FM_ERROR, "C type", (u8*)&event->eventHdr.type, 2);
                          if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                          {
                              MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
                              MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
                          }
                   
                          if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
                          {
                              EVENT_Free(event);
                          }
                      }
              
                  return ret;
                  }
                  return ret;
              }
              
              #endif
1587          
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 27  

1588          
1589          void CTRLL_RegisterEventCallback(sCtrlLayer *ctrlLayer, 
1590              void (*callback)(void XDATA *cookie, sEvent XDATA *event),
1591              void *cookie)
1592          {
1593   1      #ifdef CALLBACK
                  ctrlLayer->deliverEvent = callback;
              #endif
1596   1          ctrlLayer->eventcookie = cookie;
1597   1      
1598   1      }
*** WARNING C280 IN LINE 1590 OF ..\..\src\ctrl\ctrll.c: 'callback': unreferenced local variable
1599          
1600          
1601          /* Post an event into the external event queue */
1602          eStatus CTRLL_SendEvent(sCtrlLayer *ctrll, sEvent *event) __REENTRANT__
1603          {
1604   1          if(event == NULL)
1605   1          {
1606   2              return STATUS_FAILURE;
1607   2          }
1608   1      
1609   1      #ifdef P8051
1610   1      __CRIT_SECTION_BEGIN__
1611   1      #else
                  SEM_WAIT(&ctrll->ctrlSem);
              #endif
1614   1      
1615   1          SLIST_Put(&ctrll->eventQueue, &event->link);
1616   1      
1617   1      #ifdef P8051
1618   1      __CRIT_SECTION_END__
1619   1      #else
                  SEM_POST(&ctrll->ctrlSem);
              #endif
1622   1          /* schedule the task */
1623   1      #ifndef RTX51_TINY_OS
                  return SCHED_Sched(&ctrll->task);
              #else
1626   1          os_set_ready(HPGP_TASK_ID_CTRL);
1627   1        ctrll->pendingEvent = 1;
1628   1      
1629   1          return STATUS_SUCCESS;
1630   1      #endif
1631   1      
1632   1      }
1633          
1634          
1635          
1636          
1637          void CTRLL_ReceiveEvent(void* cookie, sEvent* event)
1638          {
1639   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1640   1          //place the event into the queue in the Control Layer
1641   1          //SLIST_Put(&ctrlLayer->eventQueue, &event->link);
1642   1          CTRLL_SendEvent(ctrlLayer, event);
1643   1      }
*** WARNING C280 IN LINE 1637 OF ..\..\src\ctrl\ctrll.c: 'cookie': unreferenced local variable
1644          
1645          
1646          
1647          eStatus CTRLL_Init(sCtrlLayer *ctrlLayer)
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 28  

1648          {
1649   1          eStatus     status = STATUS_SUCCESS;
1650   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1651   1      
1652   1      #ifndef P8051
              #if defined(WIN32) || defined(_WIN32)
                  ctrlLayer->ctrlSem = CreateSemaphore(
                      NULL,           // default security attributes
                      SEM_COUNT,      // initial count
                      SEM_COUNT,      // maximum count
                      NULL);          // unnamed semaphore
                  if(ctrlLayer->ctrlSem == NULL)
              #else
                  if(sem_init(&ctrlLayer->ctrlSem, 0, SEM_COUNT))
              #endif
                  {
                      status = STATUS_FAILURE;
                  }
              #endif
1667   1      #ifdef RTX51_TINY_OS
1668   1         os_create_task(HPGP_TASK_ID_CTRL);
1669   1      #else
                  SCHED_InitTask(&ctrlLayer->task, HPGP_TASK_ID_CTRL, "CTRL", 
                                 HPGP_TASK_PRI_CTRL, CTRLL_Proc, ctrlLayer);
              #endif
1673   1          MCTRL_Init(&ctrlLayer->mainCtrl);
1674   1      #ifdef STA_FUNC
1675   1          NDC_Init(&ctrlLayer->netDiscCtrl);
1676   1          USC_Init(&ctrlLayer->uStaCtrl);
1677   1          ASC_Init(&ctrlLayer->aStaCtrl);
1678   1      #endif
1679   1      #ifdef CCO_FUNC
1680   1          UCC_Init(&ctrlLayer->uCcoCtrl);
1681   1          ACC_Init(&ctrlLayer->aCcoCtrl);
1682   1      #endif
1683   1          SLIST_Init(&ctrlLayer->eventQueue);
1684   1        SLIST_Init(&ctrlLayer->intEventQueue);
1685   1          LINKL_RegisterEventCallback(linkLayer, 
1686   1                                      CTRLL_ReceiveEvent, 
1687   1                                      (void *)ctrlLayer);
1688   1      
1689   1        ctrlLayer->pendingEvent = 0;
1690   1      
1691   1          FM_Printf(FM_MINFO, "Ctrol Layer: Initialized\n");
1692   1      
1693   1          return status;
1694   1      }
1695          
1696          
1697          void CTRLL_TimerHandler(u16 type, void *cookie)
1698          {
1699   1          sEvent *event = NULL;
1700   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
1701   1          //Generate a time event
1702   1          event = EVENT_Alloc(0, 0);
1703   1          if(event == NULL)
1704   1          {
1705   2              FM_Printf(FM_ERROR, "Ctrll EAllocErr\n");
1706   2              return;
1707   2          }
1708   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1709   1          event->eventHdr.type = type;
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 29  

1710   1          CTRLL_SendEvent(ctrlLayer, event);
1711   1      }
1712          
1713          #ifdef RTX51_TINY_OS
1714          void CTRL_Task (void) _task_ HPGP_TASK_ID_CTRL
1715          {
1716   1        
1717   1      
1718   1        sNma* nma = (sNma*)HOMEPLUG_GetNma();
1719   1          sCtrlLayer *ctrll = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1720   1          while (1) {
1721   2      #ifdef UART_HOST_INTF
                  os_switch_task();
              #else
1724   2        //  os_switch_task();
1725   2          if (!ctrll->pendingEvent)
1726   2          {
1727   3            os_wait1(K_SIG);
1728   3          }
1729   2      #endif    
1730   2      
1731   2          ctrll->pendingEvent = 0;
1732   2          CTRLL_Proc(ctrll);
1733   2          os_switch_task();
1734   2              LINKL_Proc(HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK));
1735   2          os_switch_task();
1736   2          NMA_Proc(nma);    
1737   2          }
1738   1      }
1739          #endif
1740          
1741          
1742          /** =========================================================
1743           *
1744           * Edit History
1745           *
1746           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/ctrl/ctrll.c,v $
1747           *
1748           * $Log: ctrll.c,v $
1749           * Revision 1.13  2014/09/05 09:28:18  ranjan
1750           * 1. uppermac cco-sta switching feature fix
1751           * 2. general stability fixes for many station associtions
1752           * 3. changed mgmt memory pool for many STA support
1753           *
1754           * Revision 1.12  2014/08/25 07:37:34  kiran
1755           * 1) RSSI & LQI support
1756           * 2) Fixed Sync related issues
1757           * 3) Fixed timer 0 timing drift for SDK
1758           * 4) MMSG & Error Logging in Flash
1759           *
1760           * Revision 1.11  2014/06/26 17:59:42  ranjan
1761           * -fixes to make uppermac more robust for n/w change
1762           *
1763           * Revision 1.10  2014/06/19 17:13:19  ranjan
1764           * -uppermac fixes for lvnet and reset command for cco and sta mode
1765           * -backup cco working
1766           *
1767           * Revision 1.9  2014/06/12 13:15:43  ranjan
1768           * -separated bcn,mgmt,um event pools
1769           * -fixed datapath issue due to previous checkin
1770           * -work in progress. neighbour cco detection
1771           *
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 30  

1772           * Revision 1.8  2014/06/11 13:17:47  kiran
1773           * UART as host interface and peripheral interface supported.
1774           *
1775           * Revision 1.7  2014/05/28 10:58:59  prashant
1776           * SDK folder structure changes, Uart changes, removed htm (UI) task
1777           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
1778           *
1779           * Revision 1.6  2014/05/12 08:09:57  prashant
1780           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
1781           *
1782           * Revision 1.5  2014/04/09 08:18:10  ranjan
1783           * 1. Added host events for homeplug uppermac indication (Host_SendIndication)
1784           * 2. timer workaround  + other fixes
1785           *
1786           * Revision 1.4  2014/02/27 10:42:47  prashant
1787           * Routing code added
1788           *
1789           * Revision 1.3  2014/01/17 11:19:28  prashant
1790           * SPI fix, UM stablity fix
1791           *
1792           * Revision 1.2  2014/01/10 17:14:40  yiming
1793           * check in Rajan 1/8/2014 code release
1794           *
1795           * Revision 1.5  2014/01/08 10:53:54  ranjan
1796           * Changes for LM OS support.
1797           * New Datapath FrameTask
1798           * LM and UM  datapath, feature verified.
1799           *
1800           * known issues : performance numbers needs revisit
1801           *
1802           * review : pending.
1803           *
1804           * Revision 1.4  2013/09/04 14:50:33  yiming
1805           * New changes for Hybrii_A code merge
1806           *
1807           * Revision 1.31  2013/07/12 08:56:36  ranjan
1808           * -UKE Push Button Security Feature.
1809           * Verified : DirectEntry Security Works.Datapath Works.
1810           *                 command SetSecMode for UKE works.
1811           * Added against bug-160
1812           *
1813           * Revision 1.30  2013/04/17 13:00:59  ranjan
1814           * Added FW ready event, Removed hybrii header from datapath, Modified hybrii header
1815           *  formate
1816           *
1817           * Revision 1.29  2013/04/04 12:21:54  prashant
1818           * Detecting PLC link failure for HMC. added project for HMC and Renesas
1819           *
1820           * Revision 1.28  2013/03/22 12:21:48  prashant
1821           * default FM_MASK and FM_Printf modified for USER INFO
1822           *
1823           * Revision 1.27  2013/03/21 07:43:26  ranjan
1824           * Starting NDC on "p reset" command
1825           *
1826           * Revision 1.26  2013/03/14 11:49:18  ranjan
1827           * 1.handled cases  for CCo toSTA switch and  viceversa
1828           * 2.UM uses bcntemplate
1829           *
1830           * Revision 1.25  2012/11/19 07:46:23  ranjan
1831           * Changes for Network discovery modes
1832           *
1833           * Revision 1.24  2012/10/11 06:21:00  ranjan
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 31  

1834           * ChangeLog:
1835           * 1. Added HPGP_MAC_SAP to support linux host data and command path.
1836           *     define HPGP_MAC_SAP, NMA needs to be added in project.
1837           *
1838           * 2. Added 'p ping' command in htm.c . Feature is under AUTO_PING macro.
1839           *
1840           * 3. Extended  'p key' command to include PPEK support.
1841           *
1842           * verified :
1843           *   1. Datapath ping works overnite after association,auth
1844           *   2. HAL TEST project is intact
1845           *
1846           * Revision 1.23  2012/07/29 02:59:22  yuanhua
1847           * Initialize the internel queue of CTRL Layer to fix an issue of unexpected event free error message.
1848           *
1849           * Revision 1.22  2012/07/08 18:42:20  yuanhua
1850           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
1851           *
1852           * Revision 1.21  2012/06/30 23:36:26  yuanhua
1853           * return the success status for LINKL_SendEvent() when RTX51 OS is used.
1854           *
1855           * Revision 1.20  2012/06/20 17:47:52  kripa
1856           * Included the SendAssocReq() func.
1857           * Reverted the changes for passive network join.
1858           * Committed on the Free edition of March Hare Software CVSNT Client.
1859           * Upgrade to CVS Suite for more features and support:
1860           * http://march-hare.com/cvsnt/
1861           *
1862           * Revision 1.19  2012/06/15 04:35:21  yuanhua
1863           * add a STA type of passive unassoc STA. With this STA type, the device acts as a STA during the network 
             -discovery. It performs the network scan for beacons from the CCO, but does not transmit the UNASSOC_STA.IND and does not
             - involve in the CCO selection process. Thus, it joins the existing network.
1864           *
1865           * Revision 1.18  2012/06/08 23:37:36  son
1866           * Remove networks scan from CTRLL as it is moved to NMS
1867           *
1868           * Revision 1.17  2012/06/08 00:21:47  son
1869           * Fixed beacon RX problem
1870           *
1871           * Revision 1.16  2012/06/05 22:37:11  son
1872           * UART console does not get initialized due to task ID changed
1873           *
1874           * Revision 1.15  2012/06/05 07:25:59  yuanhua
1875           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
1876           *
1877           * Revision 1.14  2012/06/04 23:30:17  son
1878           * Created Control Task for RTX51 Tiny OS
1879           *
1880           * Revision 1.13  2012/05/24 05:08:18  yuanhua
1881           * define sendEvent functions in CTRL/LINK layer as reentrant.
1882           *
1883           * Revision 1.12  2012/05/19 20:32:17  yuanhua
1884           * added non-callback option for the protocol stack.
1885           *
1886           * Revision 1.11  2012/05/19 05:05:15  yuanhua
1887           * optimized the timer handlers in CTRL and LINK layers.
1888           *
1889           * Revision 1.10  2012/05/17 05:05:58  yuanhua
1890           * (1) added the option for timer w/o callback (2) added task id and name.
1891           *
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 32  

1892           * Revision 1.9  2012/05/14 05:22:29  yuanhua
1893           * support the SCHED without using callback functions.
1894           *
1895           * Revision 1.8  2012/05/12 04:11:46  yuanhua
1896           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
1897           *
1898           * Revision 1.7  2012/05/01 04:51:09  yuanhua
1899           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
1900           *
1901           * Revision 1.6  2012/04/20 01:39:33  yuanhua
1902           * integrated uart module and added compiler flag NMA.
1903           *
1904           * Revision 1.5  2012/04/17 23:09:50  yuanhua
1905           * fixed compiler errors for the hpgp hal test due to the integration changes.
1906           *
1907           * Revision 1.4  2012/04/13 06:15:11  yuanhua
1908           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
1909           *
1910           * Revision 1.3  2012/03/11 17:02:24  yuanhua
1911           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
1912           *
1913           * Revision 1.2  2011/09/09 07:02:31  yuanhua
1914           * migrate the firmware code from the greenchip to the hybrii.
1915           *
1916           * Revision 1.5  2011/08/12 23:13:21  yuanhua
1917           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
1918           *
1919           * Revision 1.2  2011/06/24 14:33:18  yuanhua
1920           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
1921           *
1922           * Revision 1.1  2011/05/06 19:07:48  kripa
1923           * Adding ctrl layer files to new source tree.
1924           *
1925           * Revision 1.3  2011/04/23 19:48:45  kripa
1926           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
1927           *
1928           * Revision 1.2  2011/04/23 18:31:12  kripa
1929           * 1.Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
1930           * 2.NDC_Init(), USC_Init(), USC_Start(), ACC_Init() ; placed memset after struct declaration.
1931           * 3.CTRLL_Proc(); changed event->class to event->eventClass.
1932           *
1933           * Revision 1.1  2011/04/08 21:43:29  yuanhua
1934           * Framework
1935           *
1936           *
1937           * =========================================================*/
1938          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5122    ----
   CONSTANT SIZE    =    485    ----
   XDATA SIZE       =   ----     337
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.52.0.0   CTRLL                                                             12/02/2014 14:35:39 PAGE 33  

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  9 WARNING(S),  0 ERROR(S)
