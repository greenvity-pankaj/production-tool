C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_SYNC
OBJECT MODULE PLACED IN .\obj\mac_sync.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_sync.c LARGE OBJECTADVANCED OPTIMIZE(9,S
                    -IZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\.
                    -.\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal
                    -;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firm
                    -ware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;
                    -..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;
                    -..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc
                    -;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..
                    -\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\h
                    -pgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\.
                    -.\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\co
                    -mponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\f
                    -lash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;
                    -..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk
                    -\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\.
                    -.\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8
                    -051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,U
                    -M,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETEC
                    -T,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,
                    -MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIS
                    -TER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_sync.lst) TABS(2) O
                    -BJECT(.\obj\mac_sync.obj)

line level    source

   1          /**
   2           * @file
   3           *
   4           * Handle MLME-SYNC.request
   5           *
   6           * $Id: mac_sync.c,v 1.6 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2012, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          #ifdef HYBRII_802154
  12          
  13          /* === Includes ============================================================ */
  14          
  15          #include "papdef.h"
  16          #include "timer.h"
  17          #include "return_val.h"
  18          #include "bmm.h"
  19          #include "qmm.h"
  20          #include "mac_msgs.h"
  21          #include "mac_hal.h"
  22          #include "mac_const.h"
  23          #include "mac_api.h"
  24          #include "mac_data_structures.h"
  25          #include "mac_internal.h"
  26          #include "mac.h"
  27          #include "utils_fw.h"
  28          
  29          
  30          /* === Macros =============================================================== */
  31          
  32          
  33          /* === Globals ============================================================= */
  34          
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 2   

  35          /* === Prototypes ========================================================== */
  36          
  37          /* === Implementation ====================================================== */
  38          
  39          /*
  40           * This function is a callback from the missed beacon timer and implements the
  41           * generation of sync loss if required.
  42           *
  43           * callback_parameter - Callback parameter of the expired missed beacon
  44           */
  45          void mac_sync_missed_beacons_cb (void *callback_parameter)
  46          {
  47   1          if (MAC_SYNC_NEVER != mac_sync_state) {
  48   2              /* Since the node lost sync with it's parent, it reports sync loss. */
  49   2              mac_sync_loss(MAC_BEACON_LOSS);
  50   2          }
  51   1      
  52   1          callback_parameter = callback_parameter;  /* Keep compiler happy. */
  53   1      }
  54          
  55          /*
  56           * Start missed beacon timer
  57           */
  58          void mac_sync_start_missed_beacon_timer (void)
  59          {
  60   1          uint32_t sync_loss_time;
  61   1      
  62   1          /* Stop the missed beacon timer. */
  63   1          STM_StopTimer(beacon_missed_timer);
  64   1      
  65   1          /* Calculate the time allowed for missed beacons. */
  66   1          if (hal_pib_BeaconOrder < NON_BEACON_NWK) {
  67   2              /*
  68   2               * This the regualar case where we already have a Beacon Order.
  69   2               * In this case the Sync Loss time is a function of the actual
  70   2               * Beacon Order.
  71   2               */
  72   2              sync_loss_time = HAL_GET_BEACON_INTERVAL_TIME(hal_pib_BeaconOrder);
  73   2          } else {
  74   2              /*
  75   2               * No Beacon Order
  76   2               * This happens regularly in case of synchronization before association
  77   2               * if the Beacon Order was not set be the network layer or application.
  78   2               *
  79   2               * In this case the Sync Loss time is based on the highest possible
  80   2               * Beacon Order, which is 15 - 1, since 15 means no Beacon network.
  81   2               */
  82   2              sync_loss_time = HAL_GET_BEACON_INTERVAL_TIME(NON_BEACON_NWK - 1);
  83   2          }
  84   1      
  85   1          sync_loss_time *= aMaxLostBeacons;
  86   1      
  87   1          sync_loss_time = HAL_CONVERT_SYMBOLS_TO_US(sync_loss_time) / 1000;
  88   1      
  89   1          if (STATUS_SUCCESS != STM_StartTimer(beacon_missed_timer, 
  90   1                                               sync_loss_time )) {
  91   2              /* Sync timer could not be started hence report sync-loss */
  92   2              mac_sync_loss(MAC_BEACON_LOSS);
  93   2          }
  94   1      }
  95          
  96          /*
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 3   

  97           * The MLME-SYNC.request primitive requests to synchronize with the
  98           * coordinator by acquiring and, if specified, tracking its beacons.
  99           * The MLME-SYNC.request primitive is generated by the next higher layer of a
 100           * device on a beacon-enabled PAN and issued to its MLME to synchronize with
 101           * the coordinator.
 102           *
 103           * Enable receiver and search for beacons for at most an interval of
 104           * [aBaseSuperframeDuration * ((2 ^ (n))+ 1)] symbols where n is the value of
 105           * macBeaconOrder. If a beacon frame containing the current PAN identifier of
 106           * the device is not received, the MLME shall repeat this search. Once the
 107           * number of missed beacons reaches aMaxLostBeacons, the MLME shall notify
 108           * the next higher layer by issuing the MLME-SYNC-LOSS.indication primitive
 109           * with a loss reason of BEACON_LOSS.
 110           *
 111           * @param m Pointer to the MLME sync request parameters.
 112           */
 113          void mlme_sync_request (buffer_t *buf_p)
 114          {
 115   1      
 116   1          mlme_sync_req_t *msr_p = (mlme_sync_req_t *)buf_p;
 117   1      
 118   1          /*
 119   1           * Sync is only allowed for nodes that are:
 120   1           * 1) Devices (also before association.) or coordinators
 121   1           *    (no PAN coordinators),
 122   1           * 2) Currently NOT polling, and
 123   1           * 3) Currently NOT scanning.
 124   1           */
 125   1          if ((MAC_PAN_COORD_STARTED == mac_state)      ||
 126   1              (MAC_POLL_IDLE         != mac_poll_state) ||
 127   1              (MAC_SCAN_IDLE         != mac_scan_state)) {
 128   2      
 129   2              /* Free the buffer allocated for MLME-SYNC-Request */
 130   2              bmm_buffer_free(buf_p);
 131   2      
 132   2              mac_sync_loss(MAC_BEACON_LOSS);
 133   2      
 134   2              return;
 135   2          }
 136   1      
 137   1          /* Stop the beacon tracking period timer. */
 138   1          STM_StopTimer(beacon_tracking_timer);
 139   1      
 140   1      
 141   1          /* Set MAC Sync state properly. */
 142   1          if (MAC_IDLE == mac_state) {
 143   2              /*
 144   2               * We try to sync before association.
 145   2               * This is a special sync state that checks beacon frames similar to
 146   2               * MAC_SYNC_TRACKING_BEACON while being associated.
 147   2               *
 148   2               * Before this state can be entered successfully a number of PIB
 149   2               * attributes have to be set properly:
 150   2               * 1) PAN-Id (macPANId)
 151   2               * 2) Coordinator Short or Long address (depending upon which type
 152   2               *    of addressing the coordinator is using)
 153   2               *    (macCoordShortAddress or mac macCoordExtendedAddress)
 154   2               *
 155   2               * Furthermore it is strongly recommended to set the Beacon order and
 156   2               * Superframe order (macBeaconOrder, macSuperframeOrder).
 157   2               * If these parameters are not set and the node tries to sync with a
 158   2               * network, where it never receives a beacon from, the missed beacon
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 4   

 159   2               * timer (required for reporting a sync loss condition) will start
 160   2               * with a huge time value (based on a beacon order = 15).
 161   2               * If finally a beacon is received from the desired network, the timer
 162   2               * will be updated.
 163   2               * Nevertheless setting the PIB attributes before sync is safer.
 164   2               */
 165   2              mac_sync_state = MAC_SYNC_BEFORE_ASSOC;
 166   2          } else {
 167   2              if (msr_p->TrackBeacon) {
 168   3                  mac_sync_state = MAC_SYNC_TRACKING_BEACON;
 169   3              } else {
 170   3                  mac_sync_state = MAC_SYNC_ONCE;
 171   3              }
 172   2          }
 173   1      
 174   1          /* Wake up radio first */
 175   1          mac_trx_wakeup();
 176   1      
 177   1          set_hal_pib_internal(phyCurrentPage, (void *)&(msr_p->ChannelPage));
 178   1      
 179   1          set_hal_pib_internal(phyCurrentChannel, (void *)&(msr_p->LogicalChannel));
 180   1      
 181   1          mac_sync_start_missed_beacon_timer();
 182   1      
 183   1           /* Start synching by switching ON the receiver. */
 184   1          mac_hal_hw_control(PHY_RX_ON);
 185   1      
 186   1          /* Free the buffer allocated by the higher layer */
 187   1          bmm_buffer_free(buf_p);
 188   1      }
 189          
 190          /*
 191           * This function is a callback from the tracking beacon timer and implements
 192           * the RX timer service  function during sync and enables the receiver before
 193           * the next beacon reception is expected.
 194           *
 195           * callback_parameter - Callback parameter of the expired beacon tracking timer
 196           */
 197          void mac_sync_tracking_beacons_cb (void *callback_parameter)
 198          {
 199   1          /* Wake up radio first */
 200   1          mac_trx_wakeup();
 201   1      
 202   1           /* Turn the radio on */
 203   1          mac_hal_hw_control(PHY_RX_ON);
 204   1      
 205   1          callback_parameter = callback_parameter;  /* Keep compiler happy. */
 206   1      }
 207          
 208          /*
 209           * This function is a callback from the superframe beacon timer for an
 210           * end deviceand implements the functionality required for entering the
 211           * inactive portion for an end device.
 212           *
 213           * callback_parameter - Callback parameter of the superframe timer
 214           */
 215          void mac_sync_start_inactive_device_cb (void *callback_parameter)
 216          {
 217   1          /*
 218   1           * Go to sleep (independent of the value of macRxOnWhenIdle)
 219   1           * because we enter the incative portion now.
 220   1           * Note: Do not use mac_sleep_trans() here, because this would check
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 5   

 221   1           * macRxOnWhenIdle first.
 222   1           */
 223   1          mac_trx_init_sleep();
 224   1      
 225   1          callback_parameter = callback_parameter;  /* Keep compiler happy. */
 226   1      }
 227          
 228          /**
 229           * loss_reason - MAC_REALIGNMENT if sync loss is due to receiving
 230           * coordinator realignment command and MAC_BEACON_LOSS if beacon was
 231           * lost following a sync request.
 232           */
 233          void mac_sync_loss (uint8_t loss_reason)
 234          {
 235   1          /*
 236   1           * Static buffer used to give sync loss indication.
 237   1           * This buffer is used
 238   1           * 1) when the device looses sync with the parents beacons
 239   1           * 2) when the device receives a coordinator realignment command from his
 240   1           *    parent
 241   1           * The buffer pointer is stored into the begin of the same static buffer.
 242   1           */
 243   1          static uint8_t mac_sync_loss_buffer[sizeof(buffer_t) +
 244   1                                              sizeof(mlme_sync_loss_ind_t)];
 245   1          mlme_sync_loss_ind_t *sync_loss_ind;
 246   1          buffer_t *msg_ptr;
 247   1      
 248   1          /* Update static buffer allocated for sync loss indication. */
 249   1          msg_ptr = (buffer_t *)mac_sync_loss_buffer;
 250   1          msg_ptr->body = &mac_sync_loss_buffer[sizeof(buffer_t)];
 251   1          sync_loss_ind = (mlme_sync_loss_ind_t *)(msg_ptr->body);
 252   1      
 253   1          sync_loss_ind->cmdcode = MLME_SYNC_LOSS_INDICATION;;
 254   1          sync_loss_ind->LossReason = loss_reason;
 255   1      
 256   1          if (MAC_SCAN_IDLE != mac_scan_state) {
 257   2              sync_loss_ind->PANId = mac_scan_orig_panid;
 258   2              sync_loss_ind->LogicalChannel = mac_scan_orig_channel;
 259   2              sync_loss_ind->ChannelPage = mac_scan_orig_page;
 260   2          } else {
 261   2              sync_loss_ind->PANId = hal_pib_PANId;
 262   2              sync_loss_ind->LogicalChannel = hal_pib_CurrentChannel;
 263   2              sync_loss_ind->ChannelPage = hal_pib_CurrentPage;
 264   2          }
 265   1      
 266   1          /* Send Sync Loss Indication message */
 267   1      #if (defined UM) && (!defined ZBMAC_DIAG)
 268   1        mlme_send_to_host(msg_ptr);
 269   1      #else
                mlme_sync_loss_ind(msg_ptr);
              #endif    
 272   1      
 273   1          /* A device that is neither scanning nor polling shall go to sleep now. */
 274   1          if ((MAC_IDLE == mac_state) || (MAC_ASSOCIATED == mac_state)) {
 275   2              if ((MAC_SCAN_IDLE == mac_scan_state) &&
 276   2                  (MAC_POLL_IDLE == mac_poll_state)) {
 277   3                  /* Set radio to sleep if allowed */
 278   3                  mac_trx_sleep();
 279   3              }
 280   2          }
 281   1      
 282   1          mac_sync_state = MAC_SYNC_NEVER;
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 6   

 283   1      }
 284          
 285          /**
 286           * This function processes a coordinator realignment command frame received
 287           * from the coordinator (while NOT being in the middle of an Orphan scan, but
 288           * rather after initiation of a start request primitive from the coordinator
 289           * indicating realingment.
 290           * The PAN ID, coord. short address, logical channel, and the device's new
 291           * short address will be written to the PIB.
 292           *
 293           * ind_p - coordinatoe realignment indication 
 294           */
 295          void mac_sync_process_coord_realign (buffer_t *ind_p)
 296          {
 297   1          /*
 298   1           * The coordinator realignment command is received without the orphan
 299   1           * notification. Hence a sync loss indication is given to NHLE.
 300   1           */
 301   1          mac_sync_loss(MAC_REALIGNMENT);
 302   1      
 303   1          /*
 304   1           * The buffer in which the coordinator realignment is received is
 305   1           * freed up
 306   1           */
 307   1          bmm_buffer_free((buffer_t *)ind_p);
 308   1      
 309   1          /* Set the appropriate PIB entries */
 310   1      
 311   1          set_hal_pib_internal(macPANId,
 312   1                               (void *)&mac_parse_data.\
 313   1                               mac_payload_data.coord_realign_data.pan_id);
 314   1      
 315   1      
 316   1          if (BROADCAST !=
 317   1              mac_parse_data.mac_payload_data.coord_realign_data.short_addr) {
 318   2              /* Short address only to be set if not broadcast address */
 319   2              set_hal_pib_internal(macShortAddress,
 320   2                                   (void *)&mac_parse_data.\
 321   2                                   mac_payload_data.coord_realign_data.short_addr);
 322   2      
 323   2          }
 324   1      
 325   1          mac_pib_macCoordShortAddress =
 326   1                  mac_parse_data.mac_payload_data.coord_realign_data.coord_short_addr;
 327   1      
 328   1          /*
 329   1           * If frame version subfield indicates a 802.15.4-2006 compatible frame,
 330   1           * the channel page is appended as additional information element.
 331   1           */
 332   1          if (mac_parse_data.fcf & FCF_FRAME_VERSION_2006) {
 333   2              set_hal_pib_internal(phyCurrentPage,
 334   2                                   (void *)&mac_parse_data.\
 335   2                                   mac_payload_data.coord_realign_data.channel_page);
 336   2          }
 337   1      
 338   1          set_hal_pib_internal(phyCurrentChannel,
 339   1                               (void *)&mac_parse_data.\
 340   1                               mac_payload_data.coord_realign_data.logical_channel);
 341   1      
 342   1      }
 343          #endif //HYBRII_802154
 344          
C51 COMPILER V9.53.0.0   MAC_SYNC                                                          11/04/2015 20:09:52 PAGE 7   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
