C51 COMPILER V9.53.0.0   MAC_HAL_INTF                                                      11/04/2015 20:09:49 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_HAL_INTF
OBJECT MODULE PLACED IN .\obj\mac_hal_intf.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_hal_intf.c LARGE OBJECTADVANCED OPTIMIZE
                    -(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\
                    -..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src
                    -\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\
                    -firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zig
                    -bee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\
                    -inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp
                    -\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_suppor
                    -t;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drive
                    -rs\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;
                    -..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\.
                    -.\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drive
                    -rs\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilit
                    -ies;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers
                    -\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\
                    -..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBR
                    -II_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SY
                    -NC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_D
                    -ETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERR
                    -UPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,R
                    -EGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_hal_intf.lst) T
                    -ABS(2) OBJECT(.\obj\mac_hal_intf.obj)

line level    source

   1          /**
   2           * @file mac_hal_intf.c
   3           *
   4           * Interface between MAC and HAL
   5           *
   6           * $Id: mac_hal_intf.c,v 1.8 2014/11/27 13:13:56 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          
  12          #ifdef HYBRII_802154
  13          
  14          /* === Includes ============================================================ */
  15          #include <stdio.h>
  16          #include <string.h>
  17          #include "papdef.h"
  18          #include "timer.h"
  19          #include "return_val.h"
  20          #include "bmm.h"
  21          #include "qmm.h"
  22          #include "mac_const.h"
  23          #include "mac_msgs.h"
  24          #include "mac_hal.h"
  25          #include "mac_api.h"
  26          #include "mac_data_structures.h"
  27          #include "mac_internal.h"
  28          #include "mac.h"
  29          #include "mac_security.h"
  30          
  31          /* === Macros =============================================================== */
  32          
  33          
  34          /* === Globals ============================================================= */
C51 COMPILER V9.53.0.0   MAC_HAL_INTF                                                      11/04/2015 20:09:49 PAGE 2   

  35          
  36          
  37          /* === Prototypes ========================================================== */
  38          
  39          /* === Implementation ====================================================== */
  40          
  41          /**
  42           * Checks whether the indirect data frame address matches
  43           * with the address passed.
  44           *
  45           * buf_p        - Pointer to indirect data buffer
  46           * search_buf_p - Pointer to the buffer to be searched
  47           *
  48           * return:
  49           * TRUE if found the search_buf_p
  50           * FALSE - otherwise
  51           */
  52          bool find_buffer (void xdata *buf_p, void xdata *search_buf_p)
  53          {
  54   1          uint8_t *buf_body_p = BMM_BUFFER_POINTER((buffer_t *)search_buf_p);
  55   1      
  56   1          if (buf_p == buf_body_p) {
  57   2              return (TRUE);
  58   2          }
  59   1          return (FALSE);
  60   1      }
  61          
  62          /**
  63           * Helper function to remove transmitted indirect data from the queue
  64           *
  65           * frame_p - Pointer to transmitted frame
  66           */
  67          static void remove_frame_from_indirect_q (frame_info_t *frame_p)
  68          {
  69   1          search_t find_buf;
  70   1      
  71   1      #ifdef CALLBACK
                  find_buf.compare_func = find_buffer;
              #else
  74   1          find_buf.compare_func_id = MAC_FIND_BUFFER;
  75   1      #endif
  76   1      
  77   1          /* Update the address to be searched */
  78   1          find_buf.handle = (void *)frame_p->buffer_header_p;
  79   1      
  80   1          qmm_queue_remove(&indirect_data_q, &find_buf);
  81   1          if (indirect_data_q.size == 0) {
  82   2              mac_hal_frame_pending(false);
  83   2          }
  84   1      }
  85          
  86          /*
  87           * mac_hal_intf_tx_frame_done
  88           *
  89           * According to the frame type that has previously been sent, the
  90           * corresponding actions are taken and the MAC returns to its standard state.
  91           *
  92           * tx_status - Status of transmission
  93           * frame_p   - Pointer to the transmitted frame
  94           */
  95          void mac_hal_intf_tx_frame_done (retval_t tx_status,
  96                                           frame_info_t *frame_p)
C51 COMPILER V9.53.0.0   MAC_HAL_INTF                                                      11/04/2015 20:09:49 PAGE 3   

  97          {
  98   1          buffer_t *mcps_buf_p;
  99   1      
 100   1          
 101   1      
 102   1          if (HAL_BC_TX_DONE == tx_status) {
 103   2              /* 
 104   2               * This is the case where the Beacon is sent
 105   2               * in CSMA mode from the beacon template.
 106   2               * No need to free the buffer as beacon is transmitted using
 107   2               * the static buffer.
 108   2               */
 109   2              mac_stats_g.tx_bc_pkts_count++;
 110   2              mac_stats_g.tx_bc_bytes_count += (frame_p->mpdu_p[0] + FCS_LEN);
 111   2              return;
 112   2          }
 113   1      
 114   1          if (tx_status != MAC_CHANNEL_ACCESS_FAILURE) {
 115   2              mac_stats_g.tx_pkts_count++;
 116   2              mac_stats_g.tx_bytes_count += (frame_p->mpdu_p[0] + FCS_LEN);
 117   2          }
 118   1      
 119   1          if (((MAC_SCAN_ACTIVE == mac_scan_state) && 
 120   1                (frame_p->msg_type == BEACONREQUEST)) ||
 121   1              ((MAC_SCAN_ORPHAN == mac_scan_state) && 
 122   1               (frame_p->msg_type == ORPHANNOTIFICATION))){
 123   2              mac_scan_send_complete(tx_status);
 124   2              return;
 125   2          }
 126   1      
 127   1          switch (frame_p->msg_type) {
 128   2          case MCPS_MESSAGE:
 129   2              mcps_buf_p = frame_p->buffer_header_p;
 130   2              if (frame_p->indirect_in_transit) {
 131   3                  frame_p->indirect_in_transit = false;
 132   3                  if (MAC_SUCCESS == tx_status ||
 133   3                      MAC_FRAME_TOO_LONG == tx_status) {
 134   4                      remove_frame_from_indirect_q(frame_p);
 135   4                      /* Create the MCPS DATA confirmation message */
 136   4                      mac_gen_mcps_data_conf((buffer_t *)mcps_buf_p,
 137   4                                             (uint8_t)tx_status,
 138   4                                             frame_p->msduHandle,
 139   4                                             frame_p->time_stamp);
 140   4                  }
 141   3              } else {
 142   3                  /* Create the MCPS DATA confirmation message */
 143   3                  mac_gen_mcps_data_conf((buffer_t *)mcps_buf_p,
 144   3                                         (uint8_t)tx_status,
 145   3                                         frame_p->msduHandle,
 146   3                                         frame_p->time_stamp);
 147   3              }
 148   2              break;
 149   2      
 150   2      
 151   2          case NULL_FRAME:
 152   2              /* Free the buffer allocated for the Null data frame */
 153   2              bmm_buffer_free(frame_p->buffer_header_p);
 154   2              break;
 155   2      
 156   2          case DISASSOCIATIONNOTIFICATION:
 157   2              break;
 158   2      
C51 COMPILER V9.53.0.0   MAC_HAL_INTF                                                      11/04/2015 20:09:49 PAGE 4   

 159   2          case ASSOCIATIONREQUEST:
 160   2              if (MAC_SUCCESS == tx_status) {
 161   3                  uint32_t response_timer;
 162   3      
 163   3                  /*
 164   3                   ^ Received ACK for Association.REQ, set timer to send Data.REQ
 165   3                   */
 166   3                  mac_poll_state = MAC_AWAIT_ASSOC_RESPONSE;
 167   3                  response_timer = mac_pib_macResponseWaitTime;
 168   3                  response_timer = HAL_CONVERT_SYMBOLS_TO_US(response_timer) / 1000;
 169   3                  if (STATUS_SUCCESS != 
 170   3                      STM_StartTimer(mac_rsp_wait_timer, response_timer)) {
 171   4                  }
 172   3                  
 173   3              } else {
 174   3                  mac_gen_mlme_associate_conf(frame_p->buffer_header_p,
 175   3                                          tx_status, BROADCAST);
 176   3              }
 177   2              break;
 178   2      
 179   2          case DATAREQUEST:           /* Caused by MLME-POLL.request */
 180   2          case DATAREQUEST_IMPL_POLL: /* poll without MLME-POLL.request */
 181   2              /* Free the data_request buffer */
 182   2              bmm_buffer_free(frame_p->buffer_header_p);
 183   2              break;
 184   2      
 185   2          case ASSOCIATIONRESPONSE:
 186   2              /*
 187   2               * Association Response is ALWAYS indirect, so not further check for
 188   2               * indirect_in_transit required, but clear the flag.
 189   2               */
 190   2              frame_p->indirect_in_transit = false;
 191   2              break;
 192   2      
 193   2          case ORPHANREALIGNMENT:
 194   2              break;
 195   2      
 196   2          case PANIDCONFLICTNOTIFICAION:
 197   2              /* 
 198   2               * Free the buffer allocated for the Pan-Id conflict
 199   2               * notification frame
 200   2               */
 201   2              bmm_buffer_free(frame_p->buffer_header_p);
 202   2              break;
 203   2      
 204   2          case COORDINATORREALIGNMENT:
 205   2              /*
 206   2               * The coordinator realignment command has been sent out
 207   2               * successfully. Hence the MAC should be updated with the new
 208   2               * parameters given in the MLME.START_request with
 209   2               * coordinator realignment command
 210   2               */
 211   2              mac_coord_realignment_command_tx_success(tx_status,
 212   2                                                       frame_p->buffer_header_p);
 213   2              break;
 214   2      
 215   2          case BEACON_MESSAGE:
 216   2              /* 
 217   2               * No need to free the buffer as beacon is transmitted using
 218   2               * the static buffer
 219   2               */
 220   2              break;
C51 COMPILER V9.53.0.0   MAC_HAL_INTF                                                      11/04/2015 20:09:49 PAGE 5   

 221   2      
 222   2          default:
 223   2              return;
 224   2          }
 225   1      }
 226          #endif //HYBRII_802154


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    688    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
