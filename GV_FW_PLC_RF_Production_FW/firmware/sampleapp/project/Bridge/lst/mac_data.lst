C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_DATA
OBJECT MODULE PLACED IN .\obj\mac_data.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_data.c LARGE OBJECTADVANCED OPTIMIZE(9,S
                    -IZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\.
                    -.\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal
                    -;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firm
                    -ware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;
                    -..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;
                    -..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc
                    -;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..
                    -\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\h
                    -pgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\.
                    -.\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\co
                    -mponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\f
                    -lash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;
                    -..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk
                    -\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\.
                    -.\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8
                    -051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,U
                    -M,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETEC
                    -T,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,
                    -MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIS
                    -TER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_data.lst) TABS(2) O
                    -BJECT(.\obj\mac_data.obj)

line level    source

   1          /**
   2           * @file mac_data.c
   3           *
   4           * Implements incoming frame handling in the MAC
   5           *
   6           * $Id: mac_data.c,v 1.6 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          #ifdef HYBRII_802154
  12          
  13          /* === Includes ============================================================ */
  14          #ifdef RTX51_TINY_OS
  15          #include <rtx51tny.h>
  16          #include "hybrii_tasks.h"
  17          #endif
  18          #include <stdio.h>
  19          #include <string.h>
  20          #include "papdef.h"
  21          #include "timer.h"
  22          #include "return_val.h"
  23          #include "bmm.h"
  24          #include "qmm.h"
  25          #include "utils_fw.h"
  26          #include "mac_const.h"
  27          #include "mac_msgs.h"
  28          #include "mac_hal.h"
  29          #include "mac_api.h"
  30          #include "mac_data_structures.h"
  31          #include "mac_internal.h"
  32          #include "mac_security.h"
  33          #include "mac.h"
  34          #include "fm.h"
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 2   

  35          
  36          /*
  37           * Mask of the GTS descriptor counter
  38           */
  39          #define GTS_DESCRIPTOR_COUNTER_MASK     (0x07)
  40          
  41          /*
  42           * Extract the PAN Coordinator bit from the Superframe Spec.
  43           */
  44          #define GET_PAN_COORDINATOR(spec)      (((spec) & 0x4000) >> 14)
  45          
  46          /*
  47           * PAN-Id conflict notification payload length
  48           */
  49          #define PAN_ID_CONFLICT_PAYLOAD_LEN     (1)
  50          
  51          /*
  52           * Data request payload length
  53           */
  54          #define DATA_REQ_PAYLOAD_LEN            (1)
  55          
  56          
  57          /* === Implementation ====================================================== */
  58          
  59          /*
  60           * Constructs a null data frame
  61           *
  62           * return Pointer to the created null data frame, NULL otherwise.
  63           */
  64          static buffer_t * mac_data_build_null_frame (void)
  65          {
  66   1          bool         use_long_addr_dest;
  67   1          frame_info_t *tx_frame_p;
  68   1          uint8_t      frame_len;
  69   1          uint8_t      *frame_ptr;
  70   1          uint16_t     fcf = 0;
  71   1          buffer_t     *buf_ptr = bmm_buffer_alloc(BUFFER_SIZE);
  72   1      
  73   1          if (NULL == buf_ptr) {
  74   2              return NULL;
  75   2          }
  76   1      
  77   1          tx_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_ptr);
  78   1      
  79   1          /* No data payload, this is a null packet.*/
  80   1          tx_frame_p->msg_type = NULL_FRAME;
  81   1          tx_frame_p->buffer_header_p = buf_ptr;
  82   1      
  83   1          /* No indirect transmission. */
  84   1          tx_frame_p->indirect_in_transit = false;
  85   1      
  86   1          /* Update the payload length. */
  87   1          frame_len = SHORT_ADDR_LEN +  // short Destination Address
  88   1                      PAN_ID_LEN     +  // Destination PAN-Id
  89   1                      SHORT_ADDR_LEN +  // short Source Address
  90   1                      SEQ_NUM_LEN    +  // Sequence number
  91   1                      FCF_LEN;          // FCF
  92   1      
  93   1          /* Get the payload pointer. */
  94   1          frame_ptr = (uint8_t *)tx_frame_p + BUFFER_SIZE;
  95   1      
  96   1          /*
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 3   

  97   1           * Set Source Address.
  98   1           */
  99   1          if ((BROADCAST == hal_pib_ShortAddress) ||
 100   1              (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress)) {
 101   2              /* Use long address as source address. */
 102   2              frame_ptr -= EXT_ADDR_LEN;
 103   2              frame_len += 6;  /* Already add 2 bytes for short addr above */
 104   2              mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 105   2              fcf |= FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR);
 106   2          } else {
 107   2              /* Use short address as source address. */
 108   2              frame_ptr -= SHORT_ADDR_LEN;
 109   2              mac_utils_16_bit_to_byte_array(hal_pib_ShortAddress, frame_ptr);
 110   2              fcf |= FCF_SET_SOURCE_ADDR_MODE(FCF_SHORT_ADDR);
 111   2          }
 112   1      
 113   1          /* Shall the Intra-PAN bit set? */
 114   1          if (hal_pib_PANId == mac_parse_data.src_panid) {
 115   2              /*
 116   2               * Both PAN-Ids are identical.
 117   2               * Set intra-PAN bit.
 118   2               */
 119   2              fcf |= FCF_PAN_ID_COMPRESSION;
 120   2          } else {
 121   2              /* Set Source PAN-Id. */
 122   2              frame_ptr -= PAN_ID_LEN;
 123   2              frame_len += PAN_ID_LEN;
 124   2              mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 125   2          }
 126   1      
 127   1          /* Set Destination Address. */
 128   1          use_long_addr_dest = (FCF_LONG_ADDR == mac_parse_data.src_addr_mode);
 129   1      
 130   1          /* Destination address is set from source address of received frame. */
 131   1          if (use_long_addr_dest) {
 132   2              frame_ptr -= EXT_ADDR_LEN;
 133   2              frame_len += 6; /* Already add 2 bytes for short addr above */
 134   2              mac_utils_64_bit_to_byte_array(mac_parse_data.src_addr.long_address,
 135   2                                             frame_ptr);
 136   2      
 137   2              fcf |= FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR) |
 138   2                     FCF_SET_FRAMETYPE(FCF_FRAMETYPE_DATA);
 139   2          } else {
 140   2              frame_ptr -= SHORT_ADDR_LEN;
 141   2              mac_utils_16_bit_to_byte_array(mac_parse_data.src_addr.short_address,
 142   2                                             frame_ptr);
 143   2              fcf |= FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR) |
 144   2                    FCF_SET_FRAMETYPE(FCF_FRAMETYPE_DATA);
 145   2          }
 146   1      
 147   1          /* Destination PANId is set from source PANId of received frame. */
 148   1          frame_ptr -= PAN_ID_LEN;
 149   1          mac_utils_16_bit_to_byte_array(mac_parse_data.src_panid, frame_ptr);
 150   1      
 151   1          /* Set DSN. */
 152   1          frame_ptr -= SEQ_NUM_LEN;
 153   1          *frame_ptr = mac_pib_macDSN++;
 154   1      
 155   1      
 156   1          /* Set the FCF. */
 157   1          frame_ptr -= FCF_LEN;
 158   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 4   

 159   1      
 160   1      
 161   1          /* First element shall be length of PHY frame. */
 162   1          frame_ptr -= LENGTH_FIELD_LEN;
 163   1          *frame_ptr = frame_len;
 164   1      
 165   1          /* Finished building of frame. */
 166   1          tx_frame_p->mpdu_p = frame_ptr;
 167   1      
 168   1          return buf_ptr;
 169   1      }
 170          
 171          /*
 172           * This function creates and transmits a Null Data frame in case the
 173           * coordinator does not have pending data to be transmitted.
 174           */
 175          void mac_data_tx_null_frame (void)
 176          {
 177   1          frame_info_t *tx_frame_p;
 178   1          retval_t     tx_status;
 179   1          buffer_t     *buf_ptr;
 180   1      
 181   1          /*
 182   1           * No matching pending item in the queue,
 183   1           * so a Null Data frame is created.
 184   1           */
 185   1          buf_ptr = mac_data_build_null_frame();
 186   1      
 187   1          if (NULL != buf_ptr) {
 188   2              tx_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_ptr);
 189   2      
 190   2              /*
 191   2               * Transmission should be done with CSMA-CA or
 192   2               * quickly after the ACK of the data request command.
 193   2               * Here it's done quickly after the ACK w/o CSMA.
 194   2               */
 195   2              tx_status = mac_hal_tx_frame(tx_frame_p, NO_CSMA, FALSE);
 196   2      
 197   2              if (MAC_SUCCESS == tx_status) {
 198   3                  MAC_BUSY();
 199   3              } else {
 200   3                  /*
 201   3                   * Transmission to HAL failed, free up the buffer used to create
 202   3                   * Null Data frame.
 203   3                   */
 204   3                  bmm_buffer_free(buf_ptr);
 205   3              }
 206   2          }
 207   1      }
 208          
 209          /*
 210           *
 211           * This callback function checks whether the passed short address
 212           * matches with the frame in the queue.
 213           *
 214           * buf_p      - Pointer to indirect data buffer
 215           * short_addr - Short address to be searched
 216           *
 217           * return true if short address passed matches with the destination
 218           * address of the indirect frame , false otherwise
 219           */
 220          bool mac_data_find_short_addr_buffer (void *buf_p, void *short_addr_p)
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 5   

 221          {
 222   1          uint8_t dst_addr_mode;
 223   1          frame_info_t *data_p = (frame_info_t *)buf_p;
 224   1      
 225   1          if (data_p->indirect_in_transit == FALSE) {
 226   2              /*
 227   2               * Read octet 2 of Frame Control Field containing the type
 228   2               * of destination address.
 229   2               */
 230   2              dst_addr_mode = (data_p->mpdu_p[PL_POS_FCF_2] >>
 231   2                               FCF_2_DEST_ADDR_OFFSET) & FCF_ADDR_MASK;
 232   2      
 233   2              /*
 234   2               * Compare indirect data frame's dest_address(short)
 235   2               * with short address passed.
 236   2               */
 237   2              if ((dst_addr_mode == FCF_SHORT_ADDR) &&
 238   2                  (*(uint16_t *)short_addr_p == mac_utils_byte_array_to_16_bit(
 239   2                   &data_p->mpdu_p[PL_POS_DST_ADDR_START]))) {
 240   3                  return (true);
 241   3              }
 242   2          }
 243   1      
 244   1          return (false);
 245   1      }
 246          
 247          /*
 248           *
 249           * This callback function checks whether the passed short address
 250           * matches with the frame in the queue.
 251           *
 252           * buf_p       - Pointer to indirect data buffer
 253           * long_addr_p - Extended address to be searched
 254           *
 255           * return true if extended address passed matches with the destination
 256           * address of the indirect frame, false otherwise
 257           */
 258          bool mac_data_find_long_addr_buffer (void *buf_p, void *long_addr_p)
 259          {
 260   1          uint8_t dst_addr_mode;
 261   1          frame_info_t *data_p = (frame_info_t *)buf_p;
 262   1      
 263   1          if (data_p->indirect_in_transit == FALSE) {
 264   2              /*
 265   2               * Read octet 2 of Frame Control Field containing the type
 266   2               * of destination address.
 267   2               */
 268   2              dst_addr_mode = (data_p->mpdu_p[PL_POS_FCF_2] >>
 269   2                               FCF_2_DEST_ADDR_OFFSET) & FCF_ADDR_MASK;
 270   2      
 271   2              /*
 272   2               * Compare indirect data frame's dest_address(extended)
 273   2               * with the exended address passed.
 274   2               */
 275   2              if (dst_addr_mode == FCF_LONG_ADDR) {
 276   3                  uint64_t addr_in, addr_indirect;
 277   3      
 278   3            addr_in = *(uint64_t *)long_addr_p;
 279   3            addr_indirect = 
 280   3                mac_utils_byte_array_to_64_bit(
 281   3                          &data_p->mpdu_p[PL_POS_DST_ADDR_START]);
 282   3                  if (EXT_ADDR_MATCH(addr_in, addr_indirect)) {
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 6   

 283   4                      return (true);
 284   4                  }
 285   3              }
 286   2          }
 287   1      
 288   1          return (false);
 289   1      }
 290          
 291          /**
 292           *
 293           * This function processes a received data request command frame
 294           * at the coordinator, searches for pending indirect data frames
 295           * for the originator and initiates the frame transmission of the
 296           * data frame with CSMA-CA.
 297           *
 298           * buf_p - Frame reception buffer pointer
 299           */
 300          void mac_data_process_data_request (buffer_t *buf_p)
 301          {
 302   1          /* Buffer pointer to next indirect data frame to be transmitted. */
 303   1          buffer_t     *buf_next_data_p;
 304   1          search_t     find_buf;
 305   1          frame_info_t *tx_frame_p;
 306   1          retval_t     tx_status;
 307   1      
 308   1          /* Free the buffer of the received frame. */
 309   1          bmm_buffer_free(buf_p);
 310   1      
 311   1          /* Ignore data request if we are not PAN coordinator or coordinator. */
 312   1          if ((MAC_IDLE == mac_state) ||
 313   1              (MAC_ASSOCIATED == mac_state)) {
 314   2              return;
 315   2          }
 316   1      
 317   1          /* Check the addressing mode */
 318   1          if (mac_parse_data.src_addr_mode == FCF_SHORT_ADDR) {
 319   2              /*
 320   2               * Look for pending data in the indirect queue for
 321   2               * this short address.
 322   2               */
 323   2      
 324   2              /*
 325   2               * Assign the function pointer for searching the
 326   2               * data having address of the requested device.
 327   2               */
 328   2      #ifdef CALLBACK
                      find_buf.compare_func = mac_data_find_short_addr_buffer;
              #else
 331   2              find_buf.compare_func_id = MAC_DATA_FIND_SHORT_ADDR;
 332   2      #endif
 333   2      
 334   2              /* Update the short address to be searched. */
 335   2              find_buf.handle = &mac_parse_data.src_addr.short_address;
 336   2          } else if (mac_parse_data.src_addr_mode == FCF_LONG_ADDR) {
 337   2              /*
 338   2               * Look for pending data in the indirect queue for
 339   2               * this long address.
 340   2               */
 341   2      
 342   2              /*
 343   2               * Assign the function pointer for searching the
 344   2               * data having address of the requested device.
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 7   

 345   2               */
 346   2      #ifdef CALLBACK
                      find_buf.compare_func = mac_data_find_long_addr_buffer;
              #else
 349   2              find_buf.compare_func_id = MAC_DATA_FIND_EXT_ADDR;
 350   2      #endif
 351   2      
 352   2              /* Update the long address to be searched. */
 353   2              find_buf.handle = &mac_parse_data.src_addr.long_address;
 354   2          } else {
 355   2              return;
 356   2          }
 357   1      
 358   1          /*
 359   1           * Read from the indirect queue. The removal of items from this queue
 360   1           * will be done after successful transmission of the frame.
 361   1           */
 362   1          buf_next_data_p = qmm_queue_read(&indirect_data_q, &find_buf);
 363   1          /* Note: The find_buf structure is reused below, so do not change this. */
 364   1      
 365   1          if (NULL == buf_next_data_p) {
 366   2              mac_data_tx_null_frame();
 367   2              return;
 368   2          } else {
 369   2              /* Indirect data found and to be sent. */
 370   2              tx_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_next_data_p);
 371   2      
 372   2              /*
 373   2               * We need to check whether the source PAN-Id of the previously
 374   2               * received data request frame is identical to the destination PAN-Id
 375   2               * of the pending frame. If not the frame shall not be transmitted,
 376   2               * but a Null Data frame instead.
 377   2               */
 378   2              if (mac_parse_data.src_panid !=
 379   2                  mac_utils_byte_array_to_16_bit(
 380   2                      &tx_frame_p->mpdu_p[PL_POS_DST_PAN_ID_START])) {
 381   3                  mac_data_tx_null_frame();
 382   3                  return;
 383   3              } else {
 384   3                  /*
 385   3                   * The frame to be transmitted next is marked.
 386   3                   * This is necessary since the queue needs to be traversed again
 387   3                   * to find other pending indirect data frames for this particular
 388   3                   * recipient.
 389   3                   */
 390   3                  tx_frame_p->indirect_in_transit = true;
 391   3                  tx_frame_p->buffer_header_p = buf_next_data_p;
 392   3      
 393   3                  /*
 394   3                   * Go through the indirect data queue to find out the frame
 395   3                   * pending for the device which has requested for the data.
 396   3                   */
 397   3                  /*
 398   3                   * Since the buffer header has already been stored in
 399   3                   * transmit_frame->buffer_header, it can be reused here for
 400   3                   * other purpose.
 401   3                   */
 402   3                  /*
 403   3                   * It is assumed that the find_buf struct does still have
 404   3                   * the original values from above.
 405   3                   */
 406   3                  buf_next_data_p = qmm_queue_read(&indirect_data_q, &find_buf);
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 8   

 407   3                  /*
 408   3                   * Check whether there is another indirect data available
 409   3                   * for the same recipient.
 410   3                   */
 411   3                  if (NULL != buf_next_data_p) {
 412   4                      tx_frame_p->mpdu_p[PL_POS_FCF_1] |= FCF_FRAME_PENDING;
 413   4                  }
 414   3              }
 415   2      
 416   2              /*
 417   2               * Transmission should be done with CSMA-CA or
 418   2               * quickly after the ACK of the data request command.
 419   2               * Here it's done quickly after the ACK w/o CSMA.
 420   2               */
 421   2              tx_status = mac_hal_tx_frame(tx_frame_p, NO_CSMA, FALSE);
 422   2      
 423   2              if (MAC_SUCCESS == tx_status) {
 424   3                  MAC_BUSY();
 425   3              } else {
 426   3                  /*
 427   3                   * TAL rejects frame transmission, since it's too close to the next
 428   3                   * beacon transmission. The frame is kept in the indirect queue.
 429   3                   */
 430   3                  tx_frame_p->indirect_in_transit = false;
 431   3              }
 432   2          }
 433   1      }
 434          
 435          static void mac_data_promis_mode_rx_frame (buffer_t *b_ptr,
 436                                                     frame_info_t *f_ptr)
 437          {
 438   1          mcps_data_ind_t *mdi = (mcps_data_ind_t *)BMM_BUFFER_POINTER(b_ptr);
 439   1      
 440   1          /*
 441   1           * In promiscous mode the MCPS_DATA.indication is used as container
 442   1           * for the received frame.
 443   1           */
 444   1      
 445   1      
 446   1          /*
 447   1           * Since both f_ptr and mdi point to the same data storage place,
 448   1           * we need to save all required data first.
 449   1           * The time stamp has already been saved into .
 450   1           * So lets save the payload now.
 451   1           */
 452   1      
 453   1          /* Set payload pointer to MPDU of received frame. */
 454   1          mdi->msduLength = f_ptr->mpdu_p[0];
 455   1          mdi->msdu_p = &f_ptr->mpdu_p[1];
 456   1          
 457   1      
 458   1          /* Build the MLME_Data_indication parameters */
 459   1          mdi->DSN = 0;
 460   1          mdi->Timestamp = f_ptr->time_stamp;
 461   1      
 462   1          /* Source address mode is 0. */
 463   1          mdi->SrcAddrMode = FCF_NO_ADDR;
 464   1          mdi->SrcPANId = 0;
 465   1          mdi->SrcAddr.lo_u32 = 0;
 466   1          mdi->SrcAddr.hi_u32 = 0;
 467   1                        
 468   1          /* Destination address mode is 0.*/
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 9   

 469   1          mdi->DstAddrMode = FCF_NO_ADDR;
 470   1          mdi->DstPANId = 0;
 471   1          mdi->DstAddr.lo_u32 = 0;
 472   1          mdi->DstAddr.hi_u32 = 0;
 473   1      
 474   1          mdi->mpduLinkQuality = mac_parse_data.ppdu_link_quality;
 475   1          mdi->cmdcode = MCPS_DATA_INDICATION;
 476   1      
 477   1      #if (defined UM) && (!defined ZBMAC_DIAG) 
 478   1        mlme_send_to_host(b_ptr);
 479   1      #else
                  mcps_data_ind(b_ptr);
              #endif        
 482   1      }
 483          
 484          /*
 485           * Helper function to extract the complete address information
 486           *        of the received frame
 487           *
 488           * frame_ptr - Pointer to first octet of Addressing fields of received frame
 489           *        (See IEEE 802.15.4-2006 Figure 41)
 490           *
 491           * return:
 492           * Length of Addressing fields
 493           */
 494          static uint8_t mac_data_extract_mhr_addr_info (uint8_t *frame_ptr)
 495          {
 496   1          uint16_t fcf = mac_parse_data.fcf;
 497   1          uint8_t src_addr_mode = (fcf >> FCF_SOURCE_ADDR_OFFSET) & FCF_ADDR_MASK;
 498   1          uint8_t dst_addr_mode = (fcf >> FCF_DEST_ADDR_OFFSET) & FCF_ADDR_MASK;
 499   1          bool intra_pan = fcf & FCF_PAN_ID_COMPRESSION;
 500   1          uint8_t addr_field_len = 0;
 501   1      
 502   1          if (dst_addr_mode != 0) {
 503   2              mac_parse_data.dest_panid = 
 504   2                                  mac_utils_byte_array_to_16_bit(frame_ptr);
 505   2              frame_ptr += PAN_ID_LEN;
 506   2              addr_field_len += PAN_ID_LEN;
 507   2      
 508   2              if (FCF_SHORT_ADDR == dst_addr_mode) {
 509   3                  /*
 510   3                   * First initialize the complete long address with zero, since
 511   3                   * later only 16 bit are actually written.
 512   3                   */
 513   3                  mac_parse_data.dest_addr.long_address.lo_u32 = 0;
 514   3                  mac_parse_data.dest_addr.long_address.hi_u32 = 0;
 515   3                  mac_parse_data.dest_addr.short_address = 
 516   3                                    mac_utils_byte_array_to_16_bit(frame_ptr);
 517   3                  frame_ptr += SHORT_ADDR_LEN;
 518   3                  addr_field_len += SHORT_ADDR_LEN;
 519   3              } else if (FCF_LONG_ADDR == dst_addr_mode) {
 520   3                  mac_parse_data.dest_addr.long_address = 
 521   3                                    mac_utils_byte_array_to_64_bit(frame_ptr);
 522   3                  frame_ptr += EXT_ADDR_LEN;
 523   3                  addr_field_len += EXT_ADDR_LEN;
 524   3              }
 525   2          }
 526   1      
 527   1          if (src_addr_mode != 0) {
 528   2              if (!intra_pan) {
 529   3                  /*
 530   3                   * Source PAN ID is present in the frame only if the intra-PAN bit
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 10  

 531   3                   * is zero and src_addr_mode is non zero.
 532   3                   */
 533   3                  mac_parse_data.src_panid =
 534   3                                    mac_utils_byte_array_to_16_bit(frame_ptr);
 535   3                  frame_ptr += PAN_ID_LEN;
 536   3                  addr_field_len += PAN_ID_LEN;
 537   3              } else {
 538   3                  /*
 539   3                   * The received frame does not contain a source PAN ID, hence
 540   3                   * source PAN ID is updated with the destination PAN ID.
 541   3                   */
 542   3                  mac_parse_data.src_panid = mac_parse_data.dest_panid;
 543   3              }
 544   2      
 545   2              /* The source address is updated. */
 546   2              if (FCF_SHORT_ADDR == src_addr_mode) {
 547   3                  /*
 548   3                   * First initialize the complete long address with zero, since
 549   3                   * later only 16 bit are actually written.
 550   3                   */
 551   3                  mac_parse_data.src_addr.long_address.lo_u32 = 0;
 552   3                  mac_parse_data.src_addr.long_address.hi_u32 = 0;
 553   3                  mac_parse_data.src_addr.short_address = 
 554   3                                        mac_utils_byte_array_to_16_bit(frame_ptr);
 555   3                  frame_ptr += SHORT_ADDR_LEN;
 556   3                  addr_field_len += SHORT_ADDR_LEN;
 557   3              } else if (FCF_LONG_ADDR == src_addr_mode) {
 558   3            mac_parse_data.src_addr.long_address = 
 559   3                                        mac_utils_byte_array_to_64_bit(frame_ptr);
 560   3                  frame_ptr += EXT_ADDR_LEN;
 561   3                  addr_field_len += EXT_ADDR_LEN;
 562   3              }
 563   2          }
 564   1      
 565   1          /*
 566   1           * The length of the Addressing Field is known, so the length of the
 567   1           * MAC payload can be calcluated.
 568   1           * The actual MAC payload length is calculated from
 569   1           * the length of the mpdu minus 2 octets FCS, minus 1 octet sequence
 570   1           * number, minus the length of the addressing fields, minus 2 octet FCS.
 571   1           */
 572   1          mac_parse_data.mac_payload_length = mac_parse_data.mpdu_length -
 573   1                                              FCF_LEN -
 574   1                                              SEQ_NUM_LEN -
 575   1                                              addr_field_len -
 576   1                                              FCS_LEN;
 577   1          mac_parse_data.src_addr_mode = src_addr_mode;
 578   1          mac_parse_data.dest_addr_mode = dst_addr_mode;
 579   1      
 580   1          return (addr_field_len);
 581   1      }
 582          
 583          static void mac_data_parse_cmd (uint8_t  *temp_frame_ptr,
 584                                          uint8_t  payload_index,
 585                                          uint16_t fcf)
 586          {
 587   1          payload_index = 1;
 588   1      
 589   1          switch (mac_parse_data.mac_command) {
 590   2          case ASSOCIATIONREQUEST:
 591   2              mac_parse_data.mac_payload_data.assoc_req_data.capability_info =
 592   2                       temp_frame_ptr[payload_index++];
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 11  

 593   2              break;
 594   2      
 595   2          case ASSOCIATIONRESPONSE:
 596   2              memcpy(&mac_parse_data.mac_payload_data.assoc_response_data.short_addr,
 597   2                     &temp_frame_ptr[payload_index], sizeof(uint16_t));
 598   2              payload_index += sizeof(uint16_t);
 599   2              mac_parse_data.mac_payload_data.assoc_response_data.assoc_status =
 600   2                     temp_frame_ptr[payload_index];
 601   2              break;
 602   2      
 603   2          case DISASSOCIATIONNOTIFICATION:
 604   2              mac_parse_data.mac_payload_data.disassoc_req_data.disassoc_reason =
 605   2                     temp_frame_ptr[payload_index++];
 606   2              break;
 607   2      
 608   2          case COORDINATORREALIGNMENT:
 609   2              memcpy(&mac_parse_data.mac_payload_data.coord_realign_data.pan_id,
 610   2                     &temp_frame_ptr[payload_index], sizeof(uint16_t));
 611   2              payload_index += sizeof(uint16_t);
 612   2              memcpy(&mac_parse_data.mac_payload_data.coord_realign_data.\
 613   2                     coord_short_addr, &temp_frame_ptr[payload_index],
 614   2                     sizeof(uint16_t));
 615   2              payload_index += sizeof(uint16_t);
 616   2      
 617   2              mac_parse_data.mac_payload_data.coord_realign_data.logical_channel =
 618   2                          temp_frame_ptr[payload_index++];
 619   2      
 620   2              memcpy(&mac_parse_data.mac_payload_data.coord_realign_data.short_addr,
 621   2                     &temp_frame_ptr[payload_index], sizeof(uint16_t));
 622   2              payload_index += sizeof(uint16_t);
 623   2      
 624   2              /*
 625   2               * If frame version subfield indicates a 802.15.4-2006 compatible 
 626   2               * frame, the channel page is appended as additional information
 627   2               *  element.
 628   2               */
 629   2              if (fcf & FCF_FRAME_VERSION_2006) {
 630   3                  mac_parse_data.mac_payload_data.coord_realign_data.channel_page =
 631   3                        temp_frame_ptr[payload_index++];
 632   3              }
 633   2              break;
 634   2      
 635   2          case ORPHANNOTIFICATION:
 636   2          case DATAREQUEST:
 637   2          case BEACONREQUEST:
 638   2          case PANIDCONFLICTNOTIFICAION:
 639   2              break;
 640   2      
 641   2          default:
 642   2              return;
 643   2          }
 644   1      }
 645          
 646          static void mac_data_parse_data (uint8_t *temp_frame_ptr,
 647                                           uint8_t payload_index)
 648          {
 649   1          if (mac_parse_data.mac_payload_length) {
 650   2              /*
 651   2               * In case the device got a frame with a corrupted payload
 652   2               * length
 653   2               */
 654   2              if (mac_parse_data.mac_payload_length >= aMaxMACPayloadSize) {
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 12  

 655   3                  mac_parse_data.mac_payload_length = aMaxMACPayloadSize;
 656   3              }
 657   2      
 658   2              /*
 659   2               * Copy the pointer to the data frame payload for
 660   2               * further processing later.
 661   2               */
 662   2              mac_parse_data.mac_payload_data.payload_data.payload_p = 
 663   2                                                     &temp_frame_ptr[payload_index];
 664   2          } else {
 665   2              mac_parse_data.mac_payload_length = 0;
 666   2          }
 667   1      }
 668          
 669          static void mac_data_parse_beacon (uint8_t *temp_frame_ptr,
 670                                             uint8_t payload_index)
 671          {
 672   1          uint8_t temp_byte;
 673   1          uint8_t number_bytes_short_addr;
 674   1          uint8_t number_bytes_long_addr;
 675   1      
 676   1          /* Get the Superframe specification */
 677   1          mac_parse_data.mac_payload_data.beacon_data.superframe_spec =
 678   1              mac_utils_byte_array_to_16_bit(&temp_frame_ptr[payload_index]);
 679   1          payload_index += sizeof(uint16_t);
 680   1      
 681   1          /* Get the GTS specification */
 682   1          mac_parse_data.mac_payload_data.beacon_data.gts_spec = 
 683   1                                                   temp_frame_ptr[payload_index++];
 684   1      
 685   1          /*
 686   1           * If the GTS specification descriptor count is > 0, then
 687   1           * increase the index by the correct GTS field octet number
 688   1           * GTS directions and GTS address list will not be parsed
 689   1           */
 690   1          temp_byte = (mac_parse_data.mac_payload_data.beacon_data.gts_spec &
 691   1                       GTS_DESCRIPTOR_COUNTER_MASK);
 692   1          if (temp_byte > 0) {
 693   2              /* 1 octet GTS diresctions + GTS address list */
 694   2              payload_index += 1 + temp_byte;
 695   2          }
 696   1      
 697   1          /* Get the Pending address specification */
 698   1          mac_parse_data.mac_payload_data.beacon_data.pending_addr_spec =
 699   1                      temp_frame_ptr[payload_index++];
 700   1              /*
 701   1               * If the Pending address specification indicates that the number of
 702   1               * short or long addresses is > 0, then get the short and/or
 703   1               * long addresses
 704   1               */
 705   1          number_bytes_short_addr = NUM_SHORT_PEND_ADDR(
 706   1                      mac_parse_data.mac_payload_data.beacon_data.pending_addr_spec);
 707   1          number_bytes_long_addr = NUM_LONG_PEND_ADDR(
 708   1                      mac_parse_data.mac_payload_data.beacon_data.pending_addr_spec);
 709   1      
 710   1          if ((number_bytes_short_addr) || (number_bytes_long_addr)) {
 711   2              mac_parse_data.mac_payload_data.beacon_data.pending_addr_list_p =
 712   2                                  &temp_frame_ptr[payload_index];
 713   2          }
 714   1      
 715   1          if (number_bytes_short_addr) {
 716   2              payload_index += (number_bytes_short_addr * sizeof(uint16_t));
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 13  

 717   2          }
 718   1      
 719   1          if (number_bytes_long_addr) {
 720   2              payload_index += (number_bytes_long_addr * sizeof(uint64_t));
 721   2          }
 722   1      
 723   1              /* Is there a beacon payload ? */
 724   1          if (mac_parse_data.mac_payload_length > payload_index) {
 725   2              mac_parse_data.mac_payload_data.beacon_data.beacon_payload_len =
 726   2                                   mac_parse_data.mac_payload_length - payload_index;
 727   2      
 728   2              /* Store pointer to received beacon payload. */
 729   2              mac_parse_data.mac_payload_data.beacon_data.beacon_payload_p =
 730   2                                      &temp_frame_ptr[payload_index];
 731   2      
 732   2          } else {
 733   2              mac_parse_data.mac_payload_data.beacon_data.beacon_payload_len = 0;
 734   2          }
 735   1      }
 736          
 737          /*
 738           * Parse an MPDU
 739           *
 740           * This function parses an MPDU which got from data_indication,
 741           * and leaves the parse result in mac_parse_data.
 742           *
 743           * rx_frame_ptr - Pointer to frame received from TAL
 744           *
 745           * return:
 746           * TRUE - frame OK
 747           * FALSE- frame is invalid.
 748           */
 749          static bool mac_data_parse_mpdu (frame_info_t *rx_frame_ptr)
 750          {
 751   1          uint8_t     payload_index;
 752   1          uint16_t    fcf;
 753   1          uint8_t     *temp_frame_ptr = &(rx_frame_ptr->mpdu_p[1]);
 754   1          /* temp_frame_ptr points now to first octet of FCF. */
 755   1      
 756   1          /* Extract the FCF. */
 757   1          fcf = mac_utils_byte_array_to_16_bit(temp_frame_ptr);
 758   1          mac_parse_data.fcf = fcf;
 759   1          temp_frame_ptr += 2;
 760   1      
 761   1          /* Extract the Sequence Number. */
 762   1          mac_parse_data.sequence_number = *temp_frame_ptr++;
 763   1      
 764   1          /* Extract the complete address information from the MHR. */
 765   1          temp_frame_ptr += mac_data_extract_mhr_addr_info(temp_frame_ptr);
 766   1          /*
 767   1           * Note: temp_frame_ptr points now to the Auxiliry Security Header or
 768   1           * the first octet of the MAC payload if available.
 769   1           */
 770   1      
 771   1          mac_parse_data.frame_type = FCF_GET_FRAMETYPE(fcf);
 772   1      
 773   1          if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) {
 774   2              mac_parse_data.mac_command = *temp_frame_ptr;
 775   2          }
 776   1      
 777   1          payload_index = 0;
 778   1      
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 14  

 779   1          /* The timestamping is only required for beaconing networks. */
 780   1          mac_parse_data.time_stamp = rx_frame_ptr->time_stamp;
 781   1      
 782   1          if (fcf & FCF_SECURITY_ENABLED) {
 783   2              retval_t status;
 784   2              status = mac_unsecure(&mac_parse_data, rx_frame_ptr->mpdu_p, 
 785   2                                    temp_frame_ptr, &payload_index);
 786   2      
 787   2              if (status != MAC_SUCCESS) {
 788   3                  mlme_comm_status_ind_t *csi_p;
 789   3      
 790   3                  /* Generate MLME-COMM-STATUS.indication. */
 791   3                  /*
 792   3                   * In order to not interfere with the regular flow of parsing the
 793   3                   * frame and buffer handling, a fresh buffer is seized for the
 794   3                   * MLME-COMM-STATUS.indication, which will be release at the API
 795   3                   * level.
 796   3                   */
 797   3                  buffer_t *buffer_header = bmm_buffer_alloc(BUFFER_SIZE);
 798   3      
 799   3                  if (NULL == buffer_header) {
 800   4                      /* Buffer is not available */
 801   4              FM_Printf(FM_APP, "\nba:mpduF");
 802   4                      return (false);
 803   4                  }
 804   3      
 805   3                  /* Get the buffer body from buffer header */
 806   3                  csi_p = 
 807   3                          (mlme_comm_status_ind_t*)BMM_BUFFER_POINTER(buffer_header);
 808   3      
 809   3                  csi_p->cmdcode = MLME_COMM_STATUS_INDICATION;
 810   3      
 811   3                  csi_p->PANId = hal_pib_PANId;
 812   3      
 813   3                  csi_p->SrcAddrMode = mac_parse_data.src_addr_mode;
 814   3                  csi_p->SrcAddr = mac_parse_data.src_addr.long_address;
 815   3      
 816   3                  csi_p->DstAddrMode = mac_parse_data.dest_addr_mode;
 817   3                  csi_p->DstAddr = mac_parse_data.dest_addr.long_address;
 818   3      
 819   3                  csi_p->status = status;
 820   3      
 821   3      #if (defined UM) && (!defined ZBMAC_DIAG)
 822   3            mlme_send_to_host(buffer_header);
 823   3      #else
                    mlme_comm_status_ind(buffer_header);
              #endif
 826   3      
 827   3                  /*
 828   3                   * Return false - this will lead to the release of the original 
 829   3                   * buffer.
 830   3                   */
 831   3                  return (false);
 832   3              }
 833   2          } else {
 834   2              // 7.5.8.2.3 a)
 835   2              mac_parse_data.sec_ctrl.sec_level = 0;
 836   2          }
 837   1      
 838   1          /* temp_frame_ptr still points to the first octet of the MAC payload. */
 839   1          switch (mac_parse_data.frame_type) {
 840   2          case FCF_FRAMETYPE_BEACON:
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 15  

 841   2              mac_data_parse_beacon(temp_frame_ptr, payload_index);
 842   2              break;
 843   2      
 844   2          case FCF_FRAMETYPE_DATA:
 845   2              mac_data_parse_data(temp_frame_ptr, payload_index);
 846   2              break;
 847   2      
 848   2          case FCF_FRAMETYPE_MAC_CMD:
 849   2              mac_data_parse_cmd(temp_frame_ptr, payload_index, fcf);
 850   2              break;
 851   2      
 852   2          default:
 853   2              return (false);
 854   2          }
 855   1          return (true);
 856   1      }
 857          
 858          static bool mac_data_handle_mac_cmd (uint8_t command, buffer_t *buf_p)
 859          {
 860   1          bool processed_data_ind = true;
 861   1          
 862   1          switch (command) {
 863   2          case ASSOCIATIONREQUEST:
 864   2              mac_process_associate_request(buf_p);
 865   2              break;
 866   2      
 867   2          case DISASSOCIATIONNOTIFICATION:
 868   2              mac_process_disassociate_notification(buf_p);
 869   2              /*
 870   2               * Device needs to scan for networks again,
 871   2               * go into idle mode and reset variables
 872   2               */
 873   2              mac_idle_trans();
 874   2              break;
 875   2      
 876   2          case DATAREQUEST:
 877   2              if (indirect_data_q.size > 0) {
 878   3                  mac_data_process_data_request(buf_p);
 879   3              } else {
 880   3                  mac_data_tx_null_frame();
 881   3                  processed_data_ind = false;
 882   3              }
 883   2              break;
 884   2      
 885   2          case PANIDCONFLICTNOTIFICAION:
 886   2              if (MAC_PAN_COORD_STARTED == mac_state) {
 887   3                  mac_sync_loss(MAC_PAN_ID_CONFLICT);
 888   3              } else {
 889   3                  processed_data_ind = false;
 890   3              }
 891   2              break;
 892   2      
 893   2          case ORPHANNOTIFICATION:
 894   2              mac_process_orphan_notification(buf_p);
 895   2              break;
 896   2      
 897   2          case BEACONREQUEST:
 898   2              if (MAC_COORDINATOR == mac_state) {            
 899   3            /*
 900   3                   * Only a Coordinator can both poll and AND answer beacon 
 901   3                   * request frames. PAN Coordinators do not poll. End devices
 902   3                   * do not answer beacon requests.
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 16  

 903   3                   */
 904   3                  mac_process_beacon_request(buf_p);
 905   3              } else {
 906   3                  processed_data_ind = false;
 907   3              }
 908   2              break;
 909   2      
 910   2          case COORDINATORREALIGNMENT:
 911   2              /*
 912   2               * Received coordinator realignment frame for
 913   2               * entire PAN.
 914   2               */
 915   2              if (MAC_PAN_COORD_STARTED != mac_state) {
 916   3                  mac_sync_process_coord_realign(buf_p);
 917   3              } else {
 918   3                  processed_data_ind = false;
 919   3              }
 920   2              break;
 921   2      
 922   2          default:
 923   2              processed_data_ind = false;
 924   2              break;
 925   2          }
 926   1      
 927   1          return (processed_data_ind);
 928   1      }
 929          
 930          /**
 931           *
 932           * This function is called in case a device (that is associated to a
 933           * PAN Coordinator) detects a PAN-Id conflict situation.
 934           *
 935           * Return - 
 936           * true if the PAN-Id conflict notification is sent successfully,
 937           * false otherwise
 938           */
 939          static bool mac_data_tx_pan_id_conflict_notif (void)
 940          {
 941   1          retval_t tx_status;
 942   1          uint8_t frame_len;
 943   1          uint8_t *frame_ptr;
 944   1          uint16_t fcf;
 945   1          frame_info_t *pan_id_conf_frame_p;
 946   1          tx_mode_t tx_mode;
 947   1          buffer_t *buf_p = bmm_buffer_alloc(BUFFER_SIZE);
 948   1      
 949   1          if (NULL == buf_p) {
 950   2          FM_Printf(FM_APP, "\nba:panF");
 951   2              return (false);
 952   2          }
 953   1      
 954   1          pan_id_conf_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
 955   1      
 956   1          pan_id_conf_frame_p->msg_type = PANIDCONFLICTNOTIFICAION;
 957   1      
 958   1          /*
 959   1           * The buffer header is stored as a part of frame_info_t structure 
 960   1           * before the * frame is given to the HAL. After the transmission of
 961   1           * the frame, reuse the buffer using this pointer.
 962   1           */
 963   1          pan_id_conf_frame_p->buffer_header_p = buf_p;
 964   1      
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 17  

 965   1          /* Update the payload length. */
 966   1          frame_len = PAN_ID_CONFLICT_PAYLOAD_LEN +
 967   1                      EXT_ADDR_LEN                + // long Source Address
 968   1                      EXT_ADDR_LEN                + // long Destination Address
 969   1                      PAN_ID_LEN                  + // Destination PAN-Id
 970   1                      SEQ_NUM_LEN                 + // Sequence number
 971   1                      FCF_LEN;                      // FCF
 972   1      
 973   1          /* Get the payload pointer. */
 974   1          frame_ptr = (uint8_t *)pan_id_conf_frame_p +
 975   1                      BUFFER_SIZE -
 976   1                      PAN_ID_CONFLICT_PAYLOAD_LEN;
 977   1      
 978   1          /*
 979   1           * Build the command frame id.
 980   1           * This is actually being written into "transmit_frame->layload[0]".
 981   1           */
 982   1          *frame_ptr = PANIDCONFLICTNOTIFICAION;
 983   1      
 984   1          /* Source Address */
 985   1          frame_ptr -= EXT_ADDR_LEN;
 986   1          mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 987   1      
 988   1          /* Destination Address */
 989   1          frame_ptr -= EXT_ADDR_LEN;
 990   1          mac_utils_64_bit_to_byte_array(mac_pib_macCoordExtendedAddress, frame_ptr);
 991   1      
 992   1          /* Destination PAN-Id */
 993   1          frame_ptr -= PAN_ID_LEN;
 994   1          mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 995   1      
 996   1      
 997   1          /* Set DSN. */
 998   1          frame_ptr -= SEQ_NUM_LEN;
 999   1          *frame_ptr = mac_pib_macDSN++;
1000   1      
1001   1      
1002   1          /* Build the FCF. */
1003   1          fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
1004   1                FCF_ACK_REQUEST                          |
1005   1                FCF_PAN_ID_COMPRESSION                   |
1006   1                FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
1007   1                FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR);
1008   1      
1009   1          /* Set the FCF. */
1010   1          frame_ptr -= FCF_LEN;
1011   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
1012   1      
1013   1      
1014   1          /* First element shall be length of PHY frame. */
1015   1          frame_ptr -= LENGTH_FIELD_LEN;
1016   1          *frame_ptr = frame_len;
1017   1      
1018   1          /* Finished building of frame. */
1019   1          pan_id_conf_frame_p->mpdu_p = frame_ptr;
1020   1      
1021   1          /*
1022   1           * In Beacon network the frame is sent with slotted CSMA-CA only if:
1023   1           * 1) the node is associated, or
1024   1           * 2) the node is idle, but synced before association,
1025   1           * 3) the node is a Coordinator (we assume, that coordinators are always
1026   1           *    in sync with their parents).
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 18  

1027   1           *
1028   1           * In all other cases, the frame has to be sent using unslotted CSMA-CA.
1029   1           */
1030   1      
1031   1          if (NON_BEACON_NWK != hal_pib_BeaconOrder) {
1032   2              if (((MAC_IDLE == mac_state) && 
1033   2                   (MAC_SYNC_BEFORE_ASSOC == mac_sync_state)) ||
1034   2                   (MAC_ASSOCIATED == mac_state) || (MAC_COORDINATOR == mac_state)) {
1035   3                  tx_mode = CSMA_SLOTTED;
1036   3              } else {
1037   3                  tx_mode = CSMA_UNSLOTTED;
1038   3              }
1039   2          } else {
1040   2              /* In Nonbeacon network the frame is sent with unslotted CSMA-CA. */
1041   2              tx_mode = CSMA_UNSLOTTED;
1042   2          }
1043   1      
1044   1          tx_status = mac_hal_tx_frame(pan_id_conf_frame_p, tx_mode, FALSE);
1045   1      
1046   1          if (MAC_SUCCESS == tx_status) {
1047   2              MAC_BUSY();
1048   2              return (true);
1049   2          } else {
1050   2              /* HAL is busy, hence the data request could not be transmitted */
1051   2              bmm_buffer_free(buf_p);
1052   2      
1053   2              return (false);
1054   2          }
1055   1      }
1056          
1057          /**
1058           *
1059           * This function handles the detection of PAN-Id Conflict detection
1060           * in case the node is NOT a PAN Coordinator.
1061           *
1062           * in_scan Indicates whether node is currently scanning
1063           */
1064          static void mac_data_in_pan_id_conflict_detect (bool in_scan)
1065          {
1066   1          /*
1067   1           * Check whether the received frame has the PAN Coordinator bit set
1068   1           * in the Superframe Specification field of the beacon frame.
1069   1           */
1070   1          if (GET_PAN_COORDINATOR(
1071   1              mac_parse_data.mac_payload_data.beacon_data.superframe_spec)) {
1072   2              /*
1073   2               * The received beacon frame is from a PAN Coordinator
1074   2               * (not necessarily ours).
1075   2               * Now check if the PAN-Id is ours.
1076   2               */
1077   2              if (((in_scan == FALSE) &&
1078   2                   (mac_parse_data.src_panid == hal_pib_PANId)) ||
1079   2                  (mac_parse_data.src_panid == mac_scan_orig_panid)) {
1080   3                  /* This beacon frame has our own PAN-Id.
1081   3                   * If the address of the source is different from our own
1082   3                   * parent, a PAN-Id conflict has been detected.
1083   3                   */
1084   3                  if ((mac_parse_data.src_addr.short_address !=
1085   3                       mac_pib_macCoordShortAddress) &&
1086   3                      (EXT_ADDR_NOMATCH(mac_parse_data.src_addr.long_address,
1087   3                                        mac_pib_macCoordExtendedAddress))) {
1088   4                      mac_data_tx_pan_id_conflict_notif();
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 19  

1089   4                  }
1090   3              }
1091   2          }
1092   1      }
1093          
1094          static bool mac_data_ind_handle_my_coor_beacon (buffer_t *buf_p,
1095                                                          frame_info_t *frame_p)
1096          {
1097   1          uint32_t beacon_tx_time_symb;
1098   1          bool     processed_data_ind = true;
1099   1      
1100   1          /* Check for PAN-Id conflict being NOT a PAN Corodinator. */
1101   1          if (mac_pib_macAssociatedPANCoord && (MAC_IDLE != mac_state)) {
1102   2              mac_data_in_pan_id_conflict_detect(false);
1103   2          }
1104   1      
1105   1          /* Check if the beacon is received from my coordinator */
1106   1          if ((mac_parse_data.src_panid == hal_pib_PANId) &&
1107   1              (((mac_parse_data.src_addr_mode == FCF_SHORT_ADDR) &&
1108   1                (mac_parse_data.src_addr.short_address ==
1109   1                 mac_pib_macCoordShortAddress)) ||
1110   1                 ((mac_parse_data.src_addr_mode == FCF_LONG_ADDR) &&
1111   1                  (EXT_ADDR_MATCH(mac_parse_data.src_addr.long_address,
1112   1                                  mac_pib_macCoordExtendedAddress))))) {
1113   2      
1114   2              beacon_tx_time_symb = frame_p->time_stamp;
1115   2      
1116   2              set_hal_pib_internal(macBeaconTxTime, (void *)&beacon_tx_time_symb);
1117   2              if ((MAC_SYNC_TRACKING_BEACON == mac_sync_state) ||
1118   2                  (MAC_SYNC_BEFORE_ASSOC == mac_sync_state)) {
1119   3                  //uint32_t nxt_bcn_tm;
1120   3                  uint32_t beacon_int_symb;
1121   3      
1122   3                  /* Process a received beacon. */
1123   3                  mac_process_beacon_frame(buf_p);
1124   3      
1125   3                  /* Initialize beacon tracking timer. */
1126   3                  if (hal_pib_BeaconOrder < NON_BEACON_NWK) {
1127   4                      beacon_int_symb = 
1128   4                              HAL_GET_BEACON_INTERVAL_TIME(hal_pib_BeaconOrder);
1129   4                  } else {
1130   4                      beacon_int_symb =
1131   4                              HAL_GET_BEACON_INTERVAL_TIME(BO_USED_FOR_MAC_PERS_TIME);
1132   4                  }
1133   3      
1134   3                  /* Stop the beacon tracking timer */
1135   3                  STM_StopTimer(beacon_tracking_timer);
1136   3      
1137   3                  /* Calculate the time for next beacon transmission */
1138   3                  beacon_tx_time_symb =
1139   3                      mac_hal_add_time_symbols(beacon_tx_time_symb, 
1140   3                                               beacon_int_symb) / 1000;
1141   3      
1142   3                  /* 
1143   3                   * Start beacon tracking timer to call mac_sync_tracking_beacons_cb
1144   3                   */
1145   3                  STM_StartTimer(beacon_tracking_timer, 
1146   3                                 HAL_CONVERT_SYMBOLS_TO_US(beacon_tx_time_symb));
1147   3      
1148   3                  /*
1149   3                   * FIXME - Initialize superframe timer if required only
1150   3                   * for devices because Superframe timer is already running for
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 20  

1151   3                   * coordinator.
1152   3                   */
1153   3      
1154   3                  /* Initialize missed beacon timer. */
1155   3                  mac_sync_start_missed_beacon_timer();
1156   3      
1157   3                  /*
1158   3                   * A device that is neither scanning nor polling 
1159   3                   * shall go to sleep now.
1160   3                   */
1161   3                  if ((MAC_COORDINATOR != mac_state) &&
1162   3                      (MAC_SCAN_IDLE == mac_scan_state) &&
1163   3                      (MAC_POLL_IDLE == mac_poll_state)) {
1164   4                      /*
1165   4                       * If the last received beacon frame from our parent
1166   4                       * has indicated pending broadbast data, we need to
1167   4                       * stay awake, until the broadcast data has been received.
1168   4                       */
1169   4                      if (!mac_bc_data_indicated) {
1170   5                          /* Set radio to sleep if allowed */
1171   5                          mac_trx_sleep();
1172   5                      }
1173   4                  }
1174   3              } else if (MAC_SYNC_ONCE == mac_sync_state) {
1175   3                  mac_process_beacon_frame(buf_p);
1176   3      
1177   3                  /* Do this after processing the beacon. */
1178   3                  mac_sync_state = MAC_SYNC_NEVER;
1179   3      
1180   3                  /*
1181   3                   * A device that is neither scanning nor polling 
1182   3                   * shall go to sleep now.
1183   3                   */
1184   3                  if ((MAC_COORDINATOR != mac_state) &&
1185   3                      (MAC_SCAN_IDLE == mac_scan_state) &&
1186   3                      (MAC_POLL_IDLE == mac_poll_state)) {
1187   4                      /*
1188   4                       * If the last received beacon frame from our parent
1189   4                       * has indicated pending broadbast data, we need to
1190   4                       * stay awake, until the broadcast data has been received.
1191   4                       */
1192   4                      if (!mac_bc_data_indicated) {
1193   5                          /* Set radio to sleep if allowed */
1194   5                          mac_trx_sleep();
1195   5                      }
1196   4                  }
1197   3              } else {
1198   3                  processed_data_ind = false;
1199   3              }
1200   2          } else {
1201   2              /* No action taken, buffer will be freed. */
1202   2              processed_data_ind = false;
1203   2          }
1204   1      
1205   1          return (processed_data_ind);
1206   1      }
1207          
1208          /**
1209           * Continues processing a data indication from the HAL when the MAC is not 
1210           * polling or scanning
1211           *
1212           * buf_p   - Pointer to the buffer header.
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 21  

1213           * frame_p - Pointer to the frame_info_t structure.
1214           *
1215           * bool - True if frame has been processed
1216           *        False otherwise.
1217           */
1218          static bool mac_data_non_transient (buffer_t *buf_p,
1219                                              frame_info_t *frame_p)
1220          {
1221   1          bool processed_data_ind = true;
1222   1          uint8_t track = 0;
1223   1      
1224   1          switch (mac_state) {
1225   2          case MAC_PAN_COORD_STARTED:
1226   2              if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) {
1227   3                  processed_data_ind =
1228   3                      mac_data_handle_mac_cmd(mac_parse_data.mac_command, buf_p);
1229   3                  track = 1;
1230   3              } else if (FCF_FRAMETYPE_DATA == mac_parse_data.frame_type) {
1231   3                  mac_process_data_frame(buf_p);
1232   3                  track = 2;
1233   3              } else if (FCF_FRAMETYPE_BEACON == mac_parse_data.frame_type) {
1234   3                  /* PAN-Id conflict detection as PAN-Coordinator. */
1235   3                  /* Node is not scanning. */
1236   3                  mac_data_in_pan_id_conflict_detect(false);
1237   3                  processed_data_ind = false;
1238   3                  track = 3;
1239   3              } else {
1240   3                  processed_data_ind = false;
1241   3                  track = 4;
1242   3              }
1243   2              break;
1244   2      
1245   2          case MAC_IDLE:
1246   2          case MAC_ASSOCIATED:
1247   2          case MAC_COORDINATOR:
1248   2              if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) {
1249   3                  processed_data_ind =
1250   3                      mac_data_handle_mac_cmd(mac_parse_data.mac_command, buf_p);
1251   3                  track = 5;
1252   3              } else if (FCF_FRAMETYPE_DATA == mac_parse_data.frame_type) {
1253   3                  mac_process_data_frame(buf_p);
1254   3                  track = 6;
1255   3              } else if (FCF_FRAMETYPE_BEACON == mac_parse_data.frame_type) { 
1256   3                  processed_data_ind =
1257   3                              mac_data_ind_handle_my_coor_beacon(buf_p, frame_p);
1258   3                  track = 7;
1259   3              } else {
1260   3                  processed_data_ind = false;
1261   3                  track = 8;
1262   3              }
1263   2              break;
1264   2          default:
1265   2              processed_data_ind = false;
1266   2              track = 9;
1267   2              break;
1268   2          }
1269   1      
1270   1          if (false == processed_data_ind) {
1271   2      #ifdef _DEBUG_
                      printf("\ntrack => %bu\n", track);
              #endif
1274   2          }
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 22  

1275   1      
1276   1          return (processed_data_ind);
1277   1      }
1278          
1279          /**
1280           * PAN-Id conflict detection NOT as PAN-Coordinator.
1281           *
1282           * This function handles the detection of PAN-Id Conflict detection
1283           * in case the node is NOT a PAN Coordinator.
1284           *
1285           * in_scan - whether node is currently scanning
1286           */
1287          static void mac_data_pan_id_conflict_non_pc (bool in_scan)
1288          {
1289   1          /*
1290   1           * Check whether the received frame has the PAN Coordinator bit set
1291   1           * in the Superframe Specification field of the beacon frame.
1292   1           */
1293   1          if (GET_PAN_COORDINATOR(mac_parse_data.mac_payload_data.beacon_data.superframe_spec)) {
1294   2              /*
1295   2               * The received beacon frame is from a PAN Coordinator
1296   2               * (not necessarily ours).
1297   2               * Now check if the PAN-Id is ours.
1298   2               */
1299   2              if (((FALSE == in_scan) && (mac_parse_data.src_panid == hal_pib_PANId)) ||
1300   2                  (mac_parse_data.src_panid == mac_scan_orig_panid)) {
1301   3                  /* This beacon frame has our own PAN-Id.
1302   3                   * If the address of the source is different from our own
1303   3                   * parent, a PAN-Id conflict has been detected.
1304   3                   */
1305   3                  if ((mac_parse_data.src_addr.short_address != 
1306   3                       mac_pib_macCoordShortAddress) &&
1307   3                      (EXT_ADDR_MATCH(mac_parse_data.src_addr.long_address, 
1308   3                                      mac_pib_macCoordExtendedAddress))) {
1309   4                      mac_data_tx_pan_id_conflict_notif();
1310   4                  }
1311   3              }
1312   2          }    
1313   1      }
1314          
1315          /*
1316           * PAN-Id conflict detection as PAN-Coordinator.
1317           *
1318           * This function handles the detection of PAN-Id Conflict detection
1319           * in case the node is a PAN Coordinator.
1320           *
1321           * in_scan - Whether node is currently scanning
1322           */
1323          static void mac_data_pan_id_conflict_pc (bool in_scan)
1324          {
1325   1          /*
1326   1           * Check whether the received frame has the PAN Coordinator bit set
1327   1           * in the Superframe Specification field of the beacon frame, and
1328   1           * whether the received beacon frame has the same PAN-Id as the current
1329   1           * network.
1330   1           */
1331   1          if (GET_PAN_COORDINATOR(mac_parse_data.mac_payload_data.beacon_data.superframe_spec)) {
1332   2              if (((!in_scan) && (mac_parse_data.src_panid == hal_pib_PANId)) ||
1333   2                  (mac_parse_data.src_panid == mac_scan_orig_panid)) {
1334   3                  mac_sync_loss(MAC_PAN_ID_CONFLICT);
1335   3              }
1336   2          }
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 23  

1337   1      }
1338          
1339          /*
1340           * Processing indication from the HAL while scanning
1341           *
1342           * b_ptr Pointer to the buffer header.
1343           *
1344           * Return True if frame has been processed, or false otherwise.
1345           */
1346          static bool process_data_ind_scanning (buffer_t *b_ptr)
1347          {
1348   1          bool processed_in_scanning = false;
1349   1          /*
1350   1           * We are in a scanning process now (mac_scan_state is not MAC_SCAN_IDLE),
1351   1           * so continue with the specific scanning states.
1352   1           */
1353   1          switch (mac_scan_state) {
1354   2          /* Energy Detect scan */
1355   2          case MAC_SCAN_ED:
1356   2              /*
1357   2               * Ignore all frames received while performing ED measurement,
1358   2               * or while performing CCA.
1359   2               */
1360   2              break;
1361   2      
1362   2          /* Active scan or passive scan */
1363   2          case MAC_SCAN_ACTIVE:
1364   2          case MAC_SCAN_PASSIVE:
1365   2              if (FCF_FRAMETYPE_BEACON == mac_parse_data.frame_type) {
1366   3                  /* PAN-Id conflict detection as PAN-Coordinator. */
1367   3                  if (MAC_PAN_COORD_STARTED == mac_state) {
1368   4                      /* Node is currently scanning. */
1369   4                      mac_data_pan_id_conflict_pc(true);
1370   4                  }
1371   3      
1372   3                  if (mac_pib_macAssociatedPANCoord &&
1373   3                      ((MAC_ASSOCIATED == mac_state) || 
1374   3                       (MAC_COORDINATOR == mac_state))) {
1375   4                      mac_data_pan_id_conflict_non_pc(true);
1376   4                  } 
1377   3                  mac_process_beacon_frame(b_ptr);
1378   3                  processed_in_scanning = true;
1379   3              }
1380   2              break;
1381   2      
1382   2          /* Orphan scan */
1383   2          case MAC_SCAN_ORPHAN:
1384   2              if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type &&
1385   2                  COORDINATORREALIGNMENT == mac_parse_data.mac_command) {
1386   3                  /*
1387   3                   * Received coordinator realignment frame in the middle of
1388   3                   * an orphan scan.
1389   3                   */
1390   3                  STM_StopTimer(scan_duration_timer);
1391   3      
1392   3                  mac_scan_process_orphan_realign(b_ptr);
1393   3                  processed_in_scanning = true;
1394   3              }
1395   2              break;
1396   2      
1397   2          default:
1398   2              break;
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 24  

1399   2          }
1400   1      
1401   1          return (processed_in_scanning);
1402   1      }
1403          
1404          static bool mac_data_handle_mac_poll_sm (buffer_t *buf_p, frame_info_t *frame_p)
1405          {
1406   1          bool processed_data_ind = true;
1407   1          uint8_t track = 0;
1408   1      
1409   1          switch (mac_poll_state) {
1410   2          case MAC_POLL_IDLE: 
1411   2              /*
1412   2               * We are in no transient state.
1413   2               * Now are either in a non-transient MAC state or scanning.
1414   2               */
1415   2              if (MAC_SCAN_IDLE == mac_scan_state) {
1416   3                  /*
1417   3                   * Continue with handling the "real" non-transient MAC states now.
1418   3                   */
1419   3                  track = 1; 
1420   3                  processed_data_ind = mac_data_non_transient(buf_p, frame_p);
1421   3              } else {
1422   3                  /* Scanning is ongoing. */ 
1423   3                  processed_data_ind = process_data_ind_scanning(buf_p);
1424   3                  track = 2;
1425   3                  processed_data_ind = false;
1426   3              }
1427   2              break;
1428   2      
1429   2          /*
1430   2           * This is the 'wait for data' state after either
1431   2           * explicit poll or implicit poll.
1432   2           */
1433   2          case MAC_POLL_EXPLICIT:
1434   2          case MAC_POLL_IMPLICIT:
1435   2              /*
1436   2               * Function mac_poll_process_data_response() resets the
1437   2               * MAC poll state.
1438   2               */
1439   2              mac_poll_process_data_response();
1440   2      
1441   2              if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) {
1442   3                  track = 3; 
1443   3                  processed_data_ind =
1444   3                      mac_data_handle_mac_cmd(mac_parse_data.mac_command, buf_p);
1445   3              } else if (FCF_FRAMETYPE_DATA == mac_parse_data.frame_type) {
1446   3                  track = 4; 
1447   3                  mac_process_data_frame(buf_p);
1448   3              } else {
1449   3                  track = 5;
1450   3                  processed_data_ind = false;
1451   3              }
1452   2              break;
1453   2      
1454   2          case MAC_AWAIT_ASSOC_RESPONSE:
1455   2              /*
1456   2               * We are either expecting an association reponse frame
1457   2               * or a null data frame.
1458   2               */
1459   2              if ((FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) &&
1460   2                  (ASSOCIATIONRESPONSE == mac_parse_data.mac_command)) {
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 25  

1461   3                  /* This is the expected association response frame. */ 
1462   3                  STM_StopTimer(mac_asso_rsp_wait_timer); 
1463   3                  mac_process_associate_response(buf_p);
1464   3                  track = 6;
1465   3              } else if (FCF_FRAMETYPE_DATA == mac_parse_data.frame_type) { 
1466   3                  mac_process_data_frame(buf_p);
1467   3                  track = 7;
1468   3              }
1469   2              break;
1470   2      
1471   2          default:
1472   2              track = 8;
1473   2              processed_data_ind = false;
1474   2              break;
1475   2          }
1476   1      
1477   1          if (false == processed_data_ind) {
1478   2      #ifdef _DEBUG_
                      printf("\ntrack = %bu\n", track);
              #endif
1481   2          }
1482   1      
1483   1          return (processed_data_ind);
1484   1      }
1485          
1486          /**
1487           * Depending on received frame the appropriate function is called
1488           *
1489           * buf_p - Pointer to the buffer.
1490           */
1491          void mac_data_process_packet (buffer_t *buf_ptr)
1492          {
1493   1          frame_info_t *frame_ptr = (frame_info_t *)BMM_BUFFER_POINTER(buf_ptr);
1494   1          bool processed_data_ind = false;
1495   1      
1496   1          mac_parse_data.mpdu_length = frame_ptr->mpdu_p[0];
1497   1          
1498   1          mac_stats_g.rx_pkts_count++;
1499   1          mac_stats_g.rx_bytes_count += mac_parse_data.mpdu_length;
1500   1          
1501   1          /* First extract LQI since this is already needed in Promiscuous Mode. */
1502   1          mac_parse_data.ppdu_link_quality = 
1503   1                             frame_ptr->mpdu_p[mac_parse_data.mpdu_length + LQI_LEN];
1504   1          mac_parse_data.ppdu_rssi = 
1505   1                             frame_ptr->mpdu_p[mac_parse_data.mpdu_length + LQI_LEN + 1];
1506   1      
1507   1          if (hal_pib_PromiscuousMode) {
1508   2              /*
1509   2               * In promiscuous mode all received frames are forwarded to the
1510   2               * higher layer or application using MCPS_DATA.indication
1511   2               * primitives.
1512   2               */
1513   2              mac_data_promis_mode_rx_frame(buf_ptr, frame_ptr);
1514   2              return;
1515   2          }
1516   1      
1517   1          if (mac_data_parse_mpdu(frame_ptr) == FALSE) {
1518   2              /* Frame parsing failed */
1519   2          printf("\nParse Fail");
1520   2              bmm_buffer_free(buf_ptr);
1521   2              return;
1522   2          }
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 26  

1523   1      
1524   1          /* Check if the MAC is busy processing the previous requests */
1525   1          if (mac_busy) {
1526   2              /*
1527   2               * If MAC has to process an incoming frame that requires a response
1528   2               * (i.e. beacon request and data request) then process this operation
1529   2               * once the MAC has become free. Put the request received back into the
1530   2               * MAC internal event queue.
1531   2               */
1532   2              if (FCF_FRAMETYPE_MAC_CMD == mac_parse_data.frame_type) {
1533   3                  if (DATAREQUEST == mac_parse_data.mac_command ||
1534   3                      BEACONREQUEST == mac_parse_data.mac_command) {
1535   4                      if (FALSE == qmm_queue_append(&hal_mac_q, buf_ptr)) {
1536   5                          bmm_buffer_free(buf_ptr);
1537   5                      } else {
1538   5       
1539   5      #ifdef RTX51_TINY_OS
1540   5      #ifdef MAC_802154_TASK
                    os_set_ready(MAC_802154_TASK_ID);
              #else
1543   5            os_set_ready(HPGP_TASK_ID_CTRL);
1544   5      #endif /* MAC_802154_TASK */
1545   5      #endif
1546   5                      }
1547   4                      return;
1548   4                  }
1549   3              }
1550   2          } 
1551   1          processed_data_ind = mac_data_handle_mac_poll_sm(buf_ptr, frame_ptr); 
1552   1      
1553   1          /* If message is not processed */
1554   1          if (!processed_data_ind) {
1555   2              bmm_buffer_free(buf_ptr);
1556   2          }
1557   1      }
1558          
1559          void mac_data_rx_frame_cb (frame_info_t *frame_p)
1560          {
1561   1          frame_p->msg_type = (frame_msgtype_t)HAL_DATA_INDICATION;
1562   1       
1563   1          if (NULL == frame_p->buffer_header_p) {
1564   2              return;
1565   2          } 
1566   1          mac_data_process_packet(frame_p->buffer_header_p);
1567   1      }
1568          
1569          /**
1570           *
1571           * This function builds and tranmits a data request command frame.
1572           *
1573           *
1574           * expl_poll           - Data request due to explicit MLME poll request
1575           * force_own_long_addr - Forces the usage of the Extended Address as
1576           *                       Source Address. This a allows for implicitly
1577           *                       poll for pending data at the coordinator if
1578           *                       the Extended Address was used in the Beacon frame.
1579           * expl_dest_addr_mode - Mode of subsequent destination address to be used
1580           *                       explicitly (0/2/3).
1581           *                       0: No explicit destination address attached,
1582           *                          use either macCoordShortAddress or
1583           *                          macCoordExtendedAddress
1584           *                       2: Use explicitly attached address in parameter
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 27  

1585           *                          expl_dest_addr as destination address as
1586           *                          short address
1587           *                       3: Use explicitly attached address in parameter
1588           *                          expl_dest_addr as destination address as
1589           *                          extended address
1590           * expl_dest_addr      - Explicitly attached destination address for data
1591           *                       request frame. This is to be treated as either not
1592           *                       present, short or extended address, depending on
1593           *                       parameter expl_dest_addr_mode.
1594           * expl_dest_pan_id    - Explicitly attached destination PAN-Id (Coordinator
1595           *                       PAN-Id) for data request frame.
1596           *                       This is to be treated only as present, depending on
1597           *                       parameter expl_dest_addr_mode.
1598           *
1599           * return - True if data request command frame was created and sent to
1600           *          the HAL successfully, false otherwise.
1601           */
1602          bool mac_data_build_and_tx_data_req (bool expl_poll,
1603                                               bool force_own_long_addr,
1604                                               uint8_t expl_dest_addr_mode,
1605                                               address_field_t *expl_dest_addr,
1606                                               uint16_t expl_dest_pan_id)
1607          {
1608   1          retval_t tx_status;
1609   1          bool intrabit = false;
1610   1          uint8_t frame_len;
1611   1          uint8_t *frame_ptr;
1612   1          uint16_t fcf;
1613   1          tx_mode_t tx_mode;
1614   1          frame_info_t *tx_frame_p;
1615   1          buffer_t *buf_ptr = bmm_buffer_alloc(BUFFER_SIZE);
1616   1      
1617   1          if (NULL == buf_ptr) {
1618   2          FM_Printf(FM_APP, "\nba:txF");
1619   2              return false;
1620   2          }
1621   1      
1622   1          tx_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_ptr);
1623   1      
1624   1          /*
1625   1           * If this data request cmd frame was initiated by a device due to implicit
1626   1           * poll, set msgtype to DATAREQUEST_IMPL_POLL.
1627   1           * If this data request cmd frame was initiated by a MLME poll request,
1628   1           * set msgtype to DATAREQUEST.
1629   1           */
1630   1          if (expl_poll == TRUE) {
1631   2              tx_frame_p->msg_type = DATAREQUEST;
1632   2          } else {
1633   2              tx_frame_p->msg_type = DATAREQUEST_IMPL_POLL;
1634   2          }
1635   1      
1636   1          /*
1637   1           * The buffer header is stored as a part of frame_info_t structure 
1638   1           * before the frame is given to the HAL. After the transmission, reuse
1639   1           * the buffer using this pointer.
1640   1           */
1641   1          tx_frame_p->buffer_header_p = buf_ptr;
1642   1      
1643   1          /* Update the payload length. */
1644   1          frame_len = DATA_REQ_PAYLOAD_LEN +
1645   1                      SHORT_ADDR_LEN       + // short Source Address
1646   1                      SHORT_ADDR_LEN       + // short Destination Address
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 28  

1647   1                      PAN_ID_LEN           + // Destination PAN-Id
1648   1                      SEQ_NUM_LEN          + // Sequence number
1649   1                      FCF_LEN;               // FCF
1650   1      
1651   1          /* Get the payload pointer. */
1652   1          frame_ptr = (uint8_t *)tx_frame_p + BUFFER_SIZE - DATA_REQ_PAYLOAD_LEN;
1653   1      
1654   1          /*
1655   1           * Build the command frame id.
1656   1           * This is actually being written into "transmit_frame->layload[0]".
1657   1           */
1658   1          *frame_ptr = DATAREQUEST;
1659   1      
1660   1          /* Source Address */
1661   1          /*
1662   1           * Long address needs to be used if a short address is not present
1663   1           * or if we are forced to use the long address.
1664   1           *
1665   1           * This is used for example in cases where the coordinator indicates
1666   1           * pending data for us using our extended address.
1667   1           *
1668   1           * This is also used for transmitting a data request frame
1669   1           * during association, since here we always need to use our
1670   1           * extended address.
1671   1           */
1672   1          if ((BROADCAST == hal_pib_ShortAddress) ||
1673   1              (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress) ||
1674   1              force_own_long_addr) {
1675   2              frame_ptr -= EXT_ADDR_LEN;
1676   2              frame_len += 6; // Add further 6 octets for long Source Address
1677   2      
1678   2              /* Build the Source address. */
1679   2              mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
1680   2              fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
1681   2                    FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
1682   2                    FCF_ACK_REQUEST;
1683   2          } else {
1684   2              frame_ptr -= SHORT_ADDR_LEN;
1685   2      
1686   2              /* Build the Source address. */
1687   2              mac_utils_16_bit_to_byte_array(hal_pib_ShortAddress, frame_ptr);
1688   2      
1689   2              fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
1690   2                    FCF_SET_SOURCE_ADDR_MODE(FCF_SHORT_ADDR) |
1691   2                    FCF_ACK_REQUEST;
1692   2          }
1693   1      
1694   1      
1695   1          /* Source PAN-Id */
1696   1          /*
1697   1           * In IEEE 802.15.4 the PAN ID Compression bit may always be set.
1698   1           * See page 154:
1699   1           * If the data request command is being sent in response to the receipt
1700   1           * of a beacon frame indicating that data are pending for that device,
1701   1           * the Destination Addressing Mode subfield of the Frame Control field
1702   1           * may be set to zero ..."
1703   1           * In order to keep the implementation simple the address info is also in
1704   1           * this case 2 or 3, i.e. the destination address info is present.
1705   1           * This in return means that the PAN ID Compression bit is always set for
1706   1           * data request frames, except the expl_dest_pan_id parameter is
1707   1           * different from our own PAN-Id PIB attribute.
1708   1           */
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 29  

1709   1          if ((expl_dest_addr_mode != FCF_NO_ADDR) &&
1710   1              (expl_dest_pan_id    != hal_pib_PANId)) {
1711   2              frame_ptr -= PAN_ID_LEN;
1712   2              frame_len += PAN_ID_LEN;
1713   2      
1714   2              mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
1715   2          } else {
1716   2              /*
1717   2               * The source PAN Id is not present since the PAN ID
1718   2               * Compression bit is set.
1719   2               */
1720   2              /* Set intra-PAN bit. */
1721   2              intrabit = true;
1722   2              fcf |= FCF_PAN_ID_COMPRESSION;
1723   2          }
1724   1      
1725   1      
1726   1          /* Destination Address */
1727   1          if (FCF_SHORT_ADDR == expl_dest_addr_mode) {
1728   2              /* An explicit short destination address is requested. */
1729   2              fcf |= FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR);
1730   2      
1731   2              frame_ptr -= SHORT_ADDR_LEN;
1732   2              mac_utils_16_bit_to_byte_array(expl_dest_addr->short_address,
1733   2                                             frame_ptr);
1734   2          } else if (FCF_LONG_ADDR == expl_dest_addr_mode) {
1735   2              /* An explicit long destination address is requested. */
1736   2              fcf |= FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR);
1737   2      
1738   2              frame_ptr -= EXT_ADDR_LEN;
1739   2              frame_len += 6; // Add further 6 octets for long Destination Address
1740   2              mac_utils_64_bit_to_byte_array(expl_dest_addr->long_address, frame_ptr);
1741   2          } else {
1742   2              /* No explicit destination address is requested. */
1743   2              if (MAC_NO_SHORT_ADDR_VALUE != mac_pib_macCoordShortAddress) {
1744   3                  /*
1745   3                   * If current value of short address for coordinator PIB is
1746   3                   * NOT 0xFFFE, the current value of the short address for
1747   3                   * coordinator shall be used as desination address.
1748   3                   */
1749   3                  fcf |= FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR);
1750   3      
1751   3                  frame_ptr -= SHORT_ADDR_LEN;
1752   3                  mac_utils_16_bit_to_byte_array(mac_pib_macCoordShortAddress,
1753   3                                                 frame_ptr);
1754   3              } else {
1755   3                  /*
1756   3                   * If current value of short address for coordinator PIB is 0xFFFE,
1757   3                   * the current value of the extended address for coordinator
1758   3                   * shall be used as desination address.
1759   3                   */
1760   3                  fcf |= FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR);
1761   3      
1762   3                  frame_ptr -= EXT_ADDR_LEN;
1763   3                  frame_len += 6; // Add further 6 octets for long Destination Address
1764   3                  mac_utils_64_bit_to_byte_array(mac_pib_macCoordExtendedAddress,
1765   3                                                 frame_ptr);
1766   3              }
1767   2          }
1768   1      
1769   1      
1770   1          /* Destination PAN-Id */
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 30  

1771   1          frame_ptr -= PAN_ID_LEN;
1772   1      
1773   1          if (intrabit) {
1774   2              /* Add our PAN-Id. */
1775   2              mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
1776   2          } else {
1777   2              /*
1778   2               * There is an expclicit destination address present AND
1779   2               * the destination PAN-Id is different from our own PAN-ID,
1780   2               * so include the source PAN-id into the frame.
1781   2               */
1782   2              mac_utils_16_bit_to_byte_array(expl_dest_pan_id, frame_ptr);
1783   2          }
1784   1      
1785   1      
1786   1          /* Set DSN. */
1787   1          frame_ptr -= SEQ_NUM_LEN;
1788   1          *frame_ptr = mac_pib_macDSN++;
1789   1      
1790   1      
1791   1          /* Set the FCF. */
1792   1          frame_ptr -= FCF_LEN;
1793   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
1794   1      
1795   1      
1796   1          /* First element shall be length of PHY frame. */
1797   1          frame_ptr -= LENGTH_FIELD_LEN;
1798   1          *frame_ptr = frame_len;
1799   1      
1800   1          /* Finished building of frame. */
1801   1          tx_frame_p->mpdu_p = frame_ptr;
1802   1      
1803   1      
1804   1          /* Transmission should be done with CSMA-CA and frame retries. */
1805   1          /*
1806   1           * In Beacon network the frame is sent with slotted CSMA-CA only if:
1807   1           * 1) the node is associated, or
1808   1           * 2) the node is idle, but synced before association,
1809   1           * 3) the node is a Coordinator (we assume, that coordinators are always
1810   1           *    in sync with their parents).
1811   1           *
1812   1           * In all other cases, the frame has to be sent using unslotted CSMA-CA.
1813   1           */;
1814   1      
1815   1          if (NON_BEACON_NWK != hal_pib_BeaconOrder) {
1816   2              if (((MAC_IDLE == mac_state) &&
1817   2                  (MAC_SYNC_BEFORE_ASSOC == mac_sync_state)) ||
1818   2                  (MAC_ASSOCIATED == mac_state) ||
1819   2                  (MAC_COORDINATOR == mac_state)) {
1820   3                  tx_mode = CSMA_SLOTTED;
1821   3              } else {
1822   3                  tx_mode = CSMA_UNSLOTTED;
1823   3              }
1824   2          } else {
1825   2              /* In Nonbeacon network the frame is sent with unslotted CSMA-CA. */
1826   2              tx_mode = CSMA_UNSLOTTED;
1827   2          }
1828   1      
1829   1          tx_status = mac_hal_tx_frame(tx_frame_p, tx_mode, FALSE);
1830   1      
1831   1          if (MAC_SUCCESS == tx_status) {
1832   2              MAC_BUSY();
C51 COMPILER V9.53.0.0   MAC_DATA                                                          11/04/2015 20:09:49 PAGE 31  

1833   2              return (true);
1834   2          } else {
1835   2              /* HAL is busy, hence the data request could not be transmitted */
1836   2              bmm_buffer_free(buf_ptr);
1837   2      
1838   2              return (false);
1839   2          }
1840   1      }
1841          
1842          #endif //HYBRII_802154
1843          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6202    ----
   CONSTANT SIZE    =     39    ----
   XDATA SIZE       =   ----     182
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
