C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE QMM
OBJECT MODULE PLACED IN .\obj\qmm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\qmm.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) 
                    -BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\fir
                    -mware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\.
                    -.\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware\
                    -hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\..
                    -\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\..
                    -\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\.
                    -.\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\.
                    -.\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\i
                    -nc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..\
                    -..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compone
                    -nts\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash\
                    -inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\..
                    -\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc;
                    -..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\com
                    -ponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,H
                    -YBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYB
                    -RII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYB
                    -RII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,
                    -SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_A
                    -PP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\qmm.lst) TABS(2) OBJECT(.\ob
                    -j\qmm.obj)

line level    source

   1          /**
   2           * @file qmm.c
   3           *
   4           *  This file implements the  functions for initializing the queues,
   5           *  appending a buffer into the queue, removing a buffer from the queue and
   6           *  reading a buffer from the queue as per the search criteria.
   7           *
   8           * $Id: qmm.c,v 1.2 2014/11/11 14:52:59 ranjan Exp $
   9           *
  10           * Copyright (c) 2011, Greenvity Communication All rights reserved.
  11           *
  12           */
  13          #ifdef HYBRII_802154 
  14          /* === Includes ============================================================ */
  15          #include <REG51.H>
  16          #include <stdio.h>
  17          #include "papdef.h"
  18          #include "bmm.h"
  19          #include "qmm.h"
  20          
  21          /* === Types =============================================================== */
  22          
  23          /* === Macros ============================================================== */
  24          
  25          /* === Prototypes ========================================================== */
  26          
  27          /* === Implementation ====================================================== */
  28          
  29          /**
  30           * This function initializes the queue. Note that this function
  31           * should be called before invoking any other functionality of QMM.
  32           *
  33           */
  34          void qmm_queue_init (queue_t *q_p, uint8_t capacity)
C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 2   

  35          {
  36   1          q_p->head = NULL;
  37   1          q_p->tail = NULL;
  38   1          q_p->size = 0;
  39   1          q_p->capacity = capacity;
  40   1      }
  41          
  42          
  43          /**
  44           * This function appends a buffer into the queue.
  45           *
  46           * q_p   - Pointer to the Queue where buffer should be appended
  47           *
  48           * buf_p - Pointer to the buffer that should be appended into the queue.
  49           * Note that this pointer should be same as the
  50           * pointer returned by bmm_buffer_alloc.
  51           */
  52          bool qmm_queue_append (queue_t *q_p, buffer_t *buf_p)
  53          {
  54   1          bool status;
  55   1          u8   interrupt_status;
  56   1      
  57   1          interrupt_status = EA;
  58   1          EA = 0;
  59   1      
  60   1          /* Check if queue is full */
  61   1          if (q_p->size == q_p->capacity) {
  62   2              /* Buffer cannot be appended as queue is full */
  63   2              status = FALSE;
  64   2          } else {
  65   2              /* Check whether queue is empty */
  66   2              if (q_p->size == 0) {
  67   3                  /* Add the buffer at the head */
  68   3                  q_p->head = buf_p;
  69   3              } else {
  70   3                  /* Add the buffer at the end */
  71   3                  q_p->tail->next = buf_p;
  72   3              }
  73   2      
  74   2              /* Update the list */
  75   2              q_p->tail = buf_p;
  76   2      
  77   2              /* Terminate the list */
  78   2              buf_p->next = NULL;
  79   2      
  80   2              /* Update size */
  81   2              q_p->size++;
  82   2      
  83   2              status = TRUE;
  84   2          }
  85   1      
  86   1          EA = interrupt_status;
  87   1      
  88   1          return (status);
  89   1      }
  90          
  91          
  92          /*
  93           *
  94           * This function reads or removes a buffer from a queue as per
  95           * the search criteria provided. If search criteria is NULL, then the first
  96           * buffer is returned, otherwise buffer matching the given criteria is returned
C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 3   

  97           *
  98           * q_p  - Pointer to the queue where the buffer is to be read or removed.
  99           *
 100           * mode - Mode of operations. If this parameter has value REMOVE_MODE,
 101           * buffer will be removed from queue and returned. If this parameter is
 102           * READ_MODE, buffer pointer will be returned without removing from queue.
 103           *
 104           * search_p - Search criteria structure pointer.
 105           *
 106           * Return buffer header pointer, if the buffer is successfully
 107           * removed or read, otherwise NULL is returned.
 108           */
 109          static buffer_t *queue_read_or_remove (queue_t *q_p,
 110                                                 buffer_mode_t mode,
 111                                                 search_t *search_p)
 112          {
 113   1      
 114   1          buffer_t *buffer_current_p = NULL;
 115   1          buffer_t *buffer_previous_p;
 116   1          u8       interrupt_status;
 117   1          
 118   1          interrupt_status = EA;
 119   1      
 120   1          EA = 0;
 121   1          /* Check whether queue is empty */
 122   1          if (q_p->size != 0) {
 123   2              buffer_current_p  = q_p->head;
 124   2              buffer_previous_p = q_p->head;
 125   2      
 126   2              /* First get buffer matching with criteria */
 127   2              if (NULL != search_p) {
 128   3                  bool match;
 129   3                  /* Search for all buffers in the queue */
 130   3                  while (NULL != buffer_current_p) {
 131   4      #ifdef CALLBACK
                              match = search_p->compare_func((void *)buffer_current_p->body,
                                                              search_p->handle);
              #else
 135   4                      switch (search_p->compare_func_id) {
 136   5                      case MAC_BEACON_ADD_PENDING_SHORT_ADDR:
 137   5                          match = 
 138   5                              mac_beacon_add_pending_short_address_cb(
 139   5                                  (void *)buffer_current_p->body, search_p->handle);
 140   5                          break;
 141   5                      case MAC_BEACON_ADD_PENDING_EXT_ADDR:
 142   5                          match =
 143   5                              mac_beacon_add_pending_extended_address_cb(
 144   5                                  (void *)buffer_current_p->body, search_p->handle);
 145   5                          break;
 146   5                      case MAC_DATA_FIND_SHORT_ADDR:
 147   5                          match =
 148   5                              mac_data_find_short_addr_buffer(
 149   5                                  (void *)buffer_current_p->body, search_p->handle);
 150   5                          break;
 151   5                      case MAC_DATA_FIND_EXT_ADDR:
 152   5                          match =
 153   5                              mac_data_find_long_addr_buffer(
 154   5                                  (void *)buffer_current_p->body, search_p->handle);
 155   5                          break;
 156   5                      case MAC_DECREMENT_PERSI_TIME:
 157   5                          match =
 158   5                              decrement_persistence_time(
C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 4   

 159   5                                  (void *)buffer_current_p->body, search_p->handle);
 160   5                          break;
 161   5                      case MAC_CHECK_PERSI_TIME_ZERO:
 162   5                          match =
 163   5                              check_persistence_time_zero(
 164   5                                  (void *)buffer_current_p->body, search_p->handle);
 165   5                          break;
 166   5                      case MAC_FIND_BUFFER:
 167   5                          match =
 168   5                              find_buffer((void *)buffer_current_p->body,
 169   5                                          search_p->handle);
 170   5                          break;
 171   5                      case MAC_FIND_MSDU:
 172   5                          match =
 173   5                              check_msdu_handle_cb((void *)buffer_current_p->body,
 174   5                                                   search_p->handle);
 175   5                          break;
 176   5                      default:
 177   5                          goto done;
 178   5                      }
 179   4      #endif
 180   4      
 181   4                      if (match == TRUE) {
 182   5                          /* Break, if search criteria matches */
 183   5                          break;
 184   5                      }
 185   4      
 186   4                      buffer_previous_p = buffer_current_p;
 187   4                      buffer_current_p  = buffer_current_p->next;
 188   4                  }
 189   3              }
 190   2      
 191   2              /* Buffer matching with search criteria found */
 192   2              if (NULL != buffer_current_p) {
 193   3                  /* Remove buffer from the queue */
 194   3                  if (REMOVE_MODE == mode) {
 195   4                      /* Update head if buffer removed is first node */
 196   4                      if (buffer_current_p == q_p->head) {
 197   5                          q_p->head = buffer_current_p->next;
 198   5                      } else {
 199   5                          /* Update the link by removing the buffer */
 200   5                          buffer_previous_p->next = buffer_current_p->next;
 201   5                      }
 202   4      
 203   4                      /* Update tail if buffer removed is last node */
 204   4                      if (buffer_current_p == q_p->tail) {
 205   5                          q_p->tail = buffer_previous_p;
 206   5                      }
 207   4      
 208   4                      /* Update size */
 209   4                      q_p->size--;
 210   4      
 211   4                      if (NULL == q_p->head) {
 212   5                          q_p->tail = NULL;
 213   5                      }
 214   4                  } else {
 215   4                      /* Nothing needs done if the mode is READ_MODE */
 216   4                  }
 217   3              }
 218   2          }
 219   1      
 220   1      done:
C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 5   

 221   1          EA = interrupt_status;
 222   1      
 223   1          /* Return the buffer. note that pointer to header of buffer is returned */
 224   1          return (buffer_current_p);
 225   1      }
 226          
 227          /**
 228           *
 229           * This function removes a buffer from queue
 230           *
 231           * q_p - Pointer to the queue where buffer should be removed
 232           *
 233           * search_p - Search criteria. If this parameter is NULL, first buffer in the
 234           * queue will be removed. Otherwise buffer matching the criteria will be
 235           * removed.
 236           *
 237           * return Pointer to the buffer header, if the buffer is successfully removed,
 238           * NULL otherwise.
 239           */
 240          buffer_t *qmm_queue_remove (queue_t *q_p, search_t *search_p)
 241          {
 242   1          return (queue_read_or_remove(q_p, REMOVE_MODE, search_p));
 243   1      }
 244          
 245          /**
 246           *
 247           * This function reads either the first buffer if search is NULL or buffer
 248           * matching the given criteria from queue.
 249           *
 250           * q_p - Pointer to The queue where the buffer should be read.
 251           *
 252           * search_p - If this parameter is NULL first buffer in the queue will be
 253           * read. Otherwise buffer matching the criteria will be read
 254           *
 255           * Return pointer to the buffer header which is to be read, NULL if the buffer
 256           * is not available
 257           */
 258          buffer_t *qmm_queue_read (queue_t *q_p, search_t *search_p)
 259          {
 260   1          return (queue_read_or_remove(q_p, READ_MODE, search_p));
 261   1      }
 262          
 263          /**
 264           * flushing a specific queue
 265           *
 266           * q - Pointer to the Queue to be flushed
 267           */
 268          void qmm_queue_flush (queue_t *q_p)
 269          {
 270   1          buffer_t *buf_to_free_p;
 271   1      
 272   1          while (q_p->size > 0) {
 273   2              /* Remove the buffer from the queue and free it */
 274   2              buf_to_free_p = qmm_queue_remove(q_p, NULL);
 275   2      
 276   2              if (NULL == buf_to_free_p) {
 277   3                  q_p->size = 0;
 278   3                  return;
 279   3              }
 280   2              bmm_buffer_free(buf_to_free_p);
 281   2          }
 282   1      }
C51 COMPILER V9.53.0.0   QMM                                                               11/04/2015 20:09:50 PAGE 6   

 283          
 284          #endif //HYBRII_802154
 285          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1250    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      42
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
