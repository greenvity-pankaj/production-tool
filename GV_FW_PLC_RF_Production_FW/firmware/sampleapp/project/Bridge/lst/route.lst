C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE ROUTE
OBJECT MODULE PLACED IN .\obj\route.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\sampleapp\src\route.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BRO
                    -WSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\firmwa
                    -re\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\..\.
                    -.\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware\hpg
                    -p\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\..\..
                    -\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\..\..
                    -\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\..\.
                    -.\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\..\.
                    -.\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\inc;
                    -..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..\..\
                    -components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\components
                    -\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash\inc
                    -;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\..\..
                    -\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc;..\
                    -..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\compon
                    -ents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBR
                    -II_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYBRII
                    -_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYBRII
                    -_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,SW_
                    -RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_APP,
                    -LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\route.lst) TABS(2) OBJECT(.\obj
                    -\route.obj)

line level    source

   1          /* ========================================================
   2           *
   3           * @file:  route.c
   4           * 
   5           * @brief: This file handles the registration process of the 
   6           *       node with the Host
   7           *      
   8           *  Copyright (C) 2010-2015, Greenvity Communications, Inc.
   9           *  All Rights Reserved
  10           *  
  11           * =========================================================*/
  12          
  13          /****************************************************************************** 
  14            * Includes
  15            ******************************************************************************/
  16          
  17          #ifdef ROUTE_APP
  18          
  19          #include <string.h>
  20          #include <stdio.h>
  21          #include <stdlib.h>
  22          #include "gv701x_includes.h"
  23          #include "route.h"
  24          #include "route_fw.h"
  25          #ifdef REGISTER_APP
  26          #include "register.h"
  27          #include "register_fw.h"
  28          #endif
  29          #ifdef LLP_APP
  30          #include "llpapp.h"
  31          #include "llpapp_fw.h"
  32          #endif
  33          #ifdef NWKSTARTUP_APP
  34          #include "gv701x_nwkstartup.h"
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 2   

  35          #endif
  36          #ifdef LRWPAN_DRIVER_APP
  37          #include "gv701x_lrwpandriver.h"
  38          #endif
  39          #ifdef HPGP_DRIVER_APP
  40          #include "gv701x_hpgpdriver.h"
  41          #endif
  42          #ifdef RTOPO_APP
  43          #include "route_topo_fw.h"
  44          #include "route_topo.h"
  45          #endif
  46          
  47          /****************************************************************************** 
  48            * Global Data
  49            ******************************************************************************/
  50          /*Route State machine*/
  51          gv701x_state_t route_state;
  52          
  53          u8 route_app_id;
  54          gv701x_app_queue_t route_queues;  
  55          
  56          /* Routing info of this device */
  57          route_info_t route_info;
  58          
  59          /* Neighbouring or Potential Parent table */
  60          neighbor_info_t route_neighbor[MAX_NEIGHBOUR_DEVICES];
  61          
  62          /* Routing table */
  63          static route_table_t route_table[MAX_ROUTE_TABLE_ENTRIES]; 
  64          
  65          /* Route Device Profile */
  66          route_device_profile_t route_device_profile;
  67          
  68          u32 totalTx = 0;
  69          u32 totalRx = 0;
  70          
  71          /****************************************************************************** 
  72            * External Data
  73            ******************************************************************************/
  74          extern rtopo_data_t rtopo_data;
  75          
  76          /****************************************************************************** 
  77            * External Function Prototypes
  78            ******************************************************************************/
  79          extern u8 CRM_AddScbVendorField(u8 *macAddr, u16 vendor_field);
  80          extern eStatus CRM_GetMacAddr(u8 tei, u8 *macAddr);
  81          extern u8 CRM_FindScbVendorField(u16 vendor_field, u8 *macAddr);
  82          #define GV701x_getHPGPDeviceMAC CRM_GetMacAddr
  83          
  84          /****************************************************************************** 
  85            * Function Prototypes
  86            ******************************************************************************/
  87          
  88          static u8 route_handle_received_frm (u8 *frm, u8 len, u8 link, u8 lqi);
  89          static void route_handle_fpreq (u8 *frm, u8 link, u8 lqi) ;
  90          static void route_handle_fprsp (u8 *frm, u8 link, u8 lqi); 
  91          static void route_handle_sroute_req (u8 *frm, u8 len, u8 link); 
  92          static void route_handle_sroute_rsp (u8 *frm, u8 len, u8 link); 
  93          static void route_handle_probe_req (u8 *frm, u8 len, u8 link);
  94          static void route_handle_probe_rsp (u8 *frm, u8 len, u8 link);
  95          static bool route_create_discover_fpreq_frame (u16 target, u8* wir_mac_addr, u16 wir_addr, 
  96                                  u8* pwr_mac_addr, u16 pwr_addr, u8 link);
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 3   

  97          static bool route_create_and_send_fprsp_frame (u8 *dst_ieee_addr, u16 target, u8 link);
  98          static bool route_create_and_send_sroute_frame (u16 target);
  99          static bool route_create_and_send_probe_rsp (u8 *ieee_addr, u16 dest, u8 rank, u8 len, u8 link);
 100          static bool route_create_and_send_probe_req (neighbor_info_t *nbr, u8 index);
 101          static bool route_get_my_header (route_hdr_t *hdr, u16 destn, u8 frametype, u8 direction);
 102          static route_table_t *route_get_next_hop (u16 target);
 103          static route_table_t * route_get_route (u16 target);
 104          static u8 route_get_neighbor_index(u8* ieee_addr, u8 link);
 105          static neighbor_info_t *route_get_neighbor_link(u8 link);
 106          static bool route_remove_route (u16 target);
 107          static bool route_remove_neighbor(u16 neigh_addr, u8 link);
 108          static bool route_remove_neighbor_using_index(u8 idx);
 109          static bool route_remove_link_neighbor (u8 link);
 110          static bool route_flush_nwktables (void);
 111          static bool route_add_route (u16 target, u16 parent, u8 *ieee_addr, u8 link_type);
 112          neighbor_info_t* route_select_best_neighbor(u8 link);
 113          static neighbor_info_t *route_get_neighbor (u16 neigh_addr);
 114          static bool route_send_frm (u8 *dstn_ieee_addr, u8 *src_ieee_addr, u16 dest, u16 src, u8 dir, 
 115                          u8 *buff, u8 len, u8 link, u8 rhdr_present, u8 forward);
 116          static u8 route_send_to_ul (u8* frm, u8 len, u8 link);
 117          static void route_periodic_probing (void); 
 118          static void route_rtable_aging_timer (void); 
 119          //u8 RouteApp_LedControl(u8 statemode_en);
 120          void RouteApp_StartDiscovery(u8 link, u8 assignparent, u8 cont_disc); 
 121          void RouteApp_SendEvent(u8 ind, u8 link, u8 reason);
 122          
 123          
 124          
 125          /******************************************************************************
 126           * @fn      RouteApp_Init
 127           *
 128           * @brief   Initializes the Routing Layer
 129           *
 130           * @param   app_id - application identification number
 131           *
 132           * @return  none
 133           */
 134          
 135          void RouteApp_Init(u8 app_id)
 136          {
 137   1        u8* macaddr;
 138   1        memset (&route_info, 0x00, sizeof (route_info_t));
 139   1        memset(&route_state, 0x00, sizeof(gv701x_state_t));
 140   1        
 141   1        /*Record the applications id,will 
 142   1         be used while allocating timers*/
 143   1        route_app_id = app_id;
 144   1        SLIST_Init(&route_queues.appRxQueue);
 145   1      
 146   1        FM_Printf(FM_USER, "\nInit RouteApp (app id)", app_id);
 147   1        
 148   1        macaddr = GV701x_ReadMacAddress();
 149   1        memcpy((u8*)&route_info.ieee_addr, (u8*)macaddr, MAC_ADDR_LEN);
 150   1      #if 0 
                FM_HexDump(FM_APP, "MAC: ", (u8*)&route_info.ieee_addr, MAC_ADDR_LEN);      
              #endif
 153   1      
 154   1        /*Initialize the database*/
 155   1        memset(&route_table, 0x00, MAX_ROUTE_TABLE_ENTRIES*(sizeof(route_table_t))); 
 156   1        memset (route_neighbor, 0x00, MAX_NEIGHBOUR_DEVICES*(sizeof (neighbor_info_t)));    
 157   1        route_device_profile.device_type = RTR_DEVICE_TYPE; 
 158   1      
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 4   

 159   1        /*Initialize the state machine*/
 160   1        route_state.state = ROUTE_INIT;
 161   1        route_state.event = ROUTE_IDLE_EVNT;  
 162   1        route_state.statedata = NULL; 
 163   1        route_state.statedatalen = 0; 
 164   1        route_info.unreachable = TRUE;
 165   1      
 166   1        /*Initalize the different configurations*/
 167   1        route_info.rssi_threshold = ROUTE_RSSI_THRESHOLD;
 168   1        route_info.bcn_threshold = ROUTE_BCNRX_THRESHOLD;
 169   1        route_info.lqi_diff = ROUTE_LQI_DIFF;
 170   1        route_info.ed_diff = ROUTE_ED_DIFF; 
 171   1        route_info.lqi_threshold = ROUTE_LQI_THRESHOLD; 
 172   1        route_info.ed_threshold = (0xFF - ROUTE_ED_THRESHOLD);  
 173   1      
 174   1      #if 0
                FM_Printf(FM_APP, "\nEd Thresh: %bx %bu", route_info.ed_threshold, route_info.ed_threshold);
              #endif
 177   1        route_info.sroute_fail_cntdwn = MAX_SROUTE_FAIL_COUNT;          
 178   1        route_info.route_sel_active = TRUE;
 179   1      
 180   1        /* Configures GP_PB_IO4 & 5 as output pins for LED indication */
 181   1      #ifdef HQ_LINK_TEST
                GV701x_GPIO_Config(WRITE_ONLY, RED_LED | GREEN_LED);
                GV701x_GPIO_Write(GREEN_LED, LED_OFF);
                GV701x_GPIO_Write(RED_LED, LED_OFF);      
              #endif
 186   1        /* Allocate Discovery timer */
 187   1        route_info.discovery_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
 188   1                              ROUTE_DISCOVER_TIMEOUT_EVT, 
 189   1                              &route_app_id); 
 190   1      
 191   1      
 192   1      #ifdef ROUTE_PROBE
              
                /* Alloc Probe timer */
                route_info.probe.prd_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
                                        PROBE_TIMEOUT_EVT, 
                                        &route_app_id);
                
                /* Alloc Probe Retransmit timer */
                route_info.probe.retrans_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
                                        ROUTE_PROBE_RE_TIMEOUT_EVT, 
                                        &route_app_id);
              
              #endif
 205   1      
 206   1        /* Sroute Request Periodic timer */
 207   1        route_info.sroute_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
 208   1                                ROUTE_SROUTE_PERIODIC_TIMEOUT_EVT, 
 209   1                                &route_app_id);
 210   1      
 211   1      #ifdef ROUTE_RECOVERY
 212   1        route_info.rec_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
 213   1                              ROUTE_REC_TIMEOUT_EVT, 
 214   1                              &route_app_id); 
 215   1      
 216   1        STM_StartTimer(route_info.rec_timer, ROUTE_RECOVERY_TIME_BOOTUP ); //15 minutes
 217   1      
 218   1      #endif  
 219   1      }
 220          
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 5   

 221          /******************************************************************************
 222           * @fn      RouteApp_TimerHandler
 223           *
 224           * @brief   Timer handler for Routing timer events
 225           *
 226           * @param   event - event from firmware
 227           *
 228           * @return  none
 229           *
 230           */
 231          
 232          #ifdef ROUTE_RECOVERY 
 233          extern void swResetGV701x(u8 reset);
 234          #endif
 235          void RouteApp_TimerHandler(u8* buf)
 236          { 
 237   1        hostTimerEvnt_t* timerevt = 
 238   1            (hostTimerEvnt_t*)buf;  
 239   1      
 240   1        if(buf == NULL)
 241   1          return;
 242   1      
 243   1        /*Demultiplexing the specific timer event*/           
 244   1        switch((u8)timerevt->type)
 245   1        {               
 246   2          case ROUTE_DISCOVER_TIMEOUT_EVT:
 247   2          case PROBE_TIMEOUT_EVT:
 248   2          case ROUTE_PROBE_RE_TIMEOUT_EVT:        
 249   2          case ROUTE_SROUTE_PERIODIC_TIMEOUT_EVT:
 250   2      #ifdef ROUTE_RECOVERY     
 251   2          case ROUTE_REC_TIMEOUT_EVT:
 252   2      #endif
 253   2            /*Discover timeout*/
 254   2            if(((u8)timerevt->type == ROUTE_DISCOVER_TIMEOUT_EVT) &&
 255   2              (route_info.disc_params.link != 0))
 256   2            {   
 257   3              u8 disc_link = route_info.disc_params.link;
 258   3              neighbor_info_t* powerline_nbr = NULL;
 259   3              neighbor_info_t* wireless_nbr = NULL;
 260   3      
 261   3      #if 1
 262   3              FM_Printf(FM_APP, "\nDisc (dl %bx ap %bx pc %bu wc %bu pl %bu ra %bu)", route_info.disc_params.link,
 263   3                   route_info.disc_params.assignparent, route_info.disc_params.powerline.cnt,
 264   3                   route_info.disc_params.wireless.cnt, rtopo_data.link_pref.link,
 265   3                   route_info.route_sel_active);
 266   3      #endif
 267   3              /*Check if PLC is the current discovering link*/
 268   3              if((route_info.disc_params.link & POWER_LINE) == POWER_LINE)
 269   3              {           
 270   4                if((route_info.disc_params.powerline.cnt >  \
 271   4                  (((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE) ? \
 272   4                  (ROUTE_DISC_MAX_HIGH_CNT) : (ROUTE_DISC_MAX_LOW_CNT))))
 273   4                {
 274   5                  if((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE)
 275   5                  {
 276   6                    if((route_info.disc_params.link & WIRELESS) == WIRELESS)
 277   6                    {
 278   7                      /*Change pereference to Wireless when PLC 
 279   7                        discovery trials is exhausts*/
 280   7      #ifdef RTOPO_APP            
 281   7                      rtopo_data.link_pref.link = WIRELESS;
 282   7      #endif
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 6   

 283   7                    }
 284   6                    else
 285   6                      rtopo_data.link_pref.link = 0;              
 286   6                  }
 287   5                  route_info.disc_params.link &= ~POWER_LINE;             
 288   5                  route_info.start.power_line.active = FALSE;
 289   5                }
 290   4                else
 291   4                {
 292   5                  if((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE)
 293   5                  {         
 294   6                    if(route_info.disc_params.powerline.cnt == ROUTE_DISC_MAX_HIGH_CNT)
 295   6                    {
 296   7                      /*Try to find a potential parent on PLC*/
 297   7                      powerline_nbr = route_select_best_neighbor(POWER_LINE);               
 298   7                    }
 299   6                  }
 300   5                  route_info.disc_params.powerline.cnt++;           
 301   5                }           
 302   4              }
 303   3      
 304   3              /*Check if Wireless is the current discovering link*/
 305   3              if((route_info.disc_params.link & WIRELESS) == WIRELESS)
 306   3              {
 307   4                if((route_info.disc_params.wireless.cnt > \
 308   4                  (((route_info.disc_params.assignparent & WIRELESS) == WIRELESS) ? \
 309   4                  (ROUTE_DISC_MAX_HIGH_CNT) : (ROUTE_DISC_MAX_LOW_CNT))))
 310   4                {
 311   5                  if((route_info.disc_params.assignparent & WIRELESS) == WIRELESS)
 312   5                  {         
 313   6                    if((route_info.disc_params.link & POWER_LINE) == POWER_LINE)
 314   6                    {
 315   7                      /*Change pereference to PLC when Wireless
 316   7                        discovery trials is exhausts*/              
 317   7      #ifdef RTOPO_APP            
 318   7                      rtopo_data.link_pref.link = POWER_LINE;
 319   7      #endif
 320   7                    }
 321   6                    else
 322   6                      rtopo_data.link_pref.link = 0;
 323   6                  }
 324   5                  route_info.disc_params.link &= ~WIRELESS;
 325   5                  route_info.start.wireless.active = FALSE;
 326   5                }
 327   4                else
 328   4                {
 329   5                  if((route_info.disc_params.assignparent & WIRELESS) == WIRELESS)          
 330   5                  {
 331   6                    if(route_info.disc_params.wireless.cnt == ROUTE_DISC_MAX_HIGH_CNT)
 332   6                    {
 333   7                      /*Try to find a potential parent on Wireless*/
 334   7                      wireless_nbr = route_select_best_neighbor(WIRELESS);    
 335   7                    }
 336   6                  }
 337   5                  route_info.disc_params.wireless.cnt++;
 338   5                }
 339   4              }
 340   3      #ifdef RTOPO_APP        
 341   3              /*Access the PLC link*/       
 342   3              if((rtopo_data.link_pref.link == POWER_LINE) &&
 343   3                 ((powerline_nbr != NULL) ? (powerline_nbr->addr != 0): (FALSE)))
 344   3              {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 7   

 345   4                if((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE)
 346   4                {
 347   5                  if(TRUE == route_assign_best_parent(powerline_nbr))
 348   5                  {
 349   6                    /*Parent found on PLC, stop discovery on all links*/
 350   6                    route_info.disc_params.link &= ~POWER_LINE;
 351   6                    route_info.disc_params.powerline.cnt = 0;
 352   6                    //rtopo_data.link_pref.link = POWER_LINE;
 353   6                  }
 354   5                  else
 355   5                  {
 356   6                    route_remove_link_neighbor(POWER_LINE);
 357   6                  }
 358   5                }
 359   4              }
 360   3      
 361   3              /*Access the Wireless link*/
 362   3              if((rtopo_data.link_pref.link == WIRELESS) &&
 363   3                ((wireless_nbr != NULL) ? (wireless_nbr->addr != 0): (FALSE)))
 364   3              { 
 365   4                if((route_info.disc_params.assignparent & WIRELESS) == WIRELESS)
 366   4                {
 367   5                  if(TRUE == route_assign_best_parent(wireless_nbr))
 368   5                  {
 369   6                    /*Parent found on Wireless, stop discovery on all links*/           
 370   6                    route_info.disc_params.link &= ~WIRELESS;
 371   6                    route_info.disc_params.wireless.cnt = 0;  
 372   6                  }
 373   5                  else
 374   5                  {
 375   6                    route_remove_link_neighbor(WIRELESS);
 376   6                  }           
 377   5                }
 378   4              } 
 379   3      #endif    
 380   3      #if 0
                      /*Continue discovering if no parent found*/
                      if(route_info.disc_params.link != 0)
                      {       
                        if((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE)
                        {       
                          if(powerline_nbr != NULL)
                            rtopo_data.link_pref.link = POWER_LINE;
                        }
                        RouteApp_StartDiscovery(route_info.disc_params.link, 
                                route_info.disc_params.assignparent, 0);  
                      } 
                      else
              #endif          
 394   3              {
 395   4      #if 0
                        FM_Printf(FM_APP, "\nEnd(dl %bx ap %bx lo %bu %bu)", disc_link,
                            route_info.disc_params.assignparent, 
                            ((route_info.disc_params.assignparent & WIRELESS) != WIRELESS),
                            ((route_info.disc_params.assignparent & POWER_LINE) != POWER_LINE));
              #endif
 401   4      
 402   4                if((disc_link & WIRELESS) || (disc_link & POWER_LINE))
 403   4                {
 404   5                  u8 done_link = 0;
 405   5                  u8 undone_link = 0;
 406   5      
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 8   

 407   5      #if 0       
                          FM_Printf(FM_APP, "\nDdone");
              #endif          
 410   5                  if(disc_link & WIRELESS) 
 411   5                  {             
 412   6                    if((route_info.disc_params.link & WIRELESS) != WIRELESS)
 413   6                      done_link |= WIRELESS; 
 414   6                    else
 415   6                      undone_link |= WIRELESS; 
 416   6                  }
 417   5                  
 418   5                  if(disc_link & POWER_LINE)
 419   5                  {
 420   6                     if((route_info.disc_params.link & POWER_LINE) != POWER_LINE)
 421   6                      done_link |= POWER_LINE;
 422   6                     else
 423   6                      undone_link |= POWER_LINE; 
 424   6                  }
 425   5      #if 1       
 426   5                  FM_Printf(FM_APP, "\n1.0 dl %bu udl %bu pc %bu wc %bu ra %bu parl %bu", done_link, undone_link,
 427   5                      route_info.disc_params.powerline.cnt,
 428   5                      route_info.disc_params.wireless.cnt, 
 429   5                      route_info.route_sel_active, 
 430   5                      ((route_info.parent != NULL) ? (route_info.parent->link) : (0)));
 431   5      #endif
 432   5                  if(undone_link != 0)
 433   5                  {   
 434   6                    if((undone_link & POWER_LINE) && \
 435   6                      (((route_info.disc_params.powerline.cnt-1) == \
 436   6                      (((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE) ? \
 437   6                      (ROUTE_DISC_MAX_HIGH_CNT) : (ROUTE_DISC_MAX_LOW_CNT)))))
 438   6                    {               
 439   7                      if(FALSE == route_is_neightable_empty(POWER_LINE))
 440   7                      {
 441   8                        done_link |= POWER_LINE;
 442   8                        undone_link &= ~POWER_LINE;
 443   8                        route_info.start.power_line.active = FALSE;
 444   8                      }
 445   7                    }
 446   6      
 447   6                    if((undone_link & WIRELESS) && \
 448   6                      (((route_info.disc_params.wireless.cnt-1) ==  \
 449   6                      (((route_info.disc_params.assignparent & WIRELESS) == WIRELESS) ? \
 450   6                      (ROUTE_DISC_MAX_HIGH_CNT) : (ROUTE_DISC_MAX_LOW_CNT)))))
 451   6                    {
 452   7                      if(FALSE == route_is_neightable_empty(WIRELESS))
 453   7                      {
 454   8                        done_link |= WIRELESS;
 455   8                        undone_link &= ~WIRELESS;
 456   8                        route_info.start.wireless.active = FALSE;
 457   8                      }
 458   7                    }
 459   6      
 460   6      #if 0
                            FM_Printf(FM_APP, "\nDL %bu UL %bu", done_link, undone_link);
              #endif
 463   6                  }
 464   5      
 465   5                  if(done_link != 0)
 466   5                  {                           
 467   6                    route_info.disc_params.link &= ~done_link;                
 468   6                    if(done_link & POWER_LINE)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 9   

 469   6                      route_info.disc_params.powerline.cnt = 0;
 470   6                    if(done_link & WIRELESS)
 471   6                      route_info.disc_params.wireless.cnt = 0;  
 472   6      
 473   6                    if((((route_info.disc_params.assignparent & WIRELESS) != WIRELESS) &&
 474   6                      (done_link & WIRELESS)) ||
 475   6                       (((route_info.disc_params.assignparent & POWER_LINE) != POWER_LINE) &&
 476   6                       (done_link & POWER_LINE)))
 477   6                    {                                   
 478   7                      RouteApp_SendEvent(ROUTE_DISC_IND, done_link, 
 479   7                                 ROUTE_REASON_MANUAL);
 480   7                    }             
 481   6                    
 482   6                    if((((route_info.disc_params.assignparent & WIRELESS) == WIRELESS) &&
 483   6                      (done_link & WIRELESS)) ||
 484   6                       (((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE) &&
 485   6                       (done_link & POWER_LINE)))                   
 486   6                    {               
 487   7                      route_info.disc_params.assignparent &= ~done_link;
 488   7                      if(route_info.parent != NULL) 
 489   7                      {
 490   8                        if((route_info.parent->link & done_link) == 0)
 491   8                        {
 492   9                          if(route_info.route_sel_active == TRUE) 
 493   9                          {
 494  10                            RouteApp_SendEvent(ROUTE_DWN_IND, done_link, 
 495  10                                       ROUTE_REASON_ROUTEFAIL);           
 496  10                          }
 497   9                        }
 498   8                        else
 499   8                        {
 500   9                        }
 501   8                      }
 502   7                      else 
 503   7                      {
 504   8                        RouteApp_SendEvent(ROUTE_DWN_IND, done_link, 
 505   8                                   ROUTE_REASON_ROUTEFAIL); 
 506   8                      }                
 507   7                    }           
 508   6                  }
 509   5                  if(undone_link != 0)
 510   5                  {
 511   6                    RouteApp_StartDiscovery(undone_link, 
 512   6                          route_info.disc_params.assignparent, 0);
 513   6                  }           
 514   5                }
 515   4      
 516   4              }
 517   3            }
 518   2            else
 519   2            { 
 520   3      #ifdef ROUTE_RECOVERY     
 521   3              if ((u8)timerevt->type == ROUTE_REC_TIMEOUT_EVT)
 522   3              {
 523   4                swResetGV701x(1);
 524   4              }
 525   3              else
 526   3      #endif          
 527   3      #ifdef ROUTE_PROBE
                      /*Probe timeout*/
                      if((u8)timerevt->type == PROBE_TIMEOUT_EVT)
                      {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 10  

                        route_periodic_probing();           
                        /* Start Periodic timer */                
                        if(STATUS_SUCCESS != STM_StartTimer(route_info.probe.prd_timer, 
                                                MAX_PROBE_INTERVAL))
                        {             
                        }       
                      }
                      
                      /*Sroute timeout*/
                      else 
              #endif          
 542   3              if((u8)timerevt->type == ROUTE_SROUTE_PERIODIC_TIMEOUT_EVT)
 543   3              {
 544   4                /*If sroute fails*/
 545   4                if(route_info.sroute_fail_cntdwn == 0)
 546   4                {
 547   5      #ifdef ROUTE_ROAM       
                          if(route_info.parent->link == WIRELESS)
                          {
                          
                            route_info.sroute_fail_cntdwn = MAX_SROUTE_FAIL_COUNT;
              
                            route_info.roaming_enable = 1;
                            printf("ROAMEN\n");             
                            RouteApp_StartDiscovery(WIRELESS, WIRELESS, route_info.parent->link);             
                          }
                          else
                          
              #endif
 560   5                  {                                             
 561   6                    /*Remove parent from neighbor table and 
 562   6                      trigger stop event*/              
 563   6                    route_info.sroute_fail_cntdwn = MAX_SROUTE_FAIL_COUNT;
 564   6                    RouteApp_SendEvent(ROUTE_DWN_IND, route_info.parent->link, 
 565   6                              ROUTE_REASON_ROUTEFAIL);
 566   6                  }
 567   5                }         
 568   4                else 
 569   4                {
 570   5                  if(TRUE == route_create_and_send_sroute_frame(route_info.zid)) 
 571   5                  {
 572   6                    /* Start SROUTE periodic timer frame */ 
 573   6                    if (STATUS_FAILURE == STM_StartTimer(route_info.sroute_timer, 
 574   6                        ((route_state.state == ROUTE_COMPLETE) ? 
 575   6                          MAX_SROUTE_PERIODIC_INTERVAL_HIGH : MAX_SROUTE_PERIODIC_INTERVAL_LOW))) 
 576   6                    {     
 577   7                    }               
 578   6                  } 
 579   5      
 580   5                  /*Age the entries*/
 581   5                  route_rtable_aging_timer();                                   
 582   5                }           
 583   4              }
 584   3      
 585   3              /*Probe Re-transmission timeout*/
 586   3      #ifdef ROUTE_PROBE        
                      else if((u8)timerevt->type == ROUTE_PROBE_RE_TIMEOUT_EVT)
                      {
                        if (route_info.probe.retrans_index != 0xFF) 
                        {
                          if (route_info.probe.retrans_count++ <= MAX_PROBE_RETRANSMIT) 
                          {                     
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 11  

                            if(TRUE == route_create_and_send_probe_req (&route_neighbor[route_info.probe.retrans_index], 
                              route_info.probe.retrans_index))
                            { 
                            }
                          }
                          else 
                          {
                            /*Probe failed, if the neighbor was the parent trigger
                              a route stop event immediately*/
                            if(route_neighbor[route_info.probe.retrans_index].addr == route_info.parent->addr)
                            {
                              RouteApp_SendEvent(ROUTE_DWN_IND, route_info.parent->link, ROUTE_REASON_ROUTEFAIL);
                            }
                            route_info.probe.retrans_index = 0xFF;
                            route_info.probe.retrans_count = 0;                       
                          }
                        }
                      }
              #endif        
 612   3            }
 613   2          break;
 614   2      
 615   2          default:
 616   2          break;
 617   2        }
 618   1      }
 619          
 620          /******************************************************************************
 621           * @fn      RouteApp_RxAppMsg
 622           *
 623           * @brief   Receives a message from another app/fw
 624           *
 625           * @params  msg_buf - message buffer
 626           *
 627           * @return  none
 628           */
 629          
 630          void RouteApp_RxAppMsg(sEvent* event)
 631          {
 632   1        gv701x_app_msg_hdr_t* msg_hdr = (gv701x_app_msg_hdr_t*)event->buffDesc.dataptr;
 633   1        hostHdr_t* hybrii_hdr;
 634   1        hostEventHdr_t* evnt_hdr;
 635   1      
 636   1        hybrii_hdr = (hostHdr_t*)(msg_hdr + 1);
 637   1        
 638   1        if(msg_hdr->dst_app_id == route_app_id)
 639   1        {
 640   2          memcpy(&route_state.msg_hdr, msg_hdr, sizeof(gv701x_app_msg_hdr_t));
 641   2          route_state.eventproto = hybrii_hdr->protocol;
 642   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 643   2            (hybrii_hdr->type == EVENT_FRM_ID))
 644   2          {
 645   3            evnt_hdr = (hostEventHdr_t*)(hybrii_hdr + 1);
 646   3            route_state.event = evnt_hdr->type;   
 647   3            route_state.statedata = (u8*)(evnt_hdr + 1);
 648   3            route_state.statedatalen = (u16)(hybrii_hdr->length - sizeof(hostEventHdr_t));    
 649   3          }
 650   2          else
 651   2          {
 652   3            route_state.event = (u8)(*((u8*)(hybrii_hdr + 1)));
 653   3            route_state.statedata = (u8*)(hybrii_hdr + 1);
 654   3            route_state.statedatalen = (u16)hybrii_hdr->length;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 12  

 655   3          }   
 656   2          route_state.eventtype = hybrii_hdr->type;
 657   2          route_state.eventclass = event->eventHdr.eventClass;
 658   2      
 659   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 660   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 661   2            (route_state.event == HOST_EVENT_APP_TIMER))
 662   2          {     
 663   3            RouteApp_TimerHandler((u8*)(evnt_hdr + 1)); 
 664   3            return;
 665   3          }   
 666   2          else if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 667   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 668   2            (route_state.event == HOST_EVENT_APP_CMD))
 669   2          {     
 670   3            RouteApp_CmdProcess((char*)(evnt_hdr + 1)); 
 671   3            return;
 672   3          }       
 673   2        }
 674   1        else if(msg_hdr->dst_app_id == APP_BRDCST_MSG_APPID)
 675   1        {
 676   2          u8 *event = (u8*)(hybrii_hdr + 1);  
 677   2          return;
 678   2        }
 679   1        RouteApp_StateMachine(&route_state);  
 680   1      }
 681          
 682          /******************************************************************************
 683           * @fn      route_handle_received_frm
 684           *
 685           * @brief   Demultiplexes all the OTA Routing frames
 686           *
 687           * @param   event - event from firmware
 688           *
 689           * @return  none
 690           *
 691           */
 692          
 693          static u8 route_handle_received_frm (u8* frm, u8 len, u8 link, u8 lqi)
 694          {
 695   1        u8 ret = 0;
 696   1        route_hdr_t *rhdr = (route_hdr_t *)&frm[(sizeof(sEth2Hdr))];
 697   1        u8 cmdid = RHDR_GET_CMDID(rhdr);
 698   1        totalRx++;
 699   1        
 700   1        switch (cmdid)
 701   1        {
 702   2          case FINDPARENT_REQ:
 703   2            route_info.stats.fpreq_rx++;
 704   2            route_handle_fpreq (frm, link, lqi);
 705   2          break;
 706   2          case FINDPARENT_RSP:
 707   2            route_info.stats.fprsp_rx++;      
 708   2            route_handle_fprsp (frm, link, lqi);
 709   2          break;
 710   2          case SOURCE_ROUTE_REQ:
 711   2            route_handle_sroute_req (frm, len, link);   
 712   2          break;
 713   2          case SOURCE_ROUTE_RSP:
 714   2            route_handle_sroute_rsp (frm, len, link);   
 715   2          break;    
 716   2          case PROBE_REQ:
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 13  

 717   2            route_info.stats.preq_rx++; 
 718   2            route_handle_probe_req (frm, len, link);    
 719   2          break;
 720   2          case PROBE_RSP:
 721   2            route_info.stats.prsp_rx++;     
 722   2            route_handle_probe_rsp (frm, len, link);    
 723   2          break;  
 724   2      #ifdef REGISTER_APP
 725   2          case REGISTRATION_RSP:
 726   2            register_rx_rsp(frm, len);    
 727   2          break;  
 728   2          case REREGISTRATION_REQ:  
 729   2            register_rx_rereq(frm, len);
 730   2          break;    
 731   2      #endif        
 732   2          case APP_FRAME:
 733   2            ret = route_send_to_ul (frm, len, link);
 734   2          break;
 735   2          
 736   2          case GET_PARAM_RSP: 
 737   2            if(RHDR_GET_DIR(rhdr) != DIRECTION_DOWN) 
 738   2            {
 739   3              return ret;
 740   3            }
 741   2            ret = route_send_to_ul (frm, len, link);      
 742   2          break;    
 743   2      
 744   2          default:    
 745   2          break;
 746   2        }
 747   1        return ret;
 748   1      }
 749          
 750          /******************************************************************************
 751           * @fn      route_calc_path_metric
 752           *
 753           * @brief   Calculates the meteric of the neighbor
 754           *
 755           * @param   p - pointer to the neighbor entry (define found in route.h)
 756           *
 757           * @return  meteric
 758           *
 759           */
 760          
 761          static u16 route_calc_path_metric(neighbor_info_t *p)
 762          {
 763   1        if(p->link == WIRELESS)
 764   1        {
 765   2          if((p == NULL) ? (1) : ((route_info.wireless_ch != 0) ? 
 766   2                (p->ch != route_info.wireless_ch): (FALSE)))
 767   2          {
 768   3      #if 0   
                    FM_Printf(FM_APP, "\n8.0");
              #endif
 771   3            return 0;
 772   3          }
 773   2          else 
 774   2          { 
 775   3      #if 0   
                    FM_Printf(FM_APP, "\n8.1");
              #endif
 778   3            if(route_info.wireless_ch != 0)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 14  

 779   3            {
 780   4      #if 0   
                      FM_Printf(FM_APP, "\n8.2");
              #endif
 783   4              if(p->lqi <= route_info.lqi_threshold)      
 784   4              {
 785   5      #if 0       
                        FM_Printf(FM_APP, "\n8.3");
              #endif
 788   5                return 0;
 789   5              }
 790   4              else
 791   4              {
 792   5      #if 0       
                        FM_Printf(FM_APP, "\n8.3.0 %bu", p->cnt);
              #endif        
 795   5                if(p->cnt >= ROUTE_PER_THRESHOLD) 
 796   5                {
 797   6      #if 0       
                          FM_Printf(FM_APP, "\n8.4.0");
              #endif
 800   6                  return p->lqi;
 801   6                }
 802   5                else
 803   5                {
 804   6      #if 0       
                          FM_Printf(FM_APP, "\n8.4");
              #endif
 807   6                  return 0;
 808   6                }
 809   5              }
 810   4            }
 811   3            else
 812   3            {
 813   4      #if 0     
                      FM_Printf(FM_APP, "\n8.5 %bx %bx", p->ed, route_info.ed_threshold);
              #endif
 816   4              if(p->ed <= route_info.ed_threshold)
 817   4              {
 818   5      #if 0       
                        FM_Printf(FM_APP, "\n8.6");
              #endif
 821   5                  return 0;
 822   5              }
 823   4              else
 824   4              {
 825   5      #if 0       
                        FM_Printf(FM_APP, "\n8.7");
              #endif
 828   5                return p->ed;
 829   5              }
 830   4            }
 831   3          }
 832   2        }  
 833   1        else if(p->link == POWER_LINE)
 834   1        {
 835   2          if((p == NULL) ? (1) : (p->rssi <= route_info.rssi_threshold))
 836   2          {
 837   3            return 0;
 838   3          }
 839   2          else
 840   2          {     
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 15  

 841   3            if(p->bcn_rx > route_info.bcn_threshold)
 842   3            {
 843   4              if((route_info.parent != NULL)? (route_info.zid != p->parent_addr):
 844   4                  (TRUE)) 
 845   4              {
 846   5                return p->rssi; 
 847   5              }
 848   4              else
 849   4              {
 850   5                return 0; 
 851   5              }
 852   4            }
 853   3            else
 854   3            {
 855   4              return 0;
 856   4            }
 857   3          }
 858   2        }
 859   1        else
 860   1        {
 861   2          return 0;
 862   2        }
 863   1      }
 864          
 865          /******************************************************************************
 866           * @fn      route_best_parent
 867           *
 868           * @brief   Compares the two neighbors and selects the neighbor with the best meteric 
 869           *
 870           * @param   p1 - pointer to the neighbor entry (define found in route.h)
 871           *      p2 - pointer to the neighbor entry (define found in route.h)
 872           *
 873           * @return  neighbor
 874           *
 875           */
 876          
 877          static neighbor_info_t *route_best_parent(neighbor_info_t *p1, neighbor_info_t *p2)
 878          {
 879   1        u16 min_diff;
 880   1        u16 p1_metric = 0;
 881   1        u16 p2_metric = 0;
 882   1      
 883   1        if(((p1 != NULL)?(p1->link == WIRELESS):(1)) && 
 884   1          ((p2 != NULL)?(p2->link == WIRELESS):(1)))
 885   1        {
 886   2      #if 0 
                  min_diff = RPL_DAG_MC_ETX_DIVISOR /
                           PARENT_SWITCH_THRESHOLD_DIV;
              #else
 890   2          if(route_info.wireless_ch != 0)
 891   2          {
 892   3            /*LQI diff*/
 893   3            min_diff = route_info.lqi_diff;
 894   3      #if 0     
                    FM_Printf(FM_APP, "\n9.0 lqid %u", min_diff);
              #endif
 897   3          }
 898   2          else
 899   2          {
 900   3            /*ED diff*/
 901   3            min_diff = route_info.ed_diff;
 902   3      #if 0     
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 16  

                    FM_Printf(FM_APP, "\n9.1 edd %x", min_diff);
              #endif
 905   3          }     
 906   2      #endif
 907   2      
 908   2          if(p1 != NULL)
 909   2            p1_metric = route_calc_path_metric(p1);
 910   2      
 911   2          if(p2 != NULL)
 912   2            p2_metric = route_calc_path_metric(p2);
 913   2      
 914   2          if((p2_metric != 0) && (p1_metric != 0))
 915   2          {
 916   3      #if 0   
                    FM_Printf(FM_APP, "\np1 %u p2 %u",p1_metric, p2_metric);
              #endif
 919   3            if((abs(p1_metric - p2_metric)) >= min_diff)
 920   3            {
 921   4      #if 0   
                      FM_Printf(FM_APP, "\nDif p1 %u %x p2 %u %x d %u %x",
                              p1_metric, p1_metric, p2_metric, p2_metric,
                              min_diff, min_diff);
              #endif
 926   4              return p1_metric > p2_metric ? p1 : p2;
 927   4            }
 928   3            else
 929   3            {
 930   4              if(route_info.wireless_ch != 0)
 931   4              {
 932   5      #if 0     
                        FM_Printf(FM_APP, "\n8.8 p1 %u p2 %u", p1_metric, p2_metric);
              #endif
 935   5                return p1_metric > p2_metric ? p1 : p2;
 936   5              }
 937   4              else
 938   4              {
 939   5                /*LQI diff*/
 940   5                min_diff = route_info.lqi_diff;
 941   5      #if 0         
                        FM_Printf(FM_APP, "\n8.9 %bx %bx lqidiff %u", p1->lqi, p2->lqi, min_diff);
              #endif
 944   5                if((abs(p1->lqi - p2->lqi)) >= min_diff)
 945   5                {
 946   6      #if 0   
                          FM_Printf(FM_APP, "\nDif p1 %bu p2 %bu d %x ",
                                  p1->lqi, p2->lqi, min_diff);
              #endif
 950   6                  return p1->lqi > p2->lqi ? p1 : p2;
 951   6                } 
 952   5                else
 953   5                {
 954   6      #if 0         
                          FM_Printf(FM_APP, "\n11.13 %bx %bx", p1->ed, p2->ed); 
              #endif
 957   6                  if(p1->ed > p2->ed)
 958   6                  {
 959   7      #if 0           
                            FM_Printf(FM_APP, "\n11.10");
              #endif
 962   7                    return p1;
 963   7                  }
 964   6                  else if(p1->ed < p2->ed)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 17  

 965   6                  {
 966   7      #if 0           
                            FM_Printf(FM_APP, "\n11.11");
              #endif
 969   7                    return p2;
 970   7                  }
 971   6                  else
 972   6                  {
 973   7      #if 0           
                            FM_Printf(FM_APP, "\n11.12");
              #endif            
 976   7                    return p1->lqi > p2->lqi ? p1 : p2;
 977   7                  }
 978   6                }
 979   5              }     
 980   4            }
 981   3          }
 982   2          else
 983   2          {
 984   3      #if 0   
                    FM_Printf(FM_APP, "\n7.1");
              #endif
 987   3            if(p1_metric != 0)
 988   3            {
 989   4      #if 0     
                      FM_Printf(FM_APP, "\n7.2");
              #endif
 992   4              return p1;
 993   4            }
 994   3            else if(p2_metric != 0)
 995   3            {
 996   4      #if 0     
                      FM_Printf(FM_APP, "\n7.3");
              #endif
 999   4              return p2;
1000   4            }
1001   3            else
1002   3            {
1003   4      #if 0     
                      FM_Printf(FM_APP, "\n7.4");
              #endif
1006   4              return NULL;
1007   4            }
1008   3          }   
1009   2        }
1010   1        else if(((p1 != NULL)?(p1->link == POWER_LINE):(1)) && 
1011   1              ((p2 != NULL)?(p2->link == POWER_LINE):(1)))
1012   1        {
1013   2          min_diff = 30;
1014   2      
1015   2          if(p1 != NULL)
1016   2            p1_metric = route_calc_path_metric(p1);
1017   2          if(p2 != NULL)
1018   2            p2_metric = route_calc_path_metric(p2);
1019   2      #if 0     
                    FM_Printf(FM_APP, "P-RPL: p1 = %u p2 = %u\n",
                            p1_metric, p2_metric);
              #endif
1023   2          if((p2_metric != 0) && (p1_metric != 0))
1024   2          {
1025   3            if(p2_metric > p1_metric + min_diff)
1026   3              return p2;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 18  

1027   3            else
1028   3              return p1;
1029   3          }
1030   2          else
1031   2          {
1032   3            if(p1_metric != 0)
1033   3              return p1;
1034   3            else if(p2_metric != 0)
1035   3              return p2;
1036   3            else
1037   3              return NULL;
1038   3          }
1039   2        }
1040   1        else
1041   1          return NULL;
1042   1      }
1043          
1044          /******************************************************************************
1045           * @fn      route_calculate_rank
1046           *
1047           * @brief   Calculates the rank of the new neighbor
1048           *
1049           * @param   p - pointer to the neighbor entry (define found in route.h)
1050           *          base_rank - 
1051           *
1052           * @return  neighbor
1053           *
1054           */
1055          
1056          static u16 route_calculate_rank(neighbor_info_t *p, u16 base_rank)
1057          {
1058   1        u16 new_rank;
1059   1        u16 rank_increase;
1060   1      
1061   1        if(p == NULL) 
1062   1        {
1063   2          if(base_rank == 0) 
1064   2            return INFINITE_RANK;
1065   2      
1066   2          rank_increase = NEIGHBOR_INFO_FIX2ETX(INITIAL_LINK_METRIC) * RTR_MIN_HOPRANKINC;
1067   2        } 
1068   1        else 
1069   1        {
1070   2          /* multiply first, then scale down to avoid truncation effects */
1071   2          rank_increase = NEIGHBOR_INFO_FIX2ETX(p->etx * RTR_MIN_HOPRANKINC);
1072   2          if(base_rank == 0) 
1073   2            base_rank = p->rank;
1074   2        }
1075   1      
1076   1        if(INFINITE_RANK - base_rank < rank_increase) 
1077   1        {
1078   2          /* Reached the maximum rank. */
1079   2          new_rank = INFINITE_RANK;
1080   2        } 
1081   1        else 
1082   1        {
1083   2          /* Calculate the rank based on the new rank information from DIO or
1084   2            stored otherwise. */
1085   2          new_rank = base_rank + rank_increase;
1086   2        }
1087   1      
1088   1        return new_rank;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 19  

1089   1      }
1090          
1091          /******************************************************************************
1092           * @fn      route_upate_metric
1093           *
1094           * @brief   Updates the meteric of the neighbor based on PER
1095           *
1096           * @param   nbr - pointer to the neighbor entry (define found in route.h)
1097           *          tx_count - packets sent to the neighbor
1098           *
1099           * @return  none
1100           *
1101           */
1102          
1103          void route_upate_metric(u8 tx_count, neighbor_info_t *nbr)
1104          {
1105   1        u32 netx; 
1106   1      
1107   1        if (nbr->etx == RTR_LINK_ESTIMATE_UNIT) 
1108   1        {
1109   2          nbr->etx = tx_count * RTR_LINK_ESTIMATE_UNIT;
1110   2          } 
1111   1        
1112   1        netx = (((u32)tx_count * RTR_LINK_ESTIMATE_UNIT) * 
1113   1            RTR_LINK_ESTIMATE_ALPHA + 
1114   1            nbr->etx * (RTR_LINK_ESTIMATE_UNIT - RTR_LINK_ESTIMATE_ALPHA)) / 
1115   1                              RTR_LINK_ESTIMATE_UNIT ;
1116   1      #if 0 
                FM_Printf(FM_APP, "\nMupt 0x%02x, e %u, n %u, c %bx", nbr->addr, nbr->etx, netx, tx_count);
              #endif
1119   1        nbr->etx = netx;  
1120   1      }
1121          
1122          /******************************************************************************
1123           * @fn      route_handle_fpreq
1124           *
1125           * @brief   Parses and handles the find parent request frame received from the remote peer
1126           *
1127           * @param   frm - pointer to the packet
1128           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1129           *      lqi - the link quality of the received frame
1130           *
1131           * @return  none
1132           *
1133           */
1134          
1135          static void route_handle_fpreq(u8 *frm, u8 link, u8 lqi) 
1136          {
1137   1        fpreq_t* fpreq = (fpreq_t *)&frm[(sizeof(sEth2Hdr))];
1138   1        route_hdr_t* rhdr = (route_hdr_t*)fpreq;
1139   1      
1140   1      #if 1
1141   1        FM_Printf(FM_APP, "\nFPREQ Rx(s 0x%02x, d 0x%02x, l %bu lqi %bu)", 
1142   1              le16_to_cpu(fpreq->rhdr.target), 
1143   1              le16_to_cpu(fpreq->rhdr.parent), link, lqi);
1144   1      #endif
1145   1      
1146   1        if(route_device_profile.device_type != DEV_BRIDGING)
1147   1          return;
1148   1        
1149   1        /* If route has not been discovered yet, then do not respond */
1150   1        if(route_state.state != ROUTE_COMPLETE)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 20  

1151   1          return;
1152   1      
1153   1      #if 0
                if(link == POWER_LINE)
                {
                  if((route_info.parent != NULL) ? (route_info.parent->link == POWER_LINE) : (TRUE))
                    return;
                }
              #endif
1160   1      
1161   1        /* Ignore this frame if the direction is not right */
1162   1        if(RHDR_GET_DIR(rhdr) != DIRECTION_UP) 
1163   1          return;
1164   1      
1165   1        /* If target is my parent, we should not send response to him */
1166   1        if(cpu_to_le16(fpreq->rhdr.target) == route_info.parent->addr) 
1167   1          return;
1168   1      
1169   1        
1170   1        if((link == WIRELESS)&&(lqi <= ROUTE_LQI_THRESHOLD))
1171   1        {
1172   2          return;
1173   2        }
1174   1        
1175   1        route_create_and_send_fprsp_frame (&fpreq->ieee_address[2], 
1176   1              cpu_to_le16(fpreq->rhdr.target), link);
1177   1        
1178   1        return;
1179   1      }
1180          
1181          /******************************************************************************
1182           * @fn      route_handle_fprsp
1183           *
1184           * @brief   Parses and handles the find parent response frame received from the remote peer
1185           *
1186           * @param   frm - pointer to the packet
1187           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1188           *
1189           * @return  none
1190           *
1191           */
1192          
1193          static void route_handle_fprsp(u8 *frm, u8 link, u8 lqi) 
1194          {
1195   1        u8 tmac[MAC_ADDR_LEN];
1196   1        fprsp_t* fprsp = (fprsp_t *)&frm[(sizeof(sEth2Hdr))];
1197   1        route_hdr_t* rhdr = (route_hdr_t*)fprsp;
1198   1        
1199   1        memset(tmac, 0x00, MAC_ADDR_LEN);
1200   1      
1201   1        /* Ignore this frame if the direction is not right */
1202   1        if(RHDR_GET_DIR(rhdr)!= DIRECTION_DOWN)   
1203   1          return;
1204   1        
1205   1        memcpy_cpu_to_le(tmac, &fprsp->ieee_address[2], IEEE_MAC_ADDRESS_LEN-2);
1206   1      #if 1
1207   1        FM_Printf(FM_APP, "\nFPRSP Rx(s 0x%02x, d 0x%02x, l %bu lqi %bu pl %bu, lqi %bu)", 
1208   1              le16_to_cpu(fprsp->rhdr.parent), 
1209   1              le16_to_cpu(fprsp->rhdr.target), link, lqi, rtopo_data.link_pref.link, lqi);
1210   1      #endif
1211   1      
1212   1        /* Add device to the neighbor table */
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 21  

1213   1        if(!route_add_neighbor(le16_to_cpu(fprsp->rhdr.parent), tmac,
1214   1                    le16_to_cpu(fprsp->rhdr.rank), link, 
1215   1                    le16_to_cpu(fprsp->path_metric), 0, 0, lqi, 0, route_info.wireless_ch, 0)) 
1216   1        {
1217   2      #if 0 
                  FM_Printf(FM_APP, "\nNbr fail (nbr %x)", 
                        le16_to_cpu(fprsp->parent)); 
              #endif
1221   2        } 
1222   1      }
1223          
1224          /******************************************************************************
1225           * @fn      route_handle_sroute_req
1226           *
1227           * @brief   Parses and handles the sroute request frame received from the remote peer
1228           *
1229           * @param   frm - pointer to the packet
1230           *      len - length in number of bytes
1231           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1232           *
1233           * @return  none
1234           *
1235           */
1236          
1237          static void route_handle_sroute_req (u8 *frm, u8 len, u8 link) 
1238          {
1239   1        u8 addr[IEEE_MAC_ADDRESS_LEN];
1240   1        sroute_req_t* sroute = (sroute_req_t *)&frm[(sizeof(sEth2Hdr))];
1241   1        route_hdr_t* rhdr = (route_hdr_t*)sroute;
1242   1        
1243   1        len = len;
1244   1      #if 1
1245   1        FM_Printf(FM_APP, "\nSREQ Rx(s 0x%02x, d 0x%02x, l %bu)", 
1246   1              le16_to_cpu(sroute->rhdr.target), 
1247   1              le16_to_cpu(sroute->rhdr.parent), link);
1248   1      #endif
1249   1        /* Ignore this frame if the direction is not right */
1250   1        if(RHDR_GET_DIR(rhdr)!= DIRECTION_UP) 
1251   1          return;
1252   1      
1253   1        memcpy_cpu_to_le(addr, &sroute->ieee_address[2], IEEE_MAC_ADDRESS_LEN-2);
1254   1      
1255   1        if(RHDR_GET_BRIDGE(rhdr) == TRUE)
1256   1        {
1257   2          /* Add target route in the table */
1258   2          if (route_add_route (le16_to_cpu(sroute->rhdr.target), 
1259   2             le16_to_cpu(sroute->rhdr.parent), addr, link) == FALSE) 
1260   2          {
1261   3      #if 0      
                    FM_Printf(FM_APP, "\nNo route 0x%02x", le16_to_cpu(sroute->rhdr.target)); 
              #endif
1264   3          }
1265   2        }
1266   1        
1267   1        CRM_AddScbVendorField(addr, le16_to_cpu(sroute->rhdr.target));    
1268   1      }
1269          
1270          /******************************************************************************
1271           * @fn      route_handle_sroute_rsp
1272           *
1273           * @brief   Parses and handles the sroute response frame received from the remote peer
1274           *
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 22  

1275           * @param   frm - pointer to the packet
1276           *      len - length in number of bytes
1277           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1278           *
1279           * @return  none
1280           *
1281           */
1282          
1283          static void route_handle_sroute_rsp (u8 *frm, u8 len, u8 link) 
1284          {
1285   1        sroute_rsp_t *sroute_rsp = (sroute_rsp_t *)&frm[(sizeof(sEth2Hdr))];
1286   1      
1287   1        len = len;
1288   1        link = link;
1289   1      #if 1
1290   1        FM_Printf(FM_APP, "\nSRSP Rx(s 0x%02x, d 0x%02x, l %bu)", 
1291   1              le16_to_cpu(sroute_rsp->rhdr.parent), 
1292   1              le16_to_cpu(sroute_rsp->rhdr.target), link);
1293   1      #endif
1294   1      
1295   1        route_info.stats.sroute_rx++;
1296   1      
1297   1        /* If SROUTE response comes, clear STA reset flat */  
1298   1        route_info.sroute_fail_cntdwn = MAX_SROUTE_FAIL_COUNT;  
1299   1      
1300   1        if(route_state.state != ROUTE_COMPLETE)
1301   1        {
1302   2          route_updt_route_evnt_msg_t route_update;
1303   2          route_update.event = ROUTE_UPDATE_ROUTE_EVNT;
1304   2          GV701x_SendAppEvent(route_app_id, route_app_id, APP_MSG_TYPE_APPEVENT, 
1305   2              APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
1306   2              &route_update, sizeof(route_updt_route_evnt_msg_t), 0);         
1307   2        }
1308   1      }
1309          
1310          /******************************************************************************
1311           * @fn      route_handle_probe_req
1312           *
1313           * @brief   Parses and handles the probe request frame received from the remote peer
1314           *
1315           * @param   frm - pointer to the packet
1316           *      len - length in number of bytes
1317           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1318           *
1319           * @return  none
1320           *
1321           */
1322          
1323          static void route_handle_probe_req (u8 *frm, u8 len, u8 link)
1324          {
1325   1        probe_t* probe = (probe_t *)&frm[(sizeof(sEth2Hdr))];
1326   1        route_hdr_t* rhdr = (route_hdr_t*)probe;
1327   1      
1328   1      #if 0
                FM_Printf(FM_APP, "\nPREQ Rx(s 0x%02x, d 0x%02x, l %bu)", 
                      le16_to_cpu(probe->rhdr.target), 
                      le16_to_cpu(probe->rhdr.parent), link);
              #endif
1333   1      
1334   1        if(route_state.state != ROUTE_COMPLETE)
1335   1          return;
1336   1      
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 23  

1337   1        /* Ignore this frame if the direction is not right */
1338   1        if(RHDR_GET_DIR(rhdr) != DIRECTION_UP) 
1339   1          return;
1340   1        
1341   1        if (le16_to_cpu(probe->rhdr.rank) < route_info.rank) 
1342   1          return;
1343   1        
1344   1        route_create_and_send_probe_rsp (&frm[6], cpu_to_le16(probe->rhdr.target), 
1345   1                         cpu_to_le16(probe->rhdr.rank), len, link);   
1346   1      }
1347          
1348          /******************************************************************************
1349           * @fn      route_handle_probe_rsp
1350           *
1351           * @brief   Parses and handles the probe response frame received from the remote peer
1352           *
1353           * @param   frm - pointer to the packet
1354           *      len - length in number of bytes
1355           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1356           *
1357           * @return  none
1358           *
1359           */
1360          
1361          static void route_handle_probe_rsp (u8 *frm, u8 len, u8 link)
1362          {
1363   1        probe_t* probe = (probe_t *)&frm[(sizeof(sEth2Hdr))];
1364   1        route_hdr_t* rhdr = (route_hdr_t*)probe;
1365   1        neighbor_info_t *nbr = NULL;
1366   1      
1367   1        len= len;
1368   1        link = link;
1369   1      
1370   1      #if 0
                FM_Printf(FM_APP, "\nPRSP Rx(s 0x%04x, d 0x%04x, l %bu)", 
                      le16_to_cpu(probe->rhdr.parent), 
                      le16_to_cpu(probe->rhdr.target), link);
              #endif
1375   1      
1376   1        /* Ignore this frame if the direction is not right */
1377   1        if(RHDR_GET_DIR(rhdr) != DIRECTION_DOWN)
1378   1          return;
1379   1      
1380   1        /* Look up Neighbor table */
1381   1        nbr = route_get_neighbor (le16_to_cpu(probe->rhdr.parent));
1382   1        
1383   1        if (nbr == NULL) 
1384   1          return;   
1385   1      
1386   1        /* If neighbor is not matching with the current neighbor under probe - 
1387   1           ignore this frame */
1388   1        if (route_neighbor[route_info.probe.retrans_index].addr != 
1389   1              le16_to_cpu(probe->rhdr.parent)) 
1390   1          return; 
1391   1      
1392   1        /* Calculate metric */
1393   1        route_upate_metric((route_info.probe.retrans_count == 0) ? 
1394   1                   1 : route_info.probe.retrans_count, nbr);
1395   1      
1396   1      #ifdef ROUTE_PROBE  
                STM_StopTimer (route_info.probe.retrans_timer);
              #endif
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 24  

1399   1        route_info.probe.retrans_index = 0xFF;
1400   1        route_info.probe.retrans_count = 0;
1401   1      }
1402          
1403          /******************************************************************************
1404           * @fn      route_create_and_send_fprsp_frame
1405           *
1406           * @brief   Creates and sends the find parent response frame to the remote peer
1407           *
1408           * @param   dst_ieee_addr - pointer to the ieee address of the destination node
1409           *      target - the short address of the destination node
1410           *          link - the link on which the packet arrived (WIRELESS or POWER_LINE)
1411           *
1412           * @return  result - TRUE or FALSE
1413           *
1414           */
1415          
1416          static bool route_create_and_send_fprsp_frame (u8 *dst_ieee_addr, u16 target, u8 link)
1417          {
1418   1        u8 tmac[MAC_ADDR_LEN];
1419   1        u8 buff[MAX_ROUTE_FRM_SIZE];
1420   1        fprsp_t *fprsp = (fprsp_t *)&buff[(sizeof(sEth2Hdr))];
1421   1      
1422   1        if (route_state.state != ROUTE_COMPLETE) 
1423   1          return FALSE;
1424   1        
1425   1        /* Form a FPRSP frame */
1426   1        fprsp->rhdr.fc.control_bits = 0;
1427   1        fprsp->rhdr.fc.control_bits |= RHDR_SET_DIR(DIRECTION_DOWN);
1428   1        fprsp->rhdr.fc.control_bits |= RHDR_SET_CMDID(FINDPARENT_RSP);
1429   1        fprsp->rhdr.fc.control_bits |= RHDR_SET_ONEHOP(TRUE);
1430   1        fprsp->rhdr.target = cpu_to_le16(target);
1431   1        fprsp->rhdr.parent = cpu_to_le16(route_info.zid); 
1432   1        fprsp->rhdr.rank = cpu_to_le16(route_info.rank);
1433   1        fprsp->parent = cpu_to_le16(route_info.zid);
1434   1        fprsp->path_metric = cpu_to_le16(route_calc_path_metric(route_info.parent));
1435   1        memcpy_cpu_to_le (fprsp->ieee_address, route_info.ieee_addr, IEEE_MAC_ADDRESS_LEN);
1436   1      
1437   1        route_info.stats.fprsp_tx++;
1438   1      
1439   1      #if 1
1440   1        FM_Printf(FM_APP, "\nFPRSP Tx(s 0x%02x, d 0x%02x, l %bu)", 
1441   1              le16_to_cpu(fprsp->rhdr.parent), 
1442   1              le16_to_cpu(fprsp->rhdr.target), link);
1443   1      #endif
1444   1        if (dst_ieee_addr)
1445   1          memcpy_cpu_to_le(tmac, dst_ieee_addr, IEEE_MAC_ADDRESS_LEN-2); 
1446   1        else 
1447   1          memset (tmac, 0xFF, IEEE_MAC_ADDRESS_LEN-2);
1448   1      
1449   1        if (link & POWER_LINE) 
1450   1        {
1451   2          /* Send Frame */
1452   2          route_send_frm (tmac, route_info.ieee_addr, 
1453   2                target, 0, 
1454   2                DIRECTION_DOWN, buff, 
1455   2                (sizeof(sEth2Hdr)) + sizeof (fprsp_t), 
1456   2                POWER_LINE, TRUE, FALSE);
1457   2        }
1458   1        if (link & WIRELESS) 
1459   1        {
1460   2          /* Send Frame */
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 25  

1461   2          route_send_frm (tmac, route_info.ieee_addr, target, 0, DIRECTION_DOWN, buff,                      
1462   2                  (sizeof(sEth2Hdr)) + sizeof (fprsp_t), WIRELESS, TRUE, FALSE);            
1463   2        }
1464   1      
1465   1        return TRUE;
1466   1      }
1467          
1468          /******************************************************************************
1469           * @fn      route_create_discover_fpreq_frame
1470           *
1471           * @brief   Creates and sends the find parent response frame to the remote peer
1472           *
1473           * @param   target - short addres of the destination node
1474           *      wir_mac_addr - the mac address of the destination wireless node 
1475           *                         (NULL if it is to be broadcasted)
1476           *      pwr_mac_addr - the mac address of the destination powerline node
1477           *               (NULL if it is to be broadcasted)
1478           *          link - the link on which to send the packet (WIRELESS and/or POWER_LINE)
1479           *
1480           * @return  result - TRUE or FALSE
1481           *
1482           */
1483          
1484          static bool route_create_discover_fpreq_frame (u16 target, u8* wir_mac_addr, u16 wir_addr, 
1485                                  u8* pwr_mac_addr, u16 pwr_addr, u8 link)
1486          {
1487   1        u8 buff[MAX_ROUTE_FRM_SIZE];
1488   1        neighbor_info_t* nbr = NULL;
1489   1        fpreq_t *fpreq = (fpreq_t *)&buff[(sizeof(sEth2Hdr))];
1490   1      
1491   1        /* Create FPREQ frame */
1492   1        fpreq->rhdr.fc.control_bits = 0;
1493   1        fpreq->rhdr.fc.control_bits |= RHDR_SET_DIR(DIRECTION_UP);
1494   1        fpreq->rhdr.fc.control_bits |= RHDR_SET_CMDID(FINDPARENT_REQ);
1495   1        fpreq->rhdr.fc.control_bits |= RHDR_SET_ONEHOP(TRUE);
1496   1        fpreq->rhdr.target = cpu_to_le16(target); 
1497   1        fpreq->rhdr.parent = cpu_to_le16(BROADCAST_NET_ADDR);
1498   1        fpreq->rhdr.rank = cpu_to_le16(INFINITE_RANK);
1499   1        memcpy_cpu_to_le (fpreq->ieee_address, route_info.ieee_addr, 8);
1500   1      
1501   1      #if 1
1502   1        FM_Printf(FM_APP, "\nFPREQ Tx(s 0x%02x,", 
1503   1              le16_to_cpu(fpreq->rhdr.target));
1504   1        if(link == POWER_LINE)
1505   1          FM_Printf(FM_APP, " d(pl) 0x%02x) cnt %bu", pwr_addr, route_info.disc_params.powerline.cnt);
1506   1        else if(link == WIRELESS)
1507   1          FM_Printf(FM_APP, " d(wl) 0x%02x) cnt %bu", wir_addr, route_info.disc_params.wireless.cnt);
1508   1        else
1509   1          FM_Printf(FM_APP, " d(pl) 0x%02x d(wl) 0x%02x) pcnt %bu wcnt %bu", pwr_addr, wir_addr, 
1510   1                route_info.disc_params.wireless.cnt, route_info.disc_params.wireless.cnt);                  
1511   1          FM_Printf(FM_APP, " l %bu dl %bu pl %bu", link, route_info.disc_params.link, 
1512   1                rtopo_data.link_pref.link);
1513   1      #endif
1514   1        route_info.stats.fpreq_tx++;
1515   1      
1516   1        if((link & POWER_LINE) == POWER_LINE)
1517   1        {
1518   2          route_send_frm (pwr_mac_addr, route_info.ieee_addr, pwr_addr, 
1519   2                  0, DIRECTION_UP, buff, (sizeof(sEth2Hdr)) + sizeof (fpreq_t), 
1520   2                  POWER_LINE, TRUE, FALSE);
1521   2        }
1522   1      
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 26  

1523   1        if((link & WIRELESS) == WIRELESS)
1524   1        {
1525   2          route_send_frm (wir_mac_addr, route_info.ieee_addr, wir_addr,
1526   2                  0, DIRECTION_UP, buff, (sizeof(sEth2Hdr)) + sizeof (fpreq_t), 
1527   2                  WIRELESS, TRUE, FALSE);
1528   2        }
1529   1        return TRUE;  
1530   1      }
1531          
1532          /******************************************************************************
1533           * @fn      route_create_and_send_sroute_frame
1534           *
1535           * @brief   Creates and sends the sroute request frame to the Host
1536           *
1537           * @param   target - short addres of this node
1538           *
1539           * @return  result - TRUE or FALSE
1540           *
1541           */
1542          
1543          static bool route_create_and_send_sroute_frame (u16 target)
1544          {
1545   1        u8 buff[MAX_ROUTE_FRM_SIZE];
1546   1        u8 tmac[MAC_ADDR_LEN];
1547   1        sroute_req_t *sroute = (sroute_req_t *)&buff[(sizeof(sEth2Hdr))];
1548   1      
1549   1        if((route_state.state != ROUTE_DISCOVER) &&
1550   1          (route_state.state != ROUTE_COMPLETE)) 
1551   1          return FALSE;
1552   1      
1553   1        /* Create FPREQ frame */
1554   1        sroute->rhdr.fc.control_bits = 0;
1555   1        sroute->rhdr.fc.control_bits |= RHDR_SET_DIR(DIRECTION_UP);
1556   1        sroute->rhdr.fc.control_bits |= RHDR_SET_CMDID(SOURCE_ROUTE_REQ);
1557   1        sroute->rhdr.fc.control_bits |= RHDR_SET_TOROOT(TRUE);
1558   1        sroute->rhdr.fc.control_bits |= RHDR_SET_ONEHOP(FALSE);
1559   1        
1560   1        if (route_device_profile.device_type == DEV_BRIDGING) 
1561   1          sroute->rhdr.fc.control_bits |= RHDR_SET_BRIDGE(TRUE);
1562   1        
1563   1        if(route_info.unreachable == TRUE) 
1564   1          sroute->rhdr.fc.control_bits |= RHDR_SET_RESET(TRUE);
1565   1        else 
1566   1          sroute->rhdr.fc.control_bits |= RHDR_SET_RESET(FALSE);
1567   1        
1568   1        sroute->rhdr.target = cpu_to_le16(target);
1569   1        sroute->rhdr.parent = cpu_to_le16(route_info.parent->addr);
1570   1        sroute->rhdr.rank = cpu_to_le16(route_info.rank);
1571   1        memcpy_cpu_to_le (&sroute->ieee_address, &route_info.ieee_addr, (IEEE_MAC_ADDRESS_LEN));
1572   1      
1573   1      #if 1
1574   1        FM_Printf(FM_APP, "\nSREQ Tx(s 0x%02x, d 0x%02x, l %bu)", le16_to_cpu(sroute->rhdr.target),      
1575   1            le16_to_cpu(sroute->rhdr.parent), route_info.parent->link);     
1576   1      #endif
1577   1        memcpy(tmac, route_info.parent->ieee_addr, (IEEE_MAC_ADDRESS_LEN - 2));         
1578   1      
1579   1        /* Send Frame to the parent */
1580   1        route_send_frm (tmac, route_info.ieee_addr, 
1581   1                route_info.parent->addr, route_info.zid,
1582   1                DIRECTION_UP, buff, 
1583   1                (sizeof(sEth2Hdr)) + sizeof (sroute_req_t), 
1584   1                route_info.parent->link, TRUE, FALSE);
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 27  

1585   1      
1586   1        route_info.stats.sroute_tx++;
1587   1      
1588   1        if(route_info.sroute_fail_cntdwn != 0)
1589   1          route_info.sroute_fail_cntdwn--;    
1590   1      
1591   1        return TRUE;  
1592   1      }
1593          
1594          /******************************************************************************
1595           * @fn      route_create_and_send_probe_req
1596           *
1597           * @brief   Creates and sends the probe request frame to the remote peer
1598           *
1599           * @param   nbr - pointer to the remote neighbor 
1600           *      index - index to the neighbor in the neighbor table
1601           *
1602           * @return  result - TRUE or FALSE
1603           *
1604           */
1605          
1606          #ifdef ROUTE_PROBE
              
              static bool route_create_and_send_probe_req (neighbor_info_t *nbr, u8 index)
              {
                u8 buff[MAX_ROUTE_FRM_SIZE];
                probe_t *probe = (probe_t *)&buff[(sizeof(sEth2Hdr))];
              
                memset (buff, 0x00, (sizeof(sEth2Hdr)) + sizeof (probe_t));
                
                /* Create FPREQ frame */
                probe->rhdr.fc.control_bits = 0;
                probe->rhdr.fc.control_bits |= RHDR_SET_DIR(DIRECTION_UP);
                probe->rhdr.fc.control_bits |= RHDR_SET_CMDID(PROBE_REQ);
                probe->rhdr.fc.control_bits |= RHDR_SET_ONEHOP(TRUE);
                
                if (route_device_profile.device_type == DEV_BRIDGING) 
                  probe->rhdr.fc.control_bits |= RHDR_SET_BRIDGE(TRUE);
              
                probe->rhdr.target = cpu_to_le16(route_info.zid);
                probe->rhdr.parent = cpu_to_le16(nbr->addr);
                probe->rhdr.rank = cpu_to_le16(nbr->rank);
              
              #if 1
                FM_Printf(FM_APP, "\nPREQ Tx(s 0x%02x, d 0x%02x, l %bu", le16_to_cpu(probe->rhdr.target),         
                      le16_to_cpu(probe->rhdr.parent), nbr->link);        
              #endif
              
                /* Start Retransmit timer */
                if(STATUS_SUCCESS != STM_StartTimer(route_info.probe.retrans_timer, 
                                        MAX_PROBE_RETRANS_INTERVAL))
                {
              #if 0 
                  FM_Printf(FM_APP, "\nProbe retrans timer fail");              
              #endif
                }
              
                
                if(nbr->probe_count >= 0xFFFFFFFE)
                  nbr->probe_count = 0;
              
                nbr->probe_count++;   
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 28  

                route_info.stats.preq_tx++;
                route_info.probe.retrans_index = index;
                /* Send Frame to the neighbor */
                route_send_frm(nbr->ieee_addr, route_info.ieee_addr, (nbr->addr), route_info.zid,         
                        DIRECTION_UP, buff, (sizeof(sEth2Hdr)) + sizeof (probe_t), nbr->link, TRUE, FALSE);
                        
                return TRUE;  
              }
              
              #endif
1657          
1658          /******************************************************************************
1659           * @fn      route_create_and_send_probe_rsp
1660           *
1661           * @brief   Creates and sends the probe response frame to the remote peer
1662           *
1663           * @param   ieee_addr - the ieee address of the remote peer
1664           *      dest - the short adddress of the peer
1665           *      rank - the rank of the peer
1666           *      len - the length in number of bytes
1667           *      link - the link to the peer
1668           *
1669           * @return  result - TRUE or FALSE
1670           *
1671           */
1672          
1673          static bool route_create_and_send_probe_rsp (u8 *ieee_addr, u16 dest, u8 rank, u8 len, u8 link)
1674          {
1675   1        u8 buff[MAX_ROUTE_FRM_SIZE];
1676   1        probe_t *probe = (probe_t *)&buff[(sizeof(sEth2Hdr))];
1677   1      
1678   1        len = len;
1679   1        /* Create PROBE Response frame */
1680   1        probe->rhdr.fc.control_bits = 0;
1681   1        probe->rhdr.fc.control_bits |= RHDR_SET_DIR(DIRECTION_DOWN);
1682   1        probe->rhdr.fc.control_bits |= RHDR_SET_CMDID(PROBE_RSP);
1683   1        probe->rhdr.fc.control_bits |= RHDR_SET_ONEHOP(TRUE);
1684   1        probe->rhdr.target = cpu_to_le16(dest);
1685   1        probe->rhdr.parent = cpu_to_le16(route_info.zid);
1686   1        probe->rhdr.rank = cpu_to_le16(rank);
1687   1      
1688   1      #if 1
1689   1        FM_Printf(FM_APP, "\nPRSP Tx(s 0x%02x, d 0x%02x, l %bu)", le16_to_cpu(probe->rhdr.parent),        
1690   1              le16_to_cpu(probe->rhdr.target), link);       
1691   1      #endif  
1692   1      
1693   1        /* Send Frame to the source of probe_req */
1694   1        route_send_frm (ieee_addr, route_info.ieee_addr, dest, route_info.zid, DIRECTION_DOWN,          
1695   1                buff, (sizeof(sEth2Hdr)) + sizeof (probe_t), link, TRUE, FALSE);
1696   1                
1697   1        return TRUE;  
1698   1      }
1699          
1700          
1701          /******************************************************************************
1702           * @fn      route_send_frm
1703           *
1704           * @brief   Sends an OTA frame 
1705           *
1706           * @param   dstn_ieee_addr - the ieee address of the destination node
1707           *      src_ieee_addr - the ieee address of the originating node
1708           *      dest - the short address of the destination
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 29  

1709           *      src - the short address of the originating node
1710           *      dir - the direction to the destination (DIRECTION_UP or DIRECTION_DOWN)
1711           *      buff - pointer to the data frame 
1712           *      len - the length in number of bytes
1713           *      link - the link to the peer (POWER_LINE or WIRELESS)
1714           *      rhdr_present - TRUE if routing header is already present else FALSE otherwise
1715           *      forward - TRUE if the frame is to be forwarded to the sender
1716           *
1717           * @return  result - TRUE or FALSE
1718           *
1719           */
1720          
1721          static bool route_send_frm (u8 *dstn_ieee_addr, u8 *src_ieee_addr, u16 dest, u16 src, u8 dir, 
1722                          u8 *buff, u8 len, u8 link, u8 rhdr_present, u8 forward)
1723          {
1724   1        sEth2Hdr* petherhdr = (sEth2Hdr*)(buff);
1725   1      
1726   1        src_ieee_addr = src_ieee_addr;
1727   1        src = src;
1728   1        dir = dir;
1729   1        rhdr_present = rhdr_present;  
1730   1        forward = forward;
1731   1      
1732   1        totalTx++;
1733   1        
1734   1        if(dstn_ieee_addr == NULL)
1735   1          memset(&petherhdr->dstaddr, 0xFF, MAC_ADDR_LEN);
1736   1        else
1737   1          memcpy(&petherhdr->dstaddr, dstn_ieee_addr, MAC_ADDR_LEN); 
1738   1        
1739   1        memcpy(&petherhdr->srcaddr, &route_info.ieee_addr, MAC_ADDR_LEN);   
1740   1        petherhdr->ethtype = APP_ETHER_PROTO;   
1741   1      
1742   1        /* Send frame to the given link */
1743   1        if((link == POWER_LINE) && 
1744   1      #ifdef NWKSTARTUP_APP   
1745   1          (nwkstartup_data.link.power_line.state == LINK_UP)
1746   1      #else
                  (TRUE)
              #endif    
1749   1          )
1750   1        {
1751   2          GV701x_SendData(APP_PORT_PLC, buff, len, 0);  
1752   2        }
1753   1        else if(link == WIRELESS)    
1754   1        {
1755   2      #ifdef LRWPAN_DRIVER_APP        
1756   2          if((dstn_ieee_addr != NULL) || (dest != BROADCAST_NET_ADDR))         
1757   2            lrwpan_SendData(dest, buff, len);
1758   2          else
1759   2            lrwpan_SendData(BROADCAST_NET_ADDR, buff, len);
1760   2      #endif
1761   2        } 
1762   1        else 
1763   1        {
1764   2          return FALSE;
1765   2        }
1766   1        
1767   1        return TRUE;    
1768   1      }
1769          
1770          /******************************************************************************
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 30  

1771           * @fn      route_assign_best_parent
1772           *
1773           * @brief   Assigns the given neighbor to be the Parent and checks
1774           *      for the transitions between the previous parents
1775           *
1776           * @param   nbr - the pointer to the neighbor
1777           *
1778           * @return  result - TRUE or FALSE
1779           *
1780           */
1781          
1782          u8 route_assign_best_parent(neighbor_info_t* nbr)
1783          {
1784   1        u8 link;
1785   1        u16 addr;
1786   1        
1787   1        if(route_info.parent != NULL)
1788   1        {
1789   2          link = route_info.parent->link;
1790   2          addr = route_info.parent->addr;
1791   2        }
1792   1        else
1793   1        {
1794   2          link = 0;
1795   2          addr = 0;
1796   2        }
1797   1      
1798   1      #if 1
1799   1        FM_Printf(FM_APP, "\nAPar l %bu ol %bu oa %x a %x", nbr->link, link, addr, nbr->addr);
1800   1      #endif
1801   1            
1802   1        if((route_info.parent != NULL) ? ((route_info.parent->addr != nbr->addr) ||
1803   1           (route_info.parent->link != nbr->link) ): (0))
1804   1        { 
1805   2          if((route_info.route_sel_active == TRUE)
1806   2      #ifdef ROUTE_ROAM
                    ||(route_info.roaming_enable)
              #endif
1809   2            )
1810   2          {
1811   3            if(route_info.parent->link != nbr->link)
1812   3            {
1813   4              if(route_info.parent->link == WIRELESS)
1814   4              {       
1815   5      #if 0       
                        route_info.start.wireless.active = FALSE;
                        route_info.start.wireless.app_id = 0;                 
              #endif
1819   5              }
1820   4            }
1821   3            if(route_state.state == ROUTE_COMPLETE)
1822   3              route_create_and_send_fprsp_frame (NULL, 0xFFFF, WIRELESS | POWER_LINE);
1823   3      
1824   3      #if 1
1825   3            route_remove_neighbor(route_info.parent->addr, 
1826   3                  route_info.parent->link); 
1827   3      #endif
1828   3      #if 0     
                    route_state.state = ROUTE_START;
              #endif
1831   3            route_info.sroute_fail_cntdwn = MAX_SROUTE_FAIL_COUNT;
1832   3          }
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 31  

1833   2        }
1834   1        else
1835   1        {
1836   2      #if 0 
              #ifdef RTOPO_APP
                  rtopo_prof_evnt_msg_t rtopo_prof;
                  rtopo_prof.event = RTOPO_PROFILE_EVNT; 
                  GV701x_SendAppEvent(route_app_id, rtopo_app_id, APP_MSG_TYPE_APPEVENT, 
                    APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,
                        &rtopo_prof, sizeof(rtopo_prof_evnt_msg_t), 0); 
              #endif
              #endif
1845   2        }
1846   1      
1847   1        if((route_info.route_sel_active == TRUE) 
1848   1      #ifdef ROUTE_ROAM   
                  || (route_info.roaming_enable)
              #endif    
1851   1          )
1852   1        { 
1853   2          /* Select new parent device and advertise */
1854   2          route_info.parent = nbr;  
1855   2          route_info.rank = route_calculate_rank (route_info.parent, 0);
1856   2      
1857   2      #if 0
                  FM_Printf(FM_APP, "\nPar(p 0x%02x, r 0x%02x, l %bu rssi %bu)", route_info.parent->addr,             
                          route_info.parent->rank, route_info.parent->link, route_info.parent->rssi);           
              #endif    
1861   2          route_state.state = ROUTE_DISCOVER;
1862   2      
1863   2          if(nbr->link == WIRELESS)
1864   2            route_info.start.wireless.active = FALSE;
1865   2          else if(nbr->link == POWER_LINE)
1866   2            route_info.start.power_line.active = FALSE;
1867   2          
1868   2          if(register_state.state == REGISTER_REGISTERED_STATE)
1869   2          {
1870   3            route_updt_addr_evnt_msg_t route_updt_addr;
1871   3            route_updt_addr.event = ROUTE_UPDATE_ADDR_EVNT;
1872   3            route_updt_addr.addr = register_data.nwk_addr.addr_16bit;
1873   3            GV701x_SendAppEvent(route_app_id, route_app_id, APP_MSG_TYPE_APPEVENT, 
1874   3              APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,
1875   3                    &route_updt_addr, sizeof(route_updt_addr), 0);    
1876   3          }   
1877   2      
1878   2      #ifdef ROUTE_ROAM
                  route_info.roaming_enable = 0;
              #endif
1881   2          return TRUE;
1882   2        }
1883   1        else
1884   1          return FALSE;
1885   1      }
1886          
1887          /******************************************************************************
1888           * @fn      route_add_neighbor
1889           *
1890           * @brief   Adds a nearby peer to the neighbor table
1891           *
1892           * @param   neigh_addr - the short address of the peer
1893           *      ieee_addr - the IEEE address of the peer
1894           *      rank - the rank of the peer
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 32  

1895           *      metric - th meteric of the peer
1896           *      rssi - the rssi value of the peer w.r.t this node
1897           *      bcn_rx - the beacons received from the peer
1898           *      lqi - the average LQI value to that peer
1899           *      parent_addr - the parent short address (if any or-else 0)of the peer 
1900           *      ch - the wireless channel on which the peer exists  
1901           * @return  result - TRUE or FALSE
1902           *
1903           */
1904          
1905          bool route_add_neighbor(u16 neigh_addr, u8* ieee_addr, u16 rank, u8 link, u16 metric,
1906                                   u8 rssi, u32 bcn_rx, u8 lqi, u16 parent_addr, u8 ch, u8 ed)
1907          {
1908   1        u8 idx = 0;
1909   1        u8 jdx = MAX_NEIGHBOUR_DEVICES + 1;
1910   1        u8 cond = FALSE;
1911   1        u8 acc_lqi;
1912   1      
1913   1      #if 1 
1914   1        if(ieee_addr) 
1915   1          FM_HexDump(FM_APP,"\nNIeee:",ieee_addr,IEEE_MAC_ADDRESS_LEN-2);
1916   1      #endif
1917   1      
1918   1        /*Check whether entry already exists, update it*/
1919   1        for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
1920   1        {
1921   2      #if 0 
                  FM_Printf(FM_APP, "\n1. i: %bu v: %bu, n 0x%02x, na 0x%02x rssi %bu", 
                    idx, route_neighbor[idx].valid, 
                    route_neighbor[idx].addr, neigh_addr, route_neighbor[idx].rssi);
              #endif
1926   2          if(route_neighbor[idx].valid == TRUE)
1927   2          {
1928   3            if(ieee_addr != NULL)
1929   3            {
1930   4      #if 0     
                      FM_HexDump(FM_ERROR,"\nieee:",route_neighbor[idx].ieee_addr,IEEE_MAC_ADDRESS_LEN-2);
              #endif
1933   4              if((0 == memcmp(ieee_addr, route_neighbor[idx].ieee_addr, IEEE_MAC_ADDRESS_LEN-2)) &&
1934   4                (link == route_neighbor[idx].link))
1935   4                cond = TRUE;
1936   4              else
1937   4                cond = FALSE;
1938   4            }
1939   3            if(cond == TRUE)
1940   3            {
1941   4              jdx = idx;
1942   4      #if 0       
                      FM_Printf(FM_APP, "\nNeigh Updt %bu na 0x%02x rssi %bu", jdx, neigh_addr, rssi);      
              #endif
1945   4              route_neighbor[idx].timeout = MAX_NEIGHBOUR_LIFETIME; 
1946   4              if(neigh_addr != 0x0000)
1947   4                route_neighbor[idx].cnt++; 
1948   4              break;
1949   4            }
1950   3          }
1951   2        }
1952   1      
1953   1        /*Add new entry in the table */
1954   1        if(jdx >= MAX_NEIGHBOUR_DEVICES) 
1955   1        {
1956   2          for (idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 33  

1957   2          {
1958   3            if (route_neighbor[idx].valid == FALSE) 
1959   3            {     
1960   4              jdx = idx;
1961   4      #if 0       
                      FM_Printf(FM_APP, "\nNeigh Add %bu na 0x%02x rssi %bu", jdx, neigh_addr, rssi);
              #endif
1964   4              route_neighbor[idx].timeout = MAX_NEIGHBOUR_LIFETIME; 
1965   4              if(neigh_addr != 0x0000)
1966   4                route_neighbor[idx].cnt = 1; 
1967   4              break;
1968   4            }
1969   3          } 
1970   2        }
1971   1      
1972   1        /*Entry does not exist in the table, check whether it can replace 
1973   1          existing entry based on the path metric */  
1974   1        if(jdx >= MAX_NEIGHBOUR_DEVICES) 
1975   1        {
1976   2          for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
1977   2          {
1978   3            if (route_neighbor[idx].valid && ((route_info.parent != NULL)?        
1979   3              (route_neighbor[idx].addr != route_info.parent->addr) : TRUE))        
1980   3            { 
1981   4              if (rssi > route_neighbor[idx].rssi) 
1982   4              {
1983   5                jdx = idx;
1984   5      #if 0         
                        FM_Printf(FM_APP, "\nNeigh Replace na 0x%02x rssi %bu", neigh_addr, rssi);          
              #endif
1987   5                route_neighbor[idx].timeout = MAX_NEIGHBOUR_LIFETIME; 
1988   5                if(neigh_addr != 0x0000)
1989   5                  route_neighbor[idx].cnt = 1; 
1990   5                break;
1991   5              }
1992   4            }
1993   3          } 
1994   2        }
1995   1        
1996   1        if(jdx >= MAX_NEIGHBOUR_DEVICES) 
1997   1          return FALSE;
1998   1        
1999   1        /* This indicates neighbor table is full. We can replace an entry 
2000   1           which has lowest rank except parent device */  
2001   1      
2002   1        route_neighbor[jdx].valid = TRUE;
2003   1        route_neighbor[jdx].rank = rank;
2004   1        route_neighbor[jdx].addr = neigh_addr;
2005   1        route_neighbor[jdx].link = link;
2006   1        route_neighbor[jdx].probe_mark = FALSE;
2007   1        route_neighbor[jdx].path_metric = metric;
2008   1        if(rssi != 0)
2009   1          route_neighbor[jdx].rssi = rssi;
2010   1        if(bcn_rx != 0)
2011   1          route_neighbor[jdx].bcn_rx = bcn_rx;
2012   1        if(lqi != 0)
2013   1        {
2014   2          if(route_neighbor[jdx].lqi == 0)
2015   2          {
2016   3            route_neighbor[jdx].lqi = lqi;  
2017   3          }   
2018   2          else
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 34  

2019   2          {
2020   3            acc_lqi = (((route_neighbor[jdx].lqi  * 80) + (lqi * 20))/100); 
2021   3      #if 0     
                    FM_Printf(FM_APP, "\nalqi %bu l1 %bu l2 %bu", acc_lqi, route_neighbor[jdx].lqi, lqi);
              #endif
2024   3            route_neighbor[jdx].lqi = acc_lqi;
2025   3          }
2026   2        }
2027   1        if(ch != 0)
2028   1          route_neighbor[jdx].ch = ch;  
2029   1        
2030   1        if(ed != 0)
2031   1          route_neighbor[jdx].ed = (0xFF - ed);
2032   1      
2033   1        if(parent_addr != 0)
2034   1          route_neighbor[jdx].parent_addr = parent_addr;  
2035   1        
2036   1        route_neighbor[jdx].etx = RTR_LINK_ESTIMATE_UNIT;   
2037   1        route_neighbor[jdx].timeout = MAX_NEIGHBOUR_LIFETIME; 
2038   1        
2039   1        if(ieee_addr != NULL)
2040   1          memcpy(route_neighbor[jdx].ieee_addr, ieee_addr, IEEE_MAC_ADDRESS_LEN-2);
2041   1      
2042   1      #if 1
2043   1        FM_Printf(FM_APP, "\nAddN jdx: %bu rank: %u paddr: %x ch %bx lqi %bu ed1 %bx ed %bx l %bx a %x rssi %bx c
             -nt %bu",   
2044   1            jdx, route_neighbor[jdx].rank, route_neighbor[jdx].parent_addr, route_neighbor[jdx].ch, 
2045   1            route_neighbor[jdx].lqi, ed, route_neighbor[jdx].ed, route_neighbor[jdx].link, 
2046   1            route_neighbor[jdx].addr, route_neighbor[jdx].rssi, route_neighbor[idx].cnt);
2047   1      #endif
2048   1        return TRUE;
2049   1      }
2050          
2051          static u8 route_get_neighbor_index(u8* ieee_addr, u8 link)
2052          {
2053   1        u8 idx;
2054   1      
2055   1        if(ieee_addr == NULL)
2056   1          return MAX_NEIGHBOUR_DEVICES;
2057   1      #if 0 
                if(ieee_addr) 
                  FM_HexDump(FM_APP,"\nRIeee:", ieee_addr, IEEE_MAC_ADDRESS_LEN-2); 
              #endif
2061   1      
2062   1        for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2063   1        {
2064   2          if(route_neighbor[idx].valid == TRUE)
2065   2          {     
2066   3            if((0 == memcmp(ieee_addr, route_neighbor[idx].ieee_addr, IEEE_MAC_ADDRESS_LEN-2)) &&
2067   3               (link == route_neighbor[idx].link))
2068   3            {
2069   4      #if 0     
                      FM_Printf(FM_APP, "\nG %bu", idx);
              #endif
2072   4              return idx;
2073   4            }     
2074   3          }
2075   2        }
2076   1      
2077   1        return MAX_NEIGHBOUR_DEVICES;
2078   1      }
2079          
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 35  

2080          bool route_update_neighbor_ed(u8 ch, u8 ed)
2081          {
2082   1        u8 idx = 0;
2083   1        u8 ret = FALSE;
2084   1        
2085   1      #if 0
                if(ch) 
                  FM_Printf(FM_APP, "\nAddNCh: %bx", ch);
              #endif
2089   1      
2090   1        if(ch == 0)
2091   1          ret = FALSE;
2092   1        
2093   1        /*Check whether entry already exists, update it */
2094   1        for (idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2095   1        {
2096   2      #if 0
                  FM_Printf(FM_APP, "\n1. i: %bu v: %bu, ch %bx l %bx", idx, route_neighbor[idx].valid,       
                      route_neighbor[idx].ch, route_neighbor[idx].link);
              #endif
2100   2          if(route_neighbor[idx].valid == TRUE)
2101   2          {
2102   3            if(route_neighbor[idx].link == WIRELESS)
2103   3            {
2104   4              if(route_neighbor[idx].ch == ch)
2105   4              {
2106   5                if(ed != 0)
2107   5                  route_neighbor[idx].ed = (0xFF - ed);     
2108   5      #if 0       
                        FM_Printf(FM_APP, "\nChM %bu ed %bx ed1 %bx", idx, ed, route_neighbor[idx].ed);
              #endif
2111   5                ret = TRUE;
2112   5              }
2113   4            }
2114   3          }
2115   2        } 
2116   1        return ret;
2117   1      }
2118          
2119          /******************************************************************************
2120           * @fn      route_remove_neighbor
2121           *
2122           * @brief   Removes a neighbor from the table
2123           *
2124           * @param   neigh_addr - the short address of the peer
2125           *      link - the link type of the peer
2126           *
2127           * @return  result - TRUE or FALSE
2128           *
2129           */
2130          
2131          static bool route_remove_neighbor(u16 neigh_addr, u8 link)
2132          {
2133   1        u8 idx = 0;
2134   1        
2135   1        link = link;
2136   1        for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2137   1        {
2138   2          if ((route_neighbor[idx].valid == TRUE) &&      
2139   2            (route_neighbor[idx].addr == neigh_addr) &&
2140   2            (route_neighbor[idx].link == link)) 
2141   2          {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 36  

2142   3      #if 1   
2143   3            FM_Printf(FM_APP, "\nRem(a) idx %bu nbr 0x%02x link %bx isP %bu", idx, neigh_addr,
2144   3                          route_neighbor[idx].link, 
2145   3                          (route_info.parent == (&route_neighbor[idx])));
2146   3      #endif
2147   3            route_neighbor[idx].rank = 0;
2148   3            route_neighbor[idx].addr = 0;
2149   3            route_neighbor[idx].valid = FALSE;
2150   3            route_neighbor[idx].link = 0;
2151   3            route_neighbor[idx].probe_mark = FALSE;
2152   3            route_neighbor[idx].probe_count = FALSE;
2153   3            route_neighbor[idx].etx = 0;
2154   3            route_neighbor[idx].path_metric = 0;
2155   3            route_neighbor[idx].rssi = 0;
2156   3            route_neighbor[idx].bcn_rx = 0;
2157   3            route_neighbor[idx].lqi = 0;
2158   3            route_neighbor[idx].ch = 0;     
2159   3            route_neighbor[idx].cnt = 0;  
2160   3      
2161   3      #if 1   
2162   3            if((route_info.parent != NULL) &&
2163   3               (route_info.parent == (&route_neighbor[idx])))
2164   3            {
2165   4              route_info.parent = NULL;
2166   4            }
2167   3      #endif      
2168   3            memset(route_neighbor[idx].ieee_addr, 0x00, IEEE_MAC_ADDRESS_LEN);            
2169   3            return TRUE;
2170   3          }
2171   2        } 
2172   1      #if 0 
                FM_Printf(FM_APP, "\nCould not remove neighbor 0x%02x", neigh_addr);
              #endif
2175   1        return FALSE;
2176   1      }
2177          
2178          /******************************************************************************
2179           * @fn      route_remove_neighbor_using_index
2180           *
2181           * @brief   Removes a neighbor from the table looking up the index
2182           *
2183           * @param   idx - the index in the table
2184           *
2185           * @return  result - TRUE or FALSE
2186           *
2187           */
2188          
2189          static bool route_remove_neighbor_using_index(u8 idx)
2190          {
2191   1        if(route_neighbor[idx].valid == TRUE)
2192   1        {
2193   2      #if 1 
2194   2          FM_Printf(FM_APP, "\nRem(i) idx %bu nbr 0x%02x link %bx isP %bu", idx,
2195   2                        route_neighbor[idx].addr, route_neighbor[idx].link,
2196   2                        (route_info.parent == (&route_neighbor[idx])));
2197   2      #endif
2198   2          route_neighbor[idx].rank = 0;
2199   2          route_neighbor[idx].addr = 0;
2200   2          route_neighbor[idx].valid = FALSE;
2201   2          route_neighbor[idx].link = 0;
2202   2          route_neighbor[idx].probe_mark = FALSE;
2203   2          route_neighbor[idx].probe_count = FALSE;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 37  

2204   2          route_neighbor[idx].etx = 0;
2205   2          route_neighbor[idx].path_metric = 0;
2206   2          route_neighbor[idx].rssi = 0;
2207   2          route_neighbor[idx].bcn_rx = 0;
2208   2          route_neighbor[idx].lqi = 0;
2209   2          route_neighbor[idx].ch = 0; 
2210   2          route_neighbor[idx].cnt = 0;  
2211   2      #if 1   
2212   2          if((route_info.parent != NULL) &&
2213   2             (route_info.parent == (&route_neighbor[idx])))
2214   2          {
2215   3            route_info.parent = NULL;
2216   3          }     
2217   2      #endif    
2218   2          memset(route_neighbor[idx].ieee_addr, 0x00, IEEE_MAC_ADDRESS_LEN);            
2219   2          return TRUE;
2220   2        }
2221   1      
2222   1      #if 0
                FM_Printf(FM_APP, "\nCould not remove neighbor 0x%02x", neigh_addr);
              #endif
2225   1        return FALSE;
2226   1      }
2227          
2228          /******************************************************************************
2229           * @fn      route_flush_nwktables
2230           *
2231           * @brief   Clears all route information
2232           *
2233           * @param   none
2234           *
2235           * @return  result - TRUE or FALSE
2236           *
2237           */
2238          
2239          static bool route_flush_nwktables (void)
2240          {
2241   1      #ifdef ROUTE_PROBE
              
                STM_StopTimer(route_info.probe.prd_timer);          
                STM_StopTimer(route_info.probe.retrans_timer);
                
              #endif  
2247   1        STM_StopTimer(route_info.sroute_timer); 
2248   1        STM_StopTimer(route_info.discovery_timer);  
2249   1        route_info.disc_params.powerline.cnt = 0;
2250   1        route_info.disc_params.wireless.cnt = 0;
2251   1        route_info.start.wireless.active = FALSE;
2252   1        route_info.start.power_line.active = FALSE; 
2253   1        route_info.disc_params.link = 0;
2254   1        route_info.disc_params.assignparent = 0;
2255   1        route_info.rank = INFINITE_RANK;
2256   1        route_info.parent = NULL;
2257   1        memset((u8*)&route_info.stats, 0x00, sizeof(route_stats_t));  
2258   1        memset (&route_neighbor, 0x00, MAX_NEIGHBOUR_DEVICES*(sizeof (neighbor_info_t)));     
2259   1        memset(&route_table, 0x00, MAX_ROUTE_TABLE_ENTRIES*(sizeof(route_table_t)));    
2260   1      #ifdef HQ_LINK_TEST
                GV701x_GPIO_Write(GREEN_LED, LED_OFF);  
                GV701x_GPIO_Write(RED_LED, LED_OFF);  
              #endif
2264   1        return TRUE;
2265   1      }
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 38  

2266          
2267          /******************************************************************************
2268           * @fn      route_remove_link_neighbor
2269           *
2270           * @brief   Removes all neighbors on a particular link
2271           *
2272           * @param   link - the link type
2273           *
2274           * @return  result - TRUE or FALSE
2275           *
2276           */
2277          
2278          static bool route_remove_link_neighbor(u8 link)
2279          {
2280   1        u8 idx = 0;
2281   1        
2282   1        for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2283   1        {
2284   2          if((route_neighbor[idx].valid == TRUE) && 
2285   2             (route_neighbor[idx].link == link)) 
2286   2          {
2287   3      #if 1 
2288   3            FM_Printf(FM_APP, "\nRem(l)idx %bu nbr 0x%02x link %bx isP %bu", idx,
2289   3                          route_neighbor[idx].link,
2290   3                          (route_info.parent == (&route_neighbor[idx])));
2291   3      #endif
2292   3            route_neighbor[idx].rank = 0;
2293   3            route_neighbor[idx].addr = 0;
2294   3            route_neighbor[idx].valid = FALSE;
2295   3            route_neighbor[idx].link = 0;
2296   3            route_neighbor[idx].probe_mark = FALSE;
2297   3            route_neighbor[idx].probe_count = FALSE;
2298   3            route_neighbor[idx].etx = 0;
2299   3            route_neighbor[idx].path_metric = 0;
2300   3            route_neighbor[idx].rssi = 0;
2301   3            route_neighbor[idx].bcn_rx = 0;
2302   3            route_neighbor[idx].lqi = 0;
2303   3            route_neighbor[idx].ch = 0; 
2304   3            route_neighbor[idx].cnt = 0;  
2305   3      #if 1     
2306   3            if((route_info.parent != NULL) &&
2307   3               (route_info.parent == (&route_neighbor[idx])))
2308   3            {
2309   4              route_info.parent = NULL;
2310   4            }     
2311   3      #endif      
2312   3            memset(route_neighbor[idx].ieee_addr, 0x00, IEEE_MAC_ADDRESS_LEN);
2313   3            return TRUE;      
2314   3          }
2315   2        } 
2316   1        return FALSE;
2317   1      }
2318          
2319          /******************************************************************************
2320           * @fn      route_get_neighbor
2321           *
2322           * @brief   Fetches a neighbor looking up its short address
2323           *
2324           * @param   neigh_addr - the short address of the neighbor
2325           *
2326           * @return  neighbor_info_t - a pointer the neighbor
2327           *
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 39  

2328           */
2329          
2330          static neighbor_info_t *route_get_neighbor(u16 neigh_addr)
2331          {
2332   1        u8 idx = 0;
2333   1        
2334   1        for (idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2335   1        {
2336   2          if((route_neighbor[idx].valid) && 
2337   2              (route_neighbor[idx].addr == neigh_addr)) 
2338   2            return &route_neighbor[idx];
2339   2        } 
2340   1        return NULL;
2341   1      }
2342          
2343          /******************************************************************************
2344           * @fn      route_get_neighbor_link
2345           *
2346           * @brief   Fetches a neighbor looking up its link
2347           *
2348           * @param   link - the link type of the neighbor
2349           *
2350           * @return  neighbor_info_t - a pointer the neighbor
2351           *
2352           */
2353          
2354          static neighbor_info_t *route_get_neighbor_link(u8 link)
2355          {
2356   1        u8 idx = 0;
2357   1      
2358   1        for (idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2359   1        {
2360   2          if((route_neighbor[idx].valid == TRUE) && 
2361   2              (route_neighbor[idx].link == link)) 
2362   2          {     
2363   3            return &route_neighbor[idx];
2364   3          }
2365   2        } 
2366   1        return NULL;
2367   1      }
2368          
2369          /******************************************************************************
2370           * @fn      route_select_best_neighbor
2371           *
2372           * @brief   Selects the best parent based on the best meteric
2373           *
2374           * @param   link - the link on which the best parent is to be found
2375           *
2376           * @return  neighbor_info_t - a pointer the best parent
2377           *
2378           */
2379          
2380          neighbor_info_t *route_select_best_neighbor(u8 link)
2381          {
2382   1        u8 idx;
2383   1        neighbor_info_t *p = NULL;
2384   1        u8 p_idx = 0;
2385   1        u8 pold_idx = 0;
2386   1        neighbor_info_t *p_old = NULL;  
2387   1        
2388   1        /* Best parent is selected based on lower rank and best path meteric */ 
2389   1        for (idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 40  

2390   1        {   
2391   2          if((route_neighbor[idx].valid == TRUE) && (route_neighbor[idx].link == link) &&     
2392   2            ((link == WIRELESS) ? ((route_info.wireless_ch != 0) ?      
2393   2            (route_neighbor[idx].ch == route_info.wireless_ch) : (TRUE)) : TRUE))     
2394   2          {
2395   3      #if 0   
                    FM_Printf(FM_APP, "\nCmp i %bu l %bu", idx, route_neighbor[idx].link);      
              #endif
2398   3            p_old = p;
2399   3            pold_idx = p_idx;
2400   3            p = route_best_parent(p, &route_neighbor[idx]);
2401   3            if(p != NULL)
2402   3            {
2403   4              p_idx = route_get_neighbor_index(p->ieee_addr, p->link);
2404   4              
2405   4              if(p_idx == MAX_NEIGHBOUR_DEVICES)
2406   4              {
2407   5                FM_Printf(FM_APP, "\nBPE");
2408   5                return NULL;
2409   5              }
2410   4            
2411   4              if((link == POWER_LINE) || (link == WIRELESS))
2412   4              {
2413   5                if(p_old != NULL)
2414   5                {
2415   6                  if(p_old == p)
2416   6                  {     
2417   7                    if(TRUE == route_remove_neighbor_using_index(pold_idx == p_idx ? idx : pold_idx))
2418   7                    {
2419   8      #if 0             
                              FM_Printf(FM_APP, "\nNRmv 1.0 %bu", pold_idx == p_idx ? idx : pold_idx);
              #endif
2422   8                    }
2423   7                  }
2424   6                  else
2425   6                  {
2426   7                    if(TRUE == route_remove_neighbor_using_index(pold_idx == p_idx ? idx : pold_idx))
2427   7                    {
2428   8      #if 0             
                              FM_Printf(FM_APP, "\nNRmv 1.1 %bu", pold_idx == p_idx ? idx : pold_idx);
              #endif
2431   8                    }
2432   7                  }
2433   6                }
2434   5              }
2435   4            }
2436   3            else
2437   3            {
2438   4              if((link == POWER_LINE) || (link == WIRELESS))
2439   4              {
2440   5                if(TRUE == route_remove_neighbor_using_index(pold_idx == p_idx ? idx : pold_idx))
2441   5                {
2442   6      #if 0         
                          FM_Printf(FM_APP, "\nNRmv 1.2 %bu", pold_idx == p_idx ? idx : pold_idx);
              #endif
2445   6                }
2446   5              }
2447   4            }
2448   3          }
2449   2        } 
2450   1      
2451   1      #if 1 
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 41  

2452   1        if(p != NULL)
2453   1        {
2454   2          if(p->ieee_addr) 
2455   2            FM_HexDump(FM_APP,"\nBIeee:", p->ieee_addr, IEEE_MAC_ADDRESS_LEN-2);
2456   2          
2457   2          FM_Printf(FM_APP, "\nBN pidx: %bu rank: %u paddr: %x ch %bx lqi %bu ed %bx l %bx a %x rssi %bx cnt %bu",
             - p_idx, 
2458   2              route_neighbor[p_idx].rank, route_neighbor[p_idx].parent_addr, route_neighbor[p_idx].ch, 
2459   2              route_neighbor[p_idx].lqi, route_neighbor[p_idx].ed, route_neighbor[p_idx].link, 
2460   2              route_neighbor[p_idx].addr, route_neighbor[p_idx].rssi, route_neighbor[p_idx].cnt);
2461   2        }
2462   1      #endif  
2463   1        return p;
2464   1      }
2465          
2466          /******************************************************************************
2467           * @fn      route_is_neightable_empty
2468           *
2469           * @brief   Checks if neigbor table is empty
2470           *
2471           * @param   link - seacrh neighbors on this link (WIRELESSS or POWER_LINE)
2472           *
2473           * @return  bool - TRUE if neighbor exists otherwise its FALSE 
2474           *
2475           */
2476          
2477          bool route_is_neightable_empty(u8 link)
2478          {
2479   1        u8 idx;
2480   1        
2481   1        for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
2482   1        {   
2483   2          if((route_neighbor[idx].valid == TRUE) &&
2484   2             (route_neighbor[idx].link == link))
2485   2            return FALSE;
2486   2        } 
2487   1      
2488   1        return TRUE;
2489   1      }
2490          
2491          /******************************************************************************
2492           * @fn      route_periodic_probing
2493           *
2494           * @brief   Sends a probe request frame to all neighbors one neighbor 
2495           *      in one iteration of the function
2496           *
2497           * @param   none
2498           *
2499           * @return  none
2500           *
2501          
2502            */
2503          #ifdef ROUTE_PROBE
              
              static void route_periodic_probing (void) 
              {
                u8 idx;
                neighbor_info_t *nbr = NULL;
              
                if(route_state.state != ROUTE_COMPLETE) 
                  return;
                
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 42  

                for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
                {   
                  if((route_neighbor[idx].valid) && (!route_neighbor[idx].probe_mark) &&      
                    (route_info.parent == &route_neighbor[idx])) 
                  { 
                    route_neighbor[idx].probe_mark = TRUE;      
              #if 0     
                    FM_Printf(FM_APP, "\nPrb Dev idx %bu addr: %x", idx, route_neighbor[idx].addr);
              #endif
                    route_create_and_send_probe_req(&route_neighbor[idx], idx);
                    return;
                  }
                }
              
                /*One cycle is complete. All are done, unmark all active members*/
                for(idx = 0; idx < MAX_NEIGHBOUR_DEVICES; idx++) 
                {   
                  if((route_neighbor[idx].valid) && (route_neighbor[idx].probe_mark)) 
                    route_neighbor[idx].probe_mark = FALSE;
                }
              }
              
              #endif
2536          
2537          /******************************************************************************
2538           * @fn      route_add_route
2539           *
2540           * @brief   Adds a route in the routing table 
2541           *
2542           * @param   target - the short address of the remote peer
2543           *      parent - the short address of parent of the remote peer
2544           *      ieee_addr - the IEEE address of the peer
2545           *      link_type - the link type of the peer
2546           *
2547           * @return  TRUE or FALSE
2548           *
2549           */
2550          
2551          static bool route_add_route(u16 target, u16 parent, u8 *ieee_addr, u8 link_type)
2552          {
2553   1        u8 idx = 0;
2554   1        u8 jdx = 0xFF;
2555   1        u8 tidx = 0xFF;
2556   1        u8 pidx = 0xFF; 
2557   1      
2558   1        for(idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++)    
2559   1        {   
2560   2          if(route_table[idx].valid) 
2561   2          {
2562   3            if(route_table[idx].target == parent) 
2563   3              pidx = idx;
2564   3            
2565   3            if(route_table[idx].target == target) 
2566   3              tidx = idx;
2567   3          } 
2568   2          else 
2569   2          {
2570   3            if(jdx == 0xFF) 
2571   3              jdx = idx;
2572   3          }
2573   2        }
2574   1        
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 43  

2575   1        if((tidx != 0xFF) && (pidx != 0xFF)) 
2576   1        {   
2577   2          route_table[tidx].valid = TRUE;
2578   2          route_table[tidx].target = target;        
2579   2          route_table[tidx].parent_idx = pidx;
2580   2          route_table[tidx].link = link_type; 
2581   2          route_table[tidx].timeout = MAX_SROUTE_FAIL_COUNT; 
2582   2          return TRUE;
2583   2        }
2584   1      
2585   1        if((jdx != 0xFF) && (tidx == 0xFF)) 
2586   1        {
2587   2          route_table[jdx].valid = TRUE;
2588   2          route_table[jdx].target = target;       
2589   2          route_table[jdx].parent_idx = pidx;
2590   2          route_table[jdx].link = link_type;  
2591   2          memcpy(route_table[jdx].ieee_address, ieee_addr, MAC_ADDR_LEN);
2592   2          route_table[jdx].timeout = MAX_SROUTE_FAIL_COUNT;
2593   2          return TRUE;
2594   2        }
2595   1      
2596   1      #if 0 
                FM_Printf(FM_APP,  "\nCouldnt add route");  
              #endif
2599   1        return FALSE;
2600   1      }
2601          
2602          /******************************************************************************
2603           * @fn      route_remove_route
2604           *
2605           * @brief   Remove a route from the routing table 
2606           *
2607           * @param   target - the short address of the remote peer
2608           * 
2609           * @return  TRUE or FALSE
2610           *
2611           */
2612          
2613          static bool route_remove_route (u16 target)
2614          {
2615   1        u8 idx = 0;
2616   1        for(idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++)    
2617   1        { 
2618   2          /* Check if target id is valid */ 
2619   2          if((route_table[idx].valid) && (route_table[idx].target == target))
2620   2          {     
2621   3            route_table[idx].valid = FALSE;
2622   3            route_table[idx].target = 0;
2623   3            route_table[idx].link = 0;
2624   3            route_table[idx].parent_idx = MAX_ROUTE_TABLE_ENTRIES;  
2625   3            route_table[idx].timeout = 0;     
2626   3            return TRUE;      
2627   3          } 
2628   2        }
2629   1      
2630   1      #if 0 
                FM_Printf(FM_APP, "\nCouldnt remove route: Invalid Target id");
              #endif
2633   1        return FALSE; 
2634   1      }
2635          
2636          /******************************************************************************
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 44  

2637           * @fn      route_rtable_aging_timer
2638           *
2639           * @brief   Perform of all the routes
2640           *
2641           * @param   none
2642           * 
2643           * @return  none
2644           *
2645           */
2646          
2647          static void route_rtable_aging_timer (void) 
2648          {
2649   1        u8 idx = 0;
2650   1        for(idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++)    
2651   1        { 
2652   2          /* Check if target id is valid */ 
2653   2          if (route_table[idx].valid == TRUE) 
2654   2          {
2655   3            if(route_table[idx].target != route_info.zid) 
2656   3            {
2657   4      #if 0     
                      FM_Printf(FM_APP,  "\nRoute rm t - 0x%02x, TO - %bu", route_table[idx].target, route_table[idx].timeou
             -t); 
              #endif
2660   4              if (route_table[idx].timeout) 
2661   4                route_table[idx].timeout--;
2662   4              else 
2663   4                route_remove_route (route_table[idx].target);
2664   4            }
2665   3          }
2666   2        }
2667   1      }
2668          
2669          /******************************************************************************
2670           * @fn      route_get_route
2671           *
2672           * @brief   Fetch the route given the ahort address of the target node
2673           *
2674           * @param   target - the short address of the target node
2675           * 
2676           * @return  route_table_t - a pointer to the parent to the target node
2677           *
2678           */
2679          
2680          static route_table_t* route_get_route(u16 target)
2681          {
2682   1        u8 idx = 0;
2683   1        u8 cond = FALSE;
2684   1        
2685   1        for(idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++)    
2686   1        { 
2687   2      #if 0 
                  FM_Printf(FM_APP, "\nGet Route idx: %bu v %bu t1 %x t %x", 
                        idx, route_table[idx].valid, target, route_table[idx].target);  
              #endif
2691   2          /* Check if target id is valid */ 
2692   2          if((route_table[idx].valid == TRUE) && (route_table[idx].target == target))
2693   2            return &route_table[idx];
2694   2        }
2695   1      #if 0 
                FM_Printf(FM_APP,  "\nCouldnt get route: Invalid Target id");
              #endif
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 45  

2698   1        return NULL;  
2699   1      }
2700          
2701          /******************************************************************************
2702           * @fn      route_get_next_hop
2703           *
2704           * @brief   Fetches the short address of the next node towards the target node
2705           *
2706           * @param   target - the short address of the target node
2707           * 
2708           * @return  route_table_t - a pointer to the next node towards the target node
2709           *
2710           */
2711          
2712          static route_table_t* route_get_next_hop(u16 target)
2713          {
2714   1        u8 idx = 0;
2715   1        u8 jdx = 0xFF;
2716   1        
2717   1        for (idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++) 
2718   1        { 
2719   2      #if 0 
                  FM_Printf(FM_APP, "\nGet Hop idx: %bu v %bu t1 %x t %x", idx, route_table[idx].valid, 
                        target, route_table[idx].target);     
              #endif
2723   2          if((route_table[idx].valid == TRUE) && (target == route_table[idx].target)) 
2724   2          {
2725   3            jdx = idx;
2726   3            break;
2727   3          }   
2728   2        }
2729   1      
2730   1        if(jdx != 0xFF) 
2731   1        {
2732   2          for(idx = 0; idx < MAX_ROUTE_TABLE_ENTRIES; idx++) 
2733   2          { 
2734   3            if(route_table[route_table[jdx].parent_idx].target == route_info.zid) 
2735   3              return &route_table[jdx];
2736   3            else 
2737   3              jdx = route_table[jdx].parent_idx;
2738   3          } 
2739   2        }
2740   1      #if 0 
                FM_Printf(FM_APP,  "\nNo next hop");  
              #endif
2743   1        return NULL;  
2744   1      }
2745          
2746          /******************************************************************************
2747           * @fn      route_get_my_header
2748           *
2749           * @brief   Fills the routing header on behalf of the application
2750           *
2751           * @param   hdr - a pointer to the buffer holding the application frame
2752           *      destn - the short address of the destination node
2753           *      frametype - the framtype of the OTA frame
2754           *      direction - the direction of the frame
2755           *
2756           * @return  TRUE or FALSE
2757           *
2758           */
2759          
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 46  

2760          static bool route_get_my_header(route_hdr_t *hdr, u16 destn, u8 frametype, u8 direction)
2761          {
2762   1        destn = destn;
2763   1        
2764   1        if(route_info.parent == NULL) 
2765   1          return FALSE;
2766   1        
2767   1        /* Create FPREQ frame */
2768   1        hdr->fc.control_bits = 0;
2769   1        hdr->fc.control_bits |= RHDR_SET_DIR(direction);
2770   1        hdr->fc.control_bits |= RHDR_SET_CMDID(frametype);
2771   1        hdr->fc.control_bits |= RHDR_SET_TOROOT(TRUE);
2772   1        hdr->fc.control_bits |= RHDR_SET_ONEHOP(FALSE);
2773   1      
2774   1        if(frametype == REGISTRATION_CNF)
2775   1        {
2776   2      #ifdef REGISTER_APP   
2777   2          hdr->target = cpu_to_le16(register_data.nwk_addr.addr_16bit);
2778   2      #endif
2779   2        }
2780   1        else
2781   1          hdr->target = cpu_to_le16(route_info.zid);
2782   1        
2783   1        hdr->parent = cpu_to_le16(route_info.parent->addr);
2784   1        hdr->rank = cpu_to_le16(route_info.rank);
2785   1        return TRUE;
2786   1      }
2787          
2788          /******************************************************************************
2789           * @fn      route_handle_rx_from_ll
2790           *
2791           * @brief   Contains all the routing fowarding logic applied to an incoming frame
2792           *
2793           * @param   frm - a pointer to the buffer holding the incoming frame
2794           *      len - the length in bytes 
2795           *      link - the link on which the frame is received
2796           *
2797           * @return  TRUE or FALSE
2798           *
2799           */
2800          
2801          bool route_handle_rx_from_ll (u8 *frm, u8 len, u8 link, u8 lqi)
2802          {
2803   1        route_table_t *route = NULL;
2804   1        route_hdr_t *rhdr = (route_hdr_t *)&frm[sizeof(sEth2Hdr)];
2805   1        sEth2Hdr* petherhdr = (sEth2Hdr*)(frm);
2806   1        u16 dir = RHDR_GET_DIR(rhdr);
2807   1        u8 cmdid = RHDR_GET_CMDID(rhdr); 
2808   1        u8 tmac[MAC_ADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
2809   1                
2810   1        if(petherhdr->ethtype != APP_ETHER_PROTO)
2811   1          return FALSE;
2812   1      
2813   1        if (le16_to_cpu(rhdr->parent) == 0xFFFF)
2814   1        {
2815   2          u8 ret = 0;
2816   2      #if 0   
                  FM_Printf(FM_APP, "\nBcast (l-%bu)",link);
              #endif
2819   2          ret = route_handle_received_frm (frm, len,  link, lqi);       
2820   2          return TRUE;
2821   2        }
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 47  

2822   1      
2823   1        /*This device is the target*/ 
2824   1        if(le16_to_cpu(rhdr->target) == route_info.zid)
2825   1        {
2826   2          u8 ret = 0;
2827   2      #if 0   
                  FM_Printf(FM_APP, "\nTarget"); 
              #endif
2830   2          ret = route_handle_received_frm (frm, len, link, lqi);  
2831   2        } 
2832   1        
2833   1        /*This device is the parent*/ 
2834   1        else if (route_info.parent != NULL) 
2835   1        {
2836   2      #if 0 
                  FM_Printf(FM_APP, "\nParent");
                  FM_Printf(FM_APP,  "\nC3 p-%x, z-%x", le16_to_cpu(rhdr->parent), route_info.zid);       
              #endif
2840   2          if(le16_to_cpu(rhdr->parent) == route_info.zid) 
2841   2          {
2842   3      #if 0   
                    FM_Printf(FM_APP, "\nC3.0 r %u hr %u", le16_to_cpu(rhdr->rank), route_info.rank);         
              #endif
2845   3            /* I am the parent of the device, chek packet direction to avoid any looping */             
2846   3            if(le16_to_cpu(rhdr->rank) >= route_info.rank) 
2847   3            { 
2848   4              if(dir != DIRECTION_UP)
2849   4              {
2850   5      #if 0       
                        FM_Printf(FM_APP, "\nWrong dir - rk");  
              #endif
2853   5                return FALSE;
2854   5              }
2855   4            
2856   4              /* Sroute is handled only for Bridge devices */               
2857   4              if((RHDR_GET_ONEHOP(rhdr) == TRUE) || 
2858   4                 (RHDR_GET_CMDID(rhdr) == SOURCE_ROUTE_REQ)) 
2859   4              {
2860   5      #if 0       
                        //FM_Printf(FM_APP,  "\nCase 4.0"); 
              #endif
2863   5                route_handle_received_frm (frm, len, link, lqi);    
2864   5              }
2865   4      
2866   4              /*Forward frame to parent's parent*/      
2867   4              if(RHDR_GET_ONEHOP(rhdr) == FALSE)
2868   4              {
2869   5                route_info.stats.fwdup++;
2870   5      
2871   5                /* Send to parent */
2872   5                route_send_frm (route_info.parent->ieee_addr, route_info.ieee_addr, 
2873   5                      route_info.parent->addr, route_info.zid,
2874   5                      DIRECTION_UP, frm, len, 
2875   5                      route_info.parent->link, 
2876   5                      TRUE, TRUE);
2877   5              }
2878   4            }
2879   3            else if(dir == DIRECTION_DOWN) 
2880   3            {
2881   4              /* Look up route */
2882   4      #if 0         
                      FM_Printf(FM_APP,  "\nFW-Ch All 1");
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 48  

              #endif
2885   4      
2886   4              if((RHDR_GET_CMDID(rhdr) == REGISTRATION_RSP))
2887   4              {
2888   5      #if 0         
                        FM_Printf(FM_APP, "\nRegRsp");  
              #endif
2891   5                rhdr->fc.control_bits |= RHDR_SET_ONEHOP(TRUE);
2892   5                
2893   5                /* Down direction - Wireless */
2894   5                route_send_frm (NULL, route_info.ieee_addr, le16_to_cpu(rhdr->target),                    
2895   5                        route_info.zid, DIRECTION_DOWN, frm, len,                     
2896   5                        WIRELESS, TRUE, TRUE);    
2897   5                
2898   5                /* Down direction - PLC */
2899   5                route_send_frm (NULL, route_info.ieee_addr, le16_to_cpu(rhdr->target),                    
2900   5                        route_info.zid, DIRECTION_DOWN, frm, len,                     
2901   5                        POWER_LINE, TRUE, TRUE);            
2902   5              }
2903   4              else
2904   4              {
2905   5                route = route_get_next_hop (le16_to_cpu(rhdr->target));
2906   5                if(route == NULL) 
2907   5                {                           
2908   6                  if(CRM_FindScbVendorField(le16_to_cpu(rhdr->target), tmac) == STATUS_SUCCESS)
2909   6                  {
2910   7      #if 0             
                            FM_Printf(FM_APP, "\nFW-Nh (nh 0x%02x) plc", route->target); 
              #endif
2913   7                    /* Down direction - PLC */
2914   7                    route_send_frm(tmac, route_info.ieee_addr, le16_to_cpu(rhdr->target),                         
2915   7                            route_info.zid, DIRECTION_DOWN, frm, len,                         
2916   7                            POWER_LINE, TRUE, TRUE);
2917   7                  }
2918   6                } 
2919   5                else 
2920   5                {
2921   6                  /* Send it to the next hop device */
2922   6      #if 0             
                          FM_Printf(FM_APP,  "\nFW-Nh (nh 0x%02x) zb", route->target); 
              #endif
2925   6                  if(route->link == WIRELESS)
2926   6                  {
2927   7                    route_send_frm (route->ieee_address, route_info.ieee_addr, 
2928   7                              route->target, route_info.zid, DIRECTION_DOWN, frm, len,                      
2929   7                              route->link, TRUE, TRUE);                     
2930   7                  }
2931   6                  else if(CRM_FindScbVendorField(le16_to_cpu(rhdr->target), tmac) == STATUS_SUCCESS)
2932   6                  {               
2933   7                    route_send_frm(tmac, route_info.ieee_addr, route->target, route_info.zid,                     
2934   7                             DIRECTION_DOWN, frm, len, route->link, TRUE, TRUE);
2935   7                  }
2936   6                }             
2937   5              }           
2938   4            } 
2939   3          }
2940   2          else 
2941   2          {
2942   3            /* I am not parent and I am not target, so need to forward it */
2943   3      #if 0     
                    FM_Printf(FM_APP,  "\nInter"); 
              #endif
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 49  

2946   3            if(le16_to_cpu(rhdr->rank) > route_info.rank) 
2947   3            {
2948   4      #if 0     
                      FM_Printf(FM_APP, "\nFW-P");  
              #endif
2951   4              if(dir != DIRECTION_UP)
2952   4              {
2953   5                  return FALSE;
2954   5              }
2955   4      
2956   4              /* Sroute is handled only for Bridge devices */               
2957   4              if ((RHDR_GET_CMDID(rhdr) == SOURCE_ROUTE_REQ)) 
2958   4              {       
2959   5                route_handle_received_frm (frm, len, link, lqi);  
2960   5              }
2961   4      
2962   4              /* Direction is up */
2963   4              /* Send it to parent */       
2964   4              route_send_frm(route_info.parent->ieee_addr, route_info.ieee_addr, route_info.parent->addr,
2965   4                       route_info.zid, DIRECTION_UP, frm, len, route_info.parent->link, TRUE, TRUE);                                      
             -    
2966   4            } 
2967   3            else 
2968   3            {
2969   4      #if 0     
                      FM_Printf(FM_APP,  "\nFW-C");   
              #endif
2972   4              if(dir != DIRECTION_DOWN) 
2973   4                return FALSE;
2974   4              
2975   4              /* Direction is DOWN */
2976   4              if(RHDR_GET_ONEHOP(rhdr) == FALSE)
2977   4              {                                 
2978   5                /* Get route of the parent device */
2979   5                route = route_get_next_hop (le16_to_cpu(rhdr->parent));
2980   5                if (route == NULL) 
2981   5                {
2982   6      #if 0         
                          FM_Printf(FM_APP,  "\nNo route");       
              #endif
2985   6                  return FALSE;     
2986   6                } 
2987   5                else 
2988   5                {
2989   6                  /* Send it to the next hop device */
2990   6      #if 0           
                          FM_Printf(FM_APP, "\nFW-Nh (nh 0x%02x)", route->target); 
              #endif
2993   6                  route_send_frm (route->ieee_address, route_info.ieee_addr, route->target, 
2994   6                          route_info.zid, DIRECTION_DOWN, frm, len, route->link, TRUE, TRUE);
2995   6                }
2996   5              }
2997   4              else
2998   4              {
2999   5      #if 0       
                        FM_Printf(FM_APP, "\nReject(On hop only)");
              #endif
3002   5              }
3003   4            }
3004   3          }   
3005   2        }
3006   1        /*Target is broadcast*/
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 50  

3007   1        else if (le16_to_cpu(rhdr->target) == 0xFFFF) 
3008   1        {
3009   2          return FALSE;
3010   2        }
3011   1        /*This device is a forwarder or router*/  
3012   1        else
3013   1        {
3014   2      #if 0 
                  FM_Printf(FM_APP, "\nNo target 0x%02x, No parent 0x%02x", 
                      le16_to_cpu(rhdr->target), 
                      le16_to_cpu(rhdr->parent));
              #endif    
3019   2          return FALSE;
3020   2        }
3021   1        return TRUE;
3022   1      }
3023          
3024          /******************************************************************************
3025           * @fn      route_send_to_ll
3026           *
3027           * @brief   Application uses this to send a frame OTA
3028           *
3029           * @param   buff - a pointer to the buffer holding the application frame
3030           *      len - the length in bytes 
3031           *      frametype - the frametype of the application frame
3032           *      ether_hop_en - TRUE if frame is destined to the HOST, 
3033           *               FALSE if the destination is the next hop towards the Host
3034           * @return  TRUE or FALSE
3035           *
3036           */
3037          
3038          bool route_send_to_ll (u8 *buff, u8 len, u8 frametype, u8 ether_hop_en) 
3039          {
3040   1        route_hdr_t* rhdr = NULL;
3041   1        sEth2Hdr* petherhdr = (sEth2Hdr*)(buff);
3042   1        
3043   1        if(((route_state.state != ROUTE_DISCOVER) && (route_state.state != ROUTE_COMPLETE)) 
3044   1           || (route_info.parent == NULL))
3045   1          return FALSE;
3046   1      
3047   1        rhdr = (route_hdr_t*)&buff[sizeof(sEth2Hdr)];
3048   1        
3049   1        if(ether_hop_en == FALSE)
3050   1          memcpy(petherhdr->dstaddr, route_info.parent->ieee_addr, MAC_ADDR_LEN); 
3051   1        else    
3052   1          memcpy(petherhdr->dstaddr, route_info.root_ieee_addr, MAC_ADDR_LEN);
3053   1      
3054   1        memcpy(petherhdr->srcaddr, route_info.ieee_addr, MAC_ADDR_LEN);
3055   1      
3056   1        if(FALSE == route_get_my_header (rhdr, route_info.parent->addr, frametype, DIRECTION_UP)) 
3057   1        {
3058   2      #if 0 
                  FM_Printf(FM_APP, "\nRHfail"); 
              #endif
3061   2          return FALSE;
3062   2        }
3063   1      
3064   1        if(FALSE == route_send_frm (petherhdr->dstaddr, petherhdr->srcaddr, route_info.parent->addr, 
3065   1                route_info.zid, DIRECTION_UP, buff, len, route_info.parent->link, TRUE, FALSE))
3066   1          return FALSE;
3067   1      
3068   1        return TRUE;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 51  

3069   1      }
3070          
3071          /******************************************************************************
3072           * @fn      route_send_to_ul
3073           *
3074           * @brief   Place holder for application to place their receive handlers
3075           *
3076           * @param   frm - a pointer to the received frame
3077           *      len - the length in bytes 
3078           *      link - the link on which the frame is received
3079           *
3080           * @return  TRUE or FALSE
3081           *
3082           */
3083          
3084          u8 route_send_to_ul (u8* frm, u8 len, u8 link)
3085          {
3086   1        if((link == POWER_LINE) || (link == WIRELESS))
3087   1        {
3088   2      #ifdef LLP_APP
3089   2          LlpApp_Rx(frm, len);
3090   2      #endif
3091   2      #ifdef RTOPO_APP
3092   2          rtopo_rx(frm, len);
3093   2      #endif
3094   2          return TRUE;
3095   2        } 
3096   1        return FALSE;
3097   1      }
3098          
3099          /******************************************************************************
3100           * @fn      RouteApp_Poll
3101           *
3102           * @brief   A routine called perodically for a feature demading routine execution
3103           *
3104           * @param   none
3105           *
3106           * @return  none
3107           *
3108           */
3109          
3110          void RouteApp_Poll(void)
3111          {
3112   1      }
3113          
3114          void RouteApp_SendEvent(u8 ind, u8 link, u8 reason)
3115          { 
3116   1        u8 i, num_app = 0;
3117   1        u8 app_id[2];
3118   1        
3119   1        if(ind == ROUTE_DWN_IND)
3120   1        {
3121   2          route_dwn_ind_msg_t route_dwn;  
3122   2      #ifndef RTOPO_APP
              #ifdef NWKSTARTUP_APP   
                  nwk_start_evnt_msg_t nwk_start;
              #endif
              #endif
3127   2      
3128   2      #if 0   
                  FM_Printf(FM_APP, "\nRD l %bu r %bu", link, reason);    
              #endif
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 52  

3131   2          if(link == (WIRELESS | POWER_LINE))
3132   2          {
3133   3            route_flush_nwktables();    
3134   3            route_state.state = ROUTE_INIT;
3135   3            route_dwn.event = ROUTE_DWN_IND;
3136   3            route_dwn.link = link;
3137   3            route_dwn.reason =  reason;
3138   3            if(route_info.start.power_line.app_id != 
3139   3              route_info.start.wireless.app_id)
3140   3            {
3141   4              num_app = 2;
3142   4              app_id[0] = route_info.start.power_line.app_id;
3143   4              app_id[1] = route_info.start.wireless.app_id;
3144   4            }
3145   3            else
3146   3            {
3147   4              num_app = 1;
3148   4              app_id[0] = route_info.start.power_line.app_id;
3149   4              app_id[0] = route_info.start.wireless.app_id;
3150   4            }
3151   3      
3152   3            route_info.start.wireless.app_id = 0;
3153   3            route_info.start.wireless.active = FALSE;
3154   3      
3155   3            route_info.start.power_line.app_id = 0;
3156   3            route_info.start.power_line.active = FALSE;       
3157   3              
3158   3      #ifndef RTOPO_APP
              #ifdef NWKSTARTUP_APP
                    nwk_start.event = NWK_START_EVENT;
                    nwk_start.link = route_dwn->link;           
                    GV701x_SendAppEvent(rtopo_app_id, nwkstartup_data.app_id, APP_MSG_TYPE_APPEVENT, 
                        APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
                        &nwk_start, sizeof(nwk_start_evnt_msg_t), 0);
              #endif
              #endif
3167   3          }   
3168   2          else
3169   2          {
3170   3            if(route_info.parent != NULL)
3171   3            {
3172   4              if(route_info.parent->link & link)
3173   4              {
3174   5      #if 1       
3175   5                FM_Printf(FM_APP, "\nPfail");
3176   5      #endif
3177   5                route_remove_neighbor(route_info.parent->addr, 
3178   5                            route_info.parent->link);       
3179   5      #ifdef ROUTE_PROBE
              
                        STM_StopTimer(route_info.probe.prd_timer);          
                        STM_StopTimer(route_info.probe.retrans_timer);
                        
              #endif  
3185   5                STM_StopTimer(route_info.sroute_timer); 
3186   5                route_info.rank = INFINITE_RANK;
3187   5                route_info.parent = NULL;
3188   5                memset((u8*)&route_info.stats, 0x00, sizeof(route_stats_t));  
3189   5              }             
3190   4            }
3191   3      
3192   3            if(link & WIRELESS)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 53  

3193   3            {
3194   4              route_info.disc_params.wireless.cnt = 0;
3195   4              route_info.disc_params.link &= ~WIRELESS; 
3196   4              route_info.disc_params.assignparent &= ~WIRELESS;
3197   4              app_id[0] = route_info.start.wireless.app_id;
3198   4              num_app = 1;
3199   4              route_info.start.wireless.app_id = 0;
3200   4              route_info.start.wireless.active = FALSE;
3201   4              route_remove_link_neighbor(WIRELESS);       
3202   4            }
3203   3            else if(link & POWER_LINE)
3204   3            {
3205   4              route_info.disc_params.powerline.cnt = 0;
3206   4              route_info.disc_params.link &= ~POWER_LINE; 
3207   4              route_info.disc_params.assignparent &= ~POWER_LINE;       
3208   4              app_id[0] = route_info.start.power_line.app_id;
3209   4              num_app = 1;
3210   4              route_info.start.power_line.app_id = 0;
3211   4              route_info.start.power_line.active = FALSE;   
3212   4              route_remove_link_neighbor(POWER_LINE);
3213   4            } 
3214   3              
3215   3            if(route_info.disc_params.link == 0)    
3216   3            {
3217   4      #if 1     
3218   4              FM_Printf(FM_APP, "\nDiscStop");
3219   4      #endif
3220   4              STM_StopTimer(route_info.discovery_timer);        
3221   4            }
3222   3            route_dwn.event = ROUTE_DWN_IND;
3223   3            route_dwn.link = link;
3224   3            route_dwn.reason = reason;
3225   3          }
3226   2      
3227   2          for(i = 0; i < num_app; i++)
3228   2          {
3229   3            GV701x_SendAppEvent(route_app_id, app_id[i], APP_MSG_TYPE_APPIND, 
3230   3                APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
3231   3                &route_dwn, sizeof(route_dwn_ind_msg_t), 0);  
3232   3          }
3233   2        }
3234   1        else if(ind == ROUTE_UP_IND)
3235   1        {
3236   2          route_up_ind_msg_t route_up;
3237   2          route_up.event = ROUTE_UP_IND;
3238   2          route_up.link = link;   
3239   2      
3240   2      #if 0   
                  FM_Printf(FM_APP, "Route Up (%bu)", link);    
              #endif    
3243   2          if(route_info.start.power_line.app_id != 
3244   2            route_info.start.wireless.app_id)
3245   2          {
3246   3            num_app = 2;
3247   3            app_id[0] = route_info.start.power_line.app_id;
3248   3            app_id[1] = route_info.start.wireless.app_id;
3249   3          }
3250   2          else
3251   2          {
3252   3            num_app = 1;
3253   3            app_id[0] = route_info.start.power_line.app_id;
3254   3            app_id[0] = route_info.start.wireless.app_id;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 54  

3255   3          }   
3256   2      
3257   2          for(i = 0; i < num_app; i++)
3258   2          {   
3259   3            GV701x_SendAppEvent(route_app_id, app_id[i], APP_MSG_TYPE_APPIND, 
3260   3                APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
3261   3                &route_up, sizeof(route_up_ind_msg_t), 0);                
3262   3          }
3263   2        }
3264   1        else if(ind == ROUTE_DISC_IND)
3265   1        {
3266   2          route_disc_ind_msg_t route_disc;
3267   2          route_disc.event = ROUTE_DISC_IND;
3268   2          route_disc.link = link;
3269   2          route_disc.reason = reason;
3270   2      
3271   2      #if 0
                  FM_Printf(FM_APP, "Route Disc (%bu)", link);    
              #endif    
3274   2          if(route_info.start.power_line.app_id != 
3275   2            route_info.start.wireless.app_id)
3276   2          {
3277   3            num_app = 2;
3278   3            app_id[0] = route_info.start.power_line.app_id;
3279   3            app_id[1] = route_info.start.wireless.app_id;
3280   3          }
3281   2          else
3282   2          {
3283   3            num_app = 1;
3284   3            app_id[0] = route_info.start.power_line.app_id;
3285   3            app_id[0] = route_info.start.wireless.app_id;
3286   3          }   
3287   2      
3288   2          for(i = 0; i < num_app; i++)
3289   2          {   
3290   3            GV701x_SendAppEvent(route_app_id, app_id[i], APP_MSG_TYPE_APPIND, 
3291   3                APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,      
3292   3                &route_disc, sizeof(route_disc_ind_msg_t), 0);                
3293   3          }   
3294   2        }
3295   1      }
3296          
3297          /******************************************************************************
3298           * @fn      RouteApp_StateMachine
3299           *
3300           * @brief   The Routing State Machine, it executes all internal/external 
3301           *      events triggered
3302           *
3303           * @param   state - state machine object of the driver
3304           *          (passed as a reference incase there are more than one object)
3305           *
3306           * @return  none
3307           *
3308           */
3309          
3310          void RouteApp_StateMachine(gv701x_state_t* state) 
3311          {
3312   1        if(state == NULL)
3313   1          return;
3314   1      
3315   1      #if 1
3316   1        if(state->event != ROUTE_IDLE_EVNT)
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 55  

3317   1          FM_Printf(FM_APP, "\nRoute S %bu E %bu P %bu C %bu E %bu Da %bu Sa %bu T %bu", 
3318   1              state->state, state->event,
3319   1              state->eventproto, state->eventclass, state->eventtype, 
3320   1              state->msg_hdr.dst_app_id, state->msg_hdr.src_app_id, state->msg_hdr.type);
3321   1      #endif
3322   1        switch(state->state)
3323   1        {
3324   2          case ROUTE_INIT:
3325   2            if(state->eventproto == APP_MAC_ID)
3326   2            { 
3327   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
3328   3              {     
3329   4                switch(state->event)
3330   4                {
3331   5                  case ROUTE_START_EVNT:          
3332   5                  {
3333   6                    route_start_evnt_msg_t* route_start;
3334   6                    route_start = (route_start_evnt_msg_t*)(state->statedata);            
3335   6                    
3336   6                    if(((route_info.start.wireless.active == FALSE) &&
3337   6                      (route_start->link & WIRELESS)) ||
3338   6                      ((route_info.start.power_line.active == FALSE) &&
3339   6                      (route_start->link & POWER_LINE)))            
3340   6                    {         
3341   7                      if(route_start->link & POWER_LINE)
3342   7                      {
3343   8                        route_info.start.power_line.active = TRUE;
3344   8                        route_info.start.power_line.app_id = state->msg_hdr.src_app_id;
3345   8                      }
3346   7                      if(route_start->link & WIRELESS)
3347   7                      {
3348   8                        route_info.start.wireless.active = TRUE;
3349   8                        route_info.start.wireless.app_id = state->msg_hdr.src_app_id;               
3350   8                      } 
3351   7                      RouteApp_StartDiscovery(route_start->link, route_start->assignparent, route_start->link);
3352   7                    }
3353   6                  }
3354   5                  break;
3355   5                          
3356   5                  default:
3357   5                  break;        
3358   5                }
3359   4              }
3360   3            }
3361   2          break;
3362   2          
3363   2          case ROUTE_START:
3364   2            if(state->eventproto == APP_MAC_ID)
3365   2            {   
3366   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
3367   3              {     
3368   4                switch(state->event)
3369   4                {                           
3370   5                  case ROUTE_START_EVNT:          
3371   5                  {
3372   6                    route_start_evnt_msg_t* route_start;
3373   6                    route_start = (route_start_evnt_msg_t*)(state->statedata);            
3374   6                    
3375   6                    if(((route_info.start.wireless.active == FALSE) &&
3376   6                      (route_start->link == WIRELESS)) ||
3377   6                      ((route_info.start.power_line.active == FALSE) &&
3378   6                      (route_start->link == POWER_LINE)))           
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 56  

3379   6                    {             
3380   7                      if(route_start->link == POWER_LINE)
3381   7                      {
3382   8                        route_info.start.power_line.active = TRUE;
3383   8                        route_info.start.power_line.app_id = state->msg_hdr.src_app_id;
3384   8                      }
3385   7                      if(route_start->link == WIRELESS)
3386   7                      {
3387   8                        route_info.start.wireless.active = TRUE;
3388   8                        route_info.start.wireless.app_id = state->msg_hdr.src_app_id;               
3389   8                      } 
3390   7                      RouteApp_StartDiscovery(route_start->link, route_start->assignparent, route_start->link);
3391   7                    }
3392   6                  }
3393   5                  break;
3394   5                
3395   5                  case ROUTE_STOP_EVNT:
3396   5                  {
3397   6                    route_dwn_ind_msg_t* route_dwn = (route_dwn_ind_msg_t*)(state->statedata);          
3398   6                    RouteApp_SendEvent(ROUTE_DWN_IND, route_dwn->link, ROUTE_REASON_MANUAL);
3399   6                  }
3400   5                  break;
3401   5                  
3402   5                  default:
3403   5                  break;
3404   5                }
3405   4              }
3406   3            }
3407   2          break;
3408   2          
3409   2          case ROUTE_DISCOVER:
3410   2            if(state->eventproto == APP_MAC_ID)
3411   2            {     
3412   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
3413   3              {     
3414   4                switch(state->event)
3415   4                {         
3416   5                  case ROUTE_UPDATE_ADDR_EVNT:      
3417   5                  {
3418   6                    route_updt_addr_evnt_msg_t* route_update;
3419   6                    route_update = (route_updt_addr_evnt_msg_t*)state->statedata;     
3420   6      #ifdef REGISTER_APP           
3421   6                    route_info.zid = route_update->addr;
3422   6      #endif                      
3423   6                    STM_StopTimer(route_info.sroute_timer);
3424   6                    if(TRUE == route_create_and_send_sroute_frame(route_info.zid)) 
3425   6                    {
3426   7                      STM_StartTimer(route_info.sroute_timer, 
3427   7                               MAX_SROUTE_PERIODIC_INTERVAL_LOW);
3428   7                    }
3429   6                  }
3430   5                  break;
3431   5      
3432   5                  case ROUTE_UPDATE_ROUTE_EVNT:
3433   5                  {
3434   6                    state->state = ROUTE_COMPLETE;
3435   6                    route_info.unreachable = FALSE;
3436   6      #ifdef ROUTE_RECOVERY             
3437   6                    STM_StopTimer(route_info.rec_timer);
3438   6      #endif
3439   6                    RouteApp_SendEvent(ROUTE_UP_IND, route_info.parent->link, ROUTE_REASON_NONE);
3440   6      #ifdef HQ_LINK_TEST
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 57  

                            if(route_info.parent->link == WIRELESS)           
                            {
                              GV701x_GPIO_Write(RED_LED, LED_ON); 
                              GV701x_GPIO_Write(GREEN_LED, LED_OFF);  
                            }
                            else if(route_info.parent->link == POWER_LINE)
                            {
                              GV701x_GPIO_Write(GREEN_LED, LED_ON); 
                              GV701x_GPIO_Write(RED_LED, LED_OFF);  
                            }   
              #endif
3452   6      #ifdef RTOPO_APP  
3453   6                    if(route_info.route_sel_active == TRUE)
3454   6                    {           
3455   7                      rtopo_prof_evnt_msg_t rtopo_prof;
3456   7                      rtopo_prof.event = RTOPO_PROFILE_EVNT; 
3457   7                      GV701x_SendAppEvent(route_app_id, rtopo_app_id, APP_MSG_TYPE_APPEVENT, 
3458   7                        APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,
3459   7                            &rtopo_prof, sizeof(rtopo_prof_evnt_msg_t), 0); 
3460   7                    }
3461   6      #endif
3462   6      #if 0
                            FM_Printf(FM_APP, "\nRC 0x%04x)", route_info.zid);  
              #endif
3465   6      #ifdef NWKSTARTUP_APP         
3466   6                    nwkstartup_data.link.wireless.addr = route_info.zid; 
3467   6                    nwkstartup_data.link.power_line.addr = route_info.zid; 
3468   6      #endif
3469   6                    if(route_add_route(route_info.zid, 0, route_info.ieee_addr, route_info.parent->link) == TRUE)
3470   6                      route_create_and_send_fprsp_frame (NULL, 0xFFFF, WIRELESS | POWER_LINE);                      
3471   6      
3472   6      #ifdef ROUTE_PROBE              
                            if(route_device_profile.device_type == DEV_BRIDGING) 
                            { 
                              STM_StopTimer(route_info.probe.prd_timer);            
                              STM_StartTimer(route_info.probe.prd_timer, MAX_PROBE_INTERVAL);
                            }
              #endif              
3479   6                    
3480   6      #ifdef HPGP_DRIVER_APP          
3481   6                    memcpy(hpgp_nwk_data.params.nwk.app_info.byte_arr, 
3482   6                        route_info.ieee_addr, MAC_ADDR_LEN);
3483   6                    memcpy((u8*)&hpgp_nwk_data.params.nwk.app_info.byte_arr[MAC_ADDR_LEN], 
3484   6                         (u8*)&route_info.parent->addr, sizeof(route_info.parent->addr));
3485   6      #endif      
3486   6                  }
3487   5                  break;
3488   5      
3489   5                  case ROUTE_START_EVNT:          
3490   5                  {
3491   6                    route_start_evnt_msg_t* route_start;
3492   6                    route_start = (route_start_evnt_msg_t*)(state->statedata);            
3493   6                    
3494   6                    if(((route_info.start.wireless.active == FALSE) &&
3495   6                      (route_start->link == WIRELESS)) ||
3496   6                      ((route_info.start.power_line.active == FALSE) &&
3497   6                      (route_start->link == POWER_LINE)))           
3498   6                    {             
3499   7                      if(route_start->link == POWER_LINE)
3500   7                      {
3501   8                        route_info.start.power_line.active = TRUE;
3502   8                        route_info.start.power_line.app_id = state->msg_hdr.src_app_id;
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 58  

3503   8                      }
3504   7                      if(route_start->link == WIRELESS)
3505   7                      {
3506   8                        route_info.start.wireless.active = TRUE;
3507   8                        route_info.start.wireless.app_id = state->msg_hdr.src_app_id;               
3508   8                      }               
3509   7                      RouteApp_StartDiscovery(route_start->link, route_start->assignparent, route_start->link);
3510   7                    }
3511   6                  }
3512   5                  break;
3513   5      
3514   5                  case ROUTE_STOP_EVNT:         
3515   5                  {
3516   6                    route_dwn_ind_msg_t* route_dwn = (route_dwn_ind_msg_t*)(state->statedata);          
3517   6                    RouteApp_SendEvent(ROUTE_DWN_IND, route_dwn->link, ROUTE_REASON_MANUAL);
3518   6                  }
3519   5                  break;
3520   5                                  
3521   5                  default:
3522   5                  break;        
3523   5                }
3524   4              }
3525   3            }
3526   2          break;    
3527   2      
3528   2          case ROUTE_COMPLETE:
3529   2            if(state->eventproto == APP_MAC_ID)
3530   2            {   
3531   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)  
3532   3              {
3533   4                switch(state->event)
3534   4                {
3535   5                  case ROUTE_START_EVNT:
3536   5                  {
3537   6                    route_start_evnt_msg_t* route_start;
3538   6                    route_start = (route_start_evnt_msg_t*)(state->statedata);            
3539   6                    
3540   6                    if(((route_info.start.wireless.active == FALSE) &&
3541   6                      (route_start->link == WIRELESS)) ||
3542   6                      ((route_info.start.power_line.active == FALSE) &&
3543   6                      (route_start->link == POWER_LINE)))           
3544   6                    {             
3545   7                      if(route_start->link == POWER_LINE)
3546   7                      {
3547   8                        route_info.start.power_line.active = TRUE;
3548   8                        route_info.start.power_line.app_id = state->msg_hdr.src_app_id;
3549   8                      }
3550   7                      if(route_start->link == WIRELESS)
3551   7                      {
3552   8                        route_info.start.wireless.active = TRUE;
3553   8                        route_info.start.wireless.app_id = state->msg_hdr.src_app_id;               
3554   8                      }   
3555   7                      
3556   7                      RouteApp_StartDiscovery(route_start->link,
3557   7                              route_start->assignparent,
3558   7                              route_start->link);       
3559   7                    }
3560   6                  }
3561   5                  break;
3562   5      
3563   5                  case ROUTE_STOP_EVNT:
3564   5                  {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 59  

3565   6                    route_dwn_ind_msg_t* route_dwn = (route_dwn_ind_msg_t*)(state->statedata);          
3566   6                    RouteApp_SendEvent(ROUTE_DWN_IND, route_dwn->link, ROUTE_REASON_MANUAL);
3567   6                  }
3568   5      
3569   5                  break;
3570   5                          
3571   5                  default:
3572   5                  break;        
3573   5                }
3574   4              }
3575   3            }
3576   2          break;
3577   2          
3578   2          default:
3579   2          break;    
3580   2        }
3581   1      
3582   1      
3583   1        state->event = ROUTE_IDLE_EVNT; 
3584   1        state->eventtype = 0;
3585   1        state->eventclass = 0;
3586   1        state->eventproto = 0;
3587   1        state->statedata = NULL;  
3588   1        state->statedatalen = 0;  
3589   1        memset((u8*)&state->msg_hdr, 0x00, sizeof(gv701x_app_msg_hdr_t));
3590   1      }
3591          
3592          /******************************************************************************
3593           * @fn      RouteApp_StartDiscovery
3594           *
3595           * @brief   This function starts the discovery process on the given link/s
3596           *
3597           * @param   link - a bitmap indicating which link discovery is to be performed
3598           *      cont_disc - a bitmap indicating which link to continue to discover,
3599           *            set to TRUE to continue to discover, FALSE otherwise.
3600           *
3601           * @return  status - STATUS_SUCCESS/STATUS_FAILURE
3602           *
3603           */
3604          
3605          void RouteApp_StartDiscovery(u8 link, u8 assignparent, u8 cont_disc) 
3606          {
3607   1        u16 time; 
3608   1        neighbor_info_t* wir_nbr = NULL;
3609   1        neighbor_info_t* pwr_nbr = NULL;
3610   1      #ifdef HPGP_DRIVER_APP        
3611   1        route_info.zid = nwkstartup_data.link.power_line.addr;
3612   1      #endif        
3613   1      #ifdef LRWPAN_DRIVER_APP        
3614   1        route_info.zid = nwkstartup_data.link.wireless.addr;
3615   1      #endif        
3616   1      
3617   1      #ifdef NWKSTARTUP_APP               
3618   1        memcpy(route_info.ieee_addr, (u8*)nwkstartup_data.link.long_addr.ieee_addr, 
3619   1            IEEE_MAC_ADDRESS_LEN);        
3620   1      #endif
3621   1      
3622   1        if(route_state.state == ROUTE_INIT)
3623   1          route_state.state = ROUTE_START;
3624   1        
3625   1        if((link & POWER_LINE) && (!(route_info.disc_params.link & POWER_LINE)))
3626   1        {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 60  

3627   2          route_info.disc_params.powerline.cnt = 1;   
3628   2          route_info.disc_params.powerline.active = TRUE;
3629   2        }
3630   1        
3631   1        if((link & WIRELESS) && (!(route_info.disc_params.link & WIRELESS)))
3632   1        {
3633   2          route_info.disc_params.wireless.cnt = 1;    
3634   2          route_info.disc_params.wireless.active = TRUE;
3635   2        }
3636   1        
3637   1        route_info.disc_params.link |= link;  
3638   1        route_info.disc_params.assignparent |= assignparent;
3639   1        STM_StopTimer(route_info.discovery_timer);
3640   1      
3641   1        srand(route_info.zid);
3642   1        time = (u16)rand();   
3643   1        time = time % (0xFFFF / ROUTE_DISCOVER_PERIOD_HIGH);
3644   1      
3645   1      #if 0 
                FM_Printf(FM_APP, "\nS dl %bu t %u", route_info.disc_params.link, 
                    ((time < ROUTE_DISCOVER_PERIOD_LOW) ? (ROUTE_DISCOVER_PERIOD_LOW) : (time)));
              #endif
3649   1      
3650   1        /* Start timer to start route discovery */    
3651   1        if (STATUS_FAILURE == STM_StartTimer (route_info.discovery_timer, 
3652   1          ((time < ROUTE_DISCOVER_PERIOD_LOW) ? (ROUTE_DISCOVER_PERIOD_LOW) : (time)))) 
3653   1        {
3654   2          //FM_Printf(FM_APP, "\nCould not start route discovery timer"); 
3655   2        }   
3656   1        
3657   1        if((link & WIRELESS) && ((route_info.disc_params.assignparent & WIRELESS) == WIRELESS))
3658   1        {
3659   2          wir_nbr = route_get_neighbor_link(WIRELESS);
3660   2          if((cont_disc & WIRELESS) && (wir_nbr != NULL))
3661   2            wir_nbr->cnt = 0;
3662   2        }
3663   1      
3664   1        if((link & POWER_LINE) && ((route_info.disc_params.assignparent & POWER_LINE) == POWER_LINE))
3665   1        {
3666   2          pwr_nbr = route_get_neighbor_link(POWER_LINE);
3667   2          if((cont_disc & POWER_LINE) && (pwr_nbr != NULL))
3668   2            pwr_nbr->cnt = 0;
3669   2        }
3670   1        
3671   1        /* Create Discovery Frame */
3672   1        route_create_discover_fpreq_frame(route_info.zid,                             
3673   1                    ((wir_nbr != NULL) ? (wir_nbr->ieee_addr) : (NULL)),
3674   1                    ((wir_nbr != NULL) ? (wir_nbr->addr) : (BROADCAST_NET_ADDR)),
3675   1                    ((pwr_nbr != NULL) ? (pwr_nbr->ieee_addr) : (NULL)),
3676   1                    ((pwr_nbr != NULL) ? (pwr_nbr->addr) : (BROADCAST_NET_ADDR)), link);        
3677   1      }
3678          
3679          /******************************************************************************
3680           * @fn      RouteApp_DispStats
3681           *
3682           * @brief   Displays all frame counters, states and other statistics
3683           *
3684           * @param   none
3685           *
3686           * @return  none
3687           *
3688           */
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 61  

3689          
3690          void RouteApp_DispStats(void)
3691          {
3692   1      #if 1
3693   1        if(route_info.parent != NULL)
3694   1        {
3695   2          printf("\nRoute: a 0x%02x ", route_info.zid);
3696   2          FM_HexDump(FM_USER,"ieee ", route_info.parent->ieee_addr, IEEE_MAC_ADDRESS_LEN);  
3697   2          printf("\nparl %s ", ((route_info.parent->link == WIRELESS) ? 
3698   2              "Wir" : "Pwr"));        
3699   2          printf("\nr 0x%02x", route_info.rank);  
3700   2          if(route_info.parent != NULL)
3701   2            printf("\nrl %s", ((route_info.parent->link == WIRELESS) ? 
3702   2                "BCCO" : "BSTA"));              
3703   2        }
3704   1      #if 0
                printf("\nm(plc)- rssi %bu bcnt %lu (rf)- lqi %bu ract %bu", 
                    route_info.rssi_threshold, route_info.bcn_threshold, 
                    route_info.lqi_threshold, route_info.route_sel_active);
              #endif
3709   1      #endif  
3710   1      #if 0
                printf("\nsr_rx %lu sr_tx %lu", route_info.stats.sroute_rx,
                    route_info.stats.sroute_tx);
                printf("\nfpreq_tx %lu fpreq_rx %lu", route_info.stats.fpreq_tx,
                    route_info.stats.fpreq_rx);
                printf("\nfprsp_tx %lu fprsp_rx %lu", route_info.stats.fprsp_tx,
                    route_info.stats.fprsp_rx); 
                printf("\npreq_tx %lu preq_rx %lu", route_info.stats.preq_tx,
                    route_info.stats.preq_rx);  
                printf("\nprsp_tx %lu prsp_rx %lu", route_info.stats.prsp_tx,
                    route_info.stats.prsp_rx);  
                printf("\nfwdup %lu", route_info.stats.fwdup);    
              #endif
3723   1      
3724   1      
3725   1      }
3726          
3727          /******************************************************************************
3728           * @fn      RouteApp_DispNeighTable
3729           *
3730           * @brief   Displays the Neighbor table
3731           *
3732           * @param   none
3733           *
3734           * @return  none
3735           *
3736           */
3737          
3738          void RouteApp_DispNeighTable(void)
3739          {
3740   1      #if 0
                u8 i;
                for (i = 0; i < MAX_NEIGHBOUR_DEVICES; i++) 
                {
                  if (route_neighbor[i].valid == TRUE) 
                  {
                    printf("\n%bu. l %bu a 0x%02x", i, route_neighbor[i].link, route_neighbor[i].addr);
                    FM_HexDump(FM_USER,"ieee ", route_neighbor[i].ieee_addr, IEEE_MAC_ADDRESS_LEN);       
                    if(route_neighbor[i].link == POWER_LINE) 
                      printf("\nm rssi %bu bcnrx %lu cnt %bu paddr %x", route_neighbor[i].rssi, route_neighbor[i].bcn_rx,
                              route_neighbor[i].cnt, route_neighbor[i].parent_addr);
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 62  

                    else if (route_neighbor[i].link == WIRELESS)        
                      printf("\nm ch %bx ed %bx lqi %bu", route_neighbor[i].ch, 
                          (0xFF - route_neighbor[i].ed), route_neighbor[i].lqi);      
                  }
                }
              #endif  
3757   1      }
3758          
3759          /******************************************************************************
3760           * @fn      RouteApp_DispRouteTable
3761           *
3762           * @brief   Displays the Routing table
3763           *
3764           * @param   none
3765           *
3766           * @return  none
3767           *
3768           */
3769          
3770          void RouteApp_DispRouteTable(void)
3771          {
3772   1      #if 0
                u8 i= 0;
              
                for(i = 0; i < MAX_ROUTE_TABLE_ENTRIES; i++) 
                {
                  if (route_table[i].valid == TRUE) 
                  {
                    printf("\n%bu. l %bu ", i, route_table[i].link);
                    FM_HexDump(FM_USER,"ieee ", route_table[i].ieee_address, MAC_ADDR_LEN);       
                    printf("\nt %x pid %bu", i, route_table[i].target, route_table[i].parent_idx);          
                  }
                }
              #endif  
3785   1      }
3786          
3787          /******************************************************************************
3788           * @fn      RouteApp_CmdProcess
3789           *
3790           * @brief   It handles application command line requests
3791           *
3792           * @param   CmdBuf - command string
3793           *
3794           * @return  none
3795           *
3796           */
3797          
3798          void RouteApp_CmdProcess(char* CmdBuf) 
3799          {
3800   1        if(strcmp(CmdBuf, "state") == 0)
3801   1        {   
3802   2          printf("\nRoute S %bu E %bu", route_state.state, route_state.event);    
3803   2        } 
3804   1        else if(strcmp(CmdBuf, "stats") == 0)
3805   1        {
3806   2          char* subcmd = NULL;
3807   2          subcmd = strtok(CmdBuf, " ");
3808   2          subcmd = strtok(NULL, "\0");
3809   2      
3810   2      #if 0   
                  if(strcmp(subcmd, "rt") == 0)
                  {
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 63  

                    RouteApp_DispRouteTable();  
                  }
                  else if(strcmp(subcmd, "nt") == 0) 
                  {
                    RouteApp_DispNeighTable();    
                  }     
                  else if((strcmp(subcmd, "all") == 0) ||
                        (subcmd == NULL))
              #endif          
3822   2          { 
3823   3            RouteApp_DispStats();     
3824   3            RouteApp_DispNeighTable();          
3825   3            RouteApp_DispRouteTable();        
3826   3          }   
3827   2        } 
3828   1      #if 0
                else if(strcmp(CmdBuf, "test") == 0)
                {
                  char testname[15];    
                  u32 testval;
                  
                  memset(testname, 0x00, sizeof(testname));
              
                  if(sscanf(CmdBuf + sizeof("test"), "%s %lu", testname, &testval) >= 1)
                  {   
                    if(strcmp(testname, "rssithr") == 0)
                    {
                      route_info.rssi_threshold = (u8)testval;
                    }
                    else if(strcmp(testname, "bcnthr") == 0)
                    {
                      route_info.bcn_threshold = (u32)testval;
                    }     
                    else if(strcmp(testname, "lqithr") == 0)
                    {
                      route_info.lqi_threshold = (u8)testval;
                    }           
                    else if(strcmp(testname, "lqidiff") == 0)
                    {
                      route_info.lqi_diff = (u8)testval;
                      GV701x_FlashWrite(route_app_id, (u8*)&route_info.lqi_diff, 2);          
                    }                 
                    else if(strcmp(testname, "eddiff") == 0)
                    {
                      route_info.ed_diff = (u8)testval;
                      GV701x_FlashWrite(route_app_id, (u8*)&route_info.lqi_diff, 2);        
                    }
                  }
                } 
              #endif  
3863   1        else if(strcmp(CmdBuf, "nvclear") == 0) 
3864   1        {
3865   2          GV701x_FlashErase(route_app_id);
3866   2        } 
3867   1      }
3868          
3869          #endif /*ROUTE_APP*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  19451    ----
   CONSTANT SIZE    =   1093    ----
C51 COMPILER V9.53.0.0   ROUTE                                                             11/04/2015 20:09:52 PAGE 64  

   XDATA SIZE       =   1259     778
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
