C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SYS_CONFIG_DATA_UTILS
OBJECT MODULE PLACED IN .\obj\sys_config_data_utils.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\HybriiB_configuration_rw\src\sys_config_data_utils.
                    -c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..
                    -\firmware\common\include;..\..\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctr
                    -l;..\..\..\..\firmware\hpgp\src\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\fir
                    -mware\hpgp\src\nma;..\..\..\..\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\h
                    -al\src;..\..\..\..\firmware\zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..
                    -\..\components\utilities\event\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\
                    -inc;..\..\..\..\components\hpgp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;
                    -..\..\..\..\firmware\app_support;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\i
                    -nc;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802
                    -154\inc;..\..\..\..\components;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\component
                    -s\nma\ieee802154\inc;..\..\..\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\i
                    -nc;..\..\..\..\components\drivers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\in
                    -c;..\..\..\..\components\utilities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc
                    -;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..
                    -\sampleapp\src;..\..\inc;..\..\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE
                    -(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_
                    -SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_
                    -VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,
                    -UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKST
                    -ARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) 
                    -PRINT(.\lst\sys_config_data_utils.lst) TABS(2) OBJECT(.\obj\sys_config_data_utils.obj)

line level    source

   1          /*
   2          * Copyright (c) 2012-2013 Greenvity Communications, Inc.
   3          * All rights reserved.
   4          *
   5          * Author      : Peter Nguyen
   6          * Release Date: 06/12/2013
   7          * Desciption : This file contains the utilities to program 
   8          *              system configuration data into the sflash 
   9          *              load system configuration to the sram.
  10          *              The configuration data is an array of 
  11          *              max 512 bytes of ASCII hex digits end by '$'
  12          *
  13          * File name: sys_config_data_utils.c
  14          */
  15          
  16          #include <stdio.h>
  17          #include <reg51.h>
  18          #include <stdlib.h>
  19          #include <ctype.h>
  20          #include "papdef.h"
  21          #include "gv701x_flash_fw.h"
  22          
  23          #define SPIFL_TXSTAT    0x0300
  24          #define SPIFL_CFG       0x0304
  25          #define SPIFL_MSBDATABIT_FIRST 0x0305
  26          #define SPIFL_NOBYTE2TX 0x0306
  27          #define SPIFL_TXCTRL    0x0308
  28          #define SPIFL_WRDATA    0x030C
  29          #define SPIFL_RDDATA  0x030C
  30          #define SPIFL_WRDATA0   0x030F 
  31          #define SPIFL_WRDATA1   0x030E 
  32          #define SPIFL_WRDATA2   0x030D
  33          #define SPIFL_WRDATA3   0x030C
  34          #define SPIFL_WRDATA4   0x0307
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 2   

  35          
  36          #define SPIFL_RD         0x03 
  37          #define SPIFL_SECERASE   0x20000000 
  38          #define SPIFL_BLKERASE   0x52000000
  39          #define SPIFL_BLK64ERASE 0xD8000000
  40          
  41          #define SPIFL_BYTEPRGRM  0x02000000 
  42          #define SPIFL_BYTEREAD   0x03000000
  43          #define SPIFL_AAI        0xAF
  44          #define SPIFL_RDSR       0x05
  45          #define SPIFL_EWSR_B     0x50
  46          #define SPIFL_EWSR       0x50000000
  47          #define SPIFL_WRSR_B   0x01 
  48          #define SPIFL_WRSR       0x00010000 
  49          #define SPIFL_WREN_B     0x06
  50          #define SPIFL_WREN       0x06000000
  51          #define SPIFL_WRDI_B   0x04
  52          #define SPIFL_WRDI       0x04000000
  53          #define SPIFL_RDID       0x90
  54          
  55          #define SFLASH_PROTECT_ALL 0xBC   
  56          #define SFLASH_PROTECT_NONE 0x0
  57          
  58          extern char _getkey();
  59          extern char putchar(char);
  60          
  61          void spiflash_CheckFlashBusy();
  62          void spiFlash_Cmd(u8, u32, u8, u8);
  63          void spiflash_wren(u8);
  64          void spiflash_eraseConfigMem();
  65          void spiflash_eraseSector(u32);
  66          void spiflash_wrsr_unlock(u8);
  67          void test_spiflash(void);
  68          void spiflash_WriteByte(u32, u8);
  69          u8 spiflash_ReadByte(u32);
  70          void Program_Config_Data();
  71          void Load_Config_Data(u8, u8 *);
  72          u8 Asc2Hex (u8 *);
  73          //u8 Asc2Hex (u8 idata *);
  74          u32 swUtil_SwapEndian(u32);
  75          char _get1char();
  76          
  77          //***************************************************************
  78          // void spiFlash_Cmd(u8 NumOfByteCmd, u32 CmdData) is to send a command to the spiflash
  79          // An spiflash command may be from 1 to 4 bytes in length
  80          // Input:
  81          //    NumOfByteCmd: The length of command in number of bytes sent to sflash.
  82          //    CmdData: Command data from 1 byte to 4 bytes
  83          //    SpiWriteData: 5th byte to transmit to spi flash in case 5-byte command
  84          //***************************************************************
  85          void spiFlash_Cmd(u8 const NumOfByteCmd, u32 const CmdData, u8 const SpiWriteData, u8 const RdWr)
  86          {
  87   1        u8 c;
  88   1        u32 temp;
  89   1        temp = swUtil_SwapEndian(CmdData);
  90   1        *(u32 xdata *)SPIFL_WRDATA = (u32)(temp);
  91   1        *(u8 xdata *)SPIFL_WRDATA4 = (u8)(SpiWriteData);
  92   1        *(u8 xdata *)SPIFL_NOBYTE2TX = NumOfByteCmd;
  93   1        if (RdWr){    
  94   2          *(u8 xdata *)SPIFL_TXCTRL    = 0x5; 
  95   2          c = *(u8 xdata *)SPIFL_TXSTAT;
  96   2          while (c!=0)
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 3   

  97   2          {
  98   3            c = *(u8 xdata *)SPIFL_TXSTAT;
  99   3          }
 100   2          *(u8 xdata *)SPIFL_TXCTRL    = 0x3; 
 101   2        } else {
 102   2          *(u8 xdata *)SPIFL_TXCTRL    = 0x5; 
 103   2        }
 104   1        c = *(u8 xdata *)SPIFL_TXSTAT;
 105   1        while (c!=0)
 106   1        {
 107   2          c = *(u8 xdata *)SPIFL_TXSTAT;
 108   2        }
 109   1        *(u8 xdata *)SPIFL_TXCTRL  = 0x0;
 110   1        return;
 111   1      }
 112          //***************************************************************
 113          // void spiflash_wren(u8 wren) to enable or disable sflash write enable
 114          // Input:
 115          //    wren = 1: Enable write mode
 116          //    wren = 0: Disable write mode
 117          //    the write enable mode will be disable automatically after every write command
 118          //***************************************************************
 119          
 120          void spiflash_wren(u8 const wren)
 121          {
 122   1        if (wren==1)
 123   1          spiFlash_Cmd(1,SPIFL_WREN_B,0,0);
 124   1        else
 125   1          spiFlash_Cmd(1,SPIFL_WRDI_B,0,0);
 126   1        return;
 127   1      }
 128          //***************************************************************
 129          // void spiflash_wrsr_unlock(u8 unlock) is to unlock or lock the spiflash
 130          // Input
 131          //    unlock = 1: is to unlock the chip
 132          //    unlock = 0: is to lock the chip
 133          //***************************************************************
 134          
 135          void spiflash_wrsr_unlock(u8 const unlock)
 136          { 
 137   1        spiflash_wren(1);
 138   1        if (unlock==1)
 139   1          spiFlash_Cmd(2,(u32)(SFLASH_PROTECT_NONE|(SPIFL_WRSR_B<<8)),0,0);
 140   1          spiFlash_Cmd(2,(u32)(SFLASH_PROTECT_ALL|(SPIFL_WRSR_B<<8)),0,0); 
 141   1        spiflash_CheckFlashBusy();
 142   1        return;
 143   1      }
 144          //***************************************************************
 145          //void spiflash_CheckFlashBusy(void)
 146          //Read status register untill bit busy == 0
 147          //***************************************************************
 148          void spiflash_CheckFlashBusy()
 149          {
 150   1        u8 c;
 151   1      check_st_reg:
 152   1        *(u8 xdata *)SPIFL_NOBYTE2TX = 1;
 153   1        *(u8 xdata *)SPIFL_WRDATA    = (u8)(SPIFL_RDSR);
 154   1        *(u8 xdata *)SPIFL_TXCTRL  = 0x5;
 155   1      check_Txdone1:
 156   1        c = *(u8 xdata *)SPIFL_TXSTAT;
 157   1        if (c!=0)
 158   1          goto check_Txdone1;
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 4   

 159   1        *(u8 xdata *)SPIFL_TXCTRL  = 0x3;
 160   1      check_Rxdone:
 161   1        c = *(u8 xdata *)SPIFL_TXSTAT;
 162   1        if (c!=0)
 163   1          goto check_Rxdone;
 164   1        c = (*(u8 xdata *)SPIFL_RDDATA)&0x1;
 165   1      #ifdef  TEST_ON_BOARD
                printf("\nBusy = %x",(u16)(0xFF&c));
              #endif
 168   1        if (c==0x1)
 169   1          goto check_st_reg;
 170   1        *(u8 xdata *)SPIFL_TXCTRL  = 0x0;
 171   1        return;
 172   1      }
 173          
 174          //***************************************************************
 175          //spiflash_64KBlkErase(u8 BlockID, u8 block64): a block of 64Kbytes
 176          //Input: 
 177          //  BlockID: The block ID of each 32 or 64K (0,1,2,3..)
 178          //   block64: 1 - erase block 64K, 0 - erase block 32K
 179          //***************************************************************
 180          
 181          void spiflash_EraseBlock(u32 BlockID, u8 block64)
 182          {
 183   1        spiflash_wrsr_unlock((u8)1);
 184   1        spiflash_wren((u8)1);
 185   1        if (block64==1)
 186   1          spiFlash_Cmd((u8)4,(u32)(SPIFL_BLK64ERASE | (BlockID<<16)), 0,0);
 187   1        else 
 188   1          spiFlash_Cmd((u8)4,(u32)(SPIFL_BLKERASE | (BlockID<<15)), 0,0);   
 189   1        spiflash_CheckFlashBusy();
 190   1        return;
 191   1      }
 192          //***************************************************************
 193          //spiflash_eraseConfigMem() erase 32k bytes of configuration data in the spi flash
 194          //Configuration data is located at address 0x00100000 - 0x0x001000FF; 
 195          //Sector 256, beyond 1Mbyte
 196          //***************************************************************
 197          
 198          void spiflash_eraseConfigMem()
 199          {
 200   1        //printf("\n --> Delete configuration memory ...");
 201   1        spiflash_eraseSector(GVTY_CONFIG_DATA_SECTOR);
 202   1        //spiflash_EraseBlock(32, 0); //Unnecessorily erases same memory. This may erase app memory [Kiran]
 203   1        //spiflash_EraseBlock(16, 1);//Unnecessorily erases same memory. This may erase app memory [Kiran]
 204   1        spiflash_wrsr_unlock((u8)0);
 205   1        printf("\n");
 206   1        return;
 207   1      }
 208          
 209          //***************************************************************
 210          //void spiflash_WriteByte(u32 Addr, u8 IData)
 211          //***************************************************************
 212          
 213          void spiflash_WriteByte(u32 Addr, u8 IData)
 214          {
 215   1        spiflash_wren(1);
 216   1        spiFlash_Cmd(5, (SPIFL_BYTEPRGRM|Addr), IData,0);
 217   1        spiflash_CheckFlashBusy();
 218   1        return;
 219   1      }
 220          
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 5   

 221          //***************************************************************
 222          //void spiflash_ReadByte(u32 Addr, u8 IData)
 223          //***************************************************************
 224          
 225          u8 spiflash_ReadByte(u32 Addr)
 226          {
 227   1        spiFlash_Cmd((u8)4,(u32)(SPIFL_BYTEREAD|Addr),0,1);
 228   1        return (*(u8 xdata *)SPIFL_RDDATA); 
 229   1      }
 230          //***************************************************************
 231          //void spiflash_eraseSector(u32 Addr)
 232          //To erase sectors of 4kbyte
 233          //***************************************************************
 234          void spiflash_eraseSector(u32 Sector)
 235          {
 236   1        spiflash_wrsr_unlock((u8)1);
 237   1        spiflash_wren((u8)1);
 238   1        spiFlash_Cmd((u8)4,(u32)(SPIFL_SECERASE | (Sector<<12)),0,0);
 239   1        spiflash_CheckFlashBusy();
 240   1        return;
 241   1      }
 242          //***************************************************************
 243          // Program_Config_Data() is to program configuration data into spi flash at the address
 244          // 0x00100000
 245          //***************************************************************
 246          void Program_Config_Data()
 247          {
 248   1        char  c;
 249   1        u32  ConfigAddr, i, n;
 250   1        u8  HexVal;
 251   1        u8  FirstChar = 0;
 252   1        u8  xdata dlCfData[GVTY_CONFIG_DATA_MAX];
 253   1        i = 0;
 254   1        printf("\n **** PROGRAM CONFIGURATION DATA ****\n");  
 255   1        printf("\n --> Programming configuration data Y/N?: ");
 256   1        c = _get1char();
 257   1        TI = 0;
 258   1        SBUF = c;
 259   1        while (TI==0);
 260   1        if (c!='Y')
 261   1        {
 262   2          c = '1';
 263   2          goto AbortPrgConfigData;
 264   2        }
 265   1        printf("\n --> Erase current configuration data Y/N?: ");
 266   1        c = _get1char();
 267   1        TI = 0;
 268   1        SBUF = c;
 269   1        while (TI==0);
 270   1        if (c!='Y')
 271   1        {
 272   2          c = '1';
 273   2          goto AbortPrgConfigData;
 274   2        } 
 275   1        spiflash_eraseConfigMem();
 276   1        spiflash_wrsr_unlock((u8)1);
 277   1        printf("\n   **** Configuration data: max 508 bytes of ASCII Hex, ended by '$' ****"); 
 278   1        printf("\n --> Waiting for configuration data: ."); 
 279   1        ConfigAddr = GVTY_CONFIG_DATA_ADDR;
 280   1      Read_Config_data:
 281   1        c = _get1char();
 282   1        switch (c)
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 6   

 283   1        { 
 284   2        case 27:
 285   2          goto AbortPrgConfigData;
 286   2          break;
 287   2        case '$':
 288   2          goto EndPrgConfigData;
 289   2          break;
 290   2        default:
 291   2          if (isxdigit(c))
 292   2          {
 293   3            if (FirstChar++==0)
 294   3            {
 295   4              HexVal = (u8)((Asc2Hex((u8*)&c))<<4);
 296   4            }
 297   3            else
 298   3            {
 299   4              HexVal |= Asc2Hex((u8*)&c);
 300   4              dlCfData[i] = HexVal;
 301   4              i++;
 302   4              FirstChar=0;
 303   4            }
 304   3          }
 305   2          break;
 306   2        } 
 307   1        if (i==(GVTY_CONFIG_DATA_MAX-4))
 308   1        {
 309   2          printf("\n Configuration data exceeds 508 bytes being truncated!\n");
 310   2          goto EndPrgConfigData;
 311   2        } else {
 312   2          goto Read_Config_data;
 313   2        }
 314   1      AbortPrgConfigData:
 315   1        printf ("\n\n --> Abort programming configuration data\n");
 316   1        goto CloseConfigProgramming;
 317   1      EndPrgConfigData:
 318   1        n = 0;
 319   1        if (i==0){
 320   2          printf("\n No configuration data available\n");
 321   2          goto CloseConfigProgramming;
 322   2        }
 323   1        while (n<i){
 324   2          if ((n&0x7)==0)
 325   2            printf(".");
 326   2          spiflash_WriteByte(ConfigAddr++,dlCfData[n]);
 327   2          n++;
 328   2        }
 329   1        printf ("\n\n --> Finish programming configuration data - %u bytes\n", (u16)(n&0xFFFF));
 330   1      CloseConfigProgramming:
 331   1        spiflash_WriteByte(ConfigAddr,'$');
 332   1        spiflash_WriteByte((ConfigAddr+1),'$');
 333   1        spiflash_WriteByte((ConfigAddr+2),'#');
 334   1        spiflash_WriteByte((ConfigAddr+3),'#');
 335   1        spiflash_wrsr_unlock(0);
 336   1        return;
 337   1      }
 338          //***************************************************************
 339          //Load_Config_Data();
 340          //Load configuration data into the data ram @ 0xE000
 341          //Input:
 342          //  LoadConfig = 1: Load configuration data to data ram
 343          //         = 0: Dump configuration data onto screen
 344          //***************************************************************
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 7   

 345          void Load_Config_Data(u8 LoadConfig, u8  *eramConfigDatAdd)
 346          {
 347   1        u16 Temp, a;
 348   1        u8 c,d,f,g;
 349   1        if (LoadConfig==0)
 350   1          printf("\n --> Dump configuration data\n");
 351   1        else
 352   1          printf("\n --> Loading configuration data ");
 353   1        for (Temp=0;Temp<GVTY_CONFIG_DATA_MAX-4;Temp++)
 354   1        {
 355   2          c = spiflash_ReadByte((u32)(GVTY_CONFIG_DATA_ADDR+Temp));
 356   2          if (c=='$'){
 357   3            a = Temp;
 358   3            a++;
 359   3            d = spiflash_ReadByte((u32)(GVTY_CONFIG_DATA_ADDR+a++));
 360   3            f = spiflash_ReadByte((u32)(GVTY_CONFIG_DATA_ADDR+a++));
 361   3            g = spiflash_ReadByte((u32)(GVTY_CONFIG_DATA_ADDR+a));  
 362   3            if (d=='$' && f=='#' && g=='#'){
 363   4              *(u8 xdata *)((u16)(eramConfigDatAdd + Temp)) = '$';
 364   4              *(u8 xdata *)((u16)(eramConfigDatAdd + Temp + 1)) = '$';
 365   4              *(u8 xdata *)((u16)(eramConfigDatAdd + Temp + 2)) = '#';
 366   4              *(u8 xdata *)((u16)(eramConfigDatAdd + Temp + 3)) = '#';
 367   4              break;
 368   4            }       
 369   3          }
 370   2          if (LoadConfig==0)
 371   2          {     
 372   3            printf("\n Dump @0x%03X: 0x%bx",(u16)(Temp),(u8) (0xFF&c));
 373   3          }
 374   2          else
 375   2          {
 376   3            *((eramConfigDatAdd + Temp)) = c;
 377   3            //printf("\n RAM Save @0x%03X: 0x%bx",(u16)(eramConfigDatAdd + Temp), (u8 )(0xFF & *(u8 xdata *)((u16)(
             -eramConfigDatAdd + Temp))));
 378   3            //if ((Temp&0x7) == 0){
 379   3            //  printf(".");
 380   3            //}
 381   3          }
 382   2        }
 383   1        printf("\n %u byte(s) of configuration data read ..........\n", Temp);
 384   1        
 385   1        return;
 386   1      }
 387          //***************************************************************
 388          //Asc2Hex(u8) 
 389          //           Input: an ascii hex digit
 390          //           ouput: the hex value of the input
 391          //***************************************************************
 392          u8 Asc2Hex (u8 *AscDigit)
 393          {
 394   1        u8 c;
 395   1        c = toupper(*AscDigit);
 396   1        if (c <= 57)
 397   1          c = c - 48;
 398   1        else
 399   1          c = c - 55;
 400   1        return c;
 401   1      }
 402          //***************************************************************
 403          // salutil_Big2LittleEndian(u32)
 404          // Sofware Abstraction Utility to convert a 32 bit big endian to 32 bit little endian or vs
 405          //***************************************************************
C51 COMPILER V9.53.0.0   SYS_CONFIG_DATA_UTILS                                             11/04/2015 20:09:41 PAGE 8   

 406          u32 swUtil_SwapEndian(u32 var32)
 407          {
 408   1        return ((var32&0x000000FF)<<24 |
 409   1            (var32&0x0000FF00)<<8 |
 410   1            (var32&0x00FF0000)>>8 |
 411   1            (var32&0xFF000000)>>24);
 412   1      }
 413          //***************************************************************
 414          //char _get1char()
 415          //Get 1 char from the uart
 416          //***************************************************************
 417          char _get1char()
 418          {
 419   1        char  c;
 420   1        c = 0;
 421   1        while (RI==0);
 422   1        c = SBUF;
 423   1        RI = 0;
 424   1        return c;
 425   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1808    ----
   CONSTANT SIZE    =    582    ----
   XDATA SIZE       =   ----     569
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
