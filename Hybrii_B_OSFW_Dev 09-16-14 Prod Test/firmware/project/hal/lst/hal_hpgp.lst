C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HAL_HPGP
OBJECT MODULE PLACED IN .\obj\hal_hpgp.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\hal_hpgp.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR
                    -(..\..\common;..\..\project\hal\src;..\..\hpgp\src\mux;..\..\hpgp\src\link;..\..\hpgp\src\ctrl;..\..\hpgp\src\nma;..\..\
                    -hal;.\src;..\..\hpgp\src\hal;..\..\hpgp\src\sap;..\..\hpgp\src\test;..\..\hpgp\src\;..\..\common\datapath;..\..\hpgp\src
                    -\route;..\..\..\components\utilities\datatype\inc;..\..\..\components\utilities\event\inc;..\..\..\components\utilities\
                    -linklist\inc;..\..\..\components\utilities\timer\inc;..\..\app_support;..\..\..\sampleapp\src;..\..\..\sampleapp\inc;..\
                    -..\..\components\hpgp\inc;..\..\..\components\aps\inc) DEFINE(P8051,HYBRII_8051,HYBRII_HPGP,HYBRII_ASIC,PLC_SW_SYNC=1,in
                    -line,HPGP_HAL_TEST,RTX51_TINY_OS,_TIMER_INTERRUPT_,SNIFFER,Hybrii_B,NEW_SYNC,_TIMER_INTERRUPT_,HYBRII_B,HW_SPI_TX_CRC,HW
                    -_SPI_RX_CRC,_CRC_VERIFY_,HYBRII_SPI,SNIFFER,HYBRII_ETH,B_ASICPLC,FREQ_DETECT,PROD_TEST) DEBUG OBJECTEXTEND PRINT(.\lst\h
                    -al_hpgp.lst) TABS(2) OBJECT(.\obj\hal_hpgp.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgp.c,v 1.63 2014/09/05 09:28:18 ranjan Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgp.c,v $
   5          *
   6          * Description : HPGP Hardware Abstraction Layer implementation
   7          *
   8          * Copyright (c) 2010-2013 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines API interface for accessing HPGP memory mapped registers.
  13          *                           for writing tx descritpors to plc tx queues
  14          *                           for writing beacons to beacon tx fifos
  15          *                           for reading beacons from beacon rx fifos
  16          */
  17          
  18          
  19          #include <stdio.h>
  20          #include <string.h>
  21          #include <intrins.h>
  22          #include "papdef.h"
  23          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  26          #include "hal_common.h"
  27          #include "hal.h"
  28          #include "fm.h"
  29          #include "hal_hpgp.h"
  30          #include "hal_eth.h"
  31          #include "hal_tst.h"
  32          #include "hal_reg.h"
  33          #include "hpgpevt.h"
  34          #include "timer.h"
  35          #include "stm.h"
  36          #include "hybrii_tasks.h"
  37          #ifndef HPGP_HAL_TEST
              #include "hpgpapi.h"
              #endif  //HPGP_HAL_TEST
  40          
  41          
  42          #include "fm.h"
  43          
  44          #ifdef HPGP_HAL_TEST
  45          #include "hal_cfg.h"
  46          #else
              #include "hal.h"
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 2   

              #endif  //HPGP_HAL_TEST
  49          
  50          #include "hal_regs_def.h"
  51          
  52          #include "uart.h"
  53          #ifdef UM
              #include "mac_intf_common.h"
              #endif
  56          
  57          #ifdef HPGP_MAC_SAP 
              #ifdef LINK_STATUS
              #define MAX_LINK_TEST_TX_TIMEOUT 450
              #define LINK_RETRY            1
              #endif  //LINK_STATUS
              #endif  //HPGP_MAC_SAP
  63          
  64          #ifdef FREQ_DETECT
  65              u32 AC_MIN_THRESHOLD;
  66              u32 PLC_DC_LINE_CYCLE_FREQENCY  =  0x7A120;
  67          #endif
  68          u32 gBPSTdelta;
  69          u8 gNegativeflag = 0;
  70          u8 gPositiveflag = 0;
  71          u8 firsttime = 0;
  72          u32 goldbpst;
  73          u32 gavg;
  74          u8 zctrack = 0;
  75          u8 zcFlag;
  76          u32 gbpst = 0;
  77          u8 gRollOver;
  78          u32 zcCCONTBold;
  79          u32 gCCO_BTS;
  80          u32 zcCCONTB_OLD;
  81          
  82          u8 avgdone = 0;
  83          u32 avg;
  84          u8 avgcount =0;
  85          
  86          extern u32 misscnt;
  87          //extern sysConfig_t sysConfig;
  88          //extern Load_Config_Data (u8, u8 *);
  89          //extern Program_Config_Data();
  90          
  91          void sendSingleFrame(u8 mcstMode);  //1 = multicast, 0 unicast
  92          extern void datapath_init();
  93          
  94          extern u16 var1;
  95          //u32 missarr[1000];
  96          u8 testflag = 1;
  97          
  98          extern u8 opMode;
  99          #ifdef PLC_TEST
              u8 gSTA_TEI;
              u8 gCount;
              u8 gNumOfSTAAssignedTEI = 1;
              u8 gCCOTest = 0;
              extern u16 gBcnSent;
              eHpgpRoboMod gRoboMode;
              eHpgpRoboModLens gCurrRobomode;
              #define TOTAL_NUM_OF_TX_FRAME  1000
              
                u16 gRobomodeAllLenTest[5][2]= {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 3   

              
                  {HPGP_ROBOMD_MINI_100, 100},   
                  {HPGP_ROBOMD_MINI_250, 250}, 
                  //{HPGP_ROBOMD_HS_800, 800}, 
                 // {HPGP_ROBOMD_HS_1000, 1000},
                  {HPGP_ROBOMD_STD_500, 500}, 
                  {HPGP_ROBOMD_HS_800, 800}, 
                  {HPGP_ROBOMD_HS_1000, 1000}, 
              
              
              };   
              #endif
 122          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
 123          
 124          u16 gAltRoboLenArr[]={101,401,801,1201};
 125          u8 gAltEksTstArr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15}; // 7 NEKs, 2 PPEKs, Unenc
 126          #endif
 127          
 128          #ifdef FREQ_DETECT
 129          u32 PLC_DC_BP_LEN     =           PLC_DC_BP_LEN_60HZ;
 130          u32 PLC_AC_BP_LEN     =           PLC_AC_BP_LEN_60HZ;//0xCB735      //these are for 60 hz AC
 131          u32 PLC_MIN_AC_BPLEN  =           0xCB300;
 132          u32 PLC_MAX_AC_BPLEN  =           0xCBA00; 
 133          #endif
 134          
 135          u32 cnt5 = 0;
 136          u32 oldRetrievedBTS;
 137          u32 oldss1;
 138          u32 OldCCOBpst;
 139          
 140          u32 gBcnPer;
 141          extern u32 gtimer2, gtimer1;
 142          u8 gsyncTimeout;
 143          u8 gBcnMissingRescanCnt;
 144          extern u8 gflag;
 145          sHpgpHalCB gHpgpHalCB;
 146          #ifdef HPGP_HAL_TEST
 147          extern sHalCB gHalCB;
 148          sHpgpHalCB *gpHhalCb;
 149          #endif  //HPGP_HAL_TEST
 150          
 151          #ifdef DEBUG_DATAPATH
              extern u8 sigDbg;
              #endif
 154          
 155          u32 gbpst1;
 156          u32 gOldBTS;
 157          #ifdef ETH_BRDG_DEBUG
              extern u32 numTxDoneInts;
              extern u8 myDebugFlag;
              extern u8 myDebugFlag1;
              #endif
 162          
 163          /*u32 TX_RXLatency_TCC[8] = {
 164                             
 165                              0x321e0417,  //TCC =1
 166                             // 0x336F0417,
 167                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
 168                              0x34ca0417,
 169                              0x361F0417,
 170                              0x37750417,
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 4   

 171                              0x38c20417,
 172                              0x3a180417,
 173                              0x3b740417,  //TCC= 8
 174          
 175          };*/
 176          
 177          //phy image gpphy_3S150_08032013- and onwards uses phy tx latency as 0x04e5 and older phy image uses phy t
             -x latency as 0x0417 
 178          #ifdef B_ASICPLC
 179          //following is for ASIC
 180          u32 TX_RXLatency_TCC[8] = {
 181                          0x30C104DD,   //TCC =1
 182                          0x319304DD,
 183                          0x325504DD,  //TCC =3   326204dd  3255
 184                          0x332604DD,
 185                          0x33F304DD,
 186                          0x34C004DD,
 187                          0x358C04DD,
 188                          0x365A04DD, //TCC= 8
 189          
 190          };
 191          #else
              u32 TX_RXLatency_TCC[8] = {
                                 
                                  0x321e04E5,  //TCC =1
                                 // 0x336F0417,   old phy tx latency 0x0417
                                  0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
                                  0x34ca04E5,
                                  0x361F04E5,
                                  0x377504E5,
                                  0x38c204E5,
                                  0x3a1804E5,
                                  0x3b7404E5,  //TCC= 8
              
              };
              #endif
 206          u8 TCC_REG_485_486_val[8][2] = {
 207                                          {0x40,0x80},
 208                                          {0x80,0x80},
 209                                          {0xc0,0x80},
 210                                          {0x0,0x81},
 211                                          {0x40,0x81},
 212                                          {0x80,0x81},
 213                                          {0xc0,0x81},
 214                                          {0x0,0x82},
 215          
 216          };
 217          u8 gDefNID[NID_LEN] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
 218          #define PLC_MaxPeran                    0x1B
 219          #define PLC_MinPeran                    0x1C
 220          u16  prevCsmaRgns[HYBRII_MAXSMAREGION_CNT] = {0};
 221          #ifdef FREQ_DETECT
 222          #ifdef UM
              extern eStatus CNSM_InitRegion(sCnsm *cnsm, sLinkLayer *linkl);
              #endif
 225          #endif
 226          
 227          #ifdef PLC_TEST
              void printmsg(u8* buff, u8 len)
              {
                 u8 i;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 5   

                 for(i = 0; i < len; i++)
                 {
                     printf("%bx\t", buff[i]);
                 }
                 printf("\n");
              }
              
              void HHT_ProcessPlcFrame(sSwFrmDesc* plcRxFrmSwDesc)
              {
                  
                  u8 HeaderOffset = sizeof(gHeaderBytes);
                  u8 TestID;
                  u8 NumOFSTAAssignTEI;
                  u8 offset;
                  volatile u8  RxDataBuff[500];
                  volatile u8 TxdataBuff[500];
                  u8 STA_TEI;
                  u8 i;
                  u16 totalDesc ;
                  u16 freeDescCnt ;
                  u32 per;
                  
                                      
                  
                  sHpgpHalCB HpgpHalCB;
                  plcHalStatus plc_halstatus_t;
                  volatile u8 xdata * cellAddr;
                  
                  //printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
                
                
              
                  //  /?! frames should not be considered in statistic so doing minus 1
                  //gHpgpHalCB.halStats.TotalRxGoodFrmCnt--;
                  //gHpgpHalCB.halStats.RxGoodDataCnt--;
                  
                   
                   //WE assume that received data will never be more then 500 bytes since rxdabuff size is 500  and txda
             -tabuff is also 500
                  
                  cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[0].cp);
                  TestID = cellAddr[HeaderOffset + 0];//because first three bytes will be /, ?, !       HeaderOffset = 3
                  strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
                  
                  
                  for(i = 0; i < plcRxFrmSwDesc->cpCount; i++ )
                  {
                       cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[i].cp);
                       
                       if(i == 0)//if first cp then we have /?! and test ID
                       {
                           offset = HeaderOffset + 1;//since we have stored 
                       }
                       else
                           offset = 0;
                       
                       
                       memcpy(&RxDataBuff[i* HYBRII_CELLBUF_SIZE] ,&cellAddr[offset], HYBRII_CELLBUF_SIZE);
                  }
                  
               
                  
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 6   

                 // if(plcRxFrmSwDesc->frmInfo.plc.stei == DEFAULT_CCO_TEI )//source is CCO so STA is Rx
                  {
                      
                      //printf("\nSTA : \n");
                      switch(TestID)
                      {
                          case  BROADCAST_CCO_TEI_TESTID:
                          
                    //send STA TEI to CCO
                  //  printf("BROADCAST_CCO_TEI_TESTID\n");
                              NumOFSTAAssignTEI = RxDataBuff[0];
                              STA_TEI = (NumOFSTAAssignTEI + 1);
                              TxdataBuff[HeaderOffset] = ASSIGN_STA_TEI_TESTID;
                              TxdataBuff[HeaderOffset + 1] = STA_TEI;
                              
                              //printf("\n Rx:\n");
                              //printmsg(&cellAddr[0],5);
                              
                              //printf("\n Tx:\n");
                              //printmsg((u8*)&TxdataBuff[0],5);
                              
                              Send_SinglePLCFrame(5, &TxdataBuff[0], STA_TEI, DEFAULT_CCO_TEI);//this frame is sent from
             - sta to cco saying that tei is assign to sta
                              break;
                          
                          case ACK_FOR_STA_TEI_TESTID://3
                              //set robo mode to mini robo
                              //send start PLC data rate test ID
                              
                           //    printf("\n ACK_FOR_STA_TEI_TESTID\n");
                               gSTA_TEI = RxDataBuff[0];
                               HHAL_SetTei(gSTA_TEI);
                               gHpgpHalCB.remoteTei = DEFAULT_CCO_TEI;
                               gHpgpHalCB.selfTei = gSTA_TEI;
                               TxdataBuff[HeaderOffset] = START_PLC_DATA_RATE_TESTID;
                               //printf("\n Tx:\n"); 
                               //printmsg(&TxdataBuff[0],4);
                               
                               CHAL_DelayTicks(400);
                               Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);   //this frmae is sent
             - from cco to sta saying start test to test hardware
                               HHAL_ResetPlcStat();
                              
                              
                          break;
               
                          case DATARATE_TEST_TESTID://5 
                           //   printf("DATARATE_TEST_TESTID\n");
                              //send pstat 
                              //after send clear the p stat
                              //printf("\nHeaderOffset = %bu\n", HeaderOffset);
                              
                              // printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
                              //printf("\n>>>nSTA received ROBO mode frame.\n");
                              TxdataBuff[HeaderOffset] = PSTAT_TESTID;
                              memcpy(&TxdataBuff[HeaderOffset + 1],(char*)&gHpgpHalCB.halStats,sizeof(gHpgpHalCB.halStat
             -s));
                              
              
                            
              
                              totalDesc      = PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 7   

                              freeDescCnt    =  (u16)(HHAL_GetPlcTxQFreeDescCnt(0) + HHAL_GetPlcTxQFreeDescCnt(1) + \
                                                   HHAL_GetPlcTxQFreeDescCnt(2) + HHAL_GetPlcTxQFreeDescCnt(3));  
              
                               
              
                              plc_halstatus_t.AddrFilterErrCnt = hal_common_reg_32_read(PLC_ADDRFILTERERRCNT_REG);
                              plc_halstatus_t.FrameCtrlErrCnt = hal_common_reg_32_read(PLC_FCCSERRCNT_REG);
                              plc_halstatus_t.ICVErrCnt = hal_common_reg_32_read(PLC_ICVERRCNT_REG);
                              plc_halstatus_t.PBCSRxErrCnt = hal_common_reg_32_read(PLC_PBCSRXERRCNT_REG);
                              plc_halstatus_t.PBCSTxErrCnt = hal_common_reg_32_read(PLC_PBCSTXERRCNT_REG);
                              plc_halstatus_t.PLCMpduDropCnt = hal_common_reg_32_read(PLC_MPDUDROPCNT_REG);
                              plc_halstatus_t.outStandingDescCnt = totalDesc - freeDescCnt;
                              plc_halstatus_t.FreeCPcount = CHAL_GetFreeCPCnt();
                              plc_halstatus_t.timerIntCnt = gHalCB.timerIntCnt;
                              plc_halstatus_t.bpIntGap = gHpgpHalCB.bpIntGap;
                              plc_halstatus_t.lastNtbB4 = gHpgpHalCB.lastNtbB4;
                              plc_halstatus_t.lastNtbAft = gHpgpHalCB.lastNtbAft;
                              plc_halstatus_t.lastBpst = gHpgpHalCB.lastBpst;
                              
                              
                              memcpy(&TxdataBuff[HeaderOffset + 1 + sizeof(gHpgpHalCB.halStats)],(char*)&plc_halstatus_t
             -,sizeof(plc_halstatus_t)); 
                              
                     
                              
                              
                              //printmsg(&TxdataBuff[0],(sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t))); 
                              //clear the stat
                              HHAL_ResetPlcStat();
                             // printf("\nsize = %x\n", (sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)));
                              
                              //printf("\n >>>STA transmitting its Statistic to CCO...\n");
                              Send_SinglePLCFrame((sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)), &TxdataBu
             -ff[0], gSTA_TEI, DEFAULT_CCO_TEI);
                              
                              
                          break;
                          
                          /*case SEND_SYNC_DATA:
                              //compare and display
                              //send pxmittest dataID DATA_DURING_BCNS_TESTID
                              printf("\nRxGoodBcnCnt = %lu", gHpgpHalCB.halStats.RxGoodBcnCnt);
                              if(gHpgpHalCB.halStats.RxGoodBcnCnt >= NUM_OF_BCNS_FOR_CCO_TEST)
                              {
                                  eth_plc_bridge = 1;
                                  printf("\n\t\t\t\t\t BEACONS RECEIVED SUCCESSFULLY\n");
                                  printf("\n>>>STA Transmitting MINI_ROBO frames to CCO...\n\n");
                                  sendRobomodeFrames(100,1000);
                                  
                                   
                                  TxdataBuff[3] = SEND_SYNC_DATA;
                                  printmsg(&TxdataBuff[0],4);
                                  Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);//broadcast CCO TEI
              
                              }
                              
                          break;
                          
                          case ENABLE_BRIDGE:
                              break;
                          
                        */
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 8   

              
                              
                              
                      }
                  } 
                //  else//CCO is Rx
                  {
                      //printf("\nCCo : \n");
                      switch(TestID)
                      {
                          case ASSIGN_STA_TEI_TESTID://2
                              
                              //send Ack for STA TEI to STA
                            //  printf("ASSIGN_STA_TEI_TESTID\n");
                              HHAL_SetTei(DEFAULT_CCO_TEI);
                              gHpgpHalCB.selfTei = DEFAULT_CCO_TEI;
                              gSTA_TEI = RxDataBuff[0];
                              gRoboMode = HPGP_ROBOMD_MINI;
                              gHpgpHalCB.remoteTei = gSTA_TEI;
                              TxdataBuff[HeaderOffset] =  ACK_FOR_STA_TEI_TESTID;
                              TxdataBuff[HeaderOffset + 1]  = gSTA_TEI;
                              Send_SinglePLCFrame(5, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
                              
                              
                          break;
                          case START_PLC_DATA_RATE_TESTID://4  tx pxmitttest data    //this is rec from sta that cco has
             - to start test by sending 1000 minirobo frames followed by std robo and hs mode
                            //  printf("START_PLC_DATA_RATE_TESTID\n");
                            label1:  
                            HHAL_ResetPlcStat();
                            gRoboMode = gRobomodeAllLenTest[gCount][0];
                            sendRobomodeFrames(gRobomodeAllLenTest[gCount][1],TOTAL_NUM_OF_TX_FRAME);
                            
                            switch(gRoboMode)
                            {
                              case HPGP_ROBOMD_MINI_100:
                                   // printf("\n>>>CCO Transmitting MINI_ROBO frames to STA...\n");
                                    gCurrRobomode = HPGP_ROBOMD_MINI_100;
                              break;
                              case  HPGP_ROBOMD_MINI_250:
                                   // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");
                                    gCurrRobomode = HPGP_ROBOMD_MINI_250;
                              break;
                              case HPGP_ROBOMD_STD_500:
                                  // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");  
                                   gCurrRobomode = HPGP_ROBOMD_STD_500;
                              break;
                             
                              case  HPGP_ROBOMD_HS_800:
                                   //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
                                   gCurrRobomode = HPGP_ROBOMD_HS_800;
                              break;
                              case HPGP_ROBOMD_HS_1000:
                                   //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
                                   gCurrRobomode = HPGP_ROBOMD_HS_1000;
                                   //gCount = 0;
                              break;
                               
                            
                          }
                          strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
                          HeaderOffset = 3; 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 9   

                          TxdataBuff[HeaderOffset] =  DATARATE_TEST_TESTID;
                          //printmsg(&TxdataBuff[0], 4);
                          Send_SinglePLCFrame(4, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
                        
                              
                              
                              
                          break;
                          case PSTAT_TESTID://6 compare and display it rec all robo mode pstat
                              
                              //compare and display 
                              
                            //  printmsg(&RxDataBuff[0], 20); 
                              //printf("\n>>>CCO Received Statistcs from STA");
                              memcpy((char*)&HpgpHalCB.halStats, &RxDataBuff[0], sizeof(HpgpHalCB.halStats));
                              memcpy((char*)&plc_halstatus_t, &RxDataBuff[(sizeof(gHpgpHalCB.halStats) + 4)], sizeof(plc
             -_halstatus_t)); 
                             // printf("\nSTA Statistic\n\n\n");
                              //HHAL_DisplayPlcStatFromRAM(&HpgpHalCB.halStats, &plc_halstatus_t);
                           
                              
                             // if(HpgpHalCB.halStats.RxGoodDataCnt ==  gHpgpHalCB.halStats.TxDataCnt)
                              //{
                                 
                                  printf("\n\t\t\t\t\t RxGoodDataCnt = %lu\n", HpgpHalCB.halStats.RxGoodDataCnt);
                                   per = TOTAL_NUM_OF_TX_FRAME - HpgpHalCB.halStats.RxGoodDataCnt;
                                  
                                   per = ((per * 100)/TOTAL_NUM_OF_TX_FRAME);
                                 
                                   /*if(per <= 1)
                                      printf("\n\t\t\t\t\tPER is Less athen 1%");
                                   else
                                      printf("\nPER :  %u",per);
                                                                  */
                                  
                                  if(gCurrRobomode == HPGP_ROBOMD_MINI_100 )
                                  {
                                      printf("\n\t\t\t\t\t MINI ROBO MODE PER = %lu",per);
                                  }
                                 
                                  else  if((gCurrRobomode == HPGP_ROBOMD_MINI_250) || (gCurrRobomode == HPGP_ROBOMD_STD_
             -500) )
                                  {
                                      printf("\n\t\t\t\t\t STD ROBO MODE PER = %lu",per);
                                  }
                                  else if((gCurrRobomode == HPGP_ROBOMD_HS_800) || (gCurrRobomode == HPGP_ROBOMD_HS_1000
             -) )
                                  {
                                      printf("\n\t\t\t\t\t HS PB ROBO MODE PER = %lu",per);
                                     
                                  }
                                   
                                   printf("%c\n\n",'%');
                                   printf("-----------------------------------------------------------------\n\n");
                                  // printf("\nFrmLen = %d\n\n ", gRobomodeAllLenTest[gCount++][1]);
                                  
                                   HHAL_ResetPlcStat();
                                   
                            //  }
              
                              gCount++;
                              if(gCount == 5)   //since this is last frame test
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 10  

                              {
                                  gCount = 0;
                                  //oldssn = 0;
                                  printf("\n\t\t\t\t TEST FINISHED, PRESS ENTER");
                                  break;
                                  
                                  
                               }
                             goto label1; 
                              break;
                            
                      }       //end of switch
                  }//end of else
                  
                 
                  for( i=0 ; i< plcRxFrmSwDesc->cpCount ; i++ )
                  {
                          CHAL_DecrementReleaseCPCnt(plcRxFrmSwDesc->cpArr[i].cp);
                  }
                  
              }  
              #endif
 553          
 554          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
 555          
 556          void HHT_GetMinMaxLen ( sPlcSimTxTestParams* pTestParams, u8* stdModeSel, u8* minFrmLen, u8* maxFrmLen )
 557          {
 558   1          if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
 559   1          {
 560   2              if(pTestParams->roboTestMode == MINI_ROBO_TEST)
 561   2              {
 562   3                  *minFrmLen =  1 ;
 563   3                  *maxFrmLen = pTestParams->frmType?HYBRII_MINIROBO_DATALEN_MAX:HYBRII_MINIROBO_MGMTLEN_MAX;
 564   3              } 
 565   2              else if(pTestParams->roboTestMode == STD_ROBO_TEST) 
 566   2              {
 567   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 568   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
 569   3                  *stdModeSel = 1;
 570   3              } 
 571   2              else if(pTestParams->roboTestMode == HS1PB_ROBO_TEST)
 572   2              {
 573   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 574   3                  *maxFrmLen = pTestParams->frmType ?( HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
 575   3                  *stdModeSel = 0;
 576   3              }
 577   2              else if(pTestParams->roboTestMode == HS2PB_ROBO_TEST)
 578   2              {
 579   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX+1):(HYBRII_STD1PBHSROBO_M
             -GMTLEN_MAX+1);
 580   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX):(HYBRII_2PBHSROBO_MGMTLEN_M
             -AX);
 581   3              }
 582   2              else if(pTestParams->roboTestMode == HS3PB_ROBO_TEST)
 583   2              {
 584   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX+1):(HYBRII_2PBHSROBO_MGMTLEN
             -_MAX+1);
 585   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 11  

             -AX);
 586   3              }
 587   2              else if(pTestParams->roboTestMode == HSALLPB_ROBO_TEST)
 588   2              {
 589   3                  *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
 590   3                  *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
             -AX);
 591   3              }
 592   2          }
 593   1          else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
 594   1          {
 595   2              *stdModeSel = 1;
 596   2              *minFrmLen  = 1;
 597   2              *maxFrmLen  =  pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_MAX
             -);
 598   2          }
 599   1          else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
 600   1          {
 601   2              *stdModeSel = 1;
 602   2              *minFrmLen  = gAltRoboLenArr[0];
 603   2          }
 604   1      }
 605          
 606          void HHT_SimulateTx(sPlcSimTxTestParams* pTestParams)
 607          {
 608   1      //  sPlcTxFrmSwDesc plcTxFrmSwDesc;
 609   1      //#ifdef Packet_grouping
 610   1          u32             Sw_command_queue[8];
 611   1          u8              cmd_num;
 612   1      //#endif  
 613   1      //    uPlcTxPktQCAP_Write   cap_write;
 614   1      //    uTxCMDQueueWrite      txCmdQueueWrtie;
 615   1          sTxFrmSwDesc    plcTxFrmSwDesc;
 616   1          u8              stdModeSel;
 617   1          u16             stdRoboFrmLenMax;
 618   1          u8              minFrmLen;
 619   1          u8              maxFrmLen;
 620   1          u16             curFrmLen;     
 621   1          eFrmMcstMode    mcstMode;
 622   1          eHpgpHwFrmType  frmType;
 623   1          // mixed mode variables
 624   1          u16             tmpFrmLen;
 625   1          u8              curOffsetDW;
 626   1          u8              curDescLen;
 627   1          u8              eksArrIdx;
 628   1          uAltPlid        altPlid;
 629   1          uAltRoboLenIdx  altRoboLenIdx;        
 630   1          eStatus         status;
 631   1          u8              i, c;
 632   1          u16              j;
 633   1          u8              quit; 
 634   1          u16             tmpPayloadLen;
 635   1        u8        cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
 636   1          u8              dbc_pktchange;
 637   1      #ifndef HPGP_HAL_TEST
                  sHaLayer        *hal = HOMEPLUG_GetHal();
              #endif
 640   1      
 641   1        dbc_pktchange     = 0;
 642   1          quit              = 0;
 643   1          altPlid.val       = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 12  

 644   1          altRoboLenIdx.val = 0;
 645   1          eksArrIdx         = 0;
 646   1      //#ifdef Packet_grouping0 
 647   1        cmd_num           = 0;     
 648   1      //#endif
 649   1      
 650   1          memset((u8*)&plcTxFrmSwDesc, 0x00, sizeof(plcTxFrmSwDesc));
 651   1      
 652   1      
 653   1        FM_HexDump(FM_USER, "par", (u8*)pTestParams, sizeof(sPlcSimTxTestParams));
 654   1        
 655   1          plcTxFrmSwDesc.frmInfo.plc.eks            = pTestParams->eks;       
 656   1          plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
 657   1          plcTxFrmSwDesc.frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_RSV;//HPGP_CONVLYRSAPTYPE_ETH; 
 658   1          plcTxFrmSwDesc.frmInfo.plc.snid = HYBRII_DEFAULT_SNID;
 659   1      
 660   1          if(pTestParams->frmType == 0)     
 661   1          {
 662   2                  plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_MGMT;
 663   2                  frmType                = HPGP_HW_FRMTYPE_MGMT;
 664   2          }
 665   1          else if(pTestParams->frmType == 1)
 666   1          {
 667   2              plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;
 668   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;
 669   2          }
 670   1          else if (pTestParams->frmType == 2) // frmType = 2
 671   1          {
 672   2              plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_SOUND;
 673   2              frmType                = HPGP_HW_FRMTYPE_SOUND;
 674   2              plcTxFrmSwDesc.frmInfo.plc.src     = pTestParams->src;
 675   2              plcTxFrmSwDesc.frmInfo.plc.saf     = pTestParams->saf;
 676   2              plcTxFrmSwDesc.frmInfo.plc.scf     = pTestParams->scf;
 677   2          }
 678   1        else if (pTestParams->frmType == HPGP_HW_FRMTYPE_RTS)
 679   1        {
 680   2            plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
 681   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
 682   2              plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
 683   2        }
 684   1        else if  (pTestParams->frmType == HPGP_HW_FRMTYPE_CTS)
 685   1          {
 686   2            plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
 687   2              frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
 688   2              plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
 689   2        }
 690   1          
 691   1          mcstMode           = pTestParams->mcstMode;
 692   1          if(pTestParams->mcstMode == 0)   
 693   1          {
 694   2              plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;       
 695   2          }
 696   1          else
 697   1          {
 698   2              plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;
 699   2          }
 700   1      
 701   1          if(pTestParams->altPlidTest)
 702   1          {
 703   2              plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->plid; //0;
 704   2          }
 705   1          else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 13  

 706   1          {
 707   2              plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;   
 708   2          }                                
 709   1        //printf("plid = %d\n",plcTxFrmSwDesc.frmInfo.plc.plid);  //[YM] debug Hybrii_B data pkt Tx
 710   1        
 711   1          plcTxFrmSwDesc.frmInfo.plc.stei           = gHpgpHalCB.selfTei;//HYBRII_DEFAULT_TEISTA;
 712   1      
 713   1      
 714   1          stdModeSel                    = pTestParams->stdModeSel;
 715   1      
 716   1          // Incremental/alternating length modes
 717   1          if(pTestParams->frmLen == 0)   //Continuous Tx mode
 718   1          {
 719   2              HHT_GetMinMaxLen(pTestParams, &stdModeSel, &minFrmLen, &maxFrmLen);
 720   2              
 721   2              stdRoboFrmLenMax = plcTxFrmSwDesc.frmType==HPGP_HW_FRMTYPE_MSDU?(HYBRII_STD1PBHSROBO_DATALEN_MAX):
             -(HYBRII_STD1PBHSROBO_MGMTLEN_MAX);               
 722   2              curFrmLen = minFrmLen;
 723   2              FM_Printf(FM_LINFO,"\nStarting from len = %u\n",curFrmLen);
 724   2          }
 725   1          else
 726   1          {
 727   2              // fixed length test
 728   2              curFrmLen = pTestParams->frmLen;
 729   2          }
 730   1          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = stdModeSel;
 731   1          curOffsetDW  = pTestParams->offsetDW;
 732   1          curDescLen   = pTestParams->descLen; 
 733   1          gHpgpHalCB.halStats.CurTxTestFrmCnt = 0;
 734   1        
 735   1          //for each frame
 736   1          while(1)
 737   1          {
 738   2              u8  frmData = 0;
 739   2              tmpFrmLen   = 0;
 740   2              tmpPayloadLen = 0;
 741   2      
 742   2              if (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
 743   2              {
 744   3                  if(pTestParams->frmLen <= 136)
 745   3                      plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //136;
 746   3                  else
 747   3                      plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //520;
 748   3              }
 749   2              else
 750   2              {
 751   3                  // check for mgmt frm max len, in case this is inclen & altfrmtype test
 752   3                  plcTxFrmSwDesc.frmLen         =  (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT && curFrmLen 
             -> HYBRII_3PBHSROBO_MGMTLEN_MAX) ? \
 753   3                                                    HYBRII_3PBHSROBO_MGMTLEN_MAX : curFrmLen ;  
 754   3              }   
 755   2          
 756   2              //[YM] Add DBC Code
 757   2            if (pTestParams->dbc)
 758   2            {
 759   3                if (pTestParams->pattern == 1)  // One RoBo + One Mini RoBo
 760   3                {
 761   4                      if (dbc_pktchange > 1)
 762   4                dbc_pktchange = 0;
 763   4              if (dbc_pktchange == 0)
 764   4                    {
 765   5                        plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 14  

 766   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  //Std RoBo
 767   5                    }
 768   4              else if (dbc_pktchange == 1)
 769   4              {
 770   5                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 771   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 772   5              }
 773   4                }
 774   3            else if (pTestParams->pattern == 2)  // Three Mini RoBo
 775   3            {
 776   4                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 777   4                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 778   4            }
 779   3            else if (pTestParams->pattern == 3)  //Two MiniRoBo + One HS RoBo 1 PB
 780   3            {
 781   4              if ((dbc_pktchange == 0)|(dbc_pktchange == 1))
 782   4                    {
 783   5                        plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 784   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 785   5                    }
 786   4              else
 787   4              {
 788   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 789   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 790   5              }
 791   4            }
 792   3            else if (pTestParams->pattern == 4)  //One MiniRoBo + One HS RoBo 2PB
 793   3            {
 794   4              if (dbc_pktchange == 0)
 795   4                    {
 796   5                        plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 797   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 798   5                    }
 799   4              else
 800   4              {
 801   5                  plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
 802   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 803   5              }
 804   4            }
 805   3            else if (pTestParams->pattern == 5)  //Two HS RoBo with 1 PB
 806   3            {
 807   4                    plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 808   4                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 809   4            }
 810   3            else if (pTestParams->pattern == 6)  //One Mini RoBo + One HS RoBo with 3 PB
 811   3            {
 812   4      
 813   4              if (dbc_pktchange == 0)
 814   4              {
 815   5                  plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
 816   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 817   5              }
 818   4              else
 819   4              {
 820   5                plcTxFrmSwDesc.frmLen =  HYBRII_3PBHSROBO_DATALEN_MAX;
 821   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 822   5              } 
 823   4            }
 824   3            else if (pTestParams->pattern == 7)  //One RoBo + One HS RoBo with 1 PB
 825   3            {
 826   4              if (dbc_pktchange == 0)
 827   4              {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 15  

 828   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 829   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  
 830   5              }
 831   4              else
 832   4              {
 833   5                plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 834   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 835   5              } 
 836   4            }
 837   3            else if (pTestParams->pattern == 8)  //One HSRoBo with 1 PB + One HSRoBo with 2 PB
 838   3            {
 839   4              if (dbc_pktchange == 0)
 840   4              {
 841   5                  plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
 842   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
 843   5              }
 844   4              else
 845   4              {
 846   5                plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
 847   5                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
 848   5              }
 849   4            }
 850   3              }
 851   2      
 852   2                  plcTxFrmSwDesc.cpCount        = 0; 
 853   2            plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = pTestParams->plid>0 ? HPGP_PPB_CAP123 : HPGP_PPB_CAP0;
 854   2                  plcTxFrmSwDesc.frmInfo.plc.mcstMode       = mcstMode;       
 855   2          
 856   2              if (mcstMode > 0)
 857   2                  plcTxFrmSwDesc.frmInfo.plc.phyPendBlks = HPGP_PPB_MCFRPT;
 858   2                else
 859   2                    plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = (pTestParams->plid > 0) ? HPGP_PPB_CAP123 : HPGP_
             -PPB_CAP0;             
 860   2      
 861   2          
 862   2              if(pTestParams->altPlidTest)
 863   2              {
 864   3                  pTestParams->plid = (gHpgpHalCB.halStats.CurTxTestFrmCnt & 0x3) ; //plid value will be changed
             - in sequence;
 865   3                  plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;    
 866   3              }
 867   2          else
 868   2            plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;
 869   2                          
 870   2              // create cp descriptors
 871   2              while(tmpFrmLen < plcTxFrmSwDesc.frmLen)
 872   2              {       
 873   3                  u8        cp;
 874   3                  u8        tmpOffsetDW;
 875   3                  u8        tmpOffsetByte;
 876   3                  u8        tmpDescLen;
 877   3                  u8        remDescLen;
 878   3                  u8        actualDescLen;
 879   3                  volatile u8 xdata *       cellAddr;
 880   3      
 881   3                  tmpOffsetDW =      curOffsetDW;
 882   3                  tmpDescLen  =      curDescLen; 
 883   3                  // Fetch CP
 884   3            //printf("(C)\n");
 885   3                  do
 886   3                  {
 887   4                      status = CHAL_RequestCP(&cp);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 16  

 888   4              //printf("\n");
 889   4      #ifdef _FIXME_
              #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')
                              {
                                  // Realease CPs fetched so far for current frame -- tbd
                                  quit = 1;
                                  break;
                              }
              
              #endif
 903   4                  }while (status != STATUS_SUCCESS);
 904   3                  // check for user initiated exit task
 905   3                  if(quit)
 906   3                  {
 907   4                      break;
 908   4                  }
 909   3            
 910   3                  i = plcTxFrmSwDesc.cpCount;
 911   3                  // test offset and desc len - only for first CPs
 912   3                  if((i==0 || i==1) && (pTestParams->frmType != 2))
 913   3                  //if(i==0 || i==1)
 914   3                  { 
 915   4                      if(pTestParams->altOffsetDescLenTest)
 916   4                      {
 917   5                          curOffsetDW--;
 918   5                          curDescLen+=4;    
 919   5                          tmpOffsetDW =      curOffsetDW;  
 920   5                          tmpDescLen  =      curDescLen;  
 921   5                          if( curOffsetDW==0 )
 922   5                          {
 923   6                              curOffsetDW  = pTestParams->offsetDW; // 0
 924   6                              curDescLen   = pTestParams->descLen;  //HYBRII_DEFAULT_SNID;
 925   6                              //FM_Printf(FM_LINFO,"OffsetDW & DescLen resetting to %bu & %bu respectively\n", c
             -urOffsetDW, curDescLen);
 926   6                          }
 927   5                      }// printf("curOffsetDW = %bu, tempDescLen=%bu\n", tmpOffsetDW, tmpDescLen);              
             -              
 928   4                  }
 929   3                  else if(pTestParams->frmType == 2)
 930   3                  {
 931   4                        tmpOffsetDW =      0;  
 932   4                        tmpDescLen  =      curDescLen;  
 933   4                  }
 934   3                  else
 935   3                  {
 936   4                      tmpOffsetDW = 0;
 937   4                      tmpDescLen  = HYBRII_CELLBUF_SIZE;
 938   4                  }
 939   3      
 940   3                  tmpOffsetByte = tmpOffsetDW << 2;
 941   3                  actualDescLen =  (plcTxFrmSwDesc.frmLen-tmpFrmLen)>tmpDescLen ? tmpDescLen : (plcTxFrmSwDesc.f
             -rmLen-tmpFrmLen);
 942   3                  remDescLen    =  actualDescLen;
 943   3      
 944   3                  if(( i==0 || i==1 ) && tmpOffsetDW != 0)
 945   3                  {
 946   4                      FM_Printf(FM_LINFO,"curFrmLen = %u, curOffsetDW = %bu, curDescLen=%bu, free CPCnt = %bu\n"
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 17  

             -, 
 947   4                                                   plcTxFrmSwDesc.frmLen, tmpOffsetDW, actualDescLen, CHAL_GetFr
             -eeCPCnt());
 948   4                  }
 949   3                  //FM_Printf(FM_LINFO,"curOffsetByte = %bu, curDescLen=%bu\n", tmpOffsetByte, actualDescLen);
 950   3                  
 951   3                  // Fill Buffer with pattern
 952   3      #ifdef MEM_PROTECTION
                    // Get local CP buffer
                    cellAddr = &cp_localBuf[0];
              #else
 956   3                  cellAddr = CHAL_GetAccessToCP(cp);
 957   3      #endif
 958   3            memset(&cp_localBuf[0], 0, HYBRII_CELLBUF_SIZE);  // clear read buf for every new test
 959   3                  //FM_Printf(FM_LINFO,"cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.hal
             -Stats.TxSeqNum);
 960   3                  //printf("cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.halStats.TxSeqN
             -um);
 961   3                  // Add Seq Num as first byte of first CP
 962   3                  if ( i==0 )
 963   3                  {
 964   4                      if (pTestParams->frmType != 2)
 965   4                      {
 966   5      #if  PLC_BCNDATA_FIXED_PATTERN
                              cellAddr[tmpOffsetByte] = 0xBB;
                              // Start frame data from seq num.
                              frmData   = (u8)(gHpgpHalCB.halStats.TxSeqNum+1);   
              
              #elif PLC_DATA_FIXED_PATTERN
 972   5                      cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
 973   5                      // Alternatig frame bytes
 974   5                      frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0xAA : 0x55 ;
 975   5      #endif        
 976   5      
 977   5                      tmpOffsetByte +=1;
 978   5                      remDescLen    -=1; 
 979   5                      }
 980   4                      else 
 981   4                      {                     
 982   5                          //cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
 983   5                          // Alternatig frame bytes
 984   5                          frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0x00 : 0x00 ;
 985   5       
 986   5                          //tmpOffsetByte +=1;
 987   5                          //remDescLen    -=1; 
 988   5                      }
 989   4                  }
 990   3      
 991   3                  if (pTestParams->frmType == 2) // Sound packet 
 992   3                  {
 993   4                      for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
 994   4                      {    
 995   5                          cellAddr[j] = 0x0;
 996   5                      }
 997   4                  }
 998   3                  else
 999   3                  {
1000   4            //printf(" tmpOffsetByte = %bu \n", tmpOffsetByte); 
1001   4            //printf(" remDescLen = %bu \n", remDescLen); 
1002   4            
1003   4                      for( j=tmpOffsetByte ; j<(tmpOffsetByte + remDescLen) ; j++)
1004   4                      {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 18  

1005   5          #if  PLC_BCNDATA_FIXED_PATTERN
              
                                  cellAddr[j] = 0xBB;
                  #elif PLC_DATA_FIXED_PATTERN
1009   5      
1010   5                          cellAddr[j] = frmData;
1011   5                          frmData     = _cror_(frmData, 1);
1012   5          #else
                                  cellAddr[j] = frmData++;
              
                  #endif
1016   5                      }
1017   4                  }
1018   3      #if 0
                          // [YM] debug message
                    printf("CP len: %bu, offset=%bu\n", remDescLen, tmpOffsetByte);                         
                    
                          for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
                          {
                              printf("0X%bx ", cellAddr[j]);
                      if ((j>0) && ((j % 20) == 0))
                        printf("\n");
                          } 
              #endif                              
1029   3                  plcTxFrmSwDesc.cpArr[i].offsetU32 = tmpOffsetDW;
1030   3                  plcTxFrmSwDesc.cpArr[i].len       = actualDescLen; 
1031   3                  tmpFrmLen                        += plcTxFrmSwDesc.cpArr[i].len; 
1032   3                  plcTxFrmSwDesc.cpArr[i].cp        = cp;
1033   3                  plcTxFrmSwDesc.cpCount++;
1034   3                  tmpPayloadLen += (plcTxFrmSwDesc.cpArr[i].len - tmpOffsetByte);
1035   3      
1036   3                  // Alternate Encryption Test Mode
1037   3                  if(pTestParams->secTestMode == ALT_UNENC_NEK)
1038   3                  {
1039   4                      plcTxFrmSwDesc.frmInfo.plc.eks = (plcTxFrmSwDesc.frmInfo.plc.eks  >= HPGP_MAX_NEKS) ? 0  :
             - (plcTxFrmSwDesc.frmInfo.plc.eks + 1);
1040   4                  }
1041   3                  else if(pTestParams->secTestMode == ALT_UNENC_NEK_PPEK)
1042   3                  {
1043   4                      plcTxFrmSwDesc.frmInfo.plc.eks  = gAltEksTstArr[eksArrIdx++];
1044   4                      plcTxFrmSwDesc.frmInfo.plc.dtei = gHpgpHalCB.remoteTei;
1045   4                  }
1046   3      
1047   3      #ifdef MEM_PROTECTION
                    // now copy the CP local buf to the actual CP memory
                    if (HHAL_CP_Put_Copy(cp, cellAddr, HYBRII_CELLBUF_SIZE) == STATUS_FAILURE)
                    {
                      printf("HHT_SimulateTx: Failed to put a copy of CP %bu. Continue with nex CP\n", cp);
                      continue;
                    }
              #endif
1055   3              } 
1056   2            
1057   2          
1058   2      #ifdef Packet_grouping0
                      //[YM] Check multiple packet queueing is requested or not
                      if (gHpgpHalCB.plcMultiPktTest > 1 )
                      {
                              cmd_num++;
              
                      printf("1-0. cmd_num = %bu \n", cmd_num);
                              /*  Write PLC Command Queue Write Register to trigger HW Tx */
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 19  

                              txCmdQueueWrtie.reg = 0;
                              txCmdQueueWrtie.s.txQ = pTestParams->plid;
                            txCmdQueueWrtie.s.txCap = pTestParams->plid;
                            txCmdQueueWrtie.s.txRobo = pTestParams->stdModeSel;
              #ifdef ETH_BRDG_DEBUG
                      if (myDebugFlag)
                      {
                        //printf("txCmdQueueWrtie.reg = %lx\n",txCmdQueueWrtie.reg);
                      //printf("txCmdQueueWrtie.s.txQ = %bu\n", txCmdQueueWrtie.s.txQ);
                      printf("txCmdQueueWrtie.s.txCap = %bu\n", txCmdQueueWrtie.s.txCap);
                      //printf("txCmdQueueWrtie.s.txRobo = %bu\n", txCmdQueueWrtie.s.txRobo);
                      }
              #endif  //ETH_BRDG_DEBUG
                      //WriteU32Reg(PLC_CMDQ_REG, txCmdQueueWrtie.reg);
                      //[YM] store command queue setting value to a software queue, will write all stored command queue sett
             -ing value to 
                      //command queue later
                      Sw_command_queue[cmd_num - 1] = txCmdQueueWrtie.reg;
                      if (cmd_num > (gHpgpHalCB.plcMultiPktTest - 1))
                        {
                                     u8 p;
                           
                           // Write all the store command settings in sw command queue [64] to HW command queue register
                           for (p = 0; p < gHpgpHalCB.plcMultiPktTest; p++)
                            {
                               WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
              #ifndef MPER               
                             printf("Write PLC_CMDQ_REQ = %u\n", Sw_command_queue[p]);
              #endif  //MPER
                            }
                           if (cmd_num > 0)
              #ifndef MPER              
                               printf("1. Write PLC_CMDQ_REG %bu times\n", cmd_num);
              #endif  //MPER
                           cmd_num = 0;
                           gHpgpHalCB.plcMultiPktTest = 0;
                        }
                      }
              #endif  //Packet_grouping0  
1104   2              // check for user initiated exit task
1105   2              if(status == STATUS_SUCCESS)
1106   2              {
1107   3                         u16 pkt_retry = 0;
1108   3                  do
1109   3                  {
1110   4                      // Transmit the frame;
1111   4                      //printf("(D)\n");
1112   4      #ifdef HPGP_HAL_TEST
1113   4                      status = HHAL_PlcTxQWrite(&plcTxFrmSwDesc);
1114   4      #else
                              status = HHAL_PlcTxQWrite(hal, &plcTxFrmSwDesc);
              #endif
1117   4              if (status == STATUS_FAILURE)
1118   4              {
1119   5                pkt_retry++;
1120   5                //printf("Write PLC Tx Q failed, %bu times, cp = %bu\n", pkt_retry, plcTxFrmSwDesc.cpCount);
1121   5                // [YM] - retry the packet transmission until it failed too many times
1122   5      
1123   5                          CHAL_DelayTicks(64);
1124   5                if (pkt_retry > 2000)   //[YM] extended delay loop, high PER condition will make Tx stop too quick
1125   5                {
1126   6      #ifndef MPER          
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 20  

1127   6                              printf("\nWrite PLC Tx Q failed, cp = %bu, Quit!!\n", plcTxFrmSwDesc.cpCount);
1128   6      #endif
1129   6                    quit = 1;
1130   6                    break;
1131   6                }
1132   5              }
1133   4                      // check for user initiated exit task from infinite loop
1134   4      #ifdef HPGP_HAL_TEST
1135   4                      c = CHT_Poll();
1136   4      #else
                              c = poll_key();
              #endif
1139   4                      if( c == 'q')              
1140   4                      {
1141   5                          // if TxQWrite failed, release CPs for current frame -- tbd
1142   5                          quit = 1;
1143   5                          break;
1144   5                      }
1145   4                  } while(status == STATUS_FAILURE);
1146   3                    pkt_retry = 0;
1147   3              }
1148   2      
1149   2           
1150   2              if(status == STATUS_SUCCESS)
1151   2              {
1152   3                  gHpgpHalCB.halStats.CurTxTestFrmCnt++;
1153   3                  gHpgpHalCB.halStats.TxSeqNum++;
1154   3      
1155   3                  // check for alternating plid
1156   3                  plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->altPlidTest ? altPlid.s.plid++ : pTestParams->p
             -lid;
1157   3      
1158   3                  // check for alternating frametype
1159   3                  if(pTestParams->altFrmTypeTest)
1160   3                  {
1161   4                      plcTxFrmSwDesc.frmType = (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MSDU) ? HPGP_HW_FRMTYP
             -E_MGMT : HPGP_HW_FRMTYPE_MSDU;
1162   4                  }
1163   3                  else
1164   3                  {
1165   4                      plcTxFrmSwDesc.frmType = frmType;
1166   4                  }
1167   3      
1168   3                  // check for alternating mcstMode
1169   3                  if(pTestParams->altMcstTest)
1170   3                  {
1171   4                      if(mcstMode == 2)
1172   4                      {
1173   5                          mcstMode = 0;
1174   5                          plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;         
1175   5                      }
1176   4                      else
1177   4                      {
1178   5                          mcstMode++;
1179   5                          plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;       
1180   5                      }
1181   4                  }
1182   3      
1183   3            if (!pTestParams->dbc)
1184   3            {
1185   4                  // check for incremental length single robo
1186   4                  if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 21  

1187   4                  {
1188   5                      curFrmLen++;
1189   5                      if(curFrmLen > maxFrmLen)
1190   5                      {
1191   6                          FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
1192   6                          curFrmLen = minFrmLen;
1193   6                      }
1194   5                  }             
1195   4                  // check for incremental length all robo
1196   4                  else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
1197   4                  {
1198   5                      curFrmLen++;            
1199   5                      if(curFrmLen > stdRoboFrmLenMax && plcTxFrmSwDesc.frmInfo.plc.stdModeSel)
1200   5                      {
1201   6                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
1202   6                          curFrmLen                 = HYBRII_MINIROBO_DATALEN_MAX+1;
1203   6                          FM_Printf(FM_LINFO,"Switching to HS Mode; len = %u\n",curFrmLen);
1204   6                          
1205   6                      }
1206   5                      // restart inc len test
1207   5                      if(curFrmLen > maxFrmLen)
1208   5                      {
1209   6                          FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
1210   6                          curFrmLen                 = minFrmLen;
1211   6                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;                  
1212   6                      }
1213   5                  } 
1214   4                  // check for fixed length alternating robo
1215   4                  else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
1216   4                  {
1217   5                      curFrmLen  = gAltRoboLenArr[altRoboLenIdx.s.idx++];
1218   5                  }
1219   4            }
1220   3            else  //DBC Test
1221   3            {
1222   4                if (dbc_pktchange == 0)
1223   4                dbc_pktchange = 1;
1224   4              else if (dbc_pktchange == 1)
1225   4                dbc_pktchange = 2;
1226   4              else
1227   4                dbc_pktchange = 0;
1228   4            }
1229   3              
1230   3              }
1231   2          
1232   2              if((gHpgpHalCB.halStats.CurTxTestFrmCnt & (u32)(0xFF)) == 0)
1233   2              {  
1234   3                  printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b
             -\b\b\b");
1235   3                  printf("Sent %ld, Received %ld HPGP frames.", gHpgpHalCB.halStats.CurTxTestFrmCnt, gHpgpHalCB.
             -halStats.TotalRxGoodFrmCnt - gHpgpHalCB.halStats.RxGoodBcnCnt);
1236   3              }
1237   2      
1238   2          
1239   2              if(!pTestParams->contMode)
1240   2              {
1241   3                  pTestParams->numFrames--;
1242   3      //      printf(" Remaining Tx packet number = %ld\n",pTestParams->numFrames);
1243   3                  if(!pTestParams->numFrames)
1244   3                  {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 22  

1245   4                      quit = 1;
1246   4                  }
1247   3              }
1248   2      
1249   2          
1250   2              if(!quit && pTestParams->delay != 0xFF)
1251   2              {
1252   3                  u32 delay64ticks = pTestParams->delay;
1253   3                  if(delay64ticks == 0)
1254   3                  {
1255   4                      printf("press c to continue\n");
1256   4                      while(1)
1257   4                      {
1258   5      #ifdef HPGP_HAL_TEST
1259   5                          u8 userInput = CHT_Poll();
1260   5      #else
                                  u8 userInput = poll_key();
              #endif
1263   5                          if( userInput == 'c' || userInput == 'C')
1264   5                          {
1265   6                              // exit delay loop and resume transmission
1266   6                              break;                      
1267   6                          }
1268   5                          else if( userInput == 'q' || userInput == 'Q')
1269   5                          {
1270   6                              // exit delay loop and quite transmission
1271   6                              quit = 1;
1272   6                              break;
1273   6                          }
1274   5                      }
1275   4                  }
1276   3                  else
1277   3                  while(delay64ticks--)
1278   3                  {
1279   4                      CHAL_DelayTicks(64);
1280   4                      // check for user initiated exit task from infinite loop
1281   4                      
1282   4      #ifdef HPGP_HAL_TEST
1283   4                      c = CHT_Poll();
1284   4      #else
                              c = poll_key();
              #endif
1287   4                      if( c == 'q')              
1288   4                      {
1289   5                          quit = 1;
1290   5                          break;
1291   5                      }
1292   4                  }  
1293   3              }
1294   2          
1295   2              if(quit )//|| CHAL_GetFreeCPCnt() < 100 || HHAL_GetPlcTxQFreeDescCnt(plcTxFrmSwDesc.plid) < 32 )
1296   2              {
1297   3      //#ifdef Packet_grouping0
1298   3              //[YM] write sw command queue setting values to HW command queue
1299   3              //printf("2. Write PLC_CMDQ_REG %bu times\n", cmd_num);
1300   3          while (cmd_num > 0)
1301   3          {
1302   4                             u8 p;
1303   4                   
1304   4                   //printf("(F)\n");
1305   4                   // Write all the store command settings in sw command queue [64] to HW command queue register
1306   4                   for (p = 0; p < cmd_num; p++)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 23  

1307   4                       WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
1308   4                   cmd_num--;
1309   4          }
1310   3      //#endif
1311   3      
1312   3      
1313   3                 // printf("Sent %ld HPGP frames.\n", gHpgpHalCB.halStats.CurTxTestFrmCnt);
1314   3                 // printf("Quit Tx: Free CP Cnt = %bu, curFrmLen = %u\n", CHAL_GetFreeCPCnt(), curFrmLen);
1315   3                  break;
1316   3              }       
1317   2          } // while(1)   
1318   1      }
1319          
1320          #endif
1321          /*u32 TX_RXLatency_TCC[8] = {
1322                             
1323                              0x321e0417,  //TCC =1
1324                             // 0x336F0417,
1325                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
1326                              0x34ca0417,
1327                              0x361F0417,
1328                              0x37750417,
1329                              0x38c20417,
1330                              0x3a180417,
1331                              0x3b740417,  //TCC= 8
1332          
1333          };*/
1334          
1335          
1336          
1337          
1338          #ifdef POWER_SAVE
              extern u16 psNoTxFrm;
              
              void HHAL_SetTxRxEn(u8 mode)
              {
                  uPlcStatusReg         plcStatus;
              
                  if (mode == TxRxEnState.state)
                  {
                      plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                    IRQ_DISABLE_INTERRUPT();  // this function can also be called from timer interrupt
                      // mode = 0: enable, 1: disable
                  if (mode == 1)
                  {
                    // disable TxRxEn
                        plcStatus.s.nTxEn  = 1;
                        plcStatus.s.nRxEn = 1;
                        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Disabled\n");
                        if (gHpgpHalCB.devMode == DEV_MODE_STA)
                    {
                            // STA: we just disabled TxRxEn, set a timer to wake
                            // up and enable them again so we can receive
                            // next beacon. Only do this for STA, CCO uses the BCN Tx
                      // interrupt and BCN Sent interrupt to wake up
                            TxRxEnState.StarttimerIntCnt = gHalCB.timerIntCnt;
                            TxRxEnState.StartRxGoodBcnCnt = gHpgpHalCB.halStats.RxGoodBcnCnt;
                        }
                  }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 24  

                  else
                  {
                    // enable TxRxEn
                      plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                        plcStatus.s.nTxEn  = 0;
                    //plcStatus.s.randomBackoff = 1;  //added by YM 
                    // below is sequence to re-enable RxEn
                      plcStatus.s.rxSoftReset = 1;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                      CHAL_DelayTicks(10);
                      plcStatus.s.rxSoftReset = 0;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Enabled\n");
                  }
                      TxRxEnState.state = !mode;    // State =  0: Disabled, 1: Enabled
                      IRQ_DISABLE_INTERRUPT();
                }
              }
              
              // HHAL_DisTxRxEn is called by the HW timer interrupt every 4 ms
              void HHAL_DisTxRxEn()
              {
                 if (!plc_powersave || TxRxEnState.state ||
                    (gHpgpHalCB.devMode == DEV_MODE_CCO))
                  // this timer ISR is only used in STA
                     return;
                  
                  if(gHalCB.timerIntCnt >= (TxRxEnState.StarttimerIntCnt + 18))
                  {
                      // STA should receive a central beacon every 33 ms 
                      // (50 Mhz) or 44 ms (60 Mhz). gHalCB.timerIntCnt is
                      // incremented every timer interrupt cycle, ie. 4ms.
                      // Enable TxRxEn so it can receive the next beacon 
                  if (ethDebugON)
                  {
                     printf("Timer INT: ON TxRxEn\n");
                     printf("Timer INT: gHalCB.timerIntCnt=%lu, TxRxEnState.StarttimerIntCnt=%lu\n", gHalCB.timerIntCnt, T
             -xRxEnState.StarttimerIntCnt);
                  } 
                      HHAL_SetTxRxEn(0);
                  }
              }
              #endif     //POWER_SAVE
1411          
1412          // this is specific to Hybrii B
1413          void set_plc_paramter(u8 sel, u32 u32Val)
1414          {
1415   1          union {
1416   1              u8  chval[4];
1417   1              u32 reg;
1418   1          }  val;
1419   1      
1420   1          val.reg = 0;
1421   1          val.chval[0] = sel;
1422   1      
1423   1          WriteU32Reg(PLC_PLCPARASEL_REG, val.reg);
1424   1          WriteU32Reg(PLC_PARA_DATAWR_REG, ctorl(u32Val));
1425   1      }
1426          
1427          
1428          /*******************************************************************
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 25  

1429          * NAME :            HHAL_mpiRxReset
1430          *
1431          * DESCRIPTION :     Reset mpi Rx MAC block
1432          *
1433          * INPUTS :
1434          *       PARAMETERS:
1435          *      
1436          *
1437          * OUTPUTS :
1438          *       None
1439          *
1440          */
1441          /*  Hybrii A only
1442          void HHAL_mpiRxReset(void)
1443          {
1444              uPlcResetReg plcReset;
1445          
1446              plcReset.reg = 0;
1447              plcReset.s.mpiRxReset = 1;
1448              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1449              CHAL_DelayTicks(2);
1450              plcReset.reg = 0;
1451              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1452          }*/
1453          
1454          
1455          /*******************************************************************
1456          * NAME :            HHAL_PhyPgmRoboMd
1457          *
1458          * DESCRIPTION :     Programs Rx to a particular Robo Md.
1459          *
1460          * INPUTS :
1461          *       PARAMETERS:
1462          *           eHpgpRpoboMod roboMd
1463          *
1464          * OUTPUTS :
1465          *       None
1466          *
1467          */
1468          void HHAL_PhyPgmRoboMd(eRegFlag enbRoboMdPgm, ePlcPhyRxRoboMod roboMd, ePlcNumPBs numPBs)
1469          {
1470   1          uPhyRxEnbRoboReg  phyRxEnbRobo;
1471   1          uPhyRxRoboMdReg   phyRxRoboMd;
1472   1          uPhyNumPBReg      phyNumPBs;
1473   1      
1474   1          // Write Rx Robo Mode override bit.
1475   1          phyRxEnbRobo.reg         = ReadU8Reg(PLC_RXROBOENB_REG);
1476   1          phyRxEnbRobo.s.enbRobo   = enbRoboMdPgm;
1477   1          WriteU8Reg(PLC_RXROBOENB_REG, phyRxEnbRobo.reg);
1478   1      
1479   1          // Write Rx Robo Mode.
1480   1          if(enbRoboMdPgm)
1481   1          {
1482   2              phyRxRoboMd.reg          = ReadU8Reg(PLC_RXROBOMD_REG);
1483   2              phyRxRoboMd.s.roboMd     = roboMd;
1484   2              WriteU8Reg(PLC_RXROBOMD_REG, phyRxRoboMd.reg);
1485   2      
1486   2              // Write Number of PBs
1487   2              if( roboMd == PLCPHY_ROBOMD_HS )
1488   2              {
1489   3                  phyNumPBs.reg          = ReadU8Reg(PLC_RXNUMPB_REG);
1490   3                  phyNumPBs.s.enbNumPBs  = 1; 
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 26  

1491   3                  phyNumPBs.s.numPBs     = numPBs;
1492   3                  WriteU8Reg(PLC_RXNUMPB_REG, phyNumPBs.reg);
1493   3              }
1494   2          }        
1495   1      }
1496          
1497          /*******************************************************************
1498          * NAME :            HHAL_SetACLine50HzFlag
1499          *
1500          * DESCRIPTION :     Sets or Clears CpuSwStatus.acLine50Hz flag.
1501          *
1502          * INPUTS :
1503          *       PARAMETERS:
1504          *           eRegFlag acLin50Hz
1505          *
1506          * OUTPUTS :
1507          *       None
1508          *
1509          */
1510          /*void HHAL_SetACLine50HzFlag(eRegFlag acLin50Hz)
1511          {
1512              uPlcLineControlReg plcLineCtrl;
1513          
1514              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1515              plcLineCtrl.s.acCycle50Hz = acLin50Hz;
1516              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
1517          } */
1518          
1519          /*******************************************************************
1520          * NAME :            HHAL_SetPlcDevMode()
1521          *
1522          * DESCRIPTION :     Sets PLC Device Mode.
1523          *
1524          * INPUTS :
1525          *       PARAMETERS:
1526          *           eRegFlag regFlag
1527          *
1528          * OUTPUTS :
1529          *       None
1530          *
1531          */
1532          void HHAL_SetPlcDevMode(ePlcDevMode plcDevMode)
1533          {
1534   1          uPlcDevCtrlReg PlcDevCtrl;
1535   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1536   1          PlcDevCtrl.s.plcDevMode = plcDevMode;
1537   1          WriteU32Reg(PLC_DEVCTRL_REG,PlcDevCtrl.reg);
1538   1      }
1539          
1540          
1541          #ifdef FREQ_DETECT
1542          void FREQDET_FreqSetting(u8 frequency)
1543          {
1544   1          
1545   1                     
1546   1          if(frequency == FREQUENCY_50HZ)
1547   1          {                
1548   2              gHpgpHalCB.lineFreq = FREQUENCY_50HZ;
1549   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1550   2              {
1551   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_50HZ;
1552   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_50HZ;                    
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 27  

1553   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1554   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
1555   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1556   3              }
1557   2              else
1558   2              {
1559   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_50HZ; 
1560   3                  //WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1561   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1562   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer)); 
1563   3                  PLC_MIN_AC_BPLEN  =           0xF3000;
1564   3                  PLC_MAX_AC_BPLEN  =           0xF6000; 
1565   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_50Hz;
1566   3              }
1567   2             // printf("\n50 HZ detected\n");
1568   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_SET);
1569   2              
1570   2              //WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1571   2          }
1572   1          else // 60 hz
1573   1          {                
1574   2              gHpgpHalCB.lineFreq = FREQUENCY_60HZ;
1575   2             // printf("\n60 HZ detected\n");
1576   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1577   2              {
1578   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_60HZ;   
1579   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_60HZ;                    
1580   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1581   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;                    
1582   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1583   3              }
1584   2              else
1585   2              {
1586   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_60HZ; 
1587   3      //            WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1588   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1589   3                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer)); 
1590   3                  PLC_MIN_AC_BPLEN  =           0xCB300;
1591   3                  PLC_MAX_AC_BPLEN  =           0xCBA00; 
1592   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_60Hz;//this is done just to avoid noise or spike while det
             -ecting zero cross
1593   3              }
1594   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_CLR);                
1595   2          }
1596   1      /*#ifndef HPGP_HAL_TEST
1597   1          CTRLL_SendFreqDetectedEvent();
1598   1      #endif*/
1599   1      }
1600          
1601          #endif
1602          /*******************************************************************
1603          * NAME :            HHAL_GetPlcDevMode
1604          *
1605          * DESCRIPTION :     Returns PLC Device Mode.
1606          *
1607          * INPUTS :
1608          *       None
1609          *
1610          * OUTPUTS :
1611          *       None
1612          *
1613          */
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 28  

1614          ePlcDevMode HHAL_GetPlcDevMode()
1615          {
1616   1          uPlcDevCtrlReg PlcDevCtrl;
1617   1      
1618   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1619   1      
1620   1          return((ePlcDevMode)PlcDevCtrl.s.plcDevMode);
1621   1      }
1622          
1623          
1624          /*******************************************************************
1625          * NAME :            HHAL_SetSWStatReqScanFlag
1626          *
1627          * DESCRIPTION :     Sets or clears PLC Scan Mode.
1628          *
1629          * INPUTS :
1630          *       PARAMETERS:
1631          *           eRegFlag scanEnb
1632          *
1633          * OUTPUTS :
1634          *       None
1635          *
1636          */
1637          void HHAL_SetSWStatReqScanFlag(eRegFlag scanEnb)
1638          {
1639   1          uPlcLineControlReg plcLineCtrl;
1640   1          uPlcDevCtrlReg  plcDevCtrl;
1641   1      
1642   1          plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1643   1          plcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1644   1          plcLineCtrl.s.reqScanning = scanEnb;
1645   1          //gHpgpHalCB.scanEnb    = scanEnb;   
1646   1          if(scanEnb && !gHpgpHalCB.scanEnb)
1647   1          {
1648   2              plcDevCtrl.s.snidValid    = 1;  // ask TRI
1649   2              gHpgpHalCB.syncComplete   = 0;
1650   2              gHpgpHalCB.halStats.RxGoodBcnCnt   = 0;
1651   2              gHpgpHalCB.halStats.syncTestValIdx = 0;
1652   2              gHpgpHalCB.nwSelected     = 0;
1653   2      
1654   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Enable\n");
1655   2      
1656   2          }
1657   1          if(!scanEnb)
1658   1          {
1659   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Disable\n");
1660   2      
1661   2          }
1662   1          gHpgpHalCB.scanEnb    = scanEnb;   
1663   1          WriteU32Reg(PLC_LINECTRL_REG,plcLineCtrl.reg);
1664   1          WriteU32Reg(PLC_DEVCTRL_REG,plcDevCtrl.reg);
1665   1      }
1666          
1667          
1668          /*******************************************************************
1669          * NAME :            HHAL_GetTei
1670          *
1671          * DESCRIPTION :     Sets local TEI.
1672          *
1673          * INPUTS :
1674          *       PARAMETERS:
1675          *           None
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 29  

1676          *
1677          * OUTPUTS :
1678          *       u8 tei
1679          *
1680          */
1681          u8 HHAL_GetTei()
1682          {
1683   1          uPlcDevCtrlReg PlcDevCtrl;
1684   1          u8             stei;
1685   1          
1686   1          PlcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1687   1          stei = PlcDevCtrl.s.stei;
1688   1      
1689   1          return stei;         
1690   1      }
1691          
1692          /*******************************************************************
1693          * NAME :            HHAL_SetTei
1694          *
1695          * DESCRIPTION :     Sets local TEI.
1696          *
1697          * INPUTS :
1698          *       PARAMETERS:
1699          *           u8 tei
1700          *
1701          * OUTPUTS :
1702          *       None
1703          *
1704          */
1705          void HHAL_SetTei(u8 stei)
1706          {
1707   1          uPlcDevCtrlReg PlcDevCtrlReg;
1708   1      #ifdef HPGP_HAL_TEST
1709   1          gHpgpHalCB.selfTei  = stei;
1710   1      #else
                  gHpgpHalCB.tei  = stei;
              #endif   //HPGP_HAL_TEST
1713   1          PlcDevCtrlReg.reg   = ReadU32Reg(PLC_DEVCTRL_REG);
1714   1          PlcDevCtrlReg.s.stei = stei;
1715   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1716   1      }
1717          
1718          /*******************************************************************
1719          * NAME :            HHAL_GetSnid
1720          *
1721          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1722          *
1723          * INPUTS :
1724          *       PARAMETERS:
1725          *           eRegFlag regFlag
1726          *
1727          * OUTPUTS :
1728          *       None
1729          *
1730          */
1731          u8 HHAL_GetSnid()
1732          {
1733   1          uPlcDevCtrlReg PlcDevCtrlReg;
1734   1          u8             snid;
1735   1      
1736   1          PlcDevCtrlReg.reg       = ReadU32Reg(PLC_DEVCTRL_REG);
1737   1          snid                 = PlcDevCtrlReg.s.snid;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 30  

1738   1      
1739   1          return snid;
1740   1      }
1741          
1742          /*******************************************************************
1743          * NAME :            HHAL_SetSnid
1744          *
1745          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1746          *
1747          * INPUTS :
1748          *       PARAMETERS:
1749          *           u8 snid
1750          *
1751          * OUTPUTS :
1752          *       None
1753          *
1754          */
1755          void HHAL_SetSnid(u8 snid)
1756          {
1757   1          uPlcDevCtrlReg PlcDevCtrlReg;
1758   1      
1759   1          gHpgpHalCB.snid      = snid;
1760   1          PlcDevCtrlReg.reg    = ReadU32Reg(PLC_DEVCTRL_REG);
1761   1          PlcDevCtrlReg.s.snid = snid;
1762   1          if(gHpgpHalCB.devMode == DEV_MODE_CCO || !gHpgpHalCB.scanEnb)
1763   1          {
1764   2              PlcDevCtrlReg.s.snidValid = 1;
1765   2              FM_Printf(FM_MINFO, "SetSnid:%bu\n", snid);
1766   2      
1767   2          }
1768   1          else
1769   1          {
1770   2              /*// FIXME : -- sync with HMAC on the use of Set SNID for STA side
1771   2              if(gHpgpHalCB.halStats.RxGoodBcnCnt >= PLC_BCNTST_SYNCTHRES)
1772   2              {
1773   2                  gHpgpHalCB.nwSelected  = 1;
1774   2                  FM_Printf(FM_MINFO, "HHAL_SetSnid: network Selected, snid = %bu\n", snid);      
1775   2              }
1776   2              else
1777   2              {
1778   2              PlcDevCtrlReg.s.snidValid = 0;
1779   2              }
1780   2                    */
1781   2      
1782   2                    gHpgpHalCB.nwSelected  = 1;
1783   2                    PlcDevCtrlReg.s.snidValid = 1;
1784   2          }
1785   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1786   1      }
1787          
1788          void HHAL_DisableLMBcnBuf(u8 bcnType)
1789          {
1790   1         gHpgpHalCB.lmBcn.txBitmap &= ~((1 << bcnType));
1791   1      }
1792          
1793          void HHAL_SetLMBcnBuf(u8 *buff, u8 bcnType, u8 bpstoOffset)
1794          {
1795   1          if (bcnType == BEACON_TYPE_CENTRAL)
1796   1          {
1797   2              memcpy(&gHpgpHalCB.lmBcn.cBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.cBcn.bcnBuff));
1798   2              gHpgpHalCB.lmBcn.cBcn.bpstoOffset = bpstoOffset;
1799   2      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 31  

1800   2      
1801   2          }
1802   1      #if 0 
                  else
                  if (bcnType == BEACON_TYPE_DISCOVER)
                  {
                      memcpy(&gHpgpHalCB.lmBcn.dBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.dBcn.bcnBuff));
                      gHpgpHalCB.lmBcn.dBcn.bpstoOffset = bpstoOffset;
                  }
              #endif
1810   1      
1811   1          gHpgpHalCB.lmBcn.txBitmap |= (1 << bcnType);
1812   1      }   
1813          
1814          /*******************************************************************
1815          * NAME :            HHAL_SetCsmaRegions
1816          *
1817          * DESCRIPTION :     Sets CSMA Regions - takes effect only next BPST.
1818          *                   Startime,EndTime,Duration in units of ATU = 10.24uS
1819          *                   Starttime is number of ATUs from EndTime of prev region.
1820          *
1821          * INPUTS :
1822          *       PARAMETERS:
1823          *           eRegFlag regFlag
1824          *
1825          * OUTPUTS :
1826          *       None
1827          *
1828          */
1829          void HHAL_SetCsmaRegions(sCsmaRegion* regionArr, u8 regionCnt)
1830          {
1831   1          uCSMARegionReg  csmaRegion;
1832   1          u8 i;
1833   1          u8 csmaRegionCnt;
1834   1      
1835   1          csmaRegionCnt = HYBRII_MAXSMAREGION_CNT < regionCnt ? HYBRII_MAXSMAREGION_CNT: regionCnt;
1836   1          //for (j=0; j<csmaRegionCnt; j++) {
1837   1         //     FM_Printf(FM_USER, "region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n", 
1838   1          //        j, regionArr[j].startTime, regionArr[j].endTime, regionArr[j].rxOnly);
1839   1         // }
1840   1          for( i=0 ; i<csmaRegionCnt ; i++ )
1841   1          {
1842   2              csmaRegion.s.csma_start_time_lo = 0;//regionArr[i].startTime & CSMAREG_STARTTMLO_MASK;
1843   2              csmaRegion.s.csma_start_time_hi = 0;//(regionArr[i].startTime & CSMAREG_STARTTMHI_MASK) >> CSMAREG
             -_STARTTMHI_POS ;
1844   2              csmaRegion.s.csma_rxOnly      = regionArr[i].rxOnly;
1845   2              csmaRegion.s.csma_endtime_lo  = regionArr[i].endTime & CSMAREG_DURATIONLO_MASK;
1846   2              csmaRegion.s.csma_endtime_hi  = (regionArr[i].endTime & CSMAREG_DURATIONHI_MASK) >> CSMAREG_DURATI
             -ONHI_POS ;
1847   2              csmaRegion.s.csma_hybrid    = regionArr[i].hybridMd;
1848   2              switch(i)
1849   2              {
1850   3                  case 0:
1851   3                      WriteU32Reg(PLC_CSMAREGION0_REG, csmaRegion.reg);
1852   3                      break;
1853   3                  case 1:
1854   3                      WriteU32Reg(PLC_CSMAREGION1_REG , csmaRegion.reg);
1855   3                      break;
1856   3                  case 2:
1857   3                      WriteU32Reg(PLC_CSMAREGION2_REG, csmaRegion.reg);
1858   3                      break;
1859   3                  case 3:
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 32  

1860   3                      WriteU32Reg(PLC_CSMAREGION3_REG, csmaRegion.reg);
1861   3                      break;
1862   3                  case 4:
1863   3                      WriteU32Reg(PLC_CSMAREGION4_REG, csmaRegion.reg);
1864   3                      break;
1865   3                  case 5:
1866   3                      WriteU32Reg(PLC_CSMAREGION5_REG, csmaRegion.reg);
1867   3                      break;
1868   3                  default:
1869   3                      {
1870   4      
1871   4                      }
1872   3      
1873   3              }
1874   2          }
1875   1      }
1876          
1877          
1878          /*******************************************************************
1879          * NAME :            HHAL_SetDiagMode
1880          *
1881          * DESCRIPTION :     Sets or clears PLC Tx/Rx Diagnostic mode operation.
1882          *
1883          * INPUTS :
1884          *       PARAMETERS:
1885          *           eRegFlag regFlag
1886          *
1887          * OUTPUTS :
1888          *       None
1889          *
1890          */
1891          void HHAL_SetDiagMode(eRegFlag regFlag)
1892          {
1893   1          uPlcStatusReg plcStatus;
1894   1      
1895   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1896   1          if(regFlag)
1897   1          {
1898   2              gHpgpHalCB.diagModeEnb = 1;
1899   2          }
1900   1          else
1901   1          {
1902   2              gHpgpHalCB.diagModeEnb = 0;
1903   2          }
1904   1          plcStatus.s.contTxDiag = regFlag;
1905   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1906   1      }
1907          
1908          /*******************************************************************
1909          * NAME :            HHAL_SetDiagModeNoSack
1910          *
1911          * DESCRIPTION :     Enables or Disables ACK during Diagnostic mode operation.
1912          *
1913          * INPUTS :
1914          *       PARAMETERS:
1915          *           eRegFlag regFlag
1916          *
1917          * OUTPUTS :
1918          *       None
1919          *
1920          */
1921          void HHAL_SetDiagModeNoSack(eRegFlag regFlag)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 33  

1922          {
1923   1          uPlcStatusReg plcStatus;
1924   1      
1925   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1926   1          plcStatus.s.noSackDiag = regFlag;
1927   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1928   1      }
1929          
1930          
1931          /*******************************************************************
1932          * NAME :            HHAL_GetPlcTxQFreeDescCnt
1933          *
1934          * DESCRIPTION :     Returns no: of dwords available in a given PLC CAP Tx Q.
1935          *
1936          * INPUTS :
1937          *       PARAMETERS:
1938          *           eRegFlag regFlag
1939          *
1940          * OUTPUTS :
1941          *       None
1942          *
1943          */
1944          u8 HHAL_GetPlcTxQFreeDescCnt(eHpgpPlidValue plid)
1945          {
1946   1          uCapTxQStatusReg capTxQStat;
1947   1          u8 freeDescCnt;
1948   1          u8* descCntArr;
1949   1      
1950   1          capTxQStat.reg = ReadU32Reg(PLC_QDSTATUS_REG);
1951   1      
1952   1          descCntArr = (u8*)&capTxQStat.reg;
1953   1          freeDescCnt = PLC_TXQ_DEPTH - descCntArr[plid];
1954   1          //printf("PLCTxQStatusReg = 0x%08lX, PLCTxQ[%bu].freeDescCnt = %bu\n", SwapU32(capTxQStat.reg),plid, f
             -reeDescCnt);
1955   1          return  freeDescCnt;
1956   1      }
1957          
1958          
1959          // txBcn starts with 16 bytes avFC & has to be zero padded
1960          // bcnLen is always 136
1961          // Always give a non-zero valid bpstoValueOffset: minimum is 16 byte AVFC + 12 byte BcnHdr + 1 byte NBE + 
             -2 bytes BEHDR,BELEN of BPSTO BENTRY
1962          //                                                            = 33 (ie., 34thth byte)
1963          eStatus HHAL_AddNEK(u8 eks, u8 nek[PLC_AES_KEYLEN] )
1964          {
1965   1          uAesLutAddrReg      aesLutAddr;
1966   1          uAesLutDataReg      aesLutData;
1967   1          uAesKeyLutAddrReg   aesKeyLutAddr;
1968   1          uAesKeyLutDataReg   aesKeyLutData;
1969   1          uAesCpuCmdStatReg   aesCpuCmd;
1970   1      
1971   1          u8                  i,j;
1972   1          u8                  arrIdx;
1973   1      
1974   1          arrIdx          = 0;
1975   1      
1976   1          // Wait for Cpu Aes Lut access grant.
1977   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
1978   1          aesCpuCmd.s.cpuTblReq = 1;
1979   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
1980   1      /*
1981   1          CHAL_DelayTicks(100);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 34  

1982   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
1983   1          if(!aesCpuCmd.s.cpuTblGnt)
1984   1          {
1985   1              printf("Add NEK failed\n");  //[YM] Add debug message of set NEK failure
1986   1              return STATUS_FAILURE;
1987   1          }
1988   1      */
1989   1          // Write Key to the Key LUT.
1990   1          for(i=0; i<4; i++)
1991   1          {
1992   2              aesKeyLutAddr.reg     = 0;
1993   2              aesKeyLutAddr.sNek.isNek = 1;
1994   2              aesKeyLutAddr.sNek.idx   = i;
1995   2              aesKeyLutAddr.sNek.eks   = (eks & 0x7);
1996   2              WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
1997   2              FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.reg), (PLC_
             -AESKEYLUTADDR_REG));
1998   2              for(j=0 ; j<4 ; j++)
1999   2              {
2000   3                  aesKeyLutData.s.key[j] = nek[arrIdx++];       
2001   3              }
2002   2              WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
2003   2              FM_Printf(FM_LINFO,"Wrote key dw        0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.reg), (PLC_
             -AESKEYLUTDATA_REG));
2004   2          }
2005   1      
2006   1          // Write Aes LUT Addr corres. to NEK.
2007   1          aesLutAddr.reg        = 0;
2008   1          aesLutAddr.sNek.eks   = eks;
2009   1          aesLutAddr.sNek.isNek = 1;
2010   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2011   1          FM_Printf(FM_LINFO,"Wrote AesLutAddr dw 0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (PLC_AESLUTA
             -DDR_REG));
2012   1      
2013   1          // Set the NEK as valid.
2014   1          aesLutData.reg        = 0;
2015   1          aesLutData.sNek.valid = 0xFF;
2016   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2017   1          FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n\n", rtocl(aesLutData.reg), (PLC_AESLU
             -TDATA_REG));
2018   1      
2019   1          // Release CPU Lock on AES LUT
2020   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2021   1          aesCpuCmd.s.cpuTblGnt = 0;
2022   1          aesCpuCmd.s.cpuTblReq = 0;
2023   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
2024   1      
2025   1          return STATUS_SUCCESS;
2026   1      }
2027           
2028          eStatus HHAL_RemoveNEK(u8 eks)
2029          {
2030   1      
2031   1          uAesLutAddrReg      aesLutAddr;
2032   1          uAesLutDataReg      aesLutData;
2033   1          uAesCpuCmdStatReg   aesCpuCmd;
2034   1          eStatus             status;
2035   1      
2036   1          // Wait for Cpu Aes Lut access grant.
2037   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2038   1          aesCpuCmd.s.cpuTblReq = 1;
2039   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 35  

2040   1      /*
2041   1          CHAL_DelayTicks(100);
2042   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2043   1          if(!aesCpuCmd.s.cpuTblGnt || eks > 7)
2044   1          {
2045   1              return STATUS_FAILURE;
2046   1          }
2047   1      */
2048   1          // Write Aes LUT Addr corres. to NEK.
2049   1          aesLutAddr.reg     = 0;
2050   1          aesLutAddr.sNek.eks   = eks;
2051   1          aesLutAddr.sNek.isNek = 1;
2052   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2053   1      
2054   1          // Set the NEK as invalid.
2055   1          aesLutData.reg        = 0;
2056   1          aesLutData.sNek.valid = 0x0;
2057   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg); 
2058   1      
2059   1          // Release CPU Lock on AES LUT
2060   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2061   1          aesCpuCmd.s.cpuTblGnt = 0;
2062   1          aesCpuCmd.s.cpuTblReq = 0;
2063   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2064   1      
2065   1          return status;
2066   1      }
2067           
2068          eStatus HHAL_AddPPEK(u8 eks, u8 ppek[PLC_AES_KEYLEN], u8 tei)
2069          {
2070   1          uAesLutAddrReg      aesLutAddr;
2071   1          uAesLutDataReg      aesLutData;
2072   1          uAesKeyLutAddrReg   aesKeyLutAddr;
2073   1          uAesKeyLutDataReg   aesKeyLutData;
2074   1          uAesCpuCmdStatReg   aesCpuCmd;
2075   1          eStatus             status;
2076   1          u8                  i,j;
2077   1          u8                  arrIdx;
2078   1          u8                  keyNum;
2079   1          u8                  region;
2080   1      
2081   1          arrIdx          = 0;
2082   1      
2083   1          status  = STATUS_SUCCESS;
2084   1          // Wait for Cpu Aes Lut access grant.
2085   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2086   1          aesCpuCmd.s.cpuTblReq = 1;
2087   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2088   1      /*
2089   1          CHAL_DelayTicks(100);
2090   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2091   1          if(!aesCpuCmd.s.cpuTblGnt)
2092   1          {
2093   1              return STATUS_FAILURE;
2094   1          }
2095   1      */
2096   1          if(eks != 8 && eks != 9 )  // EKS = 0b1000 or 0b1001
2097   1          {
2098   2              status = STATUS_FAILURE;
2099   2          }
2100   1          else
2101   1          {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 36  

2102   2               region                  = eks & 0x01;
2103   2      
2104   2              // Write AesLutAddr corres to the tei.
2105   2              aesLutAddr.reg          = 0;
2106   2              aesLutAddr.sPpek.tei    = tei;
2107   2              aesLutAddr.sPpek.isNek  = 0;
2108   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2109   2              FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to   reg#0x%08lX\n", rtocl(aesLutAddr.reg), (P
             -LC_AESLUTADDR_REG));
2110   2      
2111   2              // Read back AesLutData corres to the tei.
2112   2              aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2113   2              FM_Printf(FM_MINFO, "Readback AesLutData dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (P
             -LC_AESLUTDATA_REG));
2114   2      
2115   2              if(aesLutData.sPpek.valid)
2116   2              {
2117   3                   // Overwrite the current Key. So retrive Index of current key.
2118   3                   keyNum = aesLutData.sPpek.keyNum;
2119   3              }
2120   2              else
2121   2              {
2122   3                  // Find an available Key Index to add the new PPEK.
2123   3                  for(i=0 ; i<32 ; i++)
2124   3                  {
2125   4                      if( (gHpgpHalCB.ppekValidReg & BIT(i)) == 0)
2126   4                      {
2127   5                          keyNum = i;
2128   5                          gHpgpHalCB.ppekValidReg |= BIT(i);
2129   5                          break;
2130   5                      }                    
2131   4                  }
2132   3                  if(i == 32)
2133   3                  {
2134   4                      // All 32 KeyEntries in selected PPEK Region are currently in use.
2135   4                      // PPEK Table full.
2136   4                      status = STATUS_FAILURE;
2137   4                  }
2138   3              }
2139   2          }
2140   1      
2141   1          if(status == STATUS_SUCCESS)
2142   1          {
2143   2              // Write Key to the Key LUT.
2144   2              for(i=0; i<4; i++)
2145   2              {
2146   3                  aesKeyLutAddr.reg          = 0;
2147   3                  aesKeyLutAddr.sPpek.isNek  = 0;
2148   3                  aesKeyLutAddr.sPpek.idx    = i;
2149   3                  aesKeyLutAddr.sPpek.keyNum = keyNum;
2150   3                  aesKeyLutAddr.sPpek.region = region;
2151   3                  WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
2152   3                  FM_Printf(FM_MINFO, "Wrote keyAddr dw       0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.reg
             -), (PLC_AESKEYLUTADDR_REG));
2153   3                  for(j=0 ; j<4 ; j++)
2154   3                  {
2155   4                      aesKeyLutData.s.key[j] = ppek[arrIdx++];       
2156   4                  }
2157   3                  WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
2158   3                  FM_Printf(FM_MINFO, "Wrote key dw           0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.reg
             -), (PLC_AESKEYLUTDATA_REG));
2159   3              }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 37  

2160   2      
2161   2              // Write Aes LUT Addr corres to PPEK.
2162   2              aesLutAddr.reg          = 0;
2163   2              aesLutAddr.sPpek.tei    = tei;
2164   2              aesLutAddr.sPpek.isNek  = 0;
2165   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2166   2              FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (PLC
             -_AESLUTADDR_REG));
2167   2          
2168   2              // Set the PPEK valid.
2169   2              //aesLutData.reg           = 0;
2170   2              aesLutData.sPpek.keyNum  = keyNum;
2171   2              aesLutData.sPpek.valid   = 1;
2172   2              if(region == 0)
2173   2              {
2174   3                  aesLutData.sPpek.region0 = 1;
2175   3              }
2176   2              else
2177   2              {
2178   3                  aesLutData.sPpek.region1 = 1;
2179   3              }
2180   2      
2181   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2182   2              FM_Printf(FM_MINFO, "Wrote AesLutData dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutData.reg), (PLC
             -_AESLUTDATA_REG));
2183   2          }
2184   1      
2185   1          // Release CPU Lock on AES LUT
2186   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2187   1          aesCpuCmd.s.cpuTblGnt = 0;
2188   1          aesCpuCmd.s.cpuTblReq = 0;
2189   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2190   1      
2191   1          return status;
2192   1      }
2193          
2194          
2195          eStatus HHAL_RemovePPEK(u8 eks, u8 tei)
2196          {
2197   1          uAesLutAddrReg      aesLutAddr;
2198   1          uAesLutDataReg      aesLutData;
2199   1          uAesCpuCmdStatReg   aesCpuCmd;
2200   1          eStatus             status;
2201   1          u8                  region;
2202   1      
2203   1          // Wait for Cpu Aes Lut access grant.
2204   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2205   1          aesCpuCmd.s.cpuTblReq = 1;
2206   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2207   1      
2208   1          CHAL_DelayTicks(100);
2209   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2210   1          if(eks < 8 || eks > 9)
2211   1          {
2212   2              return STATUS_FAILURE;
2213   2          }
2214   1          region                  = eks & 0x01;
2215   1      
2216   1          // Write Aes LUT Addr corres. to PPEK.
2217   1          aesLutAddr.reg         = 0;
2218   1          aesLutAddr.sPpek.tei   = tei;
2219   1          aesLutAddr.sPpek.isNek = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 38  

2220   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2221   1      
2222   1          // Read back AesLutData corres to the tei.
2223   1          aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2224   1          FM_Printf(FM_MINFO,"Read back dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (PLC_AESLUTDATA_R
             -EG));
2225   1      
2226   1          if(aesLutData.sPpek.valid)
2227   1          {
2228   2              if(region == 0)
2229   2              {
2230   3                  aesLutData.sPpek.region0 = 0;
2231   3              }
2232   2              else
2233   2              {
2234   3                  aesLutData.sPpek.region1 = 0;
2235   3              }
2236   2              if(aesLutData.sPpek.region0 == 0 && aesLutData.sPpek.region1 == 0)
2237   2              {
2238   3                   // Set the PPEK as invalid.
2239   3                  aesLutData.reg         = 0;
2240   3                  aesLutData.sPpek.valid = 0x0;
2241   3                  
2242   3              }
2243   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutAddr.reg); 
2244   2          }
2245   1          else
2246   1          {
2247   2              status = STATUS_FAILURE;
2248   2          }
2249   1      
2250   1          // Release CPU Lock on AES LUT
2251   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2252   1          aesCpuCmd.s.cpuTblGnt = 0;
2253   1          aesCpuCmd.s.cpuTblReq = 0;
2254   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2255   1      
2256   1          return status;
2257   1      }
2258          
2259          #ifdef HPGP_HAL_TEST
2260          void HHAL_SetDefAddrConfig()
2261          {
2262   1      #if defined(Flash_Config) && defined(Z_P_BRIDGE)    
              
                      gHpgpHalCB.selfTei   = sysConfig.defaultSTEI;
                      gHpgpHalCB.remoteTei = sysConfig.defaultDTEI;
                  gHpgpHalCB.snid      = sysConfig.defaultNID[0];
              
              #else 
2269   1        if(gHpgpHalCB.devMode == DEV_MODE_CCO)
2270   1          {
2271   2              gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
2272   2              gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
2273   2          }else
2274   1          {
2275   2              gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
2276   2              gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
2277   2          }
2278   1          gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
2279   1      #endif  //Flash_Config && Z_P_BRIDGE
2280   1      #ifndef QCA
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 39  

2281   1        
2282   1          HHAL_SetTei(gHpgpHalCB.selfTei);
2283   1      
2284   1          HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other chip
             - snid should be set once we receive bcn from cco and should not get set at power on because 
2285   1      #endif
2286   1      }
2287          #endif  //HPGP_HAL_TEST
2288          
2289          void HHAL_ClearBcnInit()
2290          {
2291   1          gHpgpHalCB.bcnInitDone = 0;
2292   1          //FM_Printf(FM_MINFO, "HHAL_ClearBcnInit\n");
2293   1      
2294   1      }
2295          
2296          void HHAL_SetBcnInit()
2297          {
2298   1          gHpgpHalCB.bcnInitDone = 1;
2299   1          FM_Printf(FM_MINFO, "HHAL_SetBcnInit\n");
2300   1      
2301   1      }
2302          
2303          void HHAL_PowerSaveConfig()
2304          {
2305   1          uPlcLineControlReg plcLineCtrl;
2306   1        
2307   1        plcLineCtrl.reg = ReadU32Reg(PLC_POWERSAVE_REG);
2308   1        
2309   1      }
2310          
2311          /*******************************************************************
2312          * NAME :            HHAL_SetDevMode
2313          *
2314          * DESCRIPTION :     Sets Default PLC Device configuration.
2315          *
2316          * INPUTS :
2317          *       PARAMETERS:
2318          *           eRegFlag regFlag
2319          *
2320          * OUTPUTS :
2321          *       None
2322          *
2323          */
2324          #ifdef HPGP_HAL_TEST
2325          void HHAL_SetDevMode(eDevMode devMode, eLineMode lineMode )
2326          #else
              void HHAL_SetDevMode(sHaLayer *hal, eDevMode devMode, eLineMode lineMode)
              #endif   //HPGP_HAL_TEST
2329          {
2330   1      
2331   1      
2332   1          sCsmaRegion      csmaRegArr[5]; 
2333   1          uPlcLineControlReg plcLineCtrl;
2334   1          
2335   1         
2336   1        
2337   1          memset(csmaRegArr, 0, 5*sizeof(sCsmaRegion));
2338   1          // Added by Varsha
2339   1          if(lineMode == LINE_MODE_DC)
2340   1          {
2341   2              gHpgpHalCB.lineMode = LINE_MODE_DC;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 40  

2342   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
2343   2              //gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2344   2              WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
2345   2          WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_DC_BP_LEN >> 1)));
2346   2              WriteU32Reg(PLC_HWBCNPERCUR_REG, ctorl(PLC_DC_BP_LEN));
2347   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2348   2              plcLineCtrl.s.dcmode = 1;
2349   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2350   2               gsyncTimeout = DC_SYNC_TIMEOUT;
2351   2               gBcnMissingRescanCnt = DC_BCN_MISSING_RESCAN_CNT;  //60*4= 240= 240/40= 6 bcn missing
2352   2              //gHpgpHalCB.bPerAvgInitDone = 1;
2353   2          }
2354   1          else
2355   1          {
2356   2              gHpgpHalCB.lineMode = LINE_MODE_AC;
2357   2      
2358   2              gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2359   2            
2360   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2361   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2362   2              
2363   2              set_plc_paramter(PLC_MaxPeran,PLC_MAX_AC_BPLEN);
2364   2              set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2365   2              
2366   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2367   2              plcLineCtrl.s.dcmode = 0;
2368   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2369   2               gsyncTimeout = AC_SYNC_TIMEOUT;
2370   2               gBcnMissingRescanCnt = AC_BCN_MISSING_RESCAN_CNT;  //30*4= 120= 120/33.33= 3 bcn missing
2371   2            set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2372   2          }
2373   1      
2374   1          if(devMode == DEV_MODE_CCO)
2375   1          {
2376   2              gHpgpHalCB.devMode   = DEV_MODE_CCO;
2377   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode CCo\n");
2378   2      
2379   2              // Write PLC Devmode register.
2380   2              //cpuSwStatus.reg = ReadU32Reg(CPU_SWSTATUS_REG);
2381   2              if(lineMode == LINE_MODE_AC)
2382   2              {
2383   3                  //cpuSwStatus.s.plcDevMode = CCO_ACLINE;            
2384   3                  HHAL_SetPlcDevMode(CCO_ACLINE);
2385   3                  // Set AC cycle frequency
2386   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2387   3      /*#ifdef AC_LINECYCLE_50HZ
2388   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2389   3      #else                   
2390   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2391   3      #endif   */ //AC_LINECYCLE_50HZ         
2392   3                  gHpgpHalCB.perSumCnt       = 0;
2393   3                  gHpgpHalCB.bPerAvgInitDone = 0;
2394   3              }
2395   2              else
2396   2              {
2397   3                  
2398   3                  HHAL_SetPlcDevMode(CCO_DCLINE);
2399   3                  //HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2400   3              }
2401   2      #ifdef HPGP_HAL_TEST
2402   2              setCSMA_onCCO();                                          
2403   2      #endif
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 41  

2404   2          }
2405   1          else
2406   1          {
2407   2              gHpgpHalCB.devMode   = DEV_MODE_STA;
2408   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode Sta\n");
2409   2      
2410   2      
2411   2              // Write PLC Devmode register.
2412   2              if(lineMode == LINE_MODE_AC)
2413   2              {
2414   3                  HHAL_SetPlcDevMode(STA_CSMANW);
2415   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2416   3      /*#ifdef AC_LINECYCLE_50HZ
2417   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2418   3      #else                   
2419   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2420   3      #endif   */ //AC_LINECYCLE_50HZ       
2421   3             
2422   3              }
2423   2              else
2424   2              {
2425   3                  HHAL_SetPlcDevMode(STA_DCLINE);
2426   3                  gHpgpHalCB.lineMode = LINE_MODE_DC;
2427   3              }     
2428   2      #ifdef HPGP_HAL_TEST    
2429   2           setCSMA_onSTA();
2430   2      #endif
2431   2      
2432   2                
2433   2          }
2434   1        
2435   1         /* csmaRegArr[0].startTime  = 0;
2436   1          csmaRegArr[0].bcnRegion  = (devMode == DEV_MODE_STA) ? 1 : 0;
2437   1          csmaRegArr[0].duration   = 0x2FF;
2438   1          csmaRegArr[0].hybridMd   = 1;    
2439   1          
2440   1          csmaRegArr[2].startTime  = 0;
2441   1          csmaRegArr[2].bcnRegion  = (devMode == DEV_MODE_STA ) ? 1 : 0;
2442   1          csmaRegArr[2].duration   = gHpgpHalCB.bcnInitDone ? 0 : 0x5A3;
2443   1          csmaRegArr[2].hybridMd   = gHpgpHalCB.bcnInitDone ? 0 : 1;  
2444   1          
2445   1          csmaRegArr[3].startTime  = 0;
2446   1          csmaRegArr[3].bcnRegion  = 0;
2447   1          csmaRegArr[3].duration   = 0;//0x04A9//0xFF;
2448   1          csmaRegArr[3].hybridMd   = 0;//1;                         
2449   1          // Write CSMA Regions - mixed mode.
2450   1          if(lineMode == LINE_MODE_AC) 
2451   1          {
2452   1      
2453   1          csmaRegArr[1].startTime  = 0;
2454   1          csmaRegArr[1].bcnRegion  = 0;
2455   1          csmaRegArr[1].duration   = 0x4A1;
2456   1          csmaRegArr[1].hybridMd   = 1;
2457   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2458   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2459   1          }
2460   1          else
2461   1          {
2462   1          csmaRegArr[1].startTime  = 0;
2463   1          csmaRegArr[1].bcnRegion  = 0;
2464   1          csmaRegArr[1].duration   = 0x6A1;
2465   1          csmaRegArr[1].hybridMd   = 1;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 42  

2466   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2467   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2468   1      
2469   1          }
2470   1          //HHAL_SetCsmaRegions(csmaRegArr,4);
2471   1         
2472   1          WriteU8Reg(0x47F, 0x4);  // PHY AGC Threshold - For auto switch robo on RX
2473   1          */
2474   1      }
2475          
2476          
2477          
2478          
2479          // Write AFE registers wian SPI registers in PHY address space
2480          void HHAL_AFEInit()
2481          {
2482   1      
2483   1      #ifdef B_ASICPLC
2484   1          // [YM] 1.8GHz VCO Calibrate
2485   1          mac_utils_spi_write(0x4, 0x20);
2486   1          mac_utils_spi_write(0x4, 0x4);   //[YM] temporary disable AFE calibration    
2487   1      #endif  
2488   1      
2489   1      #ifdef B2_ASICPLC
                  // [YM] 1.8GHz VCO Calibrate
                  mac_utils_spi_write(0x4, 0x20);
                  mac_utils_spi_write(0x4, 0x24);   //[YM] temporary disable AFE calibration    
              #endif  
2494   1      
2495   1      /*
2496   1      #if defined(HYBRII_HPGP) && defined(HYBRII_ZIGBEE)
2497   1          // Program fix gain for PLC
2498   1      #ifndef HYBRII_B
2499   1          mac_utils_spi_write(0x3a, 0x0a);
2500   1          mac_utils_spi_write(0x3b, 0x72);
2501   1      #endif
2502   1      #endif   //defined(HYBRII_HPGP) && defined(HYBRII_ZIGBEE)
2503   1      */
2504   1      #ifdef _LED_DEMO_
                  WriteU8Reg(0x406, 0x00);
                  CHAL_DelayTicks(SPI_WRITE_DELAY);
                  WriteU8Reg(0x406, 0x7F);
              #endif  //_LED_DEMO_
2509   1      }
2510          
2511          
2512          void hal_hpgp_soft_reset ()
2513          {
2514   1          uPlcStatusReg  plcStatus;
2515   1          
2516   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
2517   1          plcStatus.s.txSoftReset = 1;
2518   1          plcStatus.s.rxSoftReset = 1;
2519   1      
2520   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2521   1      
2522   1          CHAL_DelayTicks(100);
2523   1          plcStatus.s.txSoftReset = 0;
2524   1          plcStatus.s.rxSoftReset = 0;
2525   1      
2526   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2527   1      }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 43  

2528          
2529          
2530          
2531          #ifdef HPGP_HAL_TEST
2532          eStatus HHAL_SyncNet(u8 *bpsto) 
2533          #else    
              eStatus HHAL_SyncNet(sHaLayer *hal, u8 *bpsto) 
              #endif  //HPGP_HAL_TEST
2536          {
2537   1          uBpstoReg    bpstoReg;
2538   1          //u32          ntb1,ntb2;
2539   1          u32          bpstoVal; //, latency;
2540   1          u32          bpst;
2541   1          u32          ss1;
2542   1      //    u32          offset;
2543   1      //    u32          ss2MinusSs1;
2544   1      //    u32 bps;
2545   1          u32 NTB_delta;
2546   1      //    u32 x;
2547   1      //    u32 E_CCOBTS;
2548   1          u32 BcnPer;
2549   1          u32 CCOBpst;
2550   1          u32 RetrievedBTS;
2551   1          u8 rollover_snapshot1 = 0;
2552   1          u8 rollover_retriveBTS = 0;
2553   1          u32 ToatalLatency;
2554   1      
2555   1        eStatus      ret = STATUS_FAILURE;
2556   1      
2557   1                           
2558   1      
2559   1          if (!gHpgpHalCB.nwSelected)
2560   1              return ret;    
2561   1      
2562   1       
2563   1        
2564   1          // Process further if the beacon has been snapshot.
2565   1          if(gHpgpHalCB.snapShot)
2566   1          {
2567   2              bpstoReg.s.bpsto0 = bpsto[0];
2568   2              bpstoReg.s.bpsto1 = bpsto[1];
2569   2              bpstoReg.s.bpsto2 = bpsto[2];
2570   2      
2571   2              bpstoVal = ((u32)(bpsto[2])<<16) + ((u32)(bpsto[1])<<8) + (u32)bpsto[0];
2572   2              //WriteU32Reg(PLC_BPSTOFFSET_REG, ctorl(bpstoVal));     
2573   2              
2574   2              ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2575   2             
2576   2               //ss2 = rtocl(ReadU32Reg(PLC_NTB_REG)); 
2577   2              // printf("\n ssdif= %lu", ((ss1-oldss1) * 40));
2578   2               
2579   2      
2580   2              if(gHpgpHalCB.syncComplete)//normal operation
2581   2              {
2582   3                   if(ss1 < oldss1)
2583   3                      rollover_snapshot1 = 1;
2584   3              }   
2585   2              oldss1 = ss1;
2586   2              RetrievedBTS = gCCO_BTS + PLC_PHY_RXLATENCY_FOR_TCC3;  //PLC_PHY_RXLATENCY_FOR_TCC2;//normal as we
             -ll as cpu scan operation
2587   2               
2588   2               
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 44  

2589   2              if(gHpgpHalCB.syncComplete)//normal operation
2590   2              {
2591   3                  if(RetrievedBTS < oldRetrievedBTS)
2592   3                      rollover_retriveBTS = 1;
2593   3              } 
2594   2              
2595   2              oldRetrievedBTS = RetrievedBTS; 
2596   2              
2597   2              if(RetrievedBTS > ss1)  //sta slower then cco
2598   2              {
2599   3                  if(rollover_retriveBTS)
2600   3                  {
2601   4                      NTB_delta = RetrievedBTS + (0xffffffff - ss1);
2602   4                  }
2603   3                  else 
2604   3                  {
2605   4                      NTB_delta = (RetrievedBTS - ss1);
2606   4                   
2607   4                  }
2608   3                  if(NTB_delta > 10)
2609   3                  {
2610   4                      gHpgpHalCB.halStats.STAlagCCOCount++;
2611   4                  }
2612   3              
2613   3              }
2614   2              else  //sta is faster then cco so take 2's complement
2615   2              {
2616   3              
2617   3                  if(rollover_snapshot1 )
2618   3                  {
2619   4                      NTB_delta = 0xffffffff - (ss1 + (0xffffffff - RetrievedBTS)) + 1;
2620   4                  }
2621   3                  else  
2622   3                  {
2623   4                      NTB_delta = 0xffffffff - (ss1 - RetrievedBTS) + 1;     //taken 2's complement
2624   4                      
2625   4                     
2626   4                  }
2627   3                  if((ss1 - RetrievedBTS) > 10)
2628   3                  {
2629   4                      gHpgpHalCB.halStats.STAleadCCOCount++;
2630   4                  } 
2631   3              }
2632   2              
2633   2              WriteU32Reg( PLC_NTBADJ_REG, ctorl(NTB_delta));  
2634   2               
2635   2            
2636   2                                                 
2637   2              //ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2638   2      
2639   2             
2640   2              //ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC2 + bpstoVal);
2641   2              ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC3+ bpstoVal);
2642   2           
2643   2      
2644   2      
2645   2      #ifdef QCA    
                      ss1 += NTB_delta;//rajan
              #endif             
2648   2      
2649   2              if( ss1 > ToatalLatency)
2650   2              {
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 45  

2651   3                  if(rollover_snapshot1)
2652   3                      CCOBpst = ss1 + (0xffffffff - ToatalLatency); 
2653   3                   else
2654   3                      CCOBpst = (ss1 - ToatalLatency);
2655   3              }
2656   2              else
2657   2              {
2658   3                    CCOBpst = ss1 + (0xffffffff - ToatalLatency + 1); 
2659   3              }
2660   2              
2661   2             
2662   2             if(CCOBpst > OldCCOBpst)
2663   2              BcnPer =  (CCOBpst - OldCCOBpst);
2664   2             else
2665   2                  BcnPer = ((0xffffffff - OldCCOBpst) + CCOBpst);
2666   2             
2667   2             OldCCOBpst = CCOBpst; 
2668   2            // printf("\n bcn per = %lu",BcnPer); 
2669   2            
2670   2             if((BcnPer * 40) > MISSING_BCN_PER_THRESHOLD) //if bcn is missed - multiplied with 40 to read in te
             -rms of ms
2671   2             {
2672   3                  gBcnPer = gBcnPer;
2673   3             } 
2674   2             else
2675   2             {
2676   3                  gBcnPer = BcnPer;
2677   3             }
2678   2             
2679   2               //this is just debug purpose to see bcn per
2680   2               if((gBcnPer * 40) > 42000000)
2681   2               {
2682   3                  //THIS IS PRINTED JUST TO DEBUG WHEN WE KEEP OVERNIGHT TEST WHETHER WE GET THIS OR NOT
2683   3      #ifndef MPER            
2684   3                  //printf("\n BCNPER = %lu", (gBcnPer * 40));
2685   3      #endif
2686   3               }
2687   2              
2688   2              //whenever we receives bcn we write sw per avg reg = bcnper/2 
2689   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gBcnPer >> 1))); 
2690   2               
2691   2             
2692   2             // ss2MinusSs1 = (ss2 > ss1) ? (ss2 - ss1) : (0xFFFFFFFF - ss1 + ss2);
2693   2             // if(ss2MinusSs1 <= (gBcnPer - 1000) )
2694   2              {
2695   3                   bpst = CCOBpst + gBcnPer;// + var1;
2696   3                   gbpst1 = bpst;
2697   3                     
2698   3      
2699   3      #ifdef QCA             
                           bpst -= NTB_delta; //rajan
              #endif               
2702   3                  
2703   3                   WriteU32Reg(PLC_BPST_REG, ctorl(bpst)); 
2704   3                   gHpgpHalCB.halStats.BcnSyncCnt++;  
2705   3                   gtimer2 = 0;//reset second timer at every bcn receive
2706   3                   gtimer1 = 0; 
2707   3                   misscnt = 0;
2708   3               }  
2709   2                  
2710   2              }
2711   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 46  

2712   1             
2713   1              if(gHpgpHalCB.syncComplete)
2714   1              {
2715   2                  ret = STATUS_SUCCESS;
2716   2              }
2717   1      
2718   1              if(!gHpgpHalCB.syncComplete && (gHpgpHalCB.halStats.BcnSyncCnt))
2719   1              {
2720   2                  gHpgpHalCB.syncComplete = 1;
2721   2                  CHAL_DelayTicks(80);
2722   2                  HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);  
2723   2                  CHAL_DelayTicks(20);              
2724   2              }      
2725   1       
2726   1               //gtimer2 = 0;//reset second timer at every bcn receive
2727   1               //gtimer1 = 0;
2728   1               
2729   1               return ret;
2730   1      }
2731          // end of Hybrii B
2732          
2733          
2734          #if 0
              
              void HHAL_ProcessPlcTxDone()
              {
              
                  u8 tailIdx;
                  sTxFrmSwDesc  *lpPlcTxFrmSwDesc;
                  sHpgpHalCB *hhalCb; 
              #ifndef HPGP_HAL_TEST    
                  sHaLayer *hal;
              #endif     //HPGP_HAL_TEST
                  volatile u32 val;
                  volatile u8 *val1; 
              
                  
              #ifdef HPGP_HAL_TEST
                  hhalCb = &gHpgpHalCB;
              #else
                  hal = (sHaLayer*)HOMEPLUG_GetHal();
              
                  hhalCb = hal->hhalCb;
              #endif     //HPGP_HAL_TEST
              
                
                  val = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
              
                  val1 = (u8*)&val;
              
                  if ((*val1) & 0x40)
                  {
              #ifdef ETH_BRDG_DEBUG
                  numTxDoneInts++;
              #endif
                      WriteU8Reg(PLC_MEDIUMINTSTATUS_REG, 0x40);         
                         
                                  
                      tailIdx = (hhalCb->gPendingTail & 0x7F);
                      lpPlcTxFrmSwDesc =  &hhalCb->gPending[tailIdx];
              
                      if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_PENDING)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 47  

                      {
                          lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;            
              #ifdef DEBUG_DATAPATH                        
                          if (sigDbg)
                              FM_Printf(FM_ERROR," plc txDone t:%bu\n",hhalCb->gPendingTail);
              #endif   //DEBUG_DATAPATH         
                      }
              
                      
                  }
              
              }
              
              #endif
2788          
2789          
2790          void plc_init_parameters ()
2791          {
2792   1          uPlcIfs0Reg         plcIfs0;
2793   1          uPlcIfs1Reg         plcIfs1;
2794   1      
2795   1          //set_plc_paramter(PLC_PHYLATENCY_SEL,  PLC_PHYLATENCY_INIT_VALUE); 
2796   1        // Added by Varsha
2797   1        
2798   1      //      u32 laten_initval;
2799   1      //     u32 rx_lat = PLC_PHY_RXLATENCY;
2800   1      //     u32 tx_lat = PLC_PHY_TXLATENCY;
2801   1          
2802   1        set_plc_paramter(PLC_TIMINGPARAM_SEL, PLC_TIMINGPARAM_INIT_VALUE);
2803   1      
2804   1          set_plc_paramter(PLC_MPIRXTIMEOUT_SEL, PLC_MPIRXTIMOUT_INIT_VALUE);
2805   1      
2806   1          set_plc_paramter(PLC_MPITXTIMEOUT_SEL, PLC_MPITXTIMOUT_INIT_VALUE);
2807   1      
2808   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_CPUSCANTIMOUT_INIT_VALUE);
2809   1      
2810   1          set_plc_paramter(PLC_500USCNT_SEL, PLC_500US_COUNT);
2811   1      
2812   1        //Added by Varsha
2813   1        
2814   1           /*  laten_initval = PLC_PHY_RXLATENCY;
2815   1           laten_initval = laten_initval << 16;
2816   1           laten_initval += PLC_PHY_TXLATENCY;
2817   1           printf("\n latenval = %lu", laten_initval); */
2818   1           set_plc_paramter(PLC_PHYLATENCY_SEL,   TX_RXLatency_TCC[2]);  //tcc =3
2819   1        
2820   1          // IFS Registers 
2821   1          plcIfs0.reg          = 0;
2822   1          plcIfs0.s.clksPerUs  = HPGP_CLKsPerUs_DEF;
2823   1          plcIfs0.s.cifs_av    = HPGP_CIFSAV_DEF;
2824   1          plcIfs0.s.rifs_av    = HPGP_RIFSAV_DEF;
2825   1          plcIfs0.s.b2bifs     = HPGP_B2BIFS_DEF;
2826   1          set_plc_paramter(PLC_IFS0_SEL, plcIfs0.reg);
2827   1      
2828   1        
2829   1          plcIfs1.reg          = 0;
2830   1          plcIfs1.s.bifs       = HPGP_BIFS_DEF;
2831   1          plcIfs1.s.aifs       = HPGP_AIFS_DEF;
2832   1          set_plc_paramter(PLC_IFS1_SEL, plcIfs1.reg);
2833   1      
2834   1          
2835   1          set_plc_paramter(PLC_IFS2_SEL, PLC_IFS2_INIT_VALUE);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 48  

2836   1      
2837   1          set_plc_paramter(PLC_IFS3_SEL, PLC_IFS3_INIT_VALUE);
2838   1      
2839   1      
2840   1        // FL_AV Registers
2841   1          // Adding 1 to the actual values, since MAC HW is using a "<" comparison with each of these feilds.
2842   1          set_plc_paramter(PLC_FLAV0_SEL, PLC_FLAV0_INIT_VALUE);
2843   1        
2844   1          set_plc_paramter(PLC_FLAV1_SEL, PLC_FLAV1_INIT_VALUE);
2845   1      
2846   1          set_plc_paramter(PLC_FLAV2_SEL, PLC_FLAV2_INIT_VALUE);
2847   1      
2848   1          set_plc_paramter(PLC_FLAV3_SEL, PLC_FLAV3_INIT_VALUE);
2849   1      
2850   1        set_plc_paramter(PLC_FLAV4_SEL, PLC_FLAV4_INIT_VALUE);
2851   1      
2852   1      
2853   1        // 0x11 is used for Early Wake Count, 0x12 and 0x13 are not being used
2854   1      //    set_plc_paramter(PLC_CRSRDYDLY0_SEL, PLC_CRSDLY0_1_INIT_VALUE); 
2855   1      //    set_plc_paramter(PLC_CRSRDYDLY1_SEL, PLC_CRSDLY2_3_INIT_VALUE);
2856   1      //    set_plc_paramter(PLC_CRSRDYDLY2_SEL, PLC_CRSDLY3_PRS_INIT_VALUE);
2857   1          set_plc_paramter(PLC_CRSRDYDLY0_SEL, 0); 
2858   1      
2859   1          set_plc_paramter(PLC_WAITCRS_SEL, PLC_WAITCRS_INIT_VALUE);
2860   1      
2861   1          set_plc_paramter(PLC_TXRX_TURNAROUND_SEL, PLC_TXRX_TURNAROUND_INIT_VALUE);
2862   1      
2863   1        set_plc_paramter(PLC_PKTTIME_SEL, PLC_PKTTIME_INIT_VALUE);
2864   1        set_plc_paramter(PLC_EIFS_SEL, PLC_EIFS_INIT_VALUE);
2865   1        set_plc_paramter(PLC_VCSPARAM0_SEL, PLC_VCSPARAM0_INIT_VALUE);
2866   1        set_plc_paramter(PLC_VCSPARAM1_SEL, PLC_VCSPARAM1_INIT_VALUE);
2867   1        set_plc_paramter(PLC_VCSPARAM2_SEL, PLC_VCSPARAM2_INIT_VALUE);
2868   1          set_plc_paramter(PLC_MaxPeran,PLC_MaxPeran_INIT_VALUE);
2869   1        set_plc_paramter(PLC_MinPeran,PLC_MinPeran_INIT_VALUE);
2870   1      }
2871          
2872          #ifdef HPGP_HAL_TEST
2873          void HHAL_Init()
2874          #else
              void HHAL_Init(sHaLayer *hal, sHpgpHalCB **ppHhalCb)
              #endif
2877          {
2878   1          uPlcStatusReg       plcStatus;
2879   1          uPlcLineControlReg  plcLineCtrl;  
2880   1        
2881   1      //  uPlcDevCtrlReg      plcDeviceCtrl;
2882   1          uAesCpuCmdStatReg   aesCpuCmd;
2883   1        uPlcSMCounterReg    plcSMCnt;
2884   1          u16 i;
2885   1      
2886   1      //  u32                RegValue;
2887   1      #ifdef POWERSAVE
                u8 byteVal;
              #endif
2890   1      
2891   1      #ifndef HPGP_HAL_TEST
                  gHpgpHalCB.hal = hal;
                  
                  *ppHhalCb = &gHpgpHalCB;
              #endif    //HPGP_HAL_TEST
2896   1      
2897   1          plcStatus.reg              = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 49  

2898   1          plcStatus.s.crsBypass      = 0;
2899   1          plcStatus.s.soundEnable    = 0;
2900   1          plcStatus.s.plcTxQSwCtrl   = 1; 
2901   1      #ifndef MPER
2902   1          plcStatus.s.randomBackoff = 1;  // Upper mac discovey beacon collision with datapath test. so have to 
             -enable randomBackoff
2903   1      #else
                  plcStatus.s.randomBackoff = 0; 
              #endif
2906   1        //plcStatus.s.plcTxQHwCtrl   = 1;
2907   1        plcStatus.s.mpiChkFlush    = 1;
2908   1      #ifdef _AES_SW_
                  plcStatus.s.hwAesResetEnb  = 1;
              #endif
2911   1      // [YM] plcStatus.s.plcRxEnSwCtrl is used only on Hybrii_A 
2912   1      //    plcStatus.s.plcRxEnSwCtrl  = 1;
2913   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2914   1        plcStatus.s.soundEnable    = 1;
2915   1        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2916   1          // Program PLC_PHYLATENCY_SEL Init Value
2917   1          plc_init_parameters();
2918   1      
2919   1       
2920   1        
2921   1           plcLineCtrl.reg = 0;
2922   1           plcLineCtrl.s.usTimerMark = 0;
2923   1           plcLineCtrl.s.cpuFreq = 0;//25 mhz
2924   1           //plcLineCtrl.s.dcmode = 1;
2925   1           plcLineCtrl.s.hybernate = 1;
2926   1      
2927   1      #ifdef PLC_SW_SYNC
2928   1           plcLineCtrl.s.swSync = 1;
2929   1           plcLineCtrl.s.swPER = 1;
2930   1      //      plcLineCtrl.s.swSync = 0;
2931   1          // plcLineCtrl.s.swPER = 0;
2932   1      #endif
2933   1          WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg); 
2934   1        
2935   1          WriteU32Reg(PLC_MAXRETRYCNT_REG, ctorl(PLC_MAXRETRYCNT_INIT_VALUE));
2936   1        
2937   1        WriteU32Reg(CPU_ETHERSA0_REG, ctorl(CPU_ETHERSA0_INIT_VALUE));
2938   1        
2939   1        WriteU32Reg(CPU_ETHERSA1_REG, ctorl(CPU_ETHERSA1_INIT_VALUE));
2940   1        
2941   1        WriteU8Reg(ETHMAC_MACMODE_REG, 0);
2942   1        WriteU8Reg(ETHMAC_TXDEFPARM_REG, 0xC);
2943   1        WriteU8Reg(ETHMAC_TXCTL1_REG, 0x11);
2944   1        WriteU8Reg(ETHMAC_RXCTL_REG, 0xF);
2945   1        
2946   1        WriteU32Reg(PLC_EARLYHPGPBPINT_REG, ctorl(PLC_EARLYHPGPBPINT_INIT_VALUE));
2947   1      
2948   1         
2949   1           // Initialize SSN Memory - 256*4 DWORDS
2950   1           for(i=0;i<1024;i++) 
2951   1           {
2952   2             WriteU32Reg(PLC_SSNMEMADDR_REG, ctorl(i));
2953   2             WriteU32Reg(PLC_SSNMEMDATA_REG, 0); 
2954   2           }
2955   1         
2956   1           // Wait for Cpu Aes Lut access grant
2957   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2958   1           aesCpuCmd.s.cpuTblReq = 1;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 50  

2959   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2960   1         
2961   1           CHAL_DelayTicks(100);
2962   1         
2963   1           // Initialize PPEK Addr table  - 256 bytes
2964   1           for(i=0;i<256;i++)  
2965   1           {
2966   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(i));
2967   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
2968   2           }
2969   1         
2970   1           // Initialize NEK Valid table - 8 bytes
2971   1           for(i=0;i<8;i++)  
2972   1           {
2973   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(256+i));
2974   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
2975   2           }
2976   1         
2977   1           // Initilaize AES Key Table  - 1024 DWORDS
2978   1           // only 1152 DWORDS actually used to store keys
2979   1           for(i=0;i<1024;i++) 
2980   1           {
2981   2             WriteU32Reg(PLC_AESKEYLUTADDR_REG, ctorl(i));
2982   2             WriteU32Reg(PLC_AESKEYLUTDATA_REG, 0);
2983   2           }
2984   1         
2985   1           // Release CPU Lock on AES LUT
2986   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2987   1           aesCpuCmd.s.cpuTblGnt = 0;
2988   1           aesCpuCmd.s.cpuTblReq = 0;
2989   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
2990   1      
2991   1      
2992   1      
2993   1          // Initialize HPGP HAL Control Blok  
2994   1          gHpgpHalCB.diagModeEnb       = 0;
2995   1          gHpgpHalCB.bcnInitDone       = 0;
2996   1          gHpgpHalCB.ppekValidReg      = 0;
2997   1          gHpgpHalCB.syncComplete      = 0;
2998   1          gHpgpHalCB.scanEnb           = 0;
2999   1          gHpgpHalCB.swSyncEnb         = 0;
3000   1          gHpgpHalCB.lastNtbB4         = 0;
3001   1          gHpgpHalCB.lastNtbAft        = 0;
3002   1          gHpgpHalCB.lastBpst          = 0;
3003   1          gHpgpHalCB.lastBcnRxTime     = 0;
3004   1          gHpgpHalCB.bcnPerSum         = 0;
3005   1          gHpgpHalCB.curBcnPer         = 0;
3006   1          gHpgpHalCB.perSumCnt         = 0;
3007   1          gHpgpHalCB.bPerAvgInitDone   = 0;
3008   1          gHpgpHalCB.bBcnNotSent       = 0; 
3009   1          gHpgpHalCB.BcnTxWaitTimeoutCnt = 0;
3010   1          gHpgpHalCB.nwSelected        = 0;
3011   1        gHpgpHalCB.nwSelectedSnid = 0;
3012   1          gHpgpHalCB.bTxPending        = 0;
3013   1          //gHpgpHalCB.bBcnTxPending     = 0;
3014   1          gHpgpHalCB.BcnLateCnt = 0;
3015   1      #ifndef HPGP_HAL_TEST 
                  gHpgpHalCB.tei               = 0;
              #else
3018   1          memcpy(gHpgpHalCB.nid, gDefNID, NID_LEN);
3019   1      #endif  
3020   1          gHpgpHalCB.plcTx10FC.reg = HPGP_HP10FC_DEF;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 51  

3021   1      #ifdef POWERSAVE
                  gHpgpHalCB.psAvln            = TRUE;
                  gHpgpHalCB.psInSleepMode     = FALSE;
              #endif
3025   1      
3026   1      
3027   1          // Setup default network as DC mode CCo & configure default addr
3028   1          // HPGP stack will overwrite in due course.
3029   1      #ifdef HPGP_HAL_TEST
3030   1          HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
3031   1          HHAL_SetDefAddrConfig();
3032   1      #else
                  if (opMode == UPPER_MAC)
                  {
                    HHAL_SetSnid(0);
                    HHAL_SetDevMode(hal, DEV_MODE_STA, gHpgpHalCB.lineMode);//LINE_MODE_DC);
                  }
                  else
                  {
                       HHAL_SetDevMode(hal, DEV_MODE_CCO, LINE_MODE_DC);
                       if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                       {
                           gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
                           gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
                       }else
                       {
                           gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
                           gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
                       }
                       gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
                    
                       HHAL_SetTei(gHpgpHalCB.selfTei);
               
                       HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other
             - chip snid should be set once we receive bcn from cco and should not get set at power on because 
                  }
              #endif
3057   1      
3058   1      #if 0
                  //[YM] set RSSI-FIFO lock for sound packet
                  WriteU32Reg(PLC_RSSI_REG, ctorl(0x1));
              #endif
3062   1      
3063   1          // Setting for Hybrii ASIC
3064   1          WriteU8Reg(0x401, 0x03);   //Enable GAFE SPI
3065   1          WriteU8Reg(0x402, 0x10);
3066   1          // ADC PLC Clk flip
3067   1          mac_utils_spi_write(0x29,0x04);   //added by varsha
3068   1        // Enable Sync timeout 
3069   1          WriteU8Reg(0x483, 0x33);
3070   1        //WriteU8Reg(0x483, 0x13);
3071   1      #ifdef B_FPGA   
                  WriteU8Reg(0x4d9, 0x67); //For FPGA only, extra delay
                  WriteU8Reg(0x4d8, 0x84);
                
                //Sync threshold
                  //WriteU8Reg(0x48a, 0x90);     //should be re-check for ASIC, commented out for FPGA
                
                //Energy detection and AGC Saturation Threshold
                  WriteU8Reg(0x479, 0x52); 
              #endif
3081   1      // Add Sync threshold - Rachel 0317-2014
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 52  

3082   1          //WriteU8Reg(0x478, 0x11);    // For long range
3083   1        WriteU8Reg(0x478, 0x05);    // Jenny new setting 03242014
3084   1        WriteU8Reg(0x484, 0x52);
3085   1        //WriteU8Reg(0x48A, 0xCA);
3086   1        WriteU8Reg(0x48A, 0xFF);     // Jenny new setting 03242014
3087   1        WriteU8Reg(0x48B, 0x00);
3088   1        WriteU8Reg(0x4DE, 0xF0);     // Jenny new setting 03242014
3089   1        WriteU8Reg(0x4DF, 0xFF);     // Jenny new setting 03242014
3090   1        WriteU8Reg(0x4E0, 0xFF);     // Jenny new setting 03242014
3091   1        
3092   1      #if 1    
3093   1          // Add init setting for Rachel - YMCHEN 09262013
3094   1          WriteU8Reg(0x48c, 0xcb);
3095   1        WriteU8Reg(0x48d, 0x96);
3096   1        WriteU8Reg(0x48e, 0x2d);
3097   1        WriteU8Reg(0x48f, 0x5b);
3098   1        WriteU8Reg(0x490, 0xb6);
3099   1        WriteU8Reg(0x491, 0x6c);
3100   1        WriteU8Reg(0x492, 0xd9);
3101   1        WriteU8Reg(0x493, 0xb2);
3102   1        WriteU8Reg(0x494, 0x65);
3103   1        WriteU8Reg(0x495, 0xcb);
3104   1        WriteU8Reg(0x496, 0x96);
3105   1        WriteU8Reg(0x497, 0x2d);
3106   1        WriteU8Reg(0x498, 0x5b);
3107   1        WriteU8Reg(0x499, 0xb6);
3108   1        WriteU8Reg(0x49a, 0x6c);
3109   1        WriteU8Reg(0x49b, 0xd9);
3110   1        WriteU8Reg(0x49c, 0xb2);
3111   1        WriteU8Reg(0x49d, 0x65);
3112   1        WriteU8Reg(0x49e, 0xcb);
3113   1        WriteU8Reg(0x49f, 0x96);
3114   1        WriteU8Reg(0x4a0, 0x2d);
3115   1        WriteU8Reg(0x4a1, 0x5b);
3116   1        WriteU8Reg(0x4a2, 0xb6);
3117   1        WriteU8Reg(0x4a3, 0x74);
3118   1        WriteU8Reg(0x4a4, 0xc9);
3119   1        WriteU8Reg(0x4a5, 0xe2);
3120   1        WriteU8Reg(0x4a6, 0x45);
3121   1        WriteU8Reg(0x4a7, 0x0b);
3122   1        WriteU8Reg(0x4a8, 0x17);
3123   1        WriteU8Reg(0x4a9, 0xcc);
3124   1        WriteU8Reg(0x4aa, 0x9d);
3125   1        WriteU8Reg(0x4ab, 0x33);
3126   1        WriteU8Reg(0x4ac, 0x7b);
3127   1        WriteU8Reg(0x4ad, 0xd6);
3128   1        WriteU8Reg(0x4ae, 0xcc);
3129   1        WriteU8Reg(0x4af, 0x19);
3130   1        WriteU8Reg(0x4b0, 0x53);
3131   1        WriteU8Reg(0x4b1, 0xa7);
3132   1        WriteU8Reg(0x4b2, 0x4c);
3133   1        WriteU8Reg(0x4b3, 0x9e);
3134   1        WriteU8Reg(0x4b4, 0x34);
3135   1        WriteU8Reg(0x4b5, 0x71);
3136   1        WriteU8Reg(0x4b6, 0xc2);
3137   1        WriteU8Reg(0x4b7, 0xd8);
3138   1        WriteU8Reg(0x4b8, 0x31);
3139   1        WriteU8Reg(0x4b9, 0xa3);
3140   1        WriteU8Reg(0x4ba, 0x47);
3141   1        WriteU8Reg(0x4bb, 0x8d);
3142   1        WriteU8Reg(0x4bc, 0x1c);
3143   1        WriteU8Reg(0x4bd, 0x31);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 53  

3144   1        WriteU8Reg(0x4be, 0x74);
3145   1        WriteU8Reg(0x4bf, 0xc8);
3146   1        WriteU8Reg(0x4c0, 0xe0);
3147   1        WriteU8Reg(0x4c1, 0x41);
3148   1        WriteU8Reg(0x4c2, 0x03);
3149   1        WriteU8Reg(0x4c3, 0x07);
3150   1        WriteU8Reg(0x4c4, 0x14);
3151   1        WriteU8Reg(0x4c5, 0x2d);
3152   1        WriteU8Reg(0x4c6, 0x52);
3153   1        WriteU8Reg(0x4c7, 0xb8);
3154   1        WriteU8Reg(0x4c8, 0x50);
3155   1        WriteU8Reg(0x4c9, 0xc1);
3156   1        WriteU8Reg(0x4ca, 0x02);
3157   1        WriteU8Reg(0x4cb, 0x41);
3158   1        WriteU8Reg(0x4cc, 0x83);
3159   1        WriteU8Reg(0x4cd, 0x04);
3160   1        WriteU8Reg(0x4ce, 0x0e);
3161   1        WriteU8Reg(0x4cf, 0x14);
3162   1        WriteU8Reg(0x4d0, 0x30);
3163   1        WriteU8Reg(0x4d1, 0x80);
3164   1        WriteU8Reg(0x4d2, 0x51);
3165   1        WriteU8Reg(0x4d3, 0x23);
3166   1        WriteU8Reg(0x4d4, 0x86);
3167   1        WriteU8Reg(0x4d5, 0x0d);
3168   1        WriteU8Reg(0x4d6, 0x19);
3169   1        WriteU8Reg(0x4d7, 0x04);
3170   1      #endif 
3171   1      #if 0
                  // Disable ADC hold - Rachel 0318-2014
                WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x44D, 0x0);
                WriteU8Reg(0x44F, 0x0);
                WriteU8Reg(0x4FA, 0x0); 
              #endif
3178   1      #ifdef B_ASICPLC
3179   1          mac_utils_spi_write(0x16,0x01);    // Enable PLC mode for AFE
3180   1          mac_utils_spi_write(0x36,0x12);   //added by YM, Jenny suggested 
3181   1      #endif
3182   1          //He li provided following regs for DC Offset setting
3183   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3184   1           mac_utils_spi_write(0x3a,0x08);   //added by varsha
3185   1           mac_utils_spi_write(0x3b,0x40);   //added by varsha 
3186   1           mac_utils_spi_write(0x18,0xa0);   //added by varsha
3187   1         // add delay > 100us
3188   1         CHAL_DelayTicks(6400);
3189   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3190   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3191   1           mac_utils_spi_write(0x3a,0x0f);   //added by varsha 
3192   1           mac_utils_spi_write(0x3b,0x74);   //added by varsha
3193   1           mac_utils_spi_write(0x18,0xc0);   //added by varsha
3194   1         // add delay > 100us
3195   1         CHAL_DelayTicks(6400);
3196   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3197   1         
3198   1      #ifdef B_ASICPLC
3199   1           mac_utils_spi_write(0x36,0x0);   //added by YM, Jenny suggested 
3200   1           mac_utils_spi_write(0x16,0x0);
3201   1      #endif
3202   1      
3203   1      //#ifdef B_FPGA
3204   1           WriteU8Reg(0x47F, 0x05);
3205   1      //#endif
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 54  

3206   1           WriteU8Reg(0x485, TCC_REG_485_486_val[2][0]);  //TCC =3
3207   1           WriteU8Reg(0x486, TCC_REG_485_486_val[2][1]);
3208   1      
3209   1      //#ifdef HPGP_HAL_TEST // WAR: code reactivated to reduce loss in lower mac
3210   1      //    WriteU8Reg(0x478, 0x61); 
3211   1      //#else
3212   1      //    WriteU8Reg(0x478, 0x51); 
3213   1      //#endif  
3214   1      
3215   1      #if 0
                  // [YM] PHY setting for Hybrii_B FPGA HP101/HP11 Detection 
                  if (gHpgpHalCB.HP101Detection)
                  {
                     plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);   
                   plcStatus.s.HP10Detect = 1;         //Enable MAC for HP10 detection
                     WriteU32Reg(PLC_STATUS_REG,plcStatus.reg);
                      
                      WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
                      tmp = ReadU8Reg(0x46F);
                      WriteU8Reg(0x46F, tmp&0xF7);  //Enable HP101 detection bit
                      WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
                  } 
              #endif
3229   1          
3230   1        // [YM] Based on Jayesh's suggestion 0307-2014
3231   1              WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
3232   1              WriteU8Reg(0x46F, 0xB);  //Enable HP101 detection bit
3233   1              WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
3234   1      #ifdef B_FPGA    
                  // Energy Detection Threshold
                  WriteU8Reg(0x478, 0x69);  //WAR: code should be deactivated to reduce loss in lower mac // according to
             - geetha comments 11/6/2012
              #endif
3238   1      //#ifdef MPER    
3239   1          mac_utils_spi_write(0x34,0x0);   //Set default txpowermode = 2 (High Tx Power Mode)
3240   1        mac_utils_spi_write(0x35,0xF);   //added by YM 0211-2014
3241   1      //#else 
3242   1      //  mac_utils_spi_write(0x34,0x08);    //Set default txpowermode = 0 (Auto Power Mode)
3243   1      //    mac_utils_spi_write(0x35,0x30);   //added by YM 0211-2014
3244   1      //#endif  //MPER
3245   1      
3246   1      #ifndef B_ASICPLC    
                // [YM] Set timeout value, based on He Li suggest
                WriteU8Reg(0x4DF, 0xCA);
              #endif  //B_ASICPLC
3250   1        
3251   1      #if (defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)  
              
              
              //#ifdef GV7013
                  
                    //[YM] change new setting value for long range 11-21-2013, make it as default for GV7013
                      WriteU8Reg(0x48a, 0xEA);   //the same as current default value
                      WriteU8Reg(0x48b, 0x00);
                      WriteU8Reg(0x484, 0x52);
                      WriteU8Reg(0x478, 0x11);
                      WriteU8Reg(0x483, 0x33);
                WriteU8Reg(0x4E0, 0xFF);
                WriteU8Reg(0x4DF, 0xFF);
              //#endif    
              //#if (defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)       
                      //[YM] add new setting value for LED, 01-09-2014
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 55  

                      WriteU8Reg(0x4F0, 0x80);  //Turn off SCO in PHY, Extend Range
              #endif  //(defined ER_TEST) || (defined LLP_APP_MASTER) || (defined LLP_APP_SLAVE)
3269   1          // Force Hybrid Mode  
3270   1      //    WriteU8Reg(0x4EB, 0x18);  
3271   1      
3272   1      
3273   1          // Reset/Init Statistics
3274   1          HHAL_ResetPlcStat();
3275   1         
3276   1          //WriteU8Reg(0xF07,0x01);           // csma 
3277   1      #ifndef B_ASICPLC
                  WriteU8Reg(0x423,0xC3);
              ////////////////////////////////////////////////////////////////
                 //WriteU8Reg(0xF07,0x01);
                 //WriteU8Reg(0xF06,0x00);
              #else
3283   1         //WriteU8Reg(0xF07,0xC1);
3284   1         //WriteU8Reg(0xF06,0x00);
3285   1         WriteU8Reg(0x423,0x81);
3286   1      #endif
3287   1         
3288   1          HHAL_AFEInit();
3289   1      
3290   1      //Set default Rx power mode to 1 - Reduce ADC power consumption
3291   1          mac_utils_spi_write(0x26, 0x1C);   //added by Yiming, 0211-2013
3292   1      
3293   1        // init CP Map
3294   1        for (i = 0; i < HYBRII_CPCOUNT_MAX; i++)
3295   1        {
3296   2          uPlcCpMapIdx plcCpMapIdx;
3297   2          uPlcCpMap plcCpMap;
3298   2      //    uPlcCpuWrCp plcCpuWrCp;
3299   2      
3300   2          plcCpMapIdx.reg = 0;
3301   2          plcCpMapIdx.s.cp_map_idx = i;
3302   2          WriteU32Reg(CPU_CPUSAGECNTIDX_REG, plcCpMapIdx.reg);
3303   2      
3304   2          plcCpMap.reg = 0;
3305   2          plcCpMap.s.cp_map = 1;
3306   2          WriteU32Reg(CPU_CPUSAGECNT_REG, plcCpMap.reg);
3307   2      
3308   2      //    CHAL_DecrementReleaseCPCnt(i);
3309   2        }
3310   1      //    WriteU32Reg(PLC_LINECTRL_REG,ctorl(0x400));
3311   1      
3312   1        // init Hang Counter Int.
3313   1        plcSMCnt.reg = RTOCL(PLC_SM_MAX_CLK_CNT);
3314   1        plcSMCnt.s.enable = TRUE;
3315   1        WriteU32Reg(PLC_SM_MAXCNT, plcSMCnt.reg);
3316   1      
3317   1      // [YM] For Hybrii_B LLP LED project
3318   1      #ifdef LED_PWM
                  WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x45C, 0x0);
                WriteU8Reg(0x45D, 0x0);
                WriteU8Reg(0x45E, 0x0);
                WriteU8Reg(0x45F, 0x0);
                WriteU8Reg(0x460, 0x0);
                WriteU8Reg(0x461, 0x0);
                WriteU8Reg(0x462, 0x0);
                WriteU8Reg(0x463, 0x0);
                WriteU8Reg(0x464, 0x0);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 56  

                WriteU8Reg(0x465, 0x0);
                WriteU8Reg(0x466, 0x0);
                WriteU8Reg(0x467, 0x0);
                WriteU8Reg(0x468, 0x0);
                WriteU8Reg(0x469, 0x0);
                WriteU8Reg(0x46A, 0x0);
                WriteU8Reg(0x46B, 0x0);
                //WriteU8Reg(0x45A, 0xDF);
                //WriteU8Reg(0x45B, 0x05);
                //[YM] 0610-2014, He Li requested range change from 1 ~ 0x2EB
                WriteU8Reg(0x45A, 0xEC);
                WriteU8Reg(0x45B, 0x02);
                WriteU8Reg(0x458, 0x11);
                WriteU8Reg(0x459, 0x11);
                WriteU8Reg(0x4FA, 0x0);
              
                //Set Init value for PWM LED channel
                
                  {
                       WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x45E, 0x01);
                   WriteU8Reg(0x45F, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                  }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x462, 0x01);
                   WriteU8Reg(0x463, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x466, 0x01);
                   WriteU8Reg(0x467, 0x0);
                   //WriteU8Reg(0x4FA, 0x0);
                }
                
                {
                     //WriteU8Reg(0x4FA, 0x01);
                   WriteU8Reg(0x46A, 0x01);
                   WriteU8Reg(0x46B, 0x0);
                   WriteU8Reg(0x4FA, 0x0);
                }
              
              #endif
3376   1      #ifdef LED_DC
                  WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x45C, 0x0);
                WriteU8Reg(0x45D, 0x0);
                WriteU8Reg(0x45E, 0x0);
                WriteU8Reg(0x45F, 0x0);
                WriteU8Reg(0x460, 0x0);
                WriteU8Reg(0x461, 0x0);
                WriteU8Reg(0x462, 0x0);
                WriteU8Reg(0x463, 0x0);
                WriteU8Reg(0x464, 0x0);
                WriteU8Reg(0x465, 0x0);
                WriteU8Reg(0x466, 0x0);
                WriteU8Reg(0x467, 0x0);
                WriteU8Reg(0x468, 0x0);
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 57  

                WriteU8Reg(0x469, 0x0);
                WriteU8Reg(0x46A, 0x0);
                WriteU8Reg(0x46B, 0x0);
                WriteU8Reg(0x45A, 0xFF);
                WriteU8Reg(0x45B, 0x0);
                WriteU8Reg(0x458, 0x0);
                WriteU8Reg(0x459, 0x10);
                WriteU8Reg(0x4FA, 0x0);
              
                //Set Init value for DC10V LED channel
                WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x46A, 0x01);
                WriteU8Reg(0x4FA, 0x0);
              #endif
3405   1      #ifdef POWERSAVE_NO
                  byteVal = ReadU8Reg(0x422);
                byteVal |= 0x8;
                  WriteU8Reg(0x422,byteVal);
              #endif
3410   1      }
3411          
3412              
3413          void HHAL_ResetPlcStat()
3414          {   
3415   1          memset(&gHpgpHalCB.halStats, 0, sizeof(shpgpHalStats));
3416   1          
3417   1          // Clear Err Count registers
3418   1          WriteU32Reg(PLC_ADDRFILTERERRCNT_REG, 0);
3419   1          WriteU32Reg(PLC_FCCSERRCNT_REG, 0);
3420   1          WriteU32Reg(PLC_PBCSRXERRCNT_REG, 0);
3421   1          WriteU32Reg(PLC_PBCSTXERRCNT_REG, 0);
3422   1          WriteU32Reg(PLC_ICVERRCNT_REG, 0);  
3423   1          WriteU32Reg(PLC_MPDUDROPCNT_REG, 0);  
3424   1        
3425   1        gHalCB.qc_no_1st_desc = 0; 
3426   1        gHalCB.qc_too_many_desc = 0; 
3427   1        gHalCB.qc_no_desc = 0; 
3428   1        gHalCB.qc_no_grant = 0; 
3429   1          gHalCB.cp_no_grant_alloc_cp = 0;
3430   1          gHalCB.cp_no_grant_free_cp = 0;
3431   1          gHalCB.cp_no_grant_write_cp = 0;
3432   1          gHalCB.cp_no_grant_read_cp = 0;
3433   1      }
3434          
3435          // Internal functios 
3436          
3437          void hhal_setStaSnidValid()
3438          {
3439   1          uPlcDevCtrlReg plcDevCtrl;
3440   1      
3441   1          if(gHpgpHalCB.devMode == DEV_MODE_STA)
3442   1          {
3443   2              plcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
3444   2              plcDevCtrl.s.snidValid = 1;
3445   2              WriteU32Reg(PLC_DEVCTRL_REG, plcDevCtrl.reg);
3446   2          }   
3447   1      }
3448          
3449          void hal_hpgp_mac_monitoring (void)
3450          {
3451   1          u32             sm_status1;
3452   1          u32             sm_status2;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 58  

3453   1      
3454   1          uPlcMedStatReg  plcMedStat;
3455   1      
3456   1      /*    if(gHpgpHalCB.halStats.bcnSyncCnt == 1 && ReadU32Reg(PLC_FCCSERRCNT_REG)!=0)
3457   1          {
3458   1              // Reset mpi Rx
3459   1              HHAL_mpiRxReset();
3460   1              //FM_Printf(FM_MINFO,"Resetting Mpi Rx\n");
3461   1          }*/
3462   1          if (gHpgpHalCB.halStats.macTxStuckCnt > 1000) {
3463   2              //printf("\nMAC Tx Stucked");
3464   2          }
3465   1          if (gHpgpHalCB.halStats.macRxStuckCnt > 1000) {
3466   2              //printf("\nMAC Rx Stucked");
3467   2          }
3468   1          //sm_status1 = ReadU32Reg(PLC_SMSHADOW1_REG);// & 0x00003fff;
3469   1          sm_status1 =  hal_common_reg_32_read(PLC_SMSHADOW1_REG);
3470   1          sm_status2 = ReadU32Reg(PLC_SMSHADOW2_REG); //& 0x03ffffff;
3471   1      
3472   1          if (sm_status1 == 0 && sm_status2 == 0) {
3473   2              plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
3474   2              if (plcMedStat.s.phyActive) {
3475   3                  gHpgpHalCB.halStats.phyStuckCnt++;
3476   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3477   4                      //printf("\nPhy Stucked");
3478   4                      // gHpgpHalCB.halStats.macHangRecover1++;
3479   4                      //gHpgpHalCB.halStats.macRxStuckCnt = 0;
3480   4                      /*
3481   4                       * MAC is idle but Phy is stuck. Reset the PHY
3482   4                       * by dropping RX Enable
3483   4                       */
3484   4                      //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3485   4                      //plcStatus.s.nRxEn = 1;
3486   4                      //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3487   4                  }
3488   3              } else {
3489   3                  gHpgpHalCB.halStats.phyStuckCnt = 0;
3490   3              }
3491   2              if (plcMedStat.s.mpiRxEn == 0) {
3492   3                  gHpgpHalCB.halStats.mpiRxStuckCnt++;
3493   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3494   4                      //printf("\nMPI RX Stucked");
3495   4                  }
3496   3              } else {
3497   3                  gHpgpHalCB.halStats.mpiRxStuckCnt = 0;
3498   3              }
3499   2          } else {
3500   2              if (sm_status2 != 0) {
3501   3                  gHpgpHalCB.halStats.smTxStuckCnt++;
3502   3                  if (gHpgpHalCB.halStats.smTxStuckCnt > 1000) {
3503   4                      //printf("\nSM TX Stucked");
3504   4                  }
3505   3              } else {
3506   3                  gHpgpHalCB.halStats.smTxStuckCnt = 0;
3507   3              }
3508   2              if (sm_status1 != 0) {
3509   3                  gHpgpHalCB.halStats.smRxStuckCnt++;
3510   3                  if (gHpgpHalCB.halStats.smRxStuckCnt > 1000) {
3511   4                     // printf("\nSM RX Stucked");
3512   4                  }
3513   3              } else {
3514   3                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 59  

3515   3              }
3516   2          }
3517   1      }
3518          
3519          #ifndef HPGP_HAL_TEST
              
              eStatus  HHAL_BcnRxIntHandler(sHaLayer *hal, sEvent *event)
              {
                  sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
                  u32              *pValue32 = NULL;
                  u32               value32 = 0;
                  sHybriiRxBcnHdr*  pRxBcnHdr = NULL;
                  u8                i;
                  uPlcStatusReg     plcStatus;
                  eStatus           ret = STATUS_SUCCESS;
                  sHpgpHdr         *hpgpHdr = NULL;
                  sHpgpHalCB       *hhalCb = hal->hhalCb;
                u8         *rxArr;
                  u8               u8val;
                  
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
              
                  hhalCb->halStats.BcnRxIntCnt++;
              
                  //FM_Printf(FM_MINFO, "HHAL_BcnRxIntHandler : Bcn received, SnapShot = %bu, Id = %lX\n", pRxBcnHdr->sn
             -apShot, rtocl(ReadU32Reg(PLC_IDENTIFIER_REG)));
              
                  // Confirm that Bcn Rx Fifo is not emplty.
                  // plcStatus.s.bcnRxFifoStat;
                  /* read the beacon Rx descriptor first */
                  value32 = ReadU32Reg(PLC_BCNRXFIFO_REG);
                  pRxBcnHdr = (sHybriiRxBcnHdr*)&value32;
                  hhalCb->snapShot = pRxBcnHdr->snapShot;
                  /* then, read the beacon */
                pValue32  = (u32 *)(event->buffDesc.dataptr);
              #ifdef UM
                if(1 == eth_plc_sniffer)
                {
                    pValue32  += ((sizeof(sEth2Hdr) + sizeof(hostHdr_t)) / sizeof(u32)); // Ethernet header + Hybrii head
             -er
                }
              #endif
              
                for ( i = 0; i < (BEACON_LEN >> 2); i++)
                  {
                      pValue32[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
                  }
                event->buffDesc.datalen = BEACON_LEN;
                  //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  //plcStatus.s.decBcnRxCnt = 1;
                  //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                  u8val = ReadU8Reg(PLC_STATUS_REG+1);
                u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
                WriteU8Reg(PLC_STATUS_REG+1, u8val);
                rxArr = event->buffDesc.dataptr;
              #ifdef UM 
              #ifdef HYBRII_ETH
                if(1 == eth_plc_sniffer)
                {
                    EHT_FromPlcBcnTx(rxArr, PLC_BCNRX_LEN);
                }
                else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 60  

              #endif
              #endif
                  {
                      // Update statistics.
              
                          /* TODO: if consective good beacons are received */
              
              
                      if(pRxBcnHdr->fccsCorrect)
                      {
                          hhalCb->bcnDetectFlag = 1;
                          pFrmCtrlBlk = (sFrmCtrlBlk*) (event->buffDesc.dataptr);
                          hhalCb->bts = ((u32)(pFrmCtrlBlk->bts[3])<<24) + 
                                        ((u32)(pFrmCtrlBlk->bts[2])<<16) + 
                                        ((u32)(pFrmCtrlBlk->bts[1])<<8) + 
                                         (u32)(pFrmCtrlBlk->bts[0]);                      
                          /* TODO: Adjust NTB in the device */
                             gCCO_NTB =  hhalCb->bts;   
              
                             gHpgpHalCB.bcnmisscnt = 0;
              
              
                                         
                             gCCO_BTS =  hhalCb->bts;
                  // Extract Bto, ded
                  
              //            HHAL_AdjustNextBcnTime(hal, pFrmCtrlBlk->bto);
                      }
                      // Update statistics.
                      if (pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && 
                          !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && 
                          !pRxBcnHdr->rsv3 && !pRxBcnHdr->rsv4 )  
                      {  
                          hhalCb->halStats.TotalRxGoodFrmCnt++;
                          hhalCb->halStats.RxGoodBcnCnt++;
              
                          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                      //            hpgpHdr->tei = rxdesc->ste;
                          hpgpHdr->snid = pFrmCtrlBlk->snid;
                          {
                              event->buffDesc.dataptr += sizeof(sFrmCtrlBlk); 
                              event->buffDesc.datalen -= sizeof(sFrmCtrlBlk); 
                              /* process the high priority portion of the beacon */
              #ifdef CALLBACK
                              hal->procBcn(hal->bcnCookie, event);
              #else
                              if (hhalCb->devMode == DEV_MODE_CCO)
                              {
              #ifdef CCO_FUNC
                                  LINKL_CcoProcBcnHandler(hal->bcnCookie, event);
              #endif
                              }
                              else 
                              {
              #ifdef STA_FUNC
                                  LINKL_StaProcBcnHandler(hal->bcnCookie, event);
              #endif
                              }
              #endif
                          }
                      } 
                      else
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 61  

                      {
                          hhalCb->halStats.RxErrBcnCnt++;
                          /* bad beacon is received, thus the beacon is lost */
                          /* TODO: adjust the next becaon period using bto */
                          hhalCb->bcnDetectFlag = 0;
                          ret = STATUS_FAILURE;
                      }
              
                  }
                  // Any more beacons ?
              //    plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
              
                  return ret;
              }
              
              u8 HHAL_GetBcnCnt(sHaLayer *hal)
              {
                  uPlcStatusReg     plcStatus;
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  return plcStatus.s.plcBcnCnt;
              }
              
              
              
              eStatus HHAL_PrepareTxFrame(sHaLayer *hal, sTxDesc *txInfo, 
                                          sSwFrmDesc *txFrmSwDesc)
              {
                  //FM_Printf(FM_MINFO, ">>>PrepareTxFrame:\n");
              
                  if(txInfo->mnbc)
                  {
                      txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
                  }
                  else if(txInfo->dtei == 0xFF)
                  {
                      txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                  }
                  else
                  {
                      txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
                  }
              
                if (txInfo->mcst == 1)
                {
                  txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                }
                
              //printf("HHAL_PrepareTxFrame=%bu, txInfo->dtei=%bu\n", HHAL_PrepareTxFrame, txInfo->dtei);
                  txFrmSwDesc->frmInfo.plc.dtei = txInfo->dtei;
                  txFrmSwDesc->frmInfo.plc.stei = hal->hhalCb->tei;
                  txFrmSwDesc->frmInfo.plc.eks = txInfo->eks;
              
                  txFrmSwDesc->frmInfo.plc.clst = HPGP_CLST_ETH;
                  txFrmSwDesc->frmInfo.plc.plid = txInfo->plid;
                  txFrmSwDesc->frmInfo.plc.mfStart = txInfo->mfStart;
                  txFrmSwDesc->frmInfo.plc.mfEnd = txInfo->mfEnd;
                 
                  if (txInfo->plid == PRI_LINK_ID_0) 
                      txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP0;
                  else
                      txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP123;
              
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 62  

                  txFrmSwDesc->frmInfo.plc.roboMode = txInfo->roboMode;
              
              
                txFrmSwDesc->frmInfo.plc.snid = txInfo->snid;
              
              
              #if 0
                  if (txInfo->roboMode == HPGP_ROBOMD_MINI)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_136;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_MINIROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else if (txInfo->roboMode == HPGP_ROBOMD_STD)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_STDROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else
                  {
                      /* HS ROBO */
                      txFrmSwDesc->frmInfo.plc.roboMode = HPGP_ROBOMD_HS;
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      if (txInfo->numPbs == 1)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_1PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                      }
                      else if (txInfo->numPbs == 2)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_2PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_TWO_PB;
                      }
                      else if (txInfo->numPbs == 3)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_3PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_THREE_PB;
                      }
                      else 
                      {
                          FM_Printf(FM_ERROR,"HHAL: PB Num Err");
                          return STATUS_FAILURE;
                      }
                  }
              #endif
              
                  //FM_Printf(FM_MINFO, "<<<PrepareTxFrame:\n");
              
                  return STATUS_SUCCESS;      
              }
              
              #endif
3752          
3753          
3754          /*******************************************************************
3755          * NAME :            HHAL_AdjustNextBcnTime
3756          *
3757          * DESCRIPTION :     The function is called at STA side passing the bto as input.
3758          *                   It adjusts the BP Length based on the 2's complement bto value
3759          *                   that CCo sends in the FC.bto[0] field.
3760          *
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 63  

3761          */
3762          #ifdef HPGP_HAL_TEST
3763          void HHAL_AdjustNextBcnTime(u16 *bto)
3764          #else
              void HHAL_AdjustNextBcnTime(sHaLayer *hal, u16 *bto)
              #endif
3767          {
3768   1          u16 btoVal = le16_to_cpu(*bto);
3769   1          if (gHpgpHalCB.lineMode == LINE_MODE_AC)
3770   1          {   
3771   2              // bto is a negative 2's complement value.
3772   2              if( btoVal > 0x8000)
3773   2              {
3774   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN - (0x10000 - btoVal);
3775   3              }
3776   2      
3777   2              // bto is a positive 2's complement value
3778   2              else if( btoVal != 0x8000)
3779   2              {
3780   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN + btoVal;       
3781   3              }
3782   2              
3783   2              //printf("bpLen = %lx, bto=%bx%02bx, %x\n", gHpgpHalCB.curBcnPer, pFrmCtrlBlk->bto0[1], pFrmCtrlBl
             -k->bto0[0], bto);
3784   2      
3785   2              if(gHpgpHalCB.devMode == DEV_MODE_STA)
3786   2              {
3787   3                  WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
3788   3      
3789   3              }
3790   2          }
3791   1          else
3792   1          {
3793   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
3794   2          }
3795   1      }
3796          
3797          #ifdef UM 
                   
              eStatus CHAL_WriteFrame(sHaLayer *hal, 
                                      sSwFrmDesc *txFrmSwDesc, 
                                      sBuffDesc *buffdesc)
              {
                  s16 resLen = buffdesc->datalen;
                  u8  numCps = txFrmSwDesc->cpCount;
                  u16 cellLen = 0;
                  u8  i = 0;
                  u8  *dataptr = buffdesc->dataptr;
                  volatile u8 XDATA *cellBlk = NULL;
                  sCpSwDesc *cpDesc = NULL;
              
              
                  while ((resLen > 0) && (i < numCps))
                  {
                      cpDesc = &txFrmSwDesc->cpArr[i];
                      cellBlk = CHAL_GetAccessToCP(cpDesc->cp);
                      cellLen = MIN(HYBRII_CELLBUF_SIZE, resLen);
                      memcpy (cellBlk, dataptr, cellLen);
                      cpDesc->offsetU32 = 0; 
                      cpDesc->len = (u8)cellLen; 
                      dataptr += cellLen;
                      resLen -= cellLen;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 64  

                      i++;
                  }
              
                  if ((resLen > 0) && (i >= numCps))
                  {
                   //   FM_Printf(FM_ERROR, "CHAL: frame len and cp number mismatch.\n");
                  }
                  return STATUS_SUCCESS;
              }
              
              #endif
3833          
3834          
3835          void doSynchronization()
3836          {
3837   1           
3838   1         u32 zcCCONTB;
3839   1           
3840   1           zcCCONTB =  rtocl(ReadU32Reg(PLC_ZCNTB_REG));
3841   1      
3842   1      
3843   1           if(firsttime == 0)
3844   1           {
3845   2              firsttime = 1;
3846   2              zcCCONTBold = zcCCONTB; 
3847   2              return;
3848   2           }
3849   1      
3850   1         gHpgpHalCB.syncComplete = 1;
3851   1         
3852   1           if(zcCCONTB > zcCCONTBold)
3853   1              gHpgpHalCB.curBcnPer   = (zcCCONTB - zcCCONTBold);
3854   1           
3855   1      
3856   1           if((gHpgpHalCB.lineMode == LINE_MODE_AC) && (gHpgpHalCB.curBcnPer  < AC_MIN_THRESHOLD))
3857   1           {
3858   2              return;
3859   2           } 
3860   1           
3861   1           zcCCONTBold = zcCCONTB; 
3862   1            
3863   1          if( gHpgpHalCB.devMode == DEV_MODE_CCO && gHpgpHalCB.lineMode == LINE_MODE_AC )
3864   1          {
3865   2              
3866   2              //printf("\n BP = %lu", (gHpgpHalCB.curBcnPer * 40));
3867   2              if( gHpgpHalCB.curBcnPer < PLC_MIN_AC_BPLEN )
3868   2              {
3869   3                  gHpgpHalCB.curBcnPer = PLC_MIN_AC_BPLEN;
3870   3              }
3871   2              else if( gHpgpHalCB.curBcnPer > PLC_MAX_AC_BPLEN )
3872   2              {
3873   3                  gHpgpHalCB.curBcnPer = PLC_MAX_AC_BPLEN;
3874   3              }
3875   2      
3876   2              gHpgpHalCB.bcnPerSum += gHpgpHalCB.curBcnPer;
3877   2              gHpgpHalCB.perSumCnt ++;
3878   2      
3879   2              if( gHpgpHalCB.perSumCnt == PLC_BCNPERAVG_CNT )
3880   2              {
3881   3                  gHpgpHalCB.bPerAvgInitDone = 1;
3882   3                  avgdone = 1;
3883   3              }
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 65  

3884   2             
3885   2              if(avgdone)
3886   2              {
3887   3                   avgdone = 0;
3888   3                   gavg       = gHpgpHalCB.bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
3889   3                   gHpgpHalCB.bcnPerSum = 0;
3890   3                   gHpgpHalCB.perSumCnt = 0;
3891   3              }
3892   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gavg >> 1)));
3893   2               
3894   2           }
3895   1      
3896   1          // Prepare and send beacon here for now.
3897   1          // This will eventually be done by hpgp nsm module.
3898   1              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
3899   1              {
3900   2                  gHpgpHalCB.bPerAvgInitDone = 1;
3901   2                   gavg       =   PLC_DC_BP_LEN; 
3902   2              }
3903   1      
3904   1            if(gHpgpHalCB.bPerAvgInitDone)
3905   1          {
3906   2                
3907   2              if(gHpgpHalCB.devMode == DEV_MODE_CCO)
3908   2            {
3909   3             
3910   3                if(zctrack == 0)
3911   3                      {
3912   4                       
3913   4                          gbpst =  gavg  + zcCCONTB + MAC_PROCESSING_CLOCK ;// + 0x1BAFF;//1365 is bpsto
3914   4                          zctrack = 1;
3915   4                          WriteU32Reg(PLC_BPST_REG, ctorl(gbpst));
3916   4                     
3917   4                      }
3918   3                      else
3919   3                      {
3920   4                      
3921   4                           avgcount++;
3922   4                           if(zcCCONTB >  gbpst)
3923   4                           {
3924   5                              
3925   5                               if(gNegativeflag)
3926   5                               {
3927   6                                 gNegativeflag = 0;
3928   6                                 gPositiveflag = 1; 
3929   6                                
3930   6                               }
3931   5                               gBPSTdelta = zcCCONTB - gbpst;
3932   5                              
3933   5                              if(gBPSTdelta > 400)//16 micro sec
3934   5                              {
3935   6                                  
3936   6                                   gNegativeflag = 0;
3937   6                                   gPositiveflag = 1;
3938   6                               }
3939   5                              
3940   5                           }
3941   4                           else
3942   4                           {
3943   5                               if(gPositiveflag)
3944   5                               {
3945   6                                 gNegativeflag = 1;
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 66  

3946   6                                 gPositiveflag = 0; 
3947   6                                
3948   6                               }
3949   5                               gBPSTdelta =  gbpst - zcCCONTB;
3950   5                               
3951   5                               if(gBPSTdelta > 400)//4 micro sec
3952   5                               {
3953   6                                  gNegativeflag = 1;
3954   6                                  gPositiveflag = 0;
3955   6                                 
3956   6                               }   
3957   5                              
3958   5                            }
3959   4                       
3960   4                       } 
3961   3                   }
3962   2               
3963   2            } 
3964   1      
3965   1      }  
3966          
3967          #ifdef FREQ_DETECT
3968          void FREQDET_DetectFrequencyUsingZC()
3969          {   
3970   1          static u8 count = 0;
3971   1           static u8 Retrycnt = 0;
3972   1          static u8 valid60Hz =0;
3973   1          static u8 valid50Hz =0;
3974   1          u32  zcCCONTB;
3975   1          static u32 zcCCONTBOld = 0;
3976   1          u32 linecyclePer;
3977   1          u8 freq;
3978   1          
3979   1      //    uPlcMedInterruptReg PlcMedInterruptReg;
3980   1         
3981   1      #ifdef UM
                  sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
              #endif
3984   1          count++;
3985   1          zcCCONTB =  rtocl(ReadU32Reg(PLC_ZCC_CCONTB_REG));
3986   1          //zcCCONTB =  rtocl(ReadU32Reg(PLC_NTB_REG));
3987   1          linecyclePer = (((zcCCONTB - zcCCONTBOld) * 40) / 2);
3988   1           freq = (1000000000/ linecyclePer);
3989   1          // printf("\n freq = %lu\n", ((zcCCONTB - zcCCONTBOld) * 40)); 
3990   1          zcCCONTBOld = zcCCONTB;
3991   1         
3992   1      
3993   1          if((freq <= MAX_60HZ_FREQ) && (freq >= MIN_60HZ_FREQ))
3994   1          {
3995   2              valid60Hz++;
3996   2          }
3997   1          else if((freq <= MAX_50HZ_FREQ) && (freq >= MIN_50HZ_FREQ))
3998   1          {
3999   2                valid50Hz++;
4000   2          }
4001   1       
4002   1      
4003   1          if(count == 8)
4004   1          { 
4005   2              //Retrycnt++;
4006   2              gHpgpHalCB.gFreqCB.freqDetected = TRUE; 
4007   2              if(valid50Hz > FREQUENCY_ZC_MAX_COUNT)
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 67  

4008   2              {
4009   3                
4010   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4011   3                  FREQDET_FreqSetting(FREQUENCY_50HZ);            
4012   3                  printf("\n50 HZ detected\n");
4013   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4014   3              }
4015   2              else if(valid60Hz > FREQUENCY_ZC_MAX_COUNT)
4016   2              {
4017   3                
4018   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4019   3                  FREQDET_FreqSetting(FREQUENCY_60HZ);            
4020   3                  printf("\n60 HZ detected\n");
4021   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4022   3              }
4023   2              else
4024   2              {
4025   3                 //do not set any default frequency ,insted keep on retrying and based on   gHpgpHalCB.gFreqCB.f
             -reqDetected flag Upper MAc will recognised that freq is not being detected for some problem
4026   3      #ifdef UM
                         sHaLayer *hal = HOMEPLUG_GetHal();
              #endif
4029   3             
4030   3                 printf("\n No Frequency detected" );
4031   3                 printf("\n switching to DC ..." );
4032   3                 count = 0;
4033   3                 gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4034   3             
4035   3             gHpgpHalCB.lineMode = LINE_MODE_DC;
4036   3             gHpgpHalCB.lineFreq = FREQUENCY_50HZ;      
4037   3             
4038   3      #ifdef UM
                     HHAL_SetDevMode(hal, gHpgpHalCB.devMode, LINE_MODE_DC);
              #else
4041   3             HHAL_SetDevMode(gHpgpHalCB.devMode, LINE_MODE_DC);
4042   3      #endif
4043   3             
4044   3             FREQDET_FreqSetting(gHpgpHalCB.lineFreq);
4045   3      
4046   3      
4047   3                 //gHpgpHalCB.gFreqCB.freqDetectUsingZC = TRUE;
4048   3              }
4049   2      #ifdef UM
                      CNSM_InitRegion(&linkl->ccoNsm, linkl);
              
              #else
4053   2          
4054   2      if(gHpgpHalCB.devMode == DEV_MODE_CCO)
4055   2          setCSMA_onCCO();
4056   2      else
4057   2          setCSMA_onSTA();
4058   2      
4059   2      #endif
4060   2      
4061   2             
4062   2          }
4063   1      }
*** WARNING C280 IN LINE 3971 OF ..\..\hal\hal_hpgp.c: 'Retrycnt': unreferenced local variable
4064          
4065          void FREQDET_DetectFrequencyUsingBcn()
4066          {
4067   1      #ifndef HPGP_HAL_TEST
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 68  

                  sHaLayer *hal = HOMEPLUG_GetHal();
              #endif 
4070   1          u32     calcBCNper;
4071   1         // static u8 bcnCnt = 0;
4072   1          
4073   1          calcBCNper = gCCO_BTS - gOldBTS;
4074   1      
4075   1          //printf("\n bp = %lu", calcBCNper);
4076   1          gOldBTS = gCCO_BTS;
4077   1         // bcnCnt++;
4078   1      
4079   1       
4080   1              if(gHpgpHalCB.halStats.BcnSyncCnt >= FREQUENCY_BCN_MAX_COUNT)   //set the frequency after syncing 
             -four bcns
4081   1              {
4082   2                  if(((calcBCNper * 40) > MIN_50HZ_BCNPER) && ((calcBCNper * 40) < MAX_50HZ_BCNPER))//38 ms   it
             - is 50 Hz that means bcnper is 40 ms
4083   2                  {                
4084   3                      //gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4085   3                      FREQDET_FreqSetting(FREQUENCY_50HZ);                
4086   3                      printf("\n50 HZ detected\n");
4087   3                     // bcnCnt = 0;
4088   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4089   3      
4090   3                  }
4091   2                  else if(((calcBCNper * 40) < MIN_50HZ_BCNPER))//33.33 ms , 60 hz
4092   2                  {             
4093   3                     // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4094   3                      printf("\n bp = %lu",(calcBCNper * 40));
4095   3      
4096   3                      FREQDET_FreqSetting(FREQUENCY_60HZ);                
4097   3                      printf("\n60 HZ detected\n");
4098   3                      //bcnCnt = 0;
4099   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4100   3                    
4101   3                  }
4102   2              }
4103   1          
4104   1      
4105   1      }
4106          //#endif 
4107          
4108          //#ifdef FREQ_DETECT
4109          void FREQDET_FreqDetectInit(void)
4110          {    
4111   1         // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4112   1         // gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4113   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4114   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4115   1          //HHAL_SetPlcDevMode(STA_CSMANW);
4116   1         
4117   1      //   gHpgpHalCB.bcnInitDone =1;
4118   1          //HHT_DevCfg();
4119   1      
4120   1      }
4121          
4122          void FREQDET_FreqDetectReset(void)
4123          {    
4124   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4125   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4126   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4127   1      
C51 COMPILER V9.52.0.0   HAL_HPGP                                                          01/10/2015 21:25:26 PAGE 69  

4128   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4129   1      }
4130          
4131          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12488    ----
   CONSTANT SIZE    =   1027    ----
   XDATA SIZE       =    742     575
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
