C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GREEN
OBJECT MODULE PLACED IN .\obj\green.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\green.c LARGE OBJECTADVANCED OPTIMIZE(9,SI
                    -ZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..
                    -\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;
                    -..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmw
                    -are\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;.
                    -.\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;.
                    -.\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;
                    -..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\
                    -..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hp
                    -gp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..
                    -\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\com
                    -ponents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\fl
                    -ash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;.
                    -.\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\
                    -inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..
                    -\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_80
                    -51,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM
                    -,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT
                    -,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,M
                    -CCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGIST
                    -ER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\green.lst) TABS(2) OBJEC
                    -T(.\obj\green.obj)

line level    source

   1          /** ========================================================
   2           *
   3           *  @file green.c 
   4           * 
   5           *  @brief GREEN PHY Main Module
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * ==========================================================*/
  11          
  12          #ifdef RTX51_TINY_OS
  13          #include <rtx51tny.h>
  14          #endif
  15          #include <string.h>
  16          #include <stdio.h>
  17          #include <stdlib.h>
  18          #include <intrins.h>
  19          #include "fm.h"
  20          #include "ism.h"
  21          #include "timer.h"
  22          #include "stm.h"
  23          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  26          #include "event.h"
  27          #include "nma.h"
  28          #include "nma_fw.h"
  29          #include "hpgpapi.h"
  30          #include "sched.h"
  31          #include "dmm.h"
  32          #if defined(SIMU) && !defined(HPGP_TEST)
              #include "host.h"
              #endif
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 2   

  35          #ifdef P8051
  36          #include "uart.h"
  37          #endif
  38          #include "green.h"
  39          #include "hal_eth.h"
  40          #include "hal_spi.h"
  41          #include "frametask.h"
  42          #include "sys_common.h" 
  43          #ifdef UART_HOST_INTF 
  44          #include "datapath.h"
  45          #include "gv701x_uartdriver_fw.h"
  46          #endif
  47          #include "hybrii_tasks.h"
  48          #include "utils_fw.h"
  49          #include "hal_common.h"
  50          #ifdef NO_HOST
  51          #include "gv701x_flash.h"
  52          #endif
  53          #include "gv701x_flash_fw.h"
  54          #include "nma.h"
  55          #ifdef SW_RECOVERY
  56          #include "hal_hpgp_reset.h"
  57          #endif
  58          #ifdef HYBRII_802154
  59          #include "return_val.h"
  60          #include "qmm.h"
  61          #include "bmm.h"
  62          #include "mac_msgs.h"
  63          #include "mac.h"
  64          #ifdef ZBMAC_DIAG
              #include "mac_diag.h"
              #endif
  67          #endif
  68          #ifdef NO_HOST
  69          extern sSlist peripheralTxQ;
  70          #endif
  71          #ifdef FREQ_DETECT
  72          extern u32 PLC_DC_LINE_CYCLE_FREQENCY;
  73          extern void FREQDET_FreqDetectInit(void); 
  74          #endif 
  75          
  76          extern void HTM_CmdRun(void);
  77          extern void hal_spi_init (void);
  78          extern void hal_spi_cleanup(void);
  79          extern sHpgpHalCB gHpgpHalCB;
  80          u8 syncThres = 0;
  81          
  82          extern u8 ethTxDone;
  83          extern u8 hostDetected;
  84          extern u8 numHostCPs;
  85          #define MEM_POOL_SIZE         4342 //70 //3072//4096//5376//6400//4096
  86          #define MEM_SLAB_SEG_SIZE_0   32
  87          #define MEM_SLAB_SEG_SIZE_1   64
  88          #define MEM_SLAB_SEG_SIZE_2   128 
  89          #define MEM_SLAB_SEG_SIZE_3   196 
  90          #define MEM_SLAB_SEG_SIZE_4   256 
  91          #define MEM_SLAB_SEG_SIZE_5   512 
  92          #define MEM_SLAB_SEG_SIZE_6   758 // to Support Peer Info
  93          
  94          
  95          u8 XDATA MemPool[MEM_POOL_SIZE];
  96          
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 3   

  97          extern sysProfile_t gSysProfile;
  98          extern u16 FmDebug;
  99          static sSlabDesc SlabDesc[] =
 100          {
 101              {6, MEM_SLAB_SEG_SIZE_0},
 102              {2, MEM_SLAB_SEG_SIZE_1},
 103              {2, MEM_SLAB_SEG_SIZE_2},
 104          //    {0, MEM_SLAB_SEG_SIZE_3},
 105              {2, MEM_SLAB_SEG_SIZE_4},
 106              {3, MEM_SLAB_SEG_SIZE_5},    
 107              {1, MEM_SLAB_SEG_SIZE_6},
 108          };
 109          
 110          #define BCN_MEM_SLAB_SEG_SIZE_0   (BEACON_BUFF_LEN + 50)
 111          #define BCN_MEM_POOL_CNT          10
 112          #define BCN_MEM_POOL_SIZE         ((BCN_MEM_SLAB_SEG_SIZE_0 + sizeof(sSegDesc))* \
 113                             BCN_MEM_POOL_CNT )
 114          
 115          
 116          #define MGMT_MEM_SLAB_SEG_SIZE_0   (100)
 117          #define MGMT_MEM_SLAB_SEG_SIZE_1   (200)
 118          #define MGMT_MEM_SLAB_SEG_SIZE_2   (512)
 119          #define MGMT_MEM_SLAB_SEG_SIZE_3   (1024)
 120          
 121          
 122          #define MGMT_MEM_POOL_SIZE         (((MGMT_MEM_SLAB_SEG_SIZE_0 + sizeof(sSegDesc))* 40) + \
 123                              ((MGMT_MEM_SLAB_SEG_SIZE_1 + sizeof(sSegDesc))* 30) + \
 124                                 ((MGMT_MEM_SLAB_SEG_SIZE_2 + sizeof(sSegDesc))* 2 ) + \
 125                               ((MGMT_MEM_SLAB_SEG_SIZE_3 + sizeof(sSegDesc))* 1))
 126          
 127          u8 XDATA BcnMemPool[BCN_MEM_POOL_SIZE];
 128          u8 XDATA MgmtMemPool[MGMT_MEM_POOL_SIZE];
 129          
 130          
 131          static sSlabDesc BcnSlabDesc[] =
 132          {
 133              {BCN_MEM_POOL_CNT, BCN_MEM_SLAB_SEG_SIZE_0},
 134          
 135          };
 136          
 137          static sSlabDesc MgmtSlabDesc[] =
 138          {
 139              {40, MGMT_MEM_SLAB_SEG_SIZE_0},   
 140              {30, MGMT_MEM_SLAB_SEG_SIZE_1}, 
 141              {2, MGMT_MEM_SLAB_SEG_SIZE_2},
 142              {1, MGMT_MEM_SLAB_SEG_SIZE_3},
 143          
 144          };
 145          
 146          u8 hwSpecDone = FALSE;
 147          #ifdef LOG_FLASH
              extern u16 *logLen;
              extern u16 *blockId;
              #endif
 151          #define MAX_HOST_WAIT 45
 152          #define MAX_INPUT_WAIT 90
 153          
 154          sHomePlugCb HomePlug;
 155          #ifdef HPGP_MAC_SAP 
 156          #ifdef LINK_STATUS
              u8 linkStatus = TRUE;
              #endif
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 4   

 159          #endif
 160          
 161          extern void HTM_SetDefaultNid();
 162          extern void EHAL_DoRelEthTxCP();
 163          extern u8 opMode;
 164          extern eStatus CTRLL_StartNetDisc(sCtrlLayer *ctrlLayer);
 165          
 166          u16 hostDetectedCnt;
 167          extern void STM_Proc (void);
 168          
 169          #ifdef STA_FUNC
 170          extern void ConfigParams();
 171          #endif
 172          #ifdef HYBRII_SPI
              void hal_spi_cmd_len_rx_rdy ();
              #endif
 175          
 176          extern volatile sStm Stm;
 177          #ifdef UART_HOST_INTF
 178          extern volatile uint8_t txEnable;// uart driver specific
 179          extern uint8_t modemstatus;//uart driver spacific
 180          extern union_uart_modemstat modemstatus_u;
 181          extern union_uart_intctrl    *uart_intctrl;
 182          
 183          extern xdata volatile uint8_t txBuffer[128];
 184          volatile uint8_t tlValue,thValue;
 185          volatile uint16_t timerValue;// For Timer polling and timer reload //Kiran
 186          volatile uint16_t timerDiff,timerCalc;
 187          #define TIMER_RELOAD_VALUE      (44702)
 188          #define TIMER_TICK10          (20833)
 189          void timer0Poll();
 190          #ifdef NO_HOST
 191          extern bool hal_uart_tx (sEvent * event);
 192          #endif
 193          #endif
 194          
 195          
 196          #ifdef SW_RECOVERY
 197          extern u32 gPastRecoveryCount1, gRecoveryCount1;
 198          extern u32 gPastRecoveryCount2, gRecoveryCount2;
 199          extern u32 gRecoveryCount3;
 200          extern u32 gL1;
 201          extern u32 gL2;
 202          extern u32 gL3;
 203          extern u32 gBCNR;
 204          void recovery_monitor();
 205          #endif
 206          #ifndef RTX51_TINY_OS
              int main (void)
              #else
 209          void green_main (void) _task_ HYBRII_TASK_ID_INIT
 210          #endif
 211          {
 212   1          
 213   1      #ifdef PLC_TEST 
                  u8 lm, lmFlag = 0;
                  u32 currTick; 
              #endif
 217   1      #ifdef HYBRII_SPI
                  static u8 sendOnSpi = FALSE;
              #endif
 220   1          memset(&HomePlug, 0, sizeof(sHomePlugCb));
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 5   

 221   1          memset(&gHpgpHalCB, 0, sizeof(sHpgpHalCB));
 222   1      //#ifdef HPGP_DEBUG
 223   1          UART_Init();
 224   1      //#endif
 225   1      
 226   1          FM_Printf(FM_USER, "INITIALISING.\n");
 227   1        FM_Printf(FM_USER, "VERSION: %s\n",get_Version());
 228   1      
 229   1      
 230   1      #ifdef P8051
 231   1      //    init_mempool(&MemPool, sizeof(MemPool));
 232   1      #endif
 233   1      #ifdef UART_HOST_INTF
 234   1            TL0 = lo8(TIMER_RELOAD_VALUE);
 235   1            TH0 = hi8(TIMER_RELOAD_VALUE);
 236   1            ET0 = 0;
 237   1            TR0 = 1;
 238   1      #endif
 239   1      #ifdef PLC_TEST
                  currTick = STM_GetTick();
                  FM_Printf(FM_USER,"Enter Diagnostic Mode(y/n) :: ");
                  while((STM_GetTick() - currTick) < MAX_INPUT_WAIT)
                  {
                      lm = poll_key();
                      if(lm == 'Y' || lm == 'y')
                      {
                          putchar(lm);
                          opMode = LOWER_MAC;
                          eth_plc_bridge = 1;
                          FM_Printf(FM_USER,"\nDiagnostic Mode Selected");
                          lmFlag = 1;
                          break;
                      }
                      else if(lm == 'N' || lm == 'n')
                      {
                          putchar(lm);
                    opMode = UPPER_MAC;
                          FM_Printf(FM_USER,"\nStation Mode Selected");
                          lmFlag = 1;
                          break;
                      }
              #ifdef UART_HOST_INTF
                  timer0Poll();
              #endif
                  }
                  FM_Printf(FM_USER,"\n");
                  if(lmFlag == 0)
                  {
                      FM_Printf(FM_USER,"\nTime Out:Station Mode Selected\n");
                  }
                  
              #endif
 273   1      //    gHpgpHalCB.lastdevMode = 2;
 274   1      
 275   1      
 276   1      
 277   1      #if 0
              //#ifdef NOT_RANDOM
                  syncThres = PLC_BCNTST_SYNCTHRES;
              //#else
                srand(ReadU32Reg(PLC_NTB_REG) + TL0);   
              
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 6   

                  syncThres = (u8)rand();
                  if(syncThres < PLC_BCNTST_SYNCTHRES)
                  {
                      syncThres = PLC_BCNTST_SYNCTHRES;
                  }
                  else if(syncThres > 10) // 90 = 30 sec
                  {
                      syncThres = 10;
                  }    
              //#endif
              #endif
 294   1      
 295   1          DMM_Init(FW_POOL_ID);
 296   1          DMM_InitMemPool(FW_POOL_ID, MemPool, sizeof(MemPool), 
 297   1                SlabDesc, sizeof(SlabDesc)/sizeof(SlabDesc[0]));
 298   1      
 299   1        DMM_Init(BCN_POOL_ID);
 300   1        DMM_InitMemPool(BCN_POOL_ID, BcnMemPool, sizeof(BcnMemPool),
 301   1                BcnSlabDesc, sizeof(BcnSlabDesc)/sizeof(BcnSlabDesc[0]));
 302   1      
 303   1        DMM_Init(MGMT_POOL_ID);
 304   1        DMM_InitMemPool(MGMT_POOL_ID, MgmtMemPool, sizeof(MgmtMemPool),
 305   1                MgmtSlabDesc, sizeof(MgmtSlabDesc)/sizeof(MgmtSlabDesc[0]));
 306   1        
 307   1          /* Initialize PAP */
 308   1          //PAP_Init();
 309   1      
 310   1        STM_Init();
 311   1         
 312   1      #if defined(SIMU) && !defined(HPGP_TEST)
                  /* initialize host software */
                Host_Init();
              #endif
 316   1          HAL_Init(&HomePlug.haLayer);
 317   1      
 318   1      #ifdef B_ASICPLC
 319   1        if(isFlashProfileValid() == STATUS_SUCCESS)
 320   1        {
 321   2          flashRead_config((u8 *)&gSysProfile,FLASH_SYS_CONFIG_OFFSET,
 322   2                    sizeof(sysProfile_t));
 323   2      #ifdef STA_FUNC   
 324   2          ConfigParams();
 325   2      #endif
 326   2      
 327   2            //FM_HexDump(FM_USER, "MAC ADDR: ", gSysProfile.macAddress, MAC_ADDR_LEN);
 328   2        }
 329   1        else
 330   1        {
 331   2      
 332   2          u8 defaultMacAddress[6] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
 333   2          
 334   2          //sCtrlLayer *ctrll = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 335   2          u8     nid[NID_LEN] = {0xb0, 0xf2, 0xe6, 0x95, 0x66, 0x6b, 0x03};
 336   2          // {0xB0, 0xF2, 0xE6, 0x95, 0x66, 0x6B, 0x83}; // Zyxel box NID = B0F2E695666B83
 337   2      
 338   2      
 339   2          u8     nmk[ENC_KEY_LEN] = {0x50, 0xD3, 0xE4, 0x93, 0x3F, 0x85, 0x5B, 0x70, 0x40,
 340   2                        0x78, 0x4D, 0xF8, 0x15, 0xAA, 0x8D, 0xB7};
 341   2      
 342   2      
 343   2          nid[NID_LEN-1] &= SECLV_MASK;       
 344   2          nid[NID_LEN-1] |= (SECLV_SC << SECLV_OFFSET); // By default SC
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 7   

 345   2          
 346   2          //FM_Printf(FM_USER,"Invalid Flash Profile\n");
 347   2            
 348   2          //set a default NID, which should be set by the user later
 349   2          memcpy(gSysProfile.nid, nid, NID_LEN);
 350   2      
 351   2          memcpy(gSysProfile.nmk, nmk, ENC_KEY_LEN);
 352   2      
 353   2          //CTRLL_SetKey(ctrll, nmk, nid);
 354   2              
 355   2          // memcpy(gSysProfile.defaultNMK, , ENC_KEY_LEN);// update
 356   2          memcpy(gSysProfile.systemName,"Greenvity HPGP", sizeof("Greenvity HPGP"));
 357   2        
 358   2          //gSysProfile.secLevel;
 359   2      
 360   2          //memcpy(gHpgpHalCB.nid, nid, NID_LEN);
 361   2          
 362   2          gSysProfile.lineMode = LINE_MODE_DC;
 363   2          //gHpgpHalCB.lineMode = LINE_MODE_DC;
 364   2      
 365   2          
 366   2      #ifdef AC_LINECYCLE_50HZ    
                  //gHpgpHalCB.lineFreq = FREQUENCY_50HZ;
                  gSysProfile.lineFreq = FREQUENCY_50HZ;
              #else
 370   2          //gHpgpHalCB.lineFreq = FREQUENCY_60HZ;
 371   2          gSysProfile.lineFreq = FREQUENCY_50HZ;
 372   2      #endif
 373   2          //gSysProfile.plcLineFreq;
 374   2          gSysProfile.cap.fields.ccoCap = CCO_CAP_LEVEL0;
 375   2          gSysProfile.cap.fields.backupCcoCap = DEFAULT_BACKUP_CCO_CAP;
 376   2          
 377   2          gSysProfile.cap.fields.proxyNetCap = DEFAULT_PROXY_NET_CAP;
 378   2            
 379   2          gSysProfile.cap.fields.greenPhyCap = DEFAULT_GREENPHY_CAP;
 380   2          gSysProfile.cap.fields.HPAVVersion = DEFAULT_HPAV_VER;
 381   2          gSysProfile.cap.fields.powerSaveCap = DEFAULT_POWER_SAVE_CAP;
 382   2          gSysProfile.cap.fields.repeaterRouting = DEFAULT_REPEATER_ROUTING_SUPPORTED;
 383   2          gSysProfile.cap.fields.bridgeSupported =  DEFAULT_BRIDGE_SUPPORTED;
 384   2      
 385   2              gSysProfile.lastUserAppCCOState = 0x00;
 386   2          
 387   2          
 388   2          // SLIST_Init(&hal->txQueue);
 389   2           
 390   2          /* FIXME: the following is to hard code MAC address */
 391   2          srand(ReadU32Reg(PLC_NTB_REG));
 392   2          defaultMacAddress[5] = (u8)(rand() & 0xFF);   
 393   2      
 394   2          memcpy(&HomePlug.haLayer.macAddr, 
 395   2              &defaultMacAddress, MAC_ADDR_LEN);
 396   2      
 397   2          memcpy(&gSysProfile.macAddress,
 398   2            &defaultMacAddress, MAC_ADDR_LEN);
 399   2             
 400   2           
 401   2            FM_HexDump(FM_USER, "MAC ADDR:", &defaultMacAddress, MAC_ADDR_LEN);
 402   2          
 403   2          flashWrite_config((u8 *)&gSysProfile,FLASH_SYS_CONFIG_OFFSET,
 404   2                     sizeof(sysProfile_t));
 405   2      
 406   2      #ifdef STA_FUNC
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 8   

 407   2          ConfigParams();
 408   2      #endif
 409   2          
 410   2        } 
 411   1      #endif
 412   1      
 413   1      #ifdef HYBRII_802154
 414   1        mac_init(); 
 415   1      #ifdef ZBMAC_DIAG
                mac_diag_init();
              #endif
 418   1      #endif
 419   1      
 420   1          HPGPCTRL_Init(&HomePlug.hpgpCtrl);
 421   1      #ifdef FREQ_DETECT
 422   1          FREQDET_FreqSetting(gHpgpHalCB.lineFreq);
 423   1          FREQDET_FreqDetectInit();
 424   1      #endif
 425   1        
 426   1      #ifdef NMA
 427   1        /* initialize HPGP network management agent */
 428   1        NMA_Init(&HomePlug.netMgmtAgt);
 429   1      #endif
 430   1      
 431   1      #ifdef SIMU
                /* initialize hpgp timer simulator */
                HTS_Init(&HomePlug.hts);
              #endif
 435   1      
 436   1      #ifdef HPGP_HAL
 437   1        ISM_EnableInterrupts();
 438   1      
 439   1        ISM_EnableMacIrq(MAC_INT_IRQ_ALL);
 440   1      //    ISM_EnableMacIrq(MAC_INT_IRQ_PLC_BCN_TX);
 441   1      #ifndef RTX51_TINY_OS
                HAL_EnablePoll(&HomePlug.haLayer);
              #endif
 444   1      #endif /* HPGP_HAL */
 445   1        
 446   1          
 447   1        /* main process */
 448   1      #ifdef HPGP_TEST
 449   1        HTM_Init(&HomePlug.htm);
 450   1      #endif
 451   1      #ifdef HYBRII_SPI
                hal_spi_init();
              #endif
 454   1      //    HTM_SetDefaultNid();
 455   1      #ifdef UART_HOST_INTF
 456   1        UART_Init16550();
 457   1      #endif
 458   1      
 459   1        frame_task_init();
 460   1      #ifdef ROUTE
                  ROUTE_routeInit();
              #endif
 463   1      #ifdef NO_HOST
 464   1        hostIntf = HOST_INTF_UART;
 465   1        hostDetected = TRUE;
 466   1      #else
                  hostIntf = HOST_INTF_ETH;
              #endif
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 9   

 469   1      
 470   1      #ifdef SW_RECOVERY
 471   1      {
 472   2        u8 reason;
 473   2        u32 hangReg;
 474   2      
 475   2        hangReg = hal_common_reg_32_read(PLC_SM_HANG_INT);
 476   2        if(hangReg)
 477   2        {
 478   3          //FM_Printf(FM_USER,"PLC Hang b4 reset\n");// remove during release and checkin
 479   3          GV701x_Chip_Reset();
 480   3        }
 481   2        reason = resetReason();
 482   2        if(reason == RESET_REASON_WDTRST)
 483   2        {
 484   3          FM_Printf(FM_USER,"\nWDT\n");
 485   3          WriteU8Reg(0x38,2);// Reset Status Register
 486   3          //HHAL_DisplayPlcStat();
 487   3          GV701x_Chip_Reset();
 488   3        }
 489   2        else if(reason == RESET_REASON_SWSYSRST)
 490   2        {
 491   3          FM_Printf(FM_USER,"\nSW SYS\n");
 492   3          WriteU8Reg(0x38,4);// Reset Status Register
 493   3        }
 494   2        else if(reason == RESET_REASON_SWCPURST)
 495   2        {
 496   3          FM_Printf(FM_USER,"\nSW CPU\n");
 497   3          WriteU8Reg(0x38,8);// Reset Status Register
 498   3        } 
 499   2        else
 500   2        {
 501   3          FM_Printf(FM_USER,"\nPOR %bu\n",reason);
 502   3        }
 503   2      }
 504   1        configWDT(1,0xffff, SYSTEM_CLOCK_1024_PRESCALE);
 505   1      #endif
 506   1          if(opMode != LOWER_MAC)
 507   1          {
 508   2      #if (defined HYBRII_802154) && (defined HYBRII_HPGP)
 509   2          NMA_SendFwReady(PLC_NIC | RF_NIC);
 510   2      #elif (defined HYBRII_HPGP) && !(defined HYBRII_802154)
                  NMA_SendFwReady(PLC_NIC);
              #elif !(defined HYBRII_HPGP) && (defined HYBRII_802154)
                  NMA_SendFwReady(RF_NIC);
              #endif
 515   2      
 516   2          }
 517   1          hostDetectedCnt = 0;
 518   1      #ifdef LOG_FLASH
                      *logLen = 0;
                      *blockId = getLastPageId();
              #endif
 522   1              os_set_ready(HYBRII_TASK_ID_FRAME);
 523   1          os_switch_task();
 524   1            
 525   1      #ifdef UART_HOST_INTF
 526   1        TL0 = lo8(TIMER_RELOAD_VALUE);
 527   1        TH0 = hi8(TIMER_RELOAD_VALUE);
 528   1        TR0 = 1;
 529   1        ET0 = 0;
 530   1      #endif
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 10  

 531   1      #ifdef RTX51_TINY_OS 
 532   1      #ifdef LOG_FLASH
                  logEvent(BOOT, 0, 0, NULL, 0);
              #endif
 535   1      
 536   1          while (1)
 537   1        {
 538   2      #ifdef SW_RECOVERY
 539   2          recovery_monitor();
 540   2      #endif
 541   2      
 542   2      #ifdef UART_HOST_INTF
 543   2          timer0Poll(); 
 544   2              
 545   2          if(uartRxControl.rxExpectedCount == 0)
 546   2          {
 547   3            uartRxProc();
 548   3          }
 549   2      #ifdef LG_UART_CONFIG   
                  if(uartTxControl.txModeControl == UART_TX_LOW_EDGE)
                  {
                      sEvent *event = NULL;
                          sSlink *slink = NULL;
                    modemstatus_u.modemstat = ReadU8Reg(UART_MODEMSTAT);//uart_modemstatus.modemstat;
                    if(modemstatus_u.modemstat_field.DCTS || modemstatus_u.modemstat_field.CTS)
                    {
                      if(modemstatus_u.modemstat_field.DCTS && modemstatus_u.modemstat_field.CTS) // DCTS & CTS are set
                      {   
                        if((uartTxControl.txCount == 0) && (uart_linestatus->linestat_field.TxThldRegEmpt))
                        {
              #ifdef NO_HOST
                                      /*Read peripheral tx  Queue*/
                                    if(!SLIST_IsEmpty(&peripheralTxQ))
                                    {
              __CRIT_SECTION_BEGIN__
                                      slink = SLIST_Pop(&peripheralTxQ);
              __CRIT_SECTION_END__  
                                      event = SLIST_GetEntry(slink, sEvent, link);
              
                                      if(event != NULL) 
                                          {      
                                            
                                          if(hostIntf == HOST_INTF_UART)
                                              {
                                                  txEnable = 1;
                                                  hal_uart_tx(event);                                        
                                              }
                                              
                                              EVENT_Free(event);
                                          }
                                    }       
                  
              #else
                          // check if any frame is in queue
                          //if available then unqueue copy in to local buffer and start interrupt 
                          if(datapath_IsQueueEmpty(HOST_DATA_QUEUE) == FALSE)
                          {
                            xdata uint8_t *cellAddrTx;
                            sSwFrmDesc* pHostTxFrmSwDesc = NULL;
                            uint16_t i;
                            if((pHostTxFrmSwDesc =
                                datapath_getHeadDesc(HOST_DATA_QUEUE, 1)) != NULL)
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 11  

                            {
                              uartTxControl.pTxBuffer = txBuffer;
                              uartTxControl.txCount = pHostTxFrmSwDesc->frmLen;
                              uartTxControl.txDone = 0;
                              cellAddrTx = CHAL_GetAccessToCP(pHostTxFrmSwDesc->cpArr[0].cp);
                              for(i=0;i<uartTxControl.txCount;i++)
                              {
                                *(uartTxControl.pTxBuffer+i) = *(cellAddrTx + i );
                              }
                              txEnable = 1;
                              uart_intctrl->intctrl_field.EnTxEmptInt = 1; // Enables tx interrupt
                              CHAL_FreeFrameCp(pHostTxFrmSwDesc->cpArr, pHostTxFrmSwDesc->cpCount);   
                              numHostCPs -= pHostTxFrmSwDesc->cpCount;
                            }//Get head disc
                          }
              #endif
                        }
                        else //if(modemstatus_u.modemstat_field.DCTS && !modemstatus_u.modemstat_field.CTS)
                        {
                          txEnable = 1;
                          uart_intctrl->intctrl_field.EnTxEmptInt = 1;// Enable TX Interrupt
                        }
                        modemstatus = ReadU8Reg(UART_MODEMSTAT);//uart_modemstatus.modemstat;
                      }
                      else if(modemstatus_u.modemstat_field.DCTS && !modemstatus_u.modemstat_field.CTS)// Only DCTS is set
                      {
                        uart_intctrl->intctrl_field.EnTxEmptInt = 0;// Disable TX Interrupt
                        txEnable = 0;
                        modemstatus = ReadU8Reg(UART_MODEMSTAT);//modemstatus = uart_modemstatus.modemstat;
                      }
                    }
                  }
              #endif
 626   2      #endif
 627   2      
 628   2              if(hwSpecDone == FALSE) 
 629   2              {
 630   3                  if(hostDetectedCnt > 1000)
 631   3                  {
 632   4                      if((hostDetected == TRUE) && (hostIntf == HOST_INTF_ETH))
 633   4                      {
 634   5                      }
 635   4      #ifdef HYBRII_SPI
                              else if(sendOnSpi == FALSE)
                              {
                                  hostIntf = HOST_INTF_SPI;
                                  if(opMode != LOWER_MAC)
                                  {
              #ifdef HYBRII_ETH                     
                                     EHAL_DoRelEthTxCP();
              #endif
              #ifndef NO_HOST                       
              #if (defined HYBRII_802154) && (defined HYBRII_HPGP)
                          NMA_SendFwReady(PLC_NIC | RF_NIC);
              #elif (defined HYBRII_HPGP) && !(defined HYBRII_802154)
                          NMA_SendFwReady(PLC_NIC);
              #elif !(defined HYBRII_HPGP) && (defined HYBRII_802154)
                          NMA_SendFwReady(RF_NIC);
              #endif
              #endif
                                      sendOnSpi = TRUE;
                                  }
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 12  

                              }
              #endif
 657   4                      else
 658   4                      {
 659   5                          hostIntf = HOST_INTF_NO;
 660   5      #ifdef HYBRII_SPI
                        hal_spi_cmd_len_rx_rdy();
              #endif
 663   5                          hwSpecDone = TRUE;
 664   5                      }
 665   4                      hostDetectedCnt = 0;
 666   4                  }
 667   3                  hostDetectedCnt++;
 668   3              }
 669   2          
 670   2          STM_Proc();
 671   2              ISM_PollInt();
 672   2      #ifdef HYBRII_SPI
                  if(spi_tx_flag == 1)
                  {
              
                    if((STM_GetTick() - spi_tx_time) > MAX_SPI_TX_TIMEOUT)
                    {
                      //hal_spi_cleanup();
                      //hal_spi_tx_cleanup ();
                      spi_tx_flag = 0;
                              //FM_Printf(FM_USER,"spi tx tm1\n");
                    }
                  }
              #endif  
 685   2              os_switch_task();
 686   2          STM_Proc();
 687   2              os_switch_task();
 688   2          }
 689   1      #else  
                  SCHED_Proc();
              #endif
 692   1      
 693   1          return;
 694   1      }
 695          
 696          sHpgpCtrl* HOMEPLUG_GetCtrlPlane()
 697          {
 698   1          return &HomePlug.hpgpCtrl;
 699   1      }
 700          
 701          sHaLayer* HOMEPLUG_GetHal()
 702          {
 703   1          return &HomePlug.haLayer;
 704   1      }
 705          
 706          sNma *HOMEPLUG_GetNma() 
 707          {
 708   1          return &HomePlug.netMgmtAgt;
 709   1      }
 710          
 711          #ifdef UART_HOST_INTF
 712          void timer0Poll()
 713          {
 714   1        EA = 0;
 715   1        if(1 == TF0)
 716   1        {
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 13  

 717   2          u8 val = 0;
 718   2          
 719   2          TF0 = 0;
 720   2          //Stm.timeTick++;
 721   2      
 722   2          if(Stm.timeTick == STM_TIME_TICK_MAX)
 723   2          {
 724   3            Stm.timeSector = !Stm.timeSector;
 725   3            Stm.timeTick = 0;
 726   3              
 727   3          }
 728   2          else
 729   2          {
 730   3            Stm.timeTick++;
 731   3          }
 732   2      
 733   2          TR0 = 0;
 734   2          tlValue = TL0;
 735   2          thValue = TH0;
 736   2      
 737   2          timerValue = ((uint16_t)(thValue<<8)) | tlValue;
 738   2          if(timerValue > 0)
 739   2          {
 740   3            val = timerValue / TIMER_TICK10;
 741   3            //val = (u8)timerCalc;
 742   3            //Stm.timeTick += val;
 743   3            if(Stm.timeTick == STM_TIME_TICK_MAX)
 744   3            {
 745   4              Stm.timeSector = !Stm.timeSector;
 746   4              Stm.timeTick = 0;   
 747   4              
 748   4            }
 749   3            else
 750   3            {
 751   4              Stm.timeTick += val;
 752   4            }
 753   3            timerCalc = timerValue % TIMER_TICK10;
 754   3            timerValue = TIMER_RELOAD_VALUE + timerCalc;
 755   3            TL0 = lo8(timerValue);
 756   3            TH0 = hi8(timerValue);
 757   3          }   
 758   2          else
 759   2          {
 760   3            val = 0;
 761   3            TL0 = lo8(TIMER_RELOAD_VALUE);
 762   3            TH0 = hi8(TIMER_RELOAD_VALUE);
 763   3          }   
 764   2          
 765   2          TR0 = 1;
 766   2          if(uartRxControl.uartRxFlag == 1) // in timer handler or in STM Proc()
 767   2          {
 768   3            uartRxControl.tick = uartRxControl.tick + ((val + 1)*10);
 769   3          }
 770   2          
 771   2        }
 772   1        EA = 1;
 773   1      }
 774          #endif
 775          
 776          #ifdef SW_RECOVERY
 777          u32 gPastbpIntCnt = 0;
 778          u32 gBcnTimer = 0;
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 14  

 779          static u8  gFirstBcnFlag = 0;
 780          u32 gBcnRecoveryCount = 0;
 781          #ifdef BCN_FIFO_RECOVERY
              volatile u8 beaconCheck;// In recovery monitor this will get incremented after 3 timer ticks if no increme
             -nt in Rx beacon count
              volatile u32 pastBcnCount;
              volatile u32 bcnDump;
              volatile u32 pastTick;
              #endif
 787          void recovery_monitor()
 788          {
 789   1        if(hal_common_reg_32_read(PLC_SM_HANG_INT) == 0)
 790   1        {
 791   2          gPastRecoveryCount1 = 0x00;
 792   2          gRecoveryCount1 = 0x00;
 793   2          
 794   2          gPastRecoveryCount2 = 0x00;
 795   2          gRecoveryCount2 = 0x00;
 796   2          gRecoveryCount3 = 0x00;
 797   2          //gBCNR = 0;
 798   2          gBcnRecoveryCount = 0;
 799   2        }
 800   1        else
 801   1        {
 802   2          if((gRecoveryCount1 > 5) && (gRecoveryCount2 <= 20))
 803   2          {
 804   3            //FM_Printf(FM_ERROR,"\nH L1 retry %lu\n",gRecoveryCount2);
 805   3            disable_plc_txrx();
 806   3            hold_reset_phy_tx();
 807   3            hold_reset_phy_rx();
 808   3              
 809   3              release_reset_phy_tx();
 810   3            release_reset_phy_rx();
 811   3            enable_plc_txrx();
 812   3            CHAL_DelayTicks(2);
 813   3            gRecoveryCount2++;
 814   3            gL1++;
 815   3            #ifndef RELEASE
 816   3            FM_Printf(FM_USER,"\nL1R\n");
 817   3            #endif
 818   3          }
 819   2          if((gRecoveryCount2 > CSMA_RETRY_COUNT) && (gRecoveryCount3 <= 20))
 820   2          {
 821   3            //FM_Printf(FM_ERROR,"\nH L2 retry %lu\n",gRecoveryCount3);
 822   3            GV701x_Chip_Reset();
 823   3            plc_reset_tx();
 824   3            CHAL_DelayTicks(2);
 825   3            gRecoveryCount3++;
 826   3            gL2++;
 827   3            #ifndef RELEASE
 828   3            FM_Printf(FM_USER,"\nL2R\n");
 829   3            #endif
 830   3          }
 831   2          if(gRecoveryCount3 > OTHERS_RETRY_COUNT)
 832   2          {
 833   3            //FM_Printf(FM_ERROR,"\nHW Reset\n");
 834   3            GV701x_Chip_Reset();
 835   3            plc_reset_tx(); // If hardware is not having support to reset chip using gpio 3
 836   3                    // Keep retrying mac resetplc_reset_tx();
 837   3            CHAL_DelayTicks(2);
 838   3            gL3++;
 839   3            #ifndef RELEASE
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 15  

 840   3            FM_Printf(FM_USER,"\nL3R\n");
 841   3            #endif
 842   3          }
 843   2      
 844   2        }
 845   1        if(gHpgpHalCB.devMode == DEV_MODE_CCO)
 846   1        {
 847   2          if(gFirstBcnFlag == 0 && gHpgpHalCB.halStats.bpIntCnt > 0)
 848   2          {
 849   3            gPastbpIntCnt = gHpgpHalCB.halStats.bpIntCnt;
 850   3            gFirstBcnFlag = 1;
 851   3            gBcnTimer = 0;
 852   3          }
 853   2          else
 854   2          { 
 855   3            if(gPastbpIntCnt != gHpgpHalCB.halStats.bpIntCnt)
 856   3            {
 857   4              gPastbpIntCnt = gHpgpHalCB.halStats.bpIntCnt;
 858   4              gBcnTimer = 0;
 859   4              gBcnRecoveryCount = 0;
 860   4            }
 861   3            else
 862   3            {
 863   4              gBcnTimer++;
 864   4            }
 865   3            if(gBcnTimer > 10000)
 866   3            {
 867   4              //FM_Printf(FM_ERROR,"\nbcn intr\n");
 868   4              plc_reset_tx();
 869   4              gBCNR++;
 870   4              CHAL_DelayTicks(2);
 871   4              gBcnRecoveryCount++;
 872   4              if(gBcnRecoveryCount > 20)
 873   4              {
 874   5                //FM_Printf(FM_ERROR,"\nbcn intr recv\n");
 875   5                GV701x_Chip_Reset();
 876   5                gBcnRecoveryCount = 0;
 877   5                plc_reset_tx(); // If hardware is not having support to reset chip using gpio 3
 878   5                        // Keep retrying mac resetplc_reset_tx();
 879   5                CHAL_DelayTicks(2);
 880   5              }
 881   4            }
 882   3          }
 883   2        }
 884   1        else
 885   1        {
 886   2          gPastbpIntCnt = 0;
 887   2          gFirstBcnFlag = 0;
 888   2          gBcnTimer = 0;// Add this code in cnsm and snsm start
 889   2        }
 890   1      #ifdef BCN_FIFO_RECOVERY
              if(pastTick != Stm.timeTick)
              {
                pastTick = Stm.timeTick;
                if(gHpgpHalCB.halStats.RxGoodBcnCnt == pastBcnCount)
                {
                  if(beaconCheck < BCN_CHECK_TICK_COUNT)// max appempt count can be set
                  {
                    beaconCheck++;
                  }
                  else
                  {
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 16  

                    u16 i;
                    EA = 0;
                    for(i=0;i<BCN_FIFO_DEPTH_WORDS;i++) //assumed that FIFO depth is in bytes
                    {
                      bcnDump = ReadU32Reg(PLC_BCNRXFIFO_REG);
                    }
                    beaconCheck = 0;
                    EA = 1;
                  }
                }
                else
                {
                  pastBcnCount = gHpgpHalCB.halStats.RxGoodBcnCnt;
                  beaconCheck = 0;
                }
              } 
              #endif
 919   1      //gHpgpHalCB.halStats.BcnSentIntCnt
 920   1      
 921   1      }
 922          
 923          #endif
 924          /** =========================================================
 925           *
 926           * Edit History
 927           *
 928           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/green.c,v $
 929           *
 930           * $Log: green.c,v $
 931           * Revision 1.39  2015/01/02 14:55:35  kiran
 932           * 1) Timer Leak fixed while freeing SCB fixed
 933           * 2) Software broadcast supported for LG
 934           * 3) UART Loopback supported for LG
 935           * 4) Keep Alive feature to ageout defunctional STA
 936           * 5) Improved flash API's for NO Host Solution
 937           * 6) Imporved PLC Hang recovery mechanism
 938           * 7) Reduced nested call tree of common path functions
 939           * 8) Code optimization and cleanup (unused arguments, unused local variables)
 940           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
 941           * 10) Use of memory specific pointers instead of generic pointers
 942           *
 943           * Revision 1.38  2014/11/26 13:19:40  ranjan
 944           * *** empty log message ***
 945           *
 946           * Revision 1.37  2014/11/11 14:52:58  ranjan
 947           * 1.New Folder Architecture espically in /components
 948           * 2.Modular arrangment of functionality in new files
 949           *    anticipating the need for exposing them as FW App
 950           *    development modules
 951           * 3.Other improvisation in code and .h files
 952           *
 953           * Revision 1.36  2014/11/06 18:28:25  ranjan
 954           * -disabling recovery_monitor
 955           * -removing scheduleframetask for interupt stability
 956           *
 957           * Revision 1.35  2014/10/28 16:27:43  kiran
 958           * 1) Software recovery using Watchdog Timer
 959           * 2) Hardware recovery monitor and policies
 960           * 3) Timer Polling in Control Task and Frame task for better accuracy
 961           * 4) Common memory optimized by reducing prints
 962           * 5) Discovered netlist corruption fixed
 963           * 6) VCO fix in HHAL_AFEInit()
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 17  

 964           * 7) Idata optimized by removing floating point operation
 965           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
 966           * 9) Beacon processing protected from interrupts
 967           * 10) Corrupted Beacons are dropped
 968           * 11) Some unused arguments removed to improve code size
 969           *
 970           * Revision 1.34  2014/10/15 10:42:51  ranjan
 971           * small fixes in um
 972           *
 973           * Revision 1.33  2014/10/13 10:23:57  prashant
 974           * LG-Uart corruption issue fix
 975           *
 976           * Revision 1.32  2014/09/30 21:39:14  tri
 977           * Added LLP PS
 978           *
 979           * Revision 1.31  2014/09/19 06:23:59  prashant
 980           * Uart data flow changed
 981           *
 982           * Revision 1.30  2014/09/05 09:28:18  ranjan
 983           * 1. uppermac cco-sta switching feature fix
 984           * 2. general stability fixes for many station associtions
 985           * 3. changed mgmt memory pool for many STA support
 986           *
 987           * Revision 1.29  2014/08/25 07:37:34  kiran
 988           * 1) RSSI & LQI support
 989           * 2) Fixed Sync related issues
 990           * 3) Fixed timer 0 timing drift for SDK
 991           * 4) MMSG & Error Logging in Flash
 992           *
 993           * Revision 1.28  2014/08/05 13:12:55  kiran
 994           * Fixed CP loss issue with UART Host & Peripheral interface
 995           *
 996           * Revision 1.27  2014/07/30 12:26:26  kiran
 997           * 1) Software Recovery for CCo
 998           * 2) User appointed CCo support in SDK
 999           * 3) Association process performance fixes
1000           * 4) SSN related fixes
1001           *
1002           * Revision 1.26  2014/07/22 10:03:52  kiran
1003           * 1) SDK Supports Power Save
1004           * 2) Uart_Driver.c cleanup
1005           * 3) SDK app memory pool optimization
1006           * 4) Prints from STM.c are commented
1007           * 5) Print messages are trimmed as common no memory left in common
1008           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
1009           *
1010           * Revision 1.25  2014/07/16 10:47:40  kiran
1011           * 1) Updated SDK
1012           * 2) Fixed Diag test in SDK
1013           * 3) Ethernet and SPI interfaces removed from SDK as common memory is less
1014           * 4) GPIO access API's added in SDK
1015           * 5) GV701x chip reset command supported
1016           * 6) Start network and Join network supported in SDK (Forced CCo and STA)
1017           * 7) Some bug fixed in SDK (CP free, p app command issue etc.)
1018           *
1019           * Revision 1.24  2014/07/10 11:42:45  prashant
1020           * power save commands added
1021           *
1022           * Revision 1.23  2014/07/05 09:16:27  prashant
1023           * 100 Devices support- only association tested, memory adjustments
1024           *
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 18  

1025           * Revision 1.22  2014/07/01 09:49:57  kiran
1026           * memory (xdata) improvement
1027           *
1028           * Revision 1.21  2014/06/19 17:13:19  ranjan
1029           * -uppermac fixes for lvnet and reset command for cco and sta mode
1030           * -backup cco working
1031           *
1032           * Revision 1.20  2014/06/19 07:16:02  prashant
1033           * Region fix, frequency setting fix
1034           *
1035           * Revision 1.19  2014/06/17 09:24:58  kiran
1036           * interface selection issue fix, get version supported.
1037           *
1038           * Revision 1.18  2014/06/13 14:55:11  ranjan
1039           * -fixing memory issue due to previous checkin
1040           *
1041           * Revision 1.17  2014/06/12 13:15:43  ranjan
1042           * -separated bcn,mgmt,um event pools
1043           * -fixed datapath issue due to previous checkin
1044           * -work in progress. neighbour cco detection
1045           *
1046           * Revision 1.16  2014/06/11 13:17:47  kiran
1047           * UART as host interface and peripheral interface supported.
1048           *
1049           * Revision 1.15  2014/06/09 13:19:46  kiran
1050           * Zigbee MAC SAP supported
1051           *
1052           * Revision 1.14  2014/06/05 10:26:07  prashant
1053           * Host Interface selection isue fix, Ac sync issue fix
1054           *
1055           * Revision 1.13  2014/06/05 08:38:41  ranjan
1056           * -flash function enabled for uppermac
1057           * - commit command after any change would flash systemprofiles
1058           * - verfied upper mac
1059           *
1060           * Revision 1.12  2014/05/28 10:58:59  prashant
1061           * SDK folder structure changes, Uart changes, removed htm (UI) task
1062           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
1063           *
1064           * Revision 1.11  2014/05/16 08:52:30  kiran
1065           * - System Profile Flashing API's Added. Upper MAC functionality tested
1066           *
1067           * Revision 1.10  2014/05/15 19:29:55  varsha
1068           * FREQ_DETECT code is added
1069           *
1070           * Revision 1.9  2014/05/12 08:09:57  prashant
1071           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
1072           *
1073           * Revision 1.8  2014/04/29 19:44:08  yiming
1074           * reduce compile flag
1075           *
1076           * Revision 1.7  2014/04/11 12:23:55  prashant
1077           * Under PLC_TEST macro Diagnostic Mode code added
1078           *
1079           * Revision 1.6  2014/02/27 10:42:47  prashant
1080           * Routing code added
1081           *
1082           * Revision 1.5  2014/02/19 10:22:40  ranjan
1083           * - common sync for hal_tst and upper mac project
1084           * - ism.c is MAC interrupt handler for hhal_tst and upper mac.
1085           *    chal_ext1isr function   is removed
1086           * - verified : lower mac sync, upper mac sync data traffic.
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 19  

1087           *
1088           * Revision 1.4  2014/01/14 23:34:22  son
1089           * Zigbee PLC UMAC integration initial commit
1090           *
1091           * Revision 1.3  2014/01/13 08:33:16  ranjan
1092           * code cleanup
1093           *
1094           * Revision 1.2  2014/01/10 17:13:09  yiming
1095           * check in Rajan 1/8/2014 code release
1096           *
1097           * Revision 1.5  2014/01/08 10:53:54  ranjan
1098           * Changes for LM OS support.
1099           * New Datapath FrameTask
1100           * LM and UM  datapath, feature verified.
1101           *
1102           * known issues : performance numbers needs revisit
1103           *
1104           * review : pending.
1105           *
1106           * Revision 1.4  2013/09/04 14:49:33  yiming
1107           * New changes for Hybrii_A code merge
1108           *
1109           * Revision 1.40  2013/07/12 08:56:36  ranjan
1110           * -UKE Push Button Security Feature.
1111           * Verified : DirectEntry Security Works.Datapath Works.
1112           *                 command SetSecMode for UKE works.
1113           * Added against bug-160
1114           *
1115           * Revision 1.39  2013/06/05 15:42:40  ranjan
1116           * 1) Lower mac bridge can be used with SPI.
1117           * 2) auto assoc stability issue
1118           *
1119           * Revision 1.38  2013/05/23 10:09:30  prashant
1120           * Version command added, SPI polling waittime increased, sys_common file added
1121           *
1122           * Revision 1.37  2013/05/20 10:15:31  prashant
1123           * poll_key bug fix and data path fix for UM
1124           *
1125           * Revision 1.36  2013/05/16 08:38:41  prashant
1126           * "p starttest" command merged in upper mac
1127           * Dignostic mode added in upper mac
1128           *
1129           * Revision 1.35  2013/04/19 12:56:34  prashant
1130           * Fix for sniffer, unresolved externs
1131           *
1132           * Revision 1.34  2013/04/17 13:00:59  ranjan
1133           * Added FW ready event, Removed hybrii header from datapath, Modified hybrii header
1134           *  formate
1135           *
1136           * Revision 1.33  2013/04/04 12:21:54  prashant
1137           * Detecting PLC link failure for HMC. added project for HMC and Renesas
1138           *
1139           * Revision 1.32  2013/03/22 12:21:48  prashant
1140           * default FM_MASK and FM_Printf modified for USER INFO
1141           *
1142           * Revision 1.31  2013/03/14 11:49:18  ranjan
1143           * 1.handled cases  for CCo toSTA switch and  viceversa
1144           * 2.UM uses bcntemplate
1145           *
1146           * Revision 1.30  2013/01/24 10:35:46  prashant
1147           * Fixing build issues in lower mac projects
1148           *
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 20  

1149           * Revision 1.29  2013/01/22 12:41:38  prashant
1150           * Fixing build issues
1151           *
1152           * Revision 1.28  2013/01/16 12:30:55  prashant
1153           * Call to EHT_SendToHost added in main function
1154           *
1155           * Revision 1.27  2013/01/15 12:26:12  ranjan
1156           * a)fixed issues in swQ for plc->host intf datapath and
1157           *    swQ for host -> plc datapath
1158           *
1159           * Revision 1.26  2013/01/04 16:11:23  prashant
1160           * SPI to PLC bridgeing added, Queue added for SPI and Ethernet
1161           *
1162           * Revision 1.25  2012/11/19 07:46:23  ranjan
1163           * Changes for Network discovery modes
1164           *
1165           * Revision 1.24  2012/09/24 06:01:38  yuanhua
1166           * (1) Integrate the NMA and HAL in Rx path (2) add a Tx queue in HAL to have less stack size needed in tx
             - path, and Tx in HAL is performed by polling now.
1167           *
1168           * Revision 1.23  2012/07/25 04:36:08  yuanhua
1169           * enable the DMM.
1170           *
1171           * Revision 1.22  2012/07/24 04:23:17  yuanhua
1172           * added DMM code for dynamic alloction with static memory to avoid memory fragmentation.
1173           *
1174           * Revision 1.21  2012/07/14 04:11:08  kripa
1175           * Moving CmdGet() call back to HTM task temporarily to avoid an unknown crash.
1176           * Committed on the Free edition of March Hare Software CVSNT Client.
1177           * Upgrade to CVS Suite for more features and support:
1178           * http://march-hare.com/cvsnt/
1179           *
1180           * Revision 1.20  2012/07/12 22:05:55  son
1181           * Moved ISM Polling to ISM Task.
1182           * UI is now part of init task
1183           *
1184           * Revision 1.19  2012/06/15 00:30:50  son
1185           * Removed call to HTM
1186           *
1187           * Revision 1.18  2012/06/13 06:24:31  yuanhua
1188           * add code for tx bcn interrupt handler integration and data structures for region entry schedule. But th
             -ey are not in execution yet.
1189           *
1190           * Revision 1.17  2012/06/11 18:01:11  son
1191           * Adding back HMT_Proc() call.
1192           * Committed on the Free edition of March Hare Software CVSNT Client.
1193           * Upgrade to CVS Suite for more features and support:
1194           * http://march-hare.com/cvsnt/
1195           *
1196           * Revision 1.16  2012/06/07 06:10:29  yuanhua
1197           * (1) free CPs if frame tx fails (2) add compiler flag HAL_INT_HDL to differentiate the interrupt and int
             -errupt handler. (3) enable all interrupts during the system initialization.
1198           *
1199           * Revision 1.15  2012/06/06 17:39:33  son
1200           * Moved HTM_Proc call to HTM Task.
1201           * Committed on the Free edition of March Hare Software CVSNT Client.
1202           * Upgrade to CVS Suite for more features and support:
1203           * http://march-hare.com/cvsnt/
1204           *
1205           * Revision 1.14  2012/06/05 22:37:11  son
1206           * UART console does not get initialized due to task ID changed
1207           *
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 21  

1208           * Revision 1.13  2012/06/05 07:25:59  yuanhua
1209           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
1210           *
1211           * Revision 1.12  2012/06/04 23:35:24  son
1212           * Added RTX51 OS support
1213           *
1214           * Revision 1.11  2012/05/21 04:20:59  yuanhua
1215           * enable/disable MAC interrupts when STA/CCO starts.
1216           *
1217           * Revision 1.10  2012/05/12 19:41:24  yuanhua
1218           * added malloc memory pool.
1219           *
1220           * Revision 1.9  2012/05/12 04:11:46  yuanhua
1221           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
1222           *
1223           * Revision 1.8  2012/05/07 04:17:57  yuanhua
1224           * (1) updated hpgp Tx integration (2) added Rx poll option
1225           *
1226           * Revision 1.7  2012/04/20 01:39:33  yuanhua
1227           * integrated uart module and added compiler flag NMA.
1228           *
1229           * Revision 1.6  2012/04/15 20:35:09  yuanhua
1230           * integrated beacon RX changes in HAL and added HTM for on board test.
1231           *
1232           * Revision 1.5  2012/04/13 06:15:11  yuanhua
1233           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
1234           *
1235           * Revision 1.4  2012/03/11 17:02:24  yuanhua
1236           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
1237           *
1238           * Revision 1.3  2011/09/14 05:52:36  yuanhua
1239           * Made Keil C251 compilation.
1240           *
1241           * Revision 1.2  2011/09/09 07:02:31  yuanhua
1242           * migrate the firmware code from the greenchip to the hybrii.
1243           *
1244           * Revision 1.2  2011/07/22 18:51:04  yuanhua
1245           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
1246           *
1247           * Revision 1.1  2011/06/23 23:52:42  yuanhua
1248           * move green.h green.c hpgpapi.h hpgpdef.h hpgpconf.h to src directory
1249           *
1250           * Revision 1.1  2011/05/06 19:14:50  kripa
1251           * Adding nmp files to the new source tree.
1252           *
1253           * Revision 1.2  2011/04/23 17:06:54  kripa
1254           * Used relative path for inclusion of stm.h, to avoid conflict with stm.h system header in VC++.
1255           *
1256           * Revision 1.1  2011/04/08 21:40:59  yuanhua
1257           * Framework
1258           *
1259           *
1260           * =========================================================*/
1261          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2063    ----
C51 COMPILER V9.53.0.0   GREEN                                                             11/04/2015 20:09:37 PAGE 22  

   CONSTANT SIZE    =    134    ----
   XDATA SIZE       =  22068      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
