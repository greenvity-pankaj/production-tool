/**
 * @file mac_disassociate.c
 *
 * MLME-DISASSOCIATION functionality
 *
 * $Id: mac_disassociate.c,v 1.1 2014/01/10 17:27:11 yiming Exp $
 *
 * Copyright (c) 2012, Greenvity Communication All rights reserved. 
 *
 */

/* === Includes ============================================================ */

#include <string.h>
#include "papdef.h"
#include "return_val.h"
#include "bmm.h"
#include "qmm.h"
#include "mac_msgs.h"
#include "mac_hal.h"
#include "mac_const.h"
#include "mac_api.h"
#include "mac_data_structures.h"
#include "mac_internal.h"
#include "mac.h"
#include "utils.h"

/* === Macros =============================================================== */

/*
 * Disassociation payload length
 */
#define DISASSOC_PAYLOAD_LEN             (2)

/* === Globals ============================================================= */


/* === Prototypes ========================================================== */


/* === Implementation ====================================================== */

/*
 *
 * This function sends the disassociation request information to HAL. On
 * sending the disassociation request all information about its parent device
 * is cleared.
 *
 * buf_p Pointer to the buffer to be sent to TAL.
 *
 * return True if the frame is transmitted successfully, false otherwise.
 */
static bool mac_awake_disassociate (buffer_t *buf_p)
{
    frame_info_t *transmit_frame_p;
    retval_t  tx_status;
    tx_mode_t tx_mode;

    transmit_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);

    if (NON_BEACON_NWK == hal_pib_BeaconOrder) {
        /* In Nonbeacon network the frame is sent with unslotted CSMA-CA. */
        tx_mode = CSMA_UNSLOTTED;
    } else {
        /* In Beacon network the frame is sent with slotted CSMA-CA. */
        tx_mode = CSMA_SLOTTED;
    }

    /*
     * FIXME - Need to handle encrypttion of dis-association packet
     */
    tx_status = mac_hal_tx_frame(transmit_frame_p, tx_mode, false);

    if (MAC_SUCCESS == tx_status) {
        MAC_BUSY();
    } else {
        return (FALSE);
    }

    return (TRUE);
}

/**
 *
 * This function creates and appends a MLME disassociate confirm message
 * into the  internal event queue.
 *
 * buf_p  - Buffer for sending MLME disassociate confirm message to NHLE
 * status - Status of disassociation
 * dev_addr_mode - Addressing mode of the device that has either requested
 *                 disassociation or been instructed to disassociate by
 *                 its coordinator.
 * dev_panid - PAN identifier of the device that has either requested
 *              disassociation or been instructed to disassociate by its
 *              coordinator.
 * dev_addr - Address of the device that has either requested
 *            disassociation or been instructed to disassociate by its
 *            coordinator.
 */
static void mac_gen_mlme_disassociate_conf (buffer_t *buf_p,
                                            uint8_t status,
                                            uint8_t dev_addr_mode,
                                            uint16_t dev_panid,
                                            address_field_t *dev_addr)
{
    mlme_disassociate_conf_t *mdc;

    mdc = (mlme_disassociate_conf_t *)BMM_BUFFER_POINTER(buf_p);

    mdc->cmdcode = MLME_DISASSOCIATE_CONFIRM;
    mdc->status = status;
    mdc->DeviceAddrMode = dev_addr_mode;
    mdc->DevicePANId = dev_panid;

    if (FCF_SHORT_ADDR == dev_addr_mode) {
        EXT_ADDR_CLEAR(mdc->DeviceAddress.long_address);
        ADDR_COPY_DST_SRC_16(mdc->DeviceAddress.short_address,
                             dev_addr->short_address);
    } else {
        ADDR_COPY_DST_SRC_64(mdc->DeviceAddress.long_address,
                             dev_addr->long_address);

    }

    mlme_associate_conf(buf_p);
}



/**
 * Handles the MLME disassociate request command from the NWK layer
 *
 * The MLME-DISASSOCIATE.request primitive is generated by the next
 * higher layer of an associated device and issued to its MLME to
 * request disassociation from the PAN. It is also generated by the
 * next higher layer of the coordinator and issued to its MLME to
 * instruct an associated device to leave the PAN.
 *
 * Pointer to the MLME-DISASSOCIATION.Request message passed by NHLE
 */
void mlme_disassociate_request (buffer_t *buf_p)
{
    mlme_disassociate_req_t disassoc_req;
    frame_info_t *transmit_frame_p;
    uint8_t frame_len;
    uint8_t *frame_ptr;
    uint8_t *temp_frame_ptr;
    uint16_t fcf;

    transmit_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);

    /* Store the disassociation request received from NHLE. */
    memcpy((uint8_t *)&disassoc_req, (uint8_t *)transmit_frame_p,
            sizeof(mlme_disassociate_req_t));

    if (disassoc_req.DevicePANId != hal_pib_PANId) {
        mac_gen_mlme_disassociate_conf(buf_p,
                                       MAC_INVALID_PARAMETER,
                                       disassoc_req.DeviceAddrMode,
                                       disassoc_req.DevicePANId,
                                       &disassoc_req.DeviceAddress);
        return;
    }

    /* Build disassociation command frame. */
    transmit_frame_p->buffer_header_p = buf_p;
    transmit_frame_p->msg_type = DISASSOCIATIONNOTIFICATION;

    /* Get the payload pointer. */
    temp_frame_ptr = (uint8_t *)transmit_frame_p +
                                BUFFER_SIZE -
                                DISASSOC_PAYLOAD_LEN; 
    frame_ptr = temp_frame_ptr;

    /* Update the payload field. */
    *frame_ptr++ = DISASSOCIATIONNOTIFICATION;

    /* Set up the disassociation reason code. */
    *frame_ptr = disassoc_req.DisassociateReason;

    /* Get the payload pointer again to add the MHR. */
    frame_ptr = temp_frame_ptr;

    /* Update the length. */
    frame_len = DISASSOC_PAYLOAD_LEN +
                PAN_ID_LEN           +
                SHORT_ADDR_LEN       +
                EXT_ADDR_LEN         +    /* Source Ext Address */
                FCF_LEN              +
                SEQ_NUM_LEN;


    /* Source address */
    frame_ptr -= EXT_ADDR_LEN;
    mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);

    /* Destination address */
    if (FCF_SHORT_ADDR == disassoc_req.DeviceAddrMode) {
        frame_ptr -= SHORT_ADDR_LEN;
        mac_utils_16_bit_to_byte_array(disassoc_req.DeviceAddress.short_address, frame_ptr);
    } else {
        frame_ptr -= EXT_ADDR_LEN;
        frame_len += EXT_ADDR_LEN;
        mac_utils_64_bit_to_byte_array(disassoc_req.DeviceAddress.long_address, frame_ptr);
    }

    /* Destination PAN-Id */
    frame_ptr -= PAN_ID_LEN;
    mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);


    /* Set DSN. */
    frame_ptr--;
    *frame_ptr = mac_pib_macDSN++;


    /* Construct FCF. */
    /* 802.15.4-2006 sets the PAN-Id compression) bit. */
     fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
           FCF_SET_DEST_ADDR_MODE(disassoc_req.DeviceAddrMode) |
           FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
           FCF_PAN_ID_COMPRESSION |
           FCF_ACK_REQUEST;

     /* Set the FCF. */
     frame_ptr -= FCF_LEN;
     mac_utils_16_bit_to_byte_array(fcf, frame_ptr);

    /* First element shall be length of PHY frame. */
    frame_ptr--;
    *frame_ptr = frame_len;

    /* Finished building of frame. */
    transmit_frame_p->mpdu_p = frame_ptr;

    /* Indirect transmission not ongoing yet. */
    transmit_frame_p->indirect_in_transit = false;

    if (((MAC_PAN_COORD_STARTED == mac_state) ||
         (MAC_COORDINATOR == mac_state)) &&
         (disassoc_req.TxIndirect)) {
        /*
         * The current device is a coordinator, and if the DeviceAddress
         * is not ours, then send via indirect transmission.
         */
        if (((disassoc_req.DeviceAddrMode == WPAN_ADDRMODE_SHORT) &&
             (disassoc_req.DeviceAddress.short_address != macCoordShortAddress)) ||
            ((disassoc_req.DeviceAddrMode == WPAN_ADDRMODE_LONG) &&
             (EXT_ADDR_NOMATCH(disassoc_req.DeviceAddress.long_address,
                               mac_pib_macCoordExtendedAddress)))) {
            /* Append the data into indirect queue. */
            if (TRUE == qmm_queue_append(&indirect_data_q,
                                         buf_p)) {
                /*
                 * If there is no capacity to store the transaction, the MLME
                 * will discard the MSDU and issue the MLME-DISASSOCIATE.
                 * confirm primitive with a status of TRANSACTION_OVERFLOW.
                 */
                mac_gen_mlme_disassociate_conf(buf_p,
                                               MAC_TRANSACTION_OVERFLOW,
                                               disassoc_req.DeviceAddrMode,
                                               disassoc_req.DevicePANId,                              
                                               &disassoc_req.DeviceAddress);
                return;
            }

            /*
             * If an FFD does have pending data,
             * the MAC persistence timer needs to be started.
             */
            transmit_frame_p->persistence_time = 
                                     mac_pib_macTransactionPersistenceTime;
            mac_start_persistence_timer();
        } else {
            mac_gen_mlme_disassociate_conf(buf_p,
                                           MAC_INVALID_PARAMETER,
                                           disassoc_req.DeviceAddrMode,
                                           disassoc_req.DevicePANId,
                                           &disassoc_req.DeviceAddress);
            return;
        }
    } else    /* Device */ {
        bool transmission_status;

        /* Wake up the radio first */
        mac_trx_wakeup();

        transmission_status = mac_awake_disassociate(buf_p);

        if (!transmission_status) {
            /* Create the MLME DISASSOCIATION confirmation message */
            mac_gen_mlme_disassociate_conf(buf_p,
                                           MAC_CHANNEL_ACCESS_FAILURE,
                                           disassoc_req.DeviceAddrMode,
                                           disassoc_req.DevicePANId,
                                           &disassoc_req.DeviceAddress);

            /* Set radio to sleep if allowed */
            mac_trx_sleep();
        }
    }
}


/**
 * Process a disassociation notification command
 *
 * This functions processes a received disassociation notification
 * command frame.
 * Actual data are taken from the incoming frame in mac_parse_buffer.
 *
 * msg_p - Frame buffer to be filled in
 */
void mac_process_disassociate_notification (buffer_t *buf_p)
{
    mlme_disassociate_ind_t *dai =
        (mlme_disassociate_ind_t *)BMM_BUFFER_POINTER(buf_p);

    /* Set up the header portion of the mlme_disassociate_ind_t. */
    dai->cmdcode = MLME_DISASSOCIATE_INDICATION;

    /* Build the indication parameters. */

    /*
     * Set the DeviceAddress first. The device address is the address
     * of the device requesting the disassociaton which is always
     * contained in the source address.
     */
    ADDR_COPY_DST_SRC_64(dai->DeviceAddress,
                         mac_parse_data.src_addr.long_address);

    dai->DisassociateReason = 
        mac_parse_data.mac_payload_data.disassoc_req_data.disassoc_reason;

    mlme_disassociate_ind(buf_p);

    /*
     * Once a device is disassociated from a coordinator, the coordinator's
     * address info should be cleared.
     */
    EXT_ADDR_CLEAR(mac_pib_macCoordExtendedAddress);

    /* The default short address is 0xFFFF. */
    mac_pib_macCoordShortAddress = INVALID_SHORT_ADDRESS;
}

/**
 * Prepares a disassociation confirm message with device address information
 *
 * This functions prepares a disassociation confirm message in case the device
 * address information needs to be extracted.
 *
 * buf_p - Buffer pointer for sending MLME disassociate confirm message to NHLE
 * status - Status of disassociation
 */
void mac_prep_disassoc_conf (buffer_t *buf_p, uint8_t status)
{

    uint8_t dis_dest_addr_mode;
    uint64_t temp_dev_addr;
    frame_info_t *frame_ptr = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);

    EXT_ADDR_CLEAR(temp_dev_addr);
    dis_dest_addr_mode = (((frame_ptr->mpdu_p[PL_POS_FCF_2]) >>
                          FCF_2_DEST_ADDR_OFFSET) & 3);

    if ((FCF_SHORT_ADDR == dis_dest_addr_mode) ||
        (FCF_LONG_ADDR  == dis_dest_addr_mode)) {
        temp_dev_addr =
              mac_utils_byte_array_to_64_bit(
                   &(frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]));
    }

    if (MAC_PAN_COORD_STARTED == mac_state) {
        /*
         * For PAN coordinator fill parameters of device that
         * we requested to disassociate into the disassociation confirm
         * message.
         * Since we have transmitted the disassociation notification frame
         * ourvelves, the destination address information is to be used here.
         */
        if (FCF_SHORT_ADDR == dis_dest_addr_mode) {
            mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                            status,
                                            dis_dest_addr_mode,
                                            hal_pib_PANId,
                                            (address_field_t *)&temp_dev_addr);
        } else {
            mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                           status,
                                           dis_dest_addr_mode,
                                           hal_pib_PANId,
                                           (address_field_t *)&temp_dev_addr);

        }
    } else if (MAC_COORDINATOR == mac_state) {
        uint16_t mac_coor_short_addr;
        uint64_t mac_coor_long_addr;

        /*
         * We are the coordinator.
         * We have requested ourselves to disassociate with our own parent.
         * Or we have requested one of our children (other coordinators or
         * end devices) to leave the network.
         */
         mac_coor_short_addr = mac_utils_byte_array_to_16_bit(
                             &frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]);
         mac_coor_long_addr  = mac_utils_byte_array_to_64_bit(
                             &frame_ptr->mpdu_p[PL_POS_DST_ADDR_START]); 
        if (((FCF_SHORT_ADDR == dis_dest_addr_mode) &&
             (mac_coor_short_addr == mac_pib_macCoordShortAddress)) ||
             ((FCF_LONG_ADDR == dis_dest_addr_mode) &&
              EXT_ADDR_MATCH(mac_coor_long_addr,
                             mac_pib_macCoordExtendedAddress))) {
            /*
             * We are acting as a child here, so we need to fill in our
             * own device parameter into the disassociation confirm message.
             */
            if ((BROADCAST == hal_pib_ShortAddress) ||
                (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress)) {
                mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                               status,
                                               FCF_LONG_ADDR,
                                               hal_pib_PANId,
                                               (address_field_t *)
                                               &hal_pib_IeeeAddress);
            } else {
                mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                               status,
                                               FCF_SHORT_ADDR,
                                               hal_pib_PANId,
                                               (address_field_t *)
                                               &hal_pib_ShortAddress);
            }
        } else {
            /*
             * We are acting as a parent here and have requested one of our
             * children to leave the network.
             * For coordinators that are disassociating their children.
             * fill parameters of device/child that we requested to
             * disassociate into the disassociation confirm message.
             * Since we have transmitted the disassociation notification frame
             * ourvelves, the destination address information is to be used
             * here.
             */
            mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                           status,
                                           dis_dest_addr_mode,
                                           hal_pib_PANId,
                                           (address_field_t *)&temp_dev_addr);
        }
    } else {
        /*
         * We are an end device. Fill in our own device parameters into the
         * disassociation confirm message.
         */
        if ((BROADCAST == hal_pib_ShortAddress) ||
            (MAC_NO_SHORT_ADDR_VALUE == hal_pib_ShortAddress)) {
            mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                           status,
                                           FCF_LONG_ADDR,
                                           hal_pib_PANId,
                                           (address_field_t *)
                                           &hal_pib_IeeeAddress);
        } else {
            mac_gen_mlme_disassociate_conf((buffer_t *)buf_p,
                                           status,
                                           FCF_SHORT_ADDR,
                                           hal_pib_PANId,
                                           (address_field_t *)
                                           &hal_pib_ShortAddress);
        }
    }
}
