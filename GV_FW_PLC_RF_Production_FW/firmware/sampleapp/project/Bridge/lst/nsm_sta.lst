C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NSM_STA
OBJECT MODULE PLACED IN .\obj\nsm_sta.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\link\nsm_sta.c LARGE OBJECTADVANCED OPTIMI
                    -ZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\.
                    -.\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\s
                    -rc\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\.
                    -.\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\z
                    -igbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\even
                    -t\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hp
                    -gp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_supp
                    -ort;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\dri
                    -vers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\component
                    -s;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..
                    -\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\dri
                    -vers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\util
                    -ities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drive
                    -rs\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\.
                    -.\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HY
                    -BRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_
                    -SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ
                    -_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTE
                    -RRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP
                    -,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\nsm_sta.lst) TABS
                    -(2) OBJECT(.\obj\nsm_sta.obj)

line level    source

   1          /** ========================================================
   2           *
   3           * @file nsm_sta.c
   4           * 
   5           *  @brief Network System Manager:
   6           *         CNSM: CCO Network System Manager
   7           *         SNSM: STA Network System Manager
   8           *
   9           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
  10           *  All Rights Reserved
  11           *  
  12           * =========================================================*/
  13          
  14          
  15          #include <string.h>
  16          #include <stdio.h>
  17          #include <assert.h>
  18          #include "papdef.h"
  19          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  22          #include "linkl.h"
  23          #include "nsm.h"
  24          #include "nam.h"
  25          #include "muxl.h"
  26          #include "nma.h"
  27          #include "nma_fw.h"
  28          #include "hpgpapi.h"
  29          #include "hpgpconf.h"
  30          #include "fm.h"
  31          #include "ism.h"
  32          #include "hpgpevt.h"
  33          #include "mmsg.h"
  34          #include "timer.h"
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 2   

  35          #include "stm.h"
  36          #include "hal.h"
  37          #ifdef HPGP_HAL
  38          #include "hal_hpgp.h"
  39          #else
              #include "sdrv.h"
              #endif
  42          #include "frametask.h"
  43          #ifndef CALLBACK
  44          #include "hpgpapi.h"
  45          #endif
  46          #include "hybrii_tasks.h"
  47          #include "sys_common.h"
  48          #include "hal_hpgp_reset.h"
  49          #include "hpgp_msgs.h"
  50          #include "event_fw.h"
  51          
  52          #ifdef LLP_POWERSAVE
              u32 lastgCCO_BTS = 0;
              #endif
  55          #ifndef UART_HOST_INTF
              #define DISC_BCN
              #endif
  58          
  59          
  60          #define HPGP_TIME_BBT                  1000   //2 seconds
  61          
  62          #define HPGP_JOINNET_TIME           3000
  63          #define HPGP_TIME_USAI                  1000   //1 seconds
  64          //#define HPGP_TIME_DISC_AGING            120000 // 2 minutes
  65          #define HPGP_TIME_BEACON_LOSS           200 // test 
  66          
  67          #define HPGP_TIME_DISC_AGING            500 // test 
  68          #define HPGP_TIME_DISC_AGING_UNASSOC    500 // test
  69          
  70          #define HPGP_TIME_BEACON_LOSS            200 // test 
  71          
  72          #define DISC_STALL_TIME         5000
  73          #define BCN_STALL_TIME          5000
  74          
  75          #define HPGP_TIME_DISC_PERIOD_MAX       5000   //10 seconds - MaxDiscoverPeriod
  76          //#define HPGP_TIME_STA_AGING_CNT       5  //5* 10 seconds - MaxDiscoverPeriod
  77          #define HPGP_IDENTIFY_CAP_TIME               500
  78          #define HPGP_HO_COUNTDOWN_MAX           5   //5 beacon periods
  79          #define HPGP_HO_SWITCH_NONE             0   //no handover switch
  80          #define HPGP_HO_SWITCH_STA              1   //switch to the STA mdoe/role
  81          #define HPGP_HO_SWITCH_CCO              2   //switch to the CCO mdoe/role
  82          
  83          /* default regions (in unit of ALU) */
  84          #define HPGP_REGION_MIN_SHARED_CSMA    0x5DC  /* minimum shared CSMA */
  85                                                        /* 1500 usec */        
  86          #define HPGP_REGION_MIN_LOCAL_CSMA     0x5DC  /* minimum local CSMA  */
  87                                                        /* 1500 usec */             
  88          #define HPGP_REGION_MAX_BEACON         (8*HPGP_BEACON_SLOT_ATU)  
  89                                                        /* maximum beacon region */
  90                                                        /* 8 slots */             
  91          #define HPGP_GLID_LOCAL_CSMA           0xFF
  92          #define HPGP_GLID_SHARED_CSMA          0xFE
  93          #define HPGP_GLID_DISC_BEACON          0xFD
  94          #define HPGP_GLID_GPP                  0xFB
  95          
  96          #ifdef SIMU
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 3   

              #define HPGP_TIME_BCN_INTERVAL    4 //4 ms
              #endif
  99          
 100          #ifdef LLP_POWERSAVE
              extern u8 psDebug;
              #ifdef PS_RESYNC
              extern u8 resyncFlag;
              #endif
              #endif
 106          extern u8 syncThres;
 107          #ifdef BCN_ERR
 108          volatile u8 bpstoFound = FALSE;
 109          #endif
 110          
 111          //beacon source
 112          enum
 113          {
 114              BCN_SRC_CCO,  // central beacon from the CCo/proxy CCo in the same network
 115              BCN_SRC_DISC, // discovery beacon from the STA in the same network 
 116              BCN_SRC_OTHER_CCO, //CCo or proxy CCo in other networks
 117              BCN_SRC_OTHER_DISC, //discovery beacon from other networks
 118              BCN_SRC_UNKNOWN,     //unknown
 119          };
 120          
 121          extern void LINKL_TimerHandler(u16 type, void *cookie);
 122          void CNSM_Stop(sCnsm *cnsm);
 123          void SCB_UpdateDiscNetList(sScb *scb, sDiscNetInfoRef *discNetInfoRef);
 124          sDiscNetInfo *SCB_GetDiscNetEntry(u8 *nid);
 125          void SCB_UpdateDiscStaList(sScb *scb, sDiscStaInfoRef *discStaInfoRef);
 126          void SCB_AgeDiscLists(sScb *scb);
 127          extern void setCSMA_onCCO1();
 128          #ifdef ROUTE
              extern void ROUTE_prepareHoldList(sCrm *crm, sScb *scb);
              eStatus ROUTE_sendRouteInfoReq(sScb *scb);
              extern eStatus ROUTE_sendRouteInfo(u16 mmType, sEvent *reqEvent);
              #endif
 133          
 134          #if 1
 135          //beacon entry header type
 136          u8 BeHdrType[] =
 137          {
 138              BEHDR_NON_PERSISTENT_SCHED,    //0x00   //Non-Persistent Schedule
 139              BEHDR_PERSISTENT_SCHED,        //0x01   //Current Persistent Schedule
 140              BEHDR_PERSISTENT_SCHED,        //0x01   //Preview Persistent Schedule
 141              BEHDR_REGIONS,                 //0x02   //region Schedule
 142              BEHDR_MAC_ADDR,                //0x03   //MAC Address
 143              BEHDR_DISCOVER,                //0x04   //Discover
 144              BEHDR_DISC_INFO,               //0x05   //Discovered Info
 145              BEHDR_BPSTO,                   //0x06   //Beacon Period Start Time Offset
 146              BEHDR_ENCRYP_KEY_CHANGE,       //0x07   //Encryption Key Change
 147              BEHDR_CCO_HANDOVER,            //0x08   //CCo Handover
 148              BEHDR_BCN_RELOC,               //0x09   //Beacon Relocation
 149              BEHDR_ACL_SYNC_CNTDOWN,        //0x0A   //AC Line Sync Countdown
 150              BEHDR_CHANGE_NUM_SLOTS,        //0x0B   //Change NumSlots
 151              BEHDR_CHANGE_HM,               //0x0C   //Change Hybrid Mode
 152              BEHDR_CHANGE_SNID,             //0x0D   //Change SNID
 153              BEHDR_RSN_INFO,                //0x0E   //RSN Info Element
 154              BEHDR_ISP,                     //0x0F   //ISP BENTRY
 155              BEHDR_EXT_BAND_STAY_OUT,       //0x10   //Extended Band Stay Out
 156              BEHDR_AG_ASSIGN,               //0x11   //AG Assignment
 157              BEHDR_EXT_CARR_SUPPORT,        //0x12   //Extended Carriers Support
 158              BEHDR_PWR_SAVE,                //0x13   //Power Save BENTRY
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 4   

 159              BEHDR_VENDOR_SPEC,             //0xFF   //Vendor Specific
 160          };
 161          
 162          //Maximum size allowed for each entry corresponding to BeHdrType[]
 163          u8 BeLenMax[] =
 164          {
 165              sizeof(sBcnHdr) + 2 + 16,     //non-persistent: 4 SAIs (4 octets per SAI)
 166              sizeof(sBcnHdr) + 2 + 16,     //current persistent: 4 SAIs (4 octets per SAI)
 167              sizeof(sBcnHdr) + 2 + 16,     //preview persistent: 4 SAIs (4 octets per SAI)
 168              sizeof(sBcnHdr) + 1 + 8,      //region: 4 regions
 169              sizeof(sBcnHdr) + MAC_ADDR_LEN,  //MAC Address
 170              sizeof(sBcnHdr) + 1,             //Discover
 171              sizeof(sBcnHdr) + sizeof(sDiscInfoEntry),   //Discovered Info
 172              sizeof(sBcnHdr) + 3,            //Beacon Period Start Time Offset
 173              sizeof(sBcnHdr) + sizeof(sEncrypKeyChangeEntry),  //Encryption Key Change
 174              sizeof(sBcnHdr) + sizeof(sCcoHoEntry),      //CCo Handover
 175              sizeof(sBcnHdr) + sizeof(sBcnRelocEntry),   //Beacon Relocation
 176              sizeof(sBcnHdr) + sizeof(sAclSyncCntDownEntry),  //AC Line Sync Countdown
 177              sizeof(sBcnHdr) + sizeof(sChangeNumSlotsEntry),  //Change NumSlots
 178              sizeof(sBcnHdr) + sizeof(sChangeHmEntry),        //Change Hybrid Mode
 179              sizeof(sBcnHdr) + sizeof(sChangeSnidEntry),      //Change SNID
 180              0,                             //RSN Info Element
 181              0,                             //ISP BENTRY
 182              0,                             //Extended Band Stay Out
 183              0,                             //AG Assignment
 184              0,                             //Extended Carriers Support
 185              sizeof(sBcnHdr) + 12,          //Power Save BENTRY: 8 stations
 186              0,                             //Vendor Specific
 187          };
 188          #else
              extern u8 BeHdrType[];
              extern u8 BeLenMax[];
              
              #endif
 193          volatile u32 gPastRxBcnCount = 0;
 194          #ifdef SW_RECOVERY
 195          
 196          static u8 gStartDiscStallTimer = 0;
 197          extern u8 gDiscStallCounter;
 198          extern u8 gBcnStallCounter;
 199          extern u32 gDiscStall;
 200          extern u32 gBcnStall;
 201          #endif
 202          void showStaType(u8 stamode, u8 staType)
 203          {
 204   1          if(stamode == LINKL_STA_MODE_STA)
 205   1          {
 206   2              switch(staType)
 207   2              {
 208   3                  case LINKL_STA_TYPE_SC_JOIN: 
 209   3                      FM_Printf(FM_USER, "STA TYPE JOIN\n");
 210   3                      break;
 211   3                  case LINKL_STA_TYPE_SC_ADD: 
 212   3                      FM_Printf(FM_USER, "STA TYPE ADD\n");
 213   3                      break;
 214   3                  case LINKL_STA_TYPE_NETDISC: 
 215   3                      FM_Printf(FM_USER, "STA NETWORK DISC\n");
 216   3                      break;
 217   3                  case LINKL_STA_TYPE_UNASSOC: 
 218   3                      FM_Printf(FM_USER, "STA UNASSOC\n");
 219   3                      break;
 220   3                  case LINKL_STA_TYPE_UNASSOC_PASSIVE:
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 5   

 221   3                      FM_Printf(FM_USER, "STA TYPE UNASSOC PASSIVE\n");
 222   3                      break;
 223   3                  case LINKL_STA_TYPE_ASSOC:
 224   3                      FM_Printf(FM_USER, "STA ASSOC\n");
 225   3                      break;
 226   3                  default:                
 227   3                  {
 228   4      
 229   4                  }
 230   3      
 231   3              }
 232   2          }
 233   1          else if(stamode == LINKL_STA_MODE_CCO)
 234   1          {
 235   2              switch(staType)
 236   2              {
 237   3                  case LINKL_CCO_TYPE_UNASSOC: 
 238   3                      FM_Printf(FM_USER, "CCO UNASSOC\n");
 239   3                      break;
 240   3                  case LINKL_CCO_TYPE_ASSOC: 
 241   3                      FM_Printf(FM_USER, "CCO ASSOC\n");
 242   3                      break;
 243   3                  case LINKL_CCO_TYPE_HO: 
 244   3                      FM_Printf(FM_USER, "CCO HANDOVER\n");
 245   3                      break;
 246   3                  default:
 247   3                  {
 248   4      
 249   4                  }
 250   3              }
 251   2      
 252   2          }
 253   1      
 254   1      }
 255          
 256          #ifdef STA_FUNC
 257          /* ========================== 
 258           * STA  network system manager
 259           * ========================== */
 260          void SNSM_UpdateUaStaList(sSnsm *snsm, sCmUaStaInd *uaStaInfo, u8 *macAddr)
 261          {
 262   1          u8 i;
 263   1          u8 k = UA_STA_LIST_MAX;
 264   1          for(i = 0; i < UA_STA_LIST_MAX; i++)
 265   1          {
 266   2              if(snsm->uaStaInfo[i].valid == TRUE)
 267   2              {
 268   3                  if( (memcmp(snsm->uaStaInfo[i].nid, uaStaInfo->nid, NID_LEN) == 0)&&
 269   3                      (memcmp(snsm->uaStaInfo[i].macAddr, macAddr, MAC_ADDR_LEN) == 0))
 270   3                  {
 271   4                      snsm->uaStaInfo[i].hit = 1;
 272   4                      return;
 273   4                  }
 274   3              }
 275   2              else
 276   2              {
 277   3                  k = i;
 278   3              }
 279   2          }
 280   1      
 281   1          if(k < UA_STA_LIST_MAX)
 282   1          {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 6   

 283   2              snsm->uaStaInfo[k].valid = 1;
 284   2              snsm->uaStaInfo[k].hit = 1;
 285   2              memcpy(snsm->uaStaInfo[k].nid, uaStaInfo->nid, NID_LEN);
 286   2              memcpy(snsm->uaStaInfo[k].macAddr, macAddr, MAC_ADDR_LEN);
 287   2              snsm->uaStaInfo[k].ccoCap = uaStaInfo->ccoCap;
 288   2          }
 289   1      }
 290          #if 0
                          
              
              void SNSM_UpdateAvlnList(sSnsm *snsm, sAvlnInfoRef *avlnInfo)
              {
              #ifdef MCCO   
                sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sStaInfo *staInfo = &linkl->staInfo;
              #endif
                  
              
                  u8 i;
                  u8 k;
                  //search through the AVLN list 
                  k = AVLN_LIST_MAX;
                  for(i = 0; i < AVLN_LIST_MAX; i++)
                  {
                    u8 weightAvg = 0;
                      if(snsm->avlnInfo[i].valid == TRUE)
                      {
                          if((memcmp(snsm->avlnInfo[i].nid, avlnInfo->nid, NID_LEN-1) == 0) &&
                             ((snsm->avlnInfo[i].nid[NID_LEN-1]&NID_EXTRA_BIT_MASK) ==
                              (avlnInfo->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)))
                          {
                              //found the existing AVLN
                              snsm->avlnInfo[i].hit = 1;
              
                      weightAvg = ((snsm->avlnInfo[i].rssi *80)/100) + (( avlnInfo->rssi* 20)/100);
                      snsm->avlnInfo[i].rssi = weightAvg;
                      snsm->avlnInfo[i].lqi = avlnInfo->lqi;
                      snsm->avlnInfo[i].tei = avlnInfo->tei;
                      snsm->avlnInfo[i].numOfSta = avlnInfo->numOfSta;
                      snsm->avlnInfo[i].bcnRxCnt++;
                      
                              return;
                          }            
                      }
                      else
                      {
                          k = i;  
                      }
                  }
                  
                  if(k < AVLN_LIST_MAX)
                  {
                      //found a new AVLN
                      snsm->avlnInfo[k].valid = TRUE;
                      memcpy(snsm->avlnInfo[k].nid, avlnInfo->nid, NID_LEN-1);
                      snsm->avlnInfo[k].nid[NID_LEN-1] = avlnInfo->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK;
                      snsm->avlnInfo[k].hit = 1;
                  snsm->avlnInfo[k].tei = avlnInfo->tei;    
              
                  //FM_Printf(FM_USER, "TEI FOUND %bu\n", avlnInfo->tei);
                  
                  snsm->avlnInfo[k].rssi = avlnInfo->rssi;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 7   

                  snsm->avlnInfo[k].lqi = avlnInfo->lqi;
                  snsm->avlnInfo[k].numOfSta = avlnInfo->numOfSta;    
                      snsm->avlnInfo[k].snid = avlnInfo->snid;
              #ifdef MCCO   
              
                  staInfo->slotUsage |= BIT(avlnInfo->slotId);
                  snsm->avlnInfo[k].slotId = avlnInfo->slotId;//Kiran
                //  printf("\nMulti NW: Slot ID AVLN List : %bu\n",avlnInfo->slotId);//Kiran
              #endif
                      snsm->numAvln++;
              
                  }
                  else
                  {
                  
              #ifndef RELEASE 
                      FM_Printf(FM_WARN, "Anetfull\n");
              #endif
                  }
              }
              
              #endif
 367          
 368          
 369          //aging the discovered STA and network lists
 370          void SNSM_PerformAging(sSnsm *snsm)
 371          {
 372   1          u8 i;
 373   1      //    sLinkLayer *linkl = NULL;
 374   1      //    sEvent *event = NULL;
 375   1          sScb   *scb = NULL;
 376   1      
 377   1          if(snsm->state ==  SNSM_STATE_NET_DISC)
 378   1          {
 379   2              for(i = 0; i < UA_STA_LIST_MAX; i++)
 380   2              {
 381   3                  if(snsm->uaStaInfo[i].valid == TRUE)
 382   3                  {
 383   4                      if(snsm->uaStaInfo[i].hit == 1)
 384   4                      {
 385   5                          snsm->uaStaInfo[i].hit = 0;
 386   5                      }
 387   4                      else
 388   4                      {
 389   5                         //remove the entry from the list
 390   5                         memset(&snsm->uaStaInfo[i], 0, sizeof(sUaStaInfo));
 391   5                         // reduce uasta count
 392   5                         snsm->numUaSta--; 
 393   5                      }
 394   4                  }
 395   3              }
 396   2              
 397   2      #if 0   
                      for(i = 0; i < AVLN_LIST_MAX; i++)
                      {
                          if(snsm->avlnInfo[i].valid == TRUE)
                          {
                              if(snsm->avlnInfo[i].hit == 1)
                              {
                                  snsm->avlnInfo[i].hit = 0;
                              }
                              else
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 8   

                              {
                                 //remove the entry from the list
                                 memset(&snsm->avlnInfo[i], 0, sizeof(sAvlnInfo));
                                 // reduce avln count
                                 snsm->numAvln--;
                              }
                          }
                      }
              #endif        
 416   2              
 417   2          }
 418   1         SCB_AgeDiscLists(scb);
 419   1         
 420   1      /*
 421   1          if(snsm->state ==  SNSM_STATE_CONN)
 422   1          {
 423   1              scb = snsm->staInfo->staScb;
 424   1              SCB_AgeDiscLists(scb);
 425   1              for(i = 0; i < DISC_STA_LIST_MAX; i++)
 426   1              {
 427   1                  if(scb->discStaInfo[i].valid == TRUE)
 428   1                  {
 429   1                      if(scb->discStaInfo[i].hit == 1)
 430   1                      {
 431   1                          scb->discStaInfo[i].hit = 0;
 432   1                      }
 433   1                      else
 434   1                      {
 435   1      FM_Printf(FM_ERROR, "SNSM: age out a discovery entry (tei: %d).\n",
 436   1                          scb->discStaInfo[i].tei);
 437   1                         //remove the entry from the list
 438   1                         memset(&scb->discStaInfo[i], 0, sizeof(sDiscStaInfo));
 439   1                         scb->discUpdate = 1;
 440   1                         scb->numDiscSta--;
 441   1                      }
 442   1                  }
 443   1              }
 444   1      
 445   1              for(i = 0; i < DISC_NET_LIST_MAX; i++)
 446   1              {
 447   1                  if(scb->discNetInfo[i].valid == TRUE)
 448   1                  {
 449   1                      if(scb->discNetInfo[i].hit == 1)
 450   1                      {
 451   1                          scb->discNetInfo[i].hit = 0;
 452   1                      }
 453   1                      else
 454   1                      {
 455   1                         //remove the entry from the list
 456   1                         memset(&scb->discNetInfo[i], 0, sizeof(sDiscNetInfo));
 457   1                         scb->discUpdate = 1;
 458   1                         scb->numDiscNet--;
 459   1                      }
 460   1                  }
 461   1              }
 462   1      
 463   1              //NOTE: noBcn is reset after the central beacon is received
 464   1              snsm->noBcn++; 
 465   1      
 466   1              if(snsm->noBcn > NO_BCN_MAX)
 467   1              {
 468   1                  //send event CCO_SEL_IND to the ctrl        
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 9   

 469   1                  event = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
 470   1                  if(event == NULL)
 471   1                  {
 472   1                      FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 473   1                  }
 474   1                  else
 475   1                  {
 476   1                      //free all SCBs in the TEI map
 477   1                      CRM_Init(snsm->crm);
 478   1      
 479   1                      //TODO: search for the backup CCO through the TEI MAP list
 480   1      
 481   1                      event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 482   1                      //deliver the event to the upper layer
 483   1                      linkl = (sLinkLayer *)HOMEPLUG_GetLayer(HP_LAYER_TYPE_LINK);
 484   1                      linkl->deliverEvent(linkl->eventcookie, event);
 485   1                  }
 486   1                                       
 487   1              } 
 488   1          }
 489   1      */
 490   1      }
 491          
 492          
 493          u8 SNSM_SelectCco(sSnsm *snsm,  sEvent *event)
 494          {
 495   1          u8          *myMacAddr = NULL;
 496   1          u8          *staMacAddr = NULL;
 497   1          u8           beCco = FALSE;
 498   1          u8           ccoCap;
 499   1          sCmUaStaInd *uaStaInfo;
 500   1      #ifdef UKE  
                  sCmJoinReq  *joinReq;
              #endif
 503   1      
 504   1          sHpgpHdr    *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
 505   1      #if  0 // defined(LG_WAR)
                  if(snsm->staInfo->lastUserAppCCOState != 0)
                  {
                      return FALSE;
                  }
              #endif
 511   1      
 512   1          if(event->eventHdr.type == EVENT_TYPE_CM_UNASSOC_STA_IND)
 513   1          {
 514   2               uaStaInfo = (sCmUaStaInd *) event->buffDesc.dataptr;
 515   2      
 516   2          //chceck if the NID is matched
 517   2              if(memcmp(snsm->staInfo->nid, uaStaInfo->nid, NID_LEN) != 0)
 518   2                  return beCco;
 519   2              
 520   2              ccoCap  = uaStaInfo->ccoCap;
 521   2      
 522   2          }
 523   1      #ifdef UKE  
                  else
                  if(event->eventHdr.type == EVENT_TYPE_CM_SC_JOIN_REQ)
                  {
                      if((snsm->staInfo->secMode != SEC_MODE_SC_ADD &&
                          snsm->staInfo->secMode != SEC_MODE_SC_JOIN))
                      {
                          return beCco;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 10  

                      }
              
                      joinReq = (sCmJoinReq *) event->buffDesc.dataptr;
                      
                      ccoCap = joinReq->ccoCapability;
                  }
              #endif
 538   1      
 539   1          if(snsm->staInfo->staCap.fields.ccoCap > ccoCap)
 540   1          {
 541   2              beCco = TRUE;
 542   2          }
 543   1          else if (snsm->staInfo->staCap.fields.ccoCap == ccoCap)
 544   1          {
 545   2              //compare MAC address
 546   2              myMacAddr = snsm->staInfo->macAddr;
 547   2              staMacAddr = hpgpHdr->macAddr;      
 548   2      #ifdef NSM_STA_PRINT                              
              FM_Printf(FM_MINFO,"my MAC Address:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
                                  myMacAddr[0], myMacAddr[1],
                                  myMacAddr[2], myMacAddr[3],
                                  myMacAddr[4], myMacAddr[5]);
              FM_Printf(FM_MINFO,"peer MAC Address:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
                                  staMacAddr[0], staMacAddr[1],
                                  staMacAddr[2], staMacAddr[3],
                                  staMacAddr[4], staMacAddr[5]);
              #endif
 558   2                  if((memcmp(myMacAddr, staMacAddr, MAC_ADDR_LEN) > 0))
 559   2                  {
 560   3                      beCco = TRUE;
 561   3                  }
 562   2          
 563   2          } 
 564   1          return beCco;
 565   1      }
 566          
 567          //this function is called by the upper layer (e.g. when BBT timer expires) 
 568          //to determine the role of STA during network discovery
 569          u8 SNSM_DetermineStaRole(sSnsm *snsm)
 570          {
 571   1          u8 i;
 572   1          u8  staRole = STA_ROLE_USTA;
 573   1          for(i = 0; i < UA_STA_LIST_MAX; i++)
 574   1          {
 575   2              if(snsm->uaStaInfo[i].valid == TRUE)
 576   2              {
 577   3                  if( memcmp(snsm->uaStaInfo[i].nid, snsm->staInfo->nid, NID_LEN) == 0)
 578   3                  {
 579   4                      //matched NID is found
 580   4                      if(snsm->staInfo->staCap.fields.ccoCap > snsm->uaStaInfo[i].ccoCap)
 581   4                      {
 582   5                          staRole = STA_ROLE_ACCO;
 583   5                      }
 584   4                      else if(snsm->staInfo->staCap.fields.ccoCap == snsm->uaStaInfo[i].ccoCap)
 585   4                      {
 586   5                          if((memcmp(snsm->staInfo->macAddr, 
 587   5                                     snsm->uaStaInfo[i].macAddr, MAC_ADDR_LEN) > 0))
 588   5                          {
 589   6                              staRole = STA_ROLE_ACCO;
 590   6                          }
 591   5                          else
 592   5                          {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 11  

 593   6                              staRole = STA_ROLE_USTA;
 594   6                          }
 595   5                      } 
 596   4                      else
 597   4                      {
 598   5                          staRole = STA_ROLE_USTA;
 599   5                      }
 600   4                      break;
 601   4                  }
 602   3              }
 603   2          }         
 604   1      
 605   1          if (i == UA_STA_LIST_MAX)
 606   1          {
 607   2              if(snsm->staInfo->numDiscNet)
 608   2              {
 609   3                  staRole = STA_ROLE_USTA;
 610   3              } 
 611   2              else
 612   2              {
 613   3                  staRole = STA_ROLE_UCCO;
 614   3              }
 615   2          }
 616   1      
 617   1          return staRole;
 618   1      }
 619          
 620          
 621          eStatus SNSM_BuildDiscBcn(sSnsm *snsm, sBeHdr *beHdrRef[])
 622          {
 623   1          u8              i, done;
 624   1          u8              offset = 0;
 625   1          u8              beLen = 0;
 626   1          u8              bcnLen = 0;
 627   1          sBcnHdr        *bcnHdr = NULL;
 628   1          sBeHdr         *centralBeHdr = NULL;
 629   1          sBeHdr         *beHdr = NULL;
 630   1          sDiscInfoEntry *discInfoEntry = NULL;
 631   1          sStaInfo       *staInfo = NULL;
 632   1          u8             *dataptr = NULL;
 633   1      
 634   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
 637   1          offset = sizeof(sFrmCtrlBlk);
 638   1      #endif
 639   1      
 640   1      
 641   1          staInfo = snsm->staInfo;
 642   1      
 643   1          memset(snsm->discBcnBuff, 0, BEACON_BUFF_LEN );
 644   1          bcnHdr = (sBcnHdr *)(snsm->discBcnBuff + offset);
 645   1          //(1)prepare the Beacon first 12 fixed portion
 646   1          memcpy(bcnHdr->nid, staInfo->nid, NID_LEN);
 647   1          bcnHdr->nid[NID_LEN-1] = (bcnHdr->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)|(staInfo->hm<<6);
 648   1          bcnHdr->stei = staInfo->staScb->tei;
 649   1      
 650   1        bcnHdr->slotid = snsm->slotId;
 651   1        bcnHdr->slotusage = staInfo->slotUsage;
 652   1        
 653   1          bcnHdr->bt = BEACON_TYPE_DISCOVER;
 654   1          bcnLen = sizeof(sBcnHdr);       //13 bytes, including nbe
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 12  

 655   1      
 656   1          //(2)prepare the Beacon entries  
 657   1          dataptr = (u8 *)bcnHdr + sizeof(sBcnHdr);
 658   1      
 659   1          i = 0;
 660   1          done = 0;
 661   1          beHdr = (sBeHdr *)dataptr;
 662   1          bcnHdr->nbe = 0;
 663   1          //TODO: may verify if there is enough room to transmit
 664   1          //the schedule entries.
 665   1          while((!done) && ((offset + bcnLen + BeLenMax[i]) <= BEACON_PAYLOAD_SIZE))
 666   1          {
 667   2              beLen = 0;
 668   2              switch(BeHdrType[i])
 669   2              {
 670   3                  case BEHDR_NON_PERSISTENT_SCHED:
 671   3                  case BEHDR_PERSISTENT_SCHED:
 672   3                  case BEHDR_REGIONS:
 673   3                  case BEHDR_CCO_HANDOVER:
 674   3                  case BEHDR_BCN_RELOC:
 675   3                  case BEHDR_CHANGE_NUM_SLOTS:
 676   3                  case BEHDR_CHANGE_SNID:
 677   3                  {
 678   4                     //copy those beacon entries
 679   4                     //from the central beacon to discover beacon
 680   4                     centralBeHdr = beHdrRef[BeHdrType[i]];
 681   4                     if(centralBeHdr)
 682   4                     {
 683   5                         memcpy(dataptr, centralBeHdr, 
 684   5                                centralBeHdr->beLen+sizeof(sBeHdr));  
 685   5                         dataptr +=sizeof(sBeHdr);
 686   5                         beLen = centralBeHdr->beLen;
 687   5                     }
 688   4                     break;
 689   4                  }
 690   3                  case BEHDR_MAC_ADDR: 
 691   3                  {
 692   4                      //always include mac addre entry
 693   4                      beHdr->beType = BEHDR_MAC_ADDR; 
 694   4                      dataptr +=sizeof(sBeHdr);
 695   4                      memcpy(dataptr, staInfo->macAddr, MAC_ADDR_LEN);
 696   4      
 697   4                      beLen = MAC_ADDR_LEN;
 698   4      
 699   4                      break;
 700   4                  } 
 701   3                  case BEHDR_DISC_INFO:
 702   3                  {
 703   4                      //always include discovered info entry
 704   4                      beHdr->beType = BEHDR_DISC_INFO;
 705   4                      dataptr +=sizeof(sBeHdr);
 706   4                      discInfoEntry = (sDiscInfoEntry *)dataptr;
 707   4                      discInfoEntry->staCap.byte = staInfo->staCap.byte;
 708   4                      discInfoEntry->staCap.fields.update = 
 709   4                          staInfo->staScb->discUpdate;          
 710   4      #ifdef BCNP                
                      FM_Printf(FM_MINFO, "SNSM:disc bcn update:%d,%d\n", discInfoEntry->staCap.fields.update, staInfo->staS
             -cb->discUpdate);
              #endif
 713   4                      discInfoEntry->numDiscSta = staInfo->numDiscSta; 
 714   4                      discInfoEntry->numDiscNet = staInfo->numDiscNet; 
 715   4                      discInfoEntry->staStatus.byte = staInfo->staStatus.byte;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 13  

 716   4      
 717   4                      beLen = sizeof(sDiscInfoEntry);
 718   4                      break;
 719   4                  }
 720   3                  case BEHDR_BPSTO:
 721   3                  {
 722   4                      //always include beacon period start time offset
 723   4                      beHdr->beType = BEHDR_BPSTO;
 724   4                      dataptr += sizeof(sBeHdr);
 725   4                      beLen = 3;
 726   4                      //snsm->bpstoOffset = bcnLen + sizeof(sBeHdr);
 727   4                      snsm->bpstoOffset = ((u8 *)beHdr  + sizeof(sBeHdr)) -  ((u8 *)snsm->discBcnBuff );
 728   4                      break;
 729   4                  }
 730   3      #ifdef POWERSAVE
                          case BEHDR_PWR_SAVE:
                          {
                              if(staInfo->staScb->psState == PSM_PS_STATE_ON)
                      {
                        // in DISC beacon's PS bentry, the only pertinent field is STA's PSS
                        sPowerSaveEntry *pPsBentry ;
              
                                beHdr->beType = BEHDR_PWR_SAVE;
                        beLen = sizeof(sPowerSaveEntry);
                                dataptr += sizeof(sBeHdr);
                        pPsBentry = (sPowerSaveEntry *) dataptr;
                        memcpy(pPsBentry, 0, sizeof(sPowerSaveEntry));
                          pPsBentry->tpss = staInfo->staScb->pss;
                      }
                      break;
                          }
              #endif
 748   3            case BEHDR_VENDOR_SPEC:  
 749   3                  {
 750   4                      done = 1;
 751   4                      break;
 752   4                  }
 753   3                  default:
 754   3                  {
 755   4                  }
 756   3              }
 757   2              if( beLen != 0)
 758   2              { 
 759   3                  beHdr->beLen = beLen; 
 760   3                  bcnLen += sizeof(sBeHdr) + beHdr->beLen;
 761   3                  dataptr += beLen;
 762   3                  beHdr = (sBeHdr *)dataptr;
 763   3                  beLen = 0;
 764   3                  bcnHdr->nbe++;
 765   3              }
 766   2              i++;
 767   2          }
 768   1      
 769   1      
 770   1          if((offset + bcnLen) > BEACON_PAYLOAD_SIZE)
 771   1          {
 772   2      #ifdef NSM_STA_PRINT  
                      FM_Printf(FM_ERROR, "SNSM:disc bcn large\n");
              #endif    
 775   2              return STATUS_FAILURE;
 776   2          }
 777   1      
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 14  

 778   1          return STATUS_SUCCESS;
 779   1      
 780   1      }
 781          
 782          void SNSM_TransmitDiscBcn(sSnsm *snsm) 
 783          {
 784   1          sTxDesc         txinfo;
 785   1          sBuffDesc       buffDesc;
 786   1          u8              offset = 0; 
 787   1      
 788   1          FM_Printf(FM_HINFO, "SNSM:>>DISC BCN\n");
 789   1      
 790   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
 793   1          offset = sizeof(sFrmCtrlBlk);
 794   1      #endif
 795   1      
 796   1          //transmit the beacon 
 797   1          txinfo.dtei = 0xFF;
 798   1          txinfo.stei = snsm->staInfo->staScb->tei;
 799   1          txinfo.frameType = BEACON_TYPE_DISCOVER;
 800   1          txinfo.snid = snsm->staInfo->snid;
 801   1        
 802   1          //prepare tx control information
 803   1          buffDesc.buff = snsm->discBcnBuff;
 804   1          buffDesc.bufflen = BEACON_BUFF_LEN;
 805   1          buffDesc.dataptr = snsm->discBcnBuff + offset;
 806   1          buffDesc.datalen = BEACON_PAYLOAD_SIZE;
 807   1      
 808   1          //FM_HexDump(FM_DATA|FM_MINFO, "SNSM: discovery beacon:", 
 809   1          //                             buffDesc.dataptr,
 810   1          //                             buffDesc.datalen);
 811   1      
 812   1          HAL_TransmitBeacon(HOMEPLUG_GetHal(), &txinfo, &buffDesc, snsm->bpstoOffset);
 813   1      }
 814          
 815          
 816          u8 SNSM_DetectCco(sSnsm *snsm, sBcnHdr *bcnHdr) 
 817          {
 818   1          sLinkLayer     *linkl = NULL;
 819   1          sStaInfo       *staInfo = NULL;
 820   1          sCrm           *crm = NULL;
 821   1          u8              bcnsrc = BCN_SRC_UNKNOWN;
 822   1      
 823   1      //    linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 824   1          linkl = snsm->linkl;
 825   1          staInfo = LINKL_GetStaInfo(linkl);
 826   1          crm = LINKL_GetCrm(linkl);
 827   1      
 828   1      
 829   1      
 830   1          bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
 831   1      /*
 832   1         FM_Printf(FM_MINFO,"my NID: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 833   1                              snsm->staInfo->nid[0], snsm->staInfo->nid[1],
 834   1                              snsm->staInfo->nid[2], snsm->staInfo->nid[3],
 835   1                              snsm->staInfo->nid[4], snsm->staInfo->nid[5],
 836   1                              snsm->staInfo->nid[6]);
 837   1         FM_Printf(FM_MINFO,"beacon NID: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 838   1                              bcnHdr->nid[0], bcnHdr->nid[1],
 839   1                              bcnHdr->nid[2], bcnHdr->nid[3],
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 15  

 840   1                              bcnHdr->nid[4], bcnHdr->nid[5],
 841   1                              bcnHdr->nid[6]);
 842   1      */
 843   1          if((memcmp(staInfo->nid, bcnHdr->nid, NID_LEN) == 0))
 844   1          {
 845   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 846   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 847   2              {
 848   3                  bcnsrc = BCN_SRC_CCO;
 849   3                  if(staInfo->ccoScb == NULL)
 850   3                  {
 851   4      #ifdef NSM_STA_PRINT      
                              FM_Printf(FM_MINFO, "SNSM:Add a scb for CCo\n");
              #endif        
 854   4                      staInfo->ccoScb = CRM_AddScb(crm, bcnHdr->stei);
 855   4                      //NOTE: Beacon event does not contain CCo's MAC adddr
 856   4                      //The STA does not know CCo's MAC address until it associates
 857   4                      //with the CCo or it sends a query or receives discovery beacon
 858   4                      if(!staInfo->ccoScb) 
 859   4                      {
 860   5                          FM_Printf(FM_WARN, "SNSM:can't get CCo scb\n");
 861   5                return bcnsrc;          
 862   5                      }
 863   4                      memcpy(staInfo->ccoScb->macAddr, bcAddr, MAC_ADDR_LEN);
 864   4                  }
 865   3              }
 866   2              else
 867   2              {
 868   3                  bcnsrc = BCN_SRC_DISC;
 869   3              }
 870   2          }
 871   1          else
 872   1          {
 873   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 874   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 875   2              {
 876   3                  bcnsrc = BCN_SRC_OTHER_CCO;
 877   3              }
 878   2              else
 879   2              {
 880   3                  bcnsrc = BCN_SRC_OTHER_DISC;
 881   3              }
 882   2          }
 883   1      //    FM_Printf(FM_MINFO, "SNSM: Detect CCo %d.\n", bcnsrc);
 884   1          return bcnsrc;
 885   1      }
 886          
 887          void SNSM_HandleBcnLoss(sSnsm *snsm, u8 type)
 888          {
 889   1      
 890   1        sBcnHdr    *bcnHdr = NULL;
 891   1        u8        becomeCco = FALSE;
 892   1        u8        *bcn = NULL;
 893   1        sEvent     *newEvent = NULL;
 894   1        sHpgpHdr   *hpgpHdr = NULL;
 895   1        sCmUaStaInd  *uaStaInfo = NULL;
 896   1        sScb     *scb = NULL;
 897   1        sStaInfo   *staInfo = NULL; 
 898   1        sCrm     *crm = NULL;
 899   1        sEvent *event;
 900   1        sSnam    *snam = NULL;
 901   1        
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 16  

 902   1        //    sCnam      *cnam = NULL;
 903   1        sLinkLayer   *linkl  = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 904   1        
 905   1      
 906   1        staInfo = LINKL_GetStaInfo(linkl); 
 907   1        crm = LINKL_GetCrm(linkl);
 908   1        snam = LINKL_GetSnam(linkl);
 909   1      
 910   1        if (!snsm->enableBcnLossDetection)
 911   1        {
 912   2          return;
 913   2      
 914   2        }
 915   1      
 916   1        //type = *(iEvent->buffDesc.dataptr);
 917   1        
 918   1        if((type == MAX_NO_BEACON_NW_DISCOVERY) ||
 919   1           (type == MAX_NO_BEACON_BACKUPCCO))
 920   1        {
 921   2          sCcoLostIndEvent *ccoLostInd;
 922   2      
 923   2          
 924   2      
 925   2          if (type ==  MAX_NO_BEACON_NW_DISCOVERY)
 926   2          {
 927   3      
 928   3            Host_SendIndication(HOST_EVENT_BCN_LOSS, HPGP_MAC_ID, NULL, 0);
 929   3            //send event CCO_SEL_IND to the ctrl    
 930   3            event = EVENT_Alloc(1, EVENT_HPGP_CTRL_HEADROOM);
 931   3      
 932   3            if(event == NULL)
 933   3            {
 934   4              FM_Printf(FM_ERROR, "EAF\n");
 935   4                      return;
 936   4            }
 937   3      
 938   3      
 939   3            event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 940   3            event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 941   3      
 942   3          
 943   3            ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;   
 944   3            //free all SCBs in the TEI map
 945   3            CRM_Init(snsm->crm);
 946   3      
 947   3            
 948   3            //SNSM_Stop(&linkl->staNsm);
 949   3            //SNAM_Stop(&linkl->staNam);
 950   3            
 951   3      
 952   3            ccoLostInd->reason   =  0;
 953   3      #ifdef SW_RECOVERY
 954   3      
 955   3            gStartDiscStallTimer = 1;
 956   3      
 957   3      #endif
 958   3      
 959   3            snsm->state = SNSM_STATE_INIT;
 960   3      
 961   3            //deliver the event to the upper layer
 962   3      #ifdef CALLBACK
                    linkl->deliverEvent(linkl->eventcookie, event);
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 17  

              #else
 965   3            CTRLL_ReceiveEvent(linkl->eventcookie, event);
 966   3      #endif
 967   3            snsm->enableBcnLossDetection = 0;
 968   3      
 969   3          }
 970   2          else
 971   2          {
 972   3            if (snsm->enableBackupCcoDetection  == 0)
 973   3            {
 974   4          
 975   4            Host_SendIndication(HOST_EVENT_PRE_BCN_LOSS, HPGP_MAC_ID, NULL, 0);
 976   4            if(staInfo->staCap.fields.backupCcoStatus)
 977   4            {
 978   5      
 979   5              
 980   5                
 981   5                
 982   5              //send event CCO_SEL_IND to the ctrl    
 983   5              event = EVENT_Alloc(1, EVENT_HPGP_CTRL_HEADROOM);
 984   5      
 985   5              if(event == NULL)
 986   5              {
 987   6                FM_Printf(FM_ERROR, "EAF\n");
 988   6                          return;
 989   6              }
 990   5      
 991   5              HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);
 992   5      
 993   5              event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 994   5              event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 995   5      
 996   5              ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;   
 997   5      
 998   5              //perform handover switch to the CCo role
 999   5              //CRM has all SCBs for each STA from the  
1000   5              //CC_HANDOVER_INFO.IND,
1001   5              
1002   5                SNSM_Stop(&linkl->staNsm);
1003   5                  SNAM_Stop(&linkl->staNam);
1004   5              
1005   5              staInfo->ccoScb = staInfo->staScb; 
1006   5              staInfo->ccoScb->staCap.fields.ccoStatus = 1;
1007   5      
1008   5              staInfo->staCap.fields.backupCcoStatus = 0;
1009   5              staInfo->staCap.fields.pcoStatus = 0;
1010   5      
1011   5              //deliver the event to the upper layer
1012   5      
1013   5              
1014   5              ccoLostInd->reason  =  1;
1015   5      #ifdef CALLBACK
                      linkl->deliverEvent(linkl->eventcookie, event);
              #else
1018   5              CTRLL_ReceiveEvent(linkl->eventcookie, event);
1019   5      #endif
1020   5            }
1021   4            else
1022   4            {
1023   5              snsm->enableBackupCcoDetection = 1;
1024   5            }
1025   4            }
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 18  

1026   3      
1027   3          }
1028   2      
1029   2      
1030   2        } 
1031   1      
1032   1      }
1033          
1034          //This function is called only when the STA is associated with the CCo
1035          //void SNSM_ProcBcn(sSnsm *snsm, sEvent *event)
1036          //We split the beacon processing into two parts:
1037          //High priority: those requiring immdiate response
1038          //Low  priority: those tolerating the delay.
1039          void SNSM_ProcBcnLow(sSnsm *snsm, sRxDesc *rxdesc, u8* bcn )
1040          {
1041   1          sBcnHdr        *bcnHdr = NULL;
1042   1          sBeHdr         *beHdr = NULL;
1043   1          u8              bcnsrc;
1044   1          u8              nid7;
1045   1          u8              nbe = 0;
1046   1          u8             *dataptr = 0;
1047   1          u8             *macAddr = NULL;
1048   1          sDiscStaInfoRef discStaInfoRef;
1049   1          sDiscNetInfoRef discNetInfoRef;
1050   1      //    sBcnRef         bcnRef;
1051   1          sCcoHoEntry    *ccoHo = NULL;
1052   1          sStaInfo       *staInfo = NULL;
1053   1      #ifdef ROUTE
                  sScb           *scb = NULL;
              #endif
1056   1        u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);
1057   1      
1058   1          /*Compiler warning suppression*/
1059   1          discNetInfoRef = discNetInfoRef;
1060   1        
1061   1          staInfo = snsm->staInfo;
1062   1      
1063   1          //(1) process the beacon header
1064   1      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
1065   1          bcnHdr = (sBcnHdr *) bcn;
1066   1          //get the Hybrid Mode before calling SNSM_DetectCco(),
1067   1          //which will remove the HM in the beacon header
1068   1          nid7 = bcnHdr->nid[NID_LEN-1];
1069   1        
1070   1          //first, check if it is my CCo
1071   1          bcnsrc = SNSM_DetectCco(snsm, bcnHdr); 
1072   1          switch(bcnsrc)
1073   1          {
1074   2              case BCN_SRC_CCO:
1075   2              {
1076   3                  //now, it is my network CCo
1077   3                  snsm->noBcn = 0;
1078   3                  if(snsm->enableCcoDetection)
1079   3                  {
1080   4      #ifdef NSM_STA_PRINT      
                              FM_Printf(FM_HINFO, "SNSM:Detect the CCo\n");
              #endif        
1083   4                      snsm->enableCcoDetection = 0;
1084   4                      snsm->ccoDetected = 1;
1085   4                  }
1086   3                  break;
1087   3              }
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 19  

1088   2              case BCN_SRC_DISC:
1089   2              {
1090   3      #ifdef P8051
1091   3                  FM_Printf(FM_HINFO, "SNSM:<<DISC BCN(L) tei: %bu\n", bcnHdr->stei);
1092   3      #else
                          FM_Printf(FM_HINFO, "SNSM:<<DISC BCN(L) tei: %d\n", bcnHdr->stei);
              #endif
1095   3                  
1096   3      #ifdef LG_WAR
                          return;
              #endif
1099   3                  break;
1100   3              }
1101   2              case BCN_SRC_OTHER_CCO:
1102   2              {
1103   3                  //It is a CCo from other networks
1104   3            #if 0  // UpdateNet list happens in SNSM_ProcEvent start
                    discNetInfoRef.snid = rxdesc->snid;     
                          
                    discNetInfoRef.rssi = bcn[PLC_BCNRX_LEN-4-lLen]; 
                    discNetInfoRef.lqi = bcn[PLC_BCNRX_LEN-3-lLen];
              
              
                          //update the network list
                          discNetInfoRef.nid = bcnHdr->nid;
                          discNetInfoRef.hybridMode = nid7>>6;
                          discNetInfoRef.netMode = bcnHdr->nm;
                          discNetInfoRef.numBcnSlots = bcnHdr->numslots;
                    discNetInfoRef.slotId = bcnHdr->slotid;                     
              //            discNetInfoRef.bpsto = snsm->bpsto; //TODO: how to get the bpsto 
              
              
                    if (bcnHdr->bt != BEACON_TYPE_CENTRAL)
                    {
              
                      break;
              
                    }
                    
              
                          SCB_UpdateDiscNetList(snsm->staInfo->staScb, &discNetInfoRef);
                    #endif
1130   3                  return;
1131   3              }
1132   2              case BCN_SRC_OTHER_DISC:
1133   2              {
1134   3                  //discovery sta list may include the STA not in the same network
1135   3                  //but do not support it at present, though it is easy.
1136   3                  //
1137   3                  return;
1138   3              }
1139   2              default:
1140   2              {
1141   3              }
1142   2          }
1143   1      
1144   1          //now, the beacon is either central/proxy/discovery beacon 
1145   1          //from the same network
1146   1      
1147   1          if(bcnHdr->hoip)
1148   1          {
1149   2              //Call the SNAM to suspend the association request and traffic
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 20  

1150   2              snsm->stopSnam = 1;
1151   2          }
1152   1          else if(snsm->stopSnam) //may not be necessary
1153   1          {
1154   2              //Call the SNAM to resume the association request and traffic
1155   2              snsm->stopSnam = 0;
1156   2          }
1157   1      
1158   1      
1159   1      //    memset(&bcnRef, 0, sizeof(sBcnRef));
1160   1          nbe = bcnHdr->nbe;
1161   1          dataptr = bcn + sizeof(sBcnHdr);
1162   1          beHdr = (sBeHdr *) dataptr;
1163   1      
1164   1      //FM_Printf(FM_HINFO, "SNSM: Beacon entry number (%d).\n", nbe);
1165   1      
1166   1      
1167   1          //(2) Process Beacon Management Information (BMI)
1168   1          //Note: According to the standard, the BENTRYs within the MBI shall 
1169   1          //be arranged in increasing order of their BEHDR values.
1170   1          while(nbe)
1171   1          {
1172   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1173   2              switch (beHdr->beType)
1174   2              {
1175   3                  case BEHDR_MAC_ADDR:
1176   3                  {
1177   4                      macAddr = dataptr;
1178   4                      if (bcnsrc == BCN_SRC_CCO)
1179   4              {
1180   5                if(memcmp(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN))
1181   5                      {
1182   6                          //the central beacon from the backup CCo
1183   6                          //perform the CCo switch 
1184   6                          //(let the previous CCo scb aging out)
1185   6      
1186   6                
1187   6                if (snsm->enableBackupCcoDetection)
1188   6                {
1189   7                  staInfo->ccoScb = CRM_AddScb(snsm->crm, bcnHdr->stei);
1190   7      
1191   7                  //send CCO_DISC.IND to the SNAM to renew TEI with the
1192   7                  //backup CCo
1193   7                  snsm->ccoDetected = 1;
1194   7      
1195   7                  gHpgpHalCB.syncComplete = 0; // forcing re-sync to new Backup CCo
1196   7      
1197   7                  snsm->netSync = 0;
1198   7                  
1199   7                  snsm->enableBackupCcoDetection = 0;
1200   7      #ifndef RELEASE
1201   7      
1202   7                  FM_Printf(FM_HINFO, "SNSM:switch to backup CCo\n");
1203   7      #endif
1204   7                  }
1205   6                }
1206   5                else
1207   5                {
1208   6                  snsm->enableBackupCcoDetection = 0;
1209   6                }
1210   5                      }
1211   4                     
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 21  

1212   4                      break;
1213   4                  }
1214   3                  case BEHDR_DISC_INFO:
1215   3                  {
1216   4                      discStaInfoRef.discInfo = (sDiscInfoEntry *)dataptr;
1217   4                      if (macAddr)
1218   4                      {
1219   5                          discStaInfoRef.macAddr = macAddr;
1220   5      //                    discStaInfoRef.nid = bcnHdr->nid;
1221   5      //                    discStaInfoRef.tei = rxdesc->stei;
1222   5                          discStaInfoRef.tei = bcnHdr->stei;
1223   5                          discStaInfoRef.snid = rxdesc->snid;
1224   5      
1225   5                discStaInfoRef.slotId = bcnHdr->slotid;
1226   5                
1227   5                discStaInfoRef.slotUsage = bcnHdr->slotusage;
1228   5                
1229   5                          //NOTE: hm filed in the beacon is set to zero
1230   5                          //in SNSM_DetectCco()
1231   5                          if( memcmp(snsm->staInfo->nid, bcnHdr->nid, NID_LEN) == 0 ) 
1232   5                          {
1233   6                              discStaInfoRef.sameNet = 1;
1234   6                          }
1235   5                          else
1236   5                          {
1237   6                              discStaInfoRef.sameNet = 0;
1238   6                          }
1239   5                          //update the discovred STA list
1240   5                          SCB_UpdateDiscStaList(staInfo->staScb, &discStaInfoRef);
1241   5      #ifdef ROUTE
                                  ROUTE_update(bcnHdr->stei);                    
              #endif
1244   5                      }
1245   4                      else
1246   4                      {
1247   5      #ifndef RELEASE
1248   5                          FM_Printf(FM_WARN, "SNSM:Unknown disc STA in Bcn\n");
1249   5      #endif
1250   5                      }
1251   4                      break;
1252   4                  }
1253   3                  case BEHDR_ENCRYP_KEY_CHANGE:
1254   3                  {
1255   4                      break;
1256   4                  }
1257   3      #ifdef HOM
                          case BEHDR_CCO_HANDOVER:
                          {
                              ccoHo = (sCcoHoEntry *)dataptr;
                              FM_Printf(FM_HINFO, "SNSM:HO cntdown(%d)\n", ccoHo->hcd);
                              if(ccoHo->hcd == 0)
                              {
                                  //FM_Printf(FM_HINFO, "SNSM: HO switch.\n");
                                  //HO countdown expires. perform handover
                                  if(ccoHo->nctei == snsm->staInfo->tei)
                                  {
                                      //switch to the CCO mode/role
                                      snsm->hoSwitch = HPGP_HO_SWITCH_CCO;
                                  }
                                  else
                                  {
                                      //still in the STA mode but associate to new CCO 
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 22  

                                      snsm->nctei = ccoHo->nctei;
                                      snsm->hoSwitch = HPGP_HO_SWITCH_STA;
                                  }
                              }
                              break;
                          }
              #endif
1281   3                  case BEHDR_ACL_SYNC_CNTDOWN:
1282   3                  {
1283   4                      break;
1284   4                  }
1285   3                  case BEHDR_CHANGE_HM:
1286   3                  {
1287   4                      break;
1288   4                  }     
1289   3                  default:
1290   3                  {
1291   4                  }
1292   3              }
1293   2              //move to the next BEHDR
1294   2              dataptr = dataptr +  beHdr->beLen; 
1295   2              beHdr = (sBeHdr *) dataptr;
1296   2              nbe--;
1297   2          }         
1298   1      
1299   1      }
1300          void SNSM_BcnCheck(u8* bcn)
1301          {
1302   1        u8        nbe = 0;
1303   1        u8      xdata   *dataptr = NULL;
1304   1        sBcnHdr   xdata   *bcnHdr = NULL;
1305   1        sBeHdr      xdata   *beHdr = NULL;
1306   1      
1307   1        bcnHdr = (sBcnHdr *)bcn;
1308   1        nbe = bcnHdr->nbe;
1309   1        dataptr = bcn + sizeof(sBcnHdr);
1310   1        beHdr = (sBeHdr *) dataptr;
1311   1        #ifdef BCN_ERR
1312   1        bpstoFound = FALSE;
1313   1        #endif
1314   1        //(2) Process Beacon Management Information (BMI)
1315   1        //Note: According to the standard, the BENTRYs within the MBI shall 
1316   1        //be arranged in increasing order of their BEHDR values.
1317   1      
1318   1        //FM_HexDump(FM_DATA|FM_MINFO, "Rx Bcn:",
1319   1        //       bcn, PLC_BCNRX_LEN);
1320   1        while(nbe)
1321   1        { 
1322   2          dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1323   2          switch (beHdr->beType)
1324   2          {
1325   3            case BEHDR_BPSTO:
1326   3                  {
1327   4                      
1328   4      #ifdef BCN_ERR
1329   4                      bpstoFound = TRUE;
1330   4              break;
1331   4      #endif    
1332   4            }
1333   3            default:
1334   3            break;
1335   3          }
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 23  

1336   2           dataptr = dataptr + beHdr->beLen; 
1337   2              beHdr = (sBeHdr *) dataptr;
1338   2              nbe--;
1339   2        }
1340   1      
1341   1      }
1342              
1343          void SNSM_ProcBcnHigh(sSnsm *snsm, u8* bcn, u8 snid, u32 bts)
1344          {
1345   1          sBcnHdr        *bcnHdr = NULL;
1346   1          sBeHdr         *beHdr = NULL;
1347   1          sBeHdr         *beHdrRef[NELEMENTS(BeHdrType)];
1348   1          u8              nid7; 
1349   1          u8              bcnsrc = BCN_SRC_UNKNOWN; 
1350   1          u8              nbe = 0;
1351   1          u8             *dataptr = 0;
1352   1          u8              i = 0;
1353   1          u8              j = 0;
1354   1          sStaInfo       *staInfo = NULL;
1355   1          sCsmaRegion    *region = NULL;
1356   1          u8              regionNum = 0;
1357   1          u16             endTime = 0;
1358   1          sRegionEntry   *regionEntry = NULL;
1359   1        sHpgpHalCB *hhalCb = HOMEPLUG_GetHal()->hhalCb;
1360   1          
1361   1      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sPowerSaveEntry *pPsBentry ;
              #endif
1365   1      
1366   1       //FM_Printf(FM_HINFO, "SNSM_ProcBcnHigh\n");
1367   1      #if 1 
1368   1        // we cannot do NID comparision as we might be syncing to
1369   1        //  non-NID match CCo to send UNASSOC IND
1370   1        
1371   1      //  if ((memcmp(staInfo->nid, bcnHdr->nid, NID_LEN) == 0) &&
1372   1      
1373   1        if ((hhalCb->nwSelected)&&(hhalCb->snid == snid))
1374   1      
1375   1      #else
              #endif
1377   1      
1378   1          {
1379   2      
1380   2      
1381   2            staInfo = snsm->staInfo;
1382   2      
1383   2      // FM_Printf(FM_HINFO, "SNSM: BeHdrType size = %d\n", NELEMENTS(BeHdrType));
1384   2          for(i = 0; i< NELEMENTS(BeHdrType); i++)
1385   2          {
1386   3              beHdrRef[i] = NULL;
1387   3          }
1388   2          //(1) process the beacon header
1389   2      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
1390   2          bcnHdr = (sBcnHdr *)bcn;
1391   2      
1392   2          nid7 = bcnHdr->nid[NID_LEN-1];
1393   2      
1394   2            bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
1395   2      
1396   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1397   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 24  

1398   2              {
1399   3                  //it should not occur
1400   3      #ifdef NSM_STA_PRINT      
                          FM_Printf(FM_MMSG|FM_LINFO, "SNSM:<<CENTRAL/PROXY BCN(H)\n");
              #endif    
1403   3            if(bcnHdr->bt == BEACON_TYPE_CENTRAL && staInfo->ccoScb != NULL)
1404   3                  {
1405   4                    u8 weightAvg;
1406   4                      u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);     
1407   4              
1408   4              weightAvg = ((staInfo->ccoScb->bRssi  *80)/100) +
1409   4                     (( bcn[PLC_BCNRX_LEN-4-lLen] * 20)/100);
1410   4      
1411   4              
1412   4                      staInfo->ccoScb->bRssi = weightAvg; 
1413   4                      staInfo->ccoScb->bLqi = bcn[PLC_BCNRX_LEN-3-lLen];
1414   4                     // FM_Printf(FM_USER,"R %bu ",staInfo->ccoScb->bRssi);
1415   4                     // FM_Printf(FM_USER,"L %bu\n",staInfo->ccoScb->bLqi);
1416   4                  } 
1417   3                  bcnsrc = BCN_SRC_CCO;
1418   3              }
1419   2              else
1420   2              {
1421   3      #ifdef P8051
1422   3                  FM_Printf(FM_HINFO, "SNSM:<<DISC BCN(H) tei: %bu\n", bcnHdr->stei);
1423   3      #else
                          FM_Printf(FM_HINFO, "SNSM:<<DISC BCN(H) tei: %d\n", bcnHdr->stei);
              #endif
1426   3                  bcnsrc = BCN_SRC_DISC;
1427   3      
1428   3      #ifdef LOG_FLASH
                    logEvent(DISC_BCN_LOG,0,0,&bcnHdr->stei,1);
              #endif
1431   3      
1432   3      //#ifdef LG_WAR
1433   3                  return;  // we do not Sync or adapt region from Discovery beacon
1434   3      //#endif
1435   3      
1436   3              }
1437   2          }
1438   1          else
1439   1          {
1440   2      
1441   2      #if 1
1442   2                  bcnsrc = BCN_SRC_OTHER_CCO;
1443   2      #ifdef BCN_ERR
1444   2              bpstoFound = TRUE;
1445   2      #endif
1446   2                  
1447   2                  return;  // we do not sync or region adapt to any central beacon
1448   2                           // unless it is nwselected
1449   2      #else
              
                      if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
                          (bcnHdr->bt == BEACON_TYPE_PROXY))
                      {
                          bcnsrc = BCN_SRC_OTHER_CCO;
                          // Process other bcn for avln detection
                          if(snsm->state != SNSM_STATE_NET_DISC)
                          {                 
              #ifdef BCN_ERR
                        bpstoFound = TRUE;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 25  

              #endif
                              return; 
                          }
                      }
                      else
                      {
                          bcnsrc = BCN_SRC_OTHER_DISC;
                          //not interested in other discover beacons at present     
              #ifdef BCN_ERR
                      bpstoFound = TRUE;
              #endif
                          
                          return; // TODO TBD
                      }
              #endif
1475   2      
1476   2          }
1477   1      
1478   1          bcnHdr->nid[NID_LEN-1] = nid7;
1479   1      
1480   1        if((bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1481   1           (bcnHdr->bt == BEACON_TYPE_PROXY))
1482   1        {   
1483   2          
1484   2          hhalCb->bcnmisscnt = 0;
1485   2      #ifdef LLP_POWERSAVE
                  lastgCCO_BTS = gCCO_BTS;
              #endif
1488   2          gCCO_BTS = bts;
1489   2          hhalCb->bts = bts;
1490   2          hhalCb->bcnDetectFlag = 1;
1491   2      
1492   2          staInfo->slotUsage |= BIT(bcnHdr->slotid);
1493   2      
1494   2          snsm->slotId = bcnHdr->slotid;
1495   2      
1496   2          snsm->noBcn = 0;
1497   2        }
1498   1      
1499   1      
1500   1          /* see if the beacon region exists */
1501   1          region = snsm->region;
1502   1          j = 0;
1503   1          if (bcnHdr->numslots)
1504   1          {
1505   2              /* need to include beacon region */
1506   2              region[j].startTime = 0;
1507   2              region[j].endTime = region[j].startTime + (bcnHdr->numslots * HPGP_BEACON_SLOT_ATU);
1508   2              region[j].regionType = REGION_TYPE_BEACON;
1509   2              region[j].rxOnly = 1;
1510   2              j++;
1511   2          }
1512   1                              
1513   1          nbe = bcnHdr->nbe;
1514   1          dataptr = bcn + sizeof(sBcnHdr);
1515   1          beHdr = (sBeHdr *) dataptr;
1516   1          
1517   1          //(2) Process Beacon Management Information (BMI)
1518   1          //Note: According to the standard, the BENTRYs within the MBI shall 
1519   1          //be arranged in increasing order of their BEHDR values.
1520   1      
1521   1          //FM_HexDump(FM_DATA|FM_MINFO, "Rx Bcn:",
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 26  

1522   1          //           bcn, PLC_BCNRX_LEN); 
1523   1          while(nbe)
1524   1          { 
1525   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1526   2              switch (beHdr->beType)
1527   2              {
1528   3                  case BEHDR_NON_PERSISTENT_SCHED:
1529   3                  {
1530   4                      beHdrRef[BEHDR_NON_PERSISTENT_SCHED] = beHdr;
1531   4      //                bcnRef.nonPersSchedEntry = beHdr;
1532   4       
1533   4                      break;
1534   4                  }
1535   3                  case BEHDR_PERSISTENT_SCHED:
1536   3                  {
1537   4                      sSaiWithSt    *saiwst = NULL;
1538   4                      sSaiWithoutSt *saiwost = NULL;
1539   4                      u8            *ptr = NULL;
1540   4                      u8 ns = 0; 
1541   4                      u8 scd = 0;
1542   4                      u8 stpf = 0;
1543   4                      u16 et = 0;
1544   4                      u16 st = 0;
1545   4                      u8 cscd;
1546   4                      static u8 changeSch = 1;
1547   4                      
1548   4                      beHdrRef[BEHDR_PERSISTENT_SCHED] = beHdr;
1549   4      //                bcnRef.persSchedEntry = beHdr;
1550   4      
1551   4                      /* schedule count down */
1552   4                      scd = *dataptr;
1553   4                      /* At present, interested in the current schedule only, 
1554   4                       * and ignore the preview schedule */ 
1555   4                      if (scd & 0x7) 
1556   4                      {
1557   5                          /* it is a preview schedule */
1558   5                          break; 
1559   5                      }
1560   4                      cscd = ((scd >> 3) & 0x7);
1561   4                      
1562   4                      if(changeSch == 1)
1563   4                      {
1564   5                              
1565   5                          /* now it is a current schedule */
1566   5                          /* NS */
1567   5                          ns = *(dataptr + 1);
1568   5                          ptr = dataptr + 2;
1569   5                          endTime = 0;
1570   5                    i = 0;
1571   5                          while((j < HPGP_REGION_MAX) && (i < ns))
1572   5                          {
1573   6                              stpf = *ptr;
1574   6                              if (stpf & 0x1) 
1575   6                              {
1576   7                                  saiwst = (sSaiWithSt *)ptr;
1577   7                                  endTime =  (saiwst->etHi << 4) | saiwst->etLo; 
1578   7                                  if ( (saiwst->glid == (HPGP_GLID_GPP & 0x7F)) ||
1579   7                                       (saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1580   7                                       (saiwst->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
1581   7                                  {
1582   8                                      st = (saiwst->stHi << 8) | saiwst->stLo;
1583   8                                      if(et != st)
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 27  

1584   8                                      {
1585   9                                          region[j].startTime =  0;//et;
1586   9                                          region[j].endTime = st;
1587   9                                          region[j].hybridMd  = 1;
1588   9                            region[j].rxOnly = 1;
1589   9                                          region[j].regionType = REGION_TYPE_STAYOUT;
1590   9      
1591   9                                      }
1592   8                                      et = endTime;
1593   8                                      j++;
1594   8                                      region[j].startTime =  0;//st;
1595   8                                      region[j].endTime = endTime;// - region[j].startTime;
1596   8                                      
1597   8                          if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) || 
1598   8                              (saiwst->glid == (HPGP_GLID_GPP & 0x7F))) 
1599   8                          {
1600   9                              region[j].hybridMd  = 1;
1601   9                            region[j].rxOnly = 0;
1602   9                            region[j].regionType = REGION_TYPE_SHARED_CSMA;
1603   9                          }
1604   8                          else
1605   8                          {
1606   9                              region[j].regionType = REGION_TYPE_LOCAL_CSMA;
1607   9                                          region[j].hybridMd = 1;
1608   9                                          region[j].rxOnly = 0;
1609   9                          }                            
1610   8                                      j++;
1611   8                                  }
1612   7                                  ptr += sizeof(sSaiWithSt);
1613   7                              }
1614   6                              else 
1615   6                              {
1616   7                                  saiwost = (sSaiWithoutSt *)ptr;
1617   7                                  if ( (saiwost->glid == (HPGP_GLID_GPP & 0x7F)) ||
1618   7                                       (saiwost->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1619   7                                       (saiwost->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
1620   7                                  {
1621   8                                      region[j].startTime =  0;//endTime;
1622   8                                      endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
1623   8                                      region[j].endTime = endTime;// - region[j].startTime;
1624   8                          if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1625   8                              (saiwost->glid == (HPGP_GLID_GPP & 0x7F))) 
1626   8                          {
1627   9                              region[j].hybridMd = 1;
1628   9                            region[j].rxOnly = 0;
1629   9                                  region[j].regionType = REGION_TYPE_SHARED_CSMA;
1630   9                          }
1631   8                          else
1632   8                          {
1633   9                              region[j].regionType = REGION_TYPE_LOCAL_CSMA;
1634   9                                          region[j].hybridMd = 1;
1635   9                                          region[j].rxOnly = 0;
1636   9                          }
1637   8                                      et = endTime;
1638   8                                      j++;
1639   8                                  }
1640   7                                  else
1641   7                                  {
1642   8                                      endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
1643   8                                      et = endTime;
1644   8                                  }
1645   7                                  ptr += sizeof(sSaiWithoutSt);
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 28  

1646   7                              }
1647   6                              i++;
1648   6                          }
1649   5                    for (;j < HPGP_REGION_MAX;j++)
1650   5                    {
1651   6                              region[j].startTime  = 0;//endTime;
1652   6                              region[j].rxOnly  = 1;
1653   6                              region[j].endTime   = 0xFFF;
1654   6                              region[j].hybridMd   = 1;  
1655   6                        region[j].regionType = REGION_TYPE_STAYOUT;
1656   6                              snsm->regionNum = j + 1;
1657   6                          }
1658   5                    //else
1659   5                          {
1660   6                              snsm->regionNum = HPGP_REGION_MAX;
1661   6                          }
1662   5                          //snsm->regionNum = HPGP_REGION_MAX;
1663   5      //#ifdef HPGP_HAL
1664   5                          HHAL_SetCsmaRegions(snsm->region, snsm->regionNum);
1665   5                          changeSch = 0;
1666   5      
1667   5      //#endif
1668   5                    //      for (j=0; j<snsm->regionNum; j++) {
1669   5                    //          FM_Printf(FM_USER, "SNSM: region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n",
             - 
1670   5                    //              j, snsm->region[j].startTime, snsm->region[j].endTime, snsm->region[j].rxOnl
             -y);
1671   5                    //      }
1672   5                      }
1673   4                //      printf("cscd : %bu \n", cscd);
1674   4      
1675   4                      if(cscd == 0 || cscd == 1) // if we loss bcn (cscd = 0) still it will modify sch
1676   4                      {
1677   5                          changeSch = 1;
1678   5                          
1679   5                      }
1680   4                      break;
1681   4                  }
1682   3                  case BEHDR_REGIONS:
1683   3                  {
1684   4                      beHdrRef[BEHDR_REGIONS] = beHdr;
1685   4                      //bcnRef.regionEntry = beHdr;
1686   4                     // setCSMA_onCCO1();
1687   4                      break;
1688   4                  }
1689   3                  case BEHDR_DISCOVER:
1690   3                  {
1691   4      #ifdef P8051
1692   4      FM_Printf(FM_HINFO, "SNSM:get discBcn sched(%bu)\n", *dataptr);
1693   4      #else
              FM_Printf(FM_HINFO, "SNSM:get discBcn sched(%d)\n", *dataptr);
              #endif
1696   4                      if( (staInfo->staScb)&&(staInfo->staScb->tei == *dataptr) )
1697   4                      {
1698   5                          //transmit the discover beacon
1699   5      #ifdef LG_WAR
                                  snsm->txDiscBcn = FALSE;
              #else
1702   5                          snsm->txDiscBcn = TRUE;
1703   5      #endif
1704   5                      }
1705   4                      break;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 29  

1706   4                  }
1707   3                  case BEHDR_BPSTO:
1708   3                  {
1709   4                      
1710   4      #ifdef BCN_ERR
1711   4                      bpstoFound = TRUE;
1712   4      #endif
1713   4      
1714   4      #ifdef HPGP_HAL
1715   4                      /* TODO: perform sync with the any net
1716   4                       * during the network discovery 
1717   4                       */
1718   4                      /* set it to MAC */
1719   4                  // Process other bcn also to sync network
1720   4                    //if((bcnsrc == BCN_SRC_CCO) || (bcnsrc == BCN_SRC_OTHER_CCO))
1721   4                    if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1722   4                          (bcnHdr->bt == BEACON_TYPE_PROXY))
1723   4                      {
1724   5      
1725   5                          memcpy(snsm->bpsto, dataptr, 3);
1726   5                          if ( HHAL_SyncNet(snsm->bpsto) == STATUS_SUCCESS 
1727   5                            && !snsm->netSync )
1728   5                          {
1729   6                              /* stop scan if it is my network */
1730   6                              //HAL_ScanNet(FALSE);
1731   6      
1732   6                              
1733   6                              snsm->netSync = TRUE;                        
1734   6      #ifndef RELEASE
1735   6                              FM_Printf(FM_MINFO, "SNSM:Setting netSync %bu\n", &snsm->bpsto[0]);                   
             -                                                    
1736   6      #endif
1737   6                          }
1738   5      #if 0
              
                                  /*FIXME: Host App should select the network , during scanning.
                                                   Selection could be based on Lqi/Rssi 
                                                   Temporarily the selection is done here */        
                                  if(snsm->netScan && !hhalCb->nwSelected)
                                  {
                          // TODO FIX THIS
                          
                                      if ((hhalCb->nwSelectedSnid == 0)  || 
                                          (hhalCb->nwSelectedSnid == snid))
                                      {
                                          if(hhalCb->halStats.RxGoodBcnCnt >= syncThres ) 
                                          {                            
                                              HHAL_SetSnid(snid);
                                              FM_Printf(FM_MINFO, "SNSM:Setting STA Snid %bu\n", snid);                 
             -            
                                          }
                                      }
                                  }
                                  
              #endif
1759   5      
1760   5                      }
1761   4      #endif
1762   4                      
1763   4                      break;
1764   4                  }
1765   3                  case BEHDR_CCO_HANDOVER:
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 30  

1766   3                  {
1767   4                      //FM_Printf(FM_HINFO, "SNSM: CCO HO (H).\n");
1768   4                      beHdrRef[BEHDR_CCO_HANDOVER] = beHdr;
1769   4                      break;
1770   4                  }
1771   3                  case BEHDR_BCN_RELOC:
1772   3                  {
1773   4                      beHdrRef[BEHDR_BCN_RELOC] = beHdr;
1774   4                      break;
1775   4                  }
1776   3                  case BEHDR_CHANGE_NUM_SLOTS:
1777   3                  {
1778   4                      beHdrRef[BEHDR_CHANGE_NUM_SLOTS] = beHdr;
1779   4                      break;
1780   4                  }
1781   3                  case BEHDR_CHANGE_SNID:
1782   3                  {
1783   4                      beHdrRef[BEHDR_CHANGE_SNID] = beHdr;
1784   4                      break;
1785   4                  }
1786   3                  case BEHDR_MAC_ADDR:
1787   3                  {
1788   4                      break;
1789   4                  }
1790   3      #ifdef POWERSAVE
                          case BEHDR_PWR_SAVE:
                          {
                              if(staInfo->staScb)
                      {
                        pPsBentry = (sPowerSaveEntry *) dataptr;
                          if (pPsBentry->spsf == TRUE)
                        {
                          // CCO wants to disable PS in AVLN
                          hhalCb->psAvln = FALSE; // AVLN PS = OFF
              
              //                    FM_Printf(FM_MMSG, "CENTRAL BCN RX: staInfo=%p, staInfo->staScb=%p, staInfo->staScb->p
             -sState=%bu\n", 
              //              staInfo, staInfo->staScb, staInfo->staScb->psState);
                          if (staInfo->staScb->psState == PSM_PS_STATE_ON)
                          {
                            // if Stop SP Flag is set by CCO, STA is not required to send 
                            // a PS_EXIT.REQ.
                            // it just clears its PS mode
                            PSM_ForcePsOff(staInfo->staScb); 
              //              PSM_set_sta_PS(FALSE, 0xF);
                          }
                        }   
                        else
                        {         
                          hhalCb->psAvln = TRUE;  // AVLN PS = ON
                        }
                        staInfo->ccoScb->psState = ((pPsBentry->tpss & 0x0f) == 0x0f) ? PSM_PS_STATE_OFF:PSM_PS_STATE_ON;  
                        staInfo->ccoScb->pss = pPsBentry->tpss;
                        staInfo->staScb->bpCnt = pPsBentry->bpCnt_Lo + (pPsBentry->bpCnt_Hi << 8);
              /*
                        if (psDebug)
                          printf("SNSM_ProcBcnHigh: received bpCnt=%d, pssi=%bu\n", staInfo->staScb->bpCnt, staInfo->staScb->p
             -ssi);
              */
                        if (staInfo->staScb->pssi != pPsBentry->pssi)
                        {
                          // PS State of AVLN has changed
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 31  

                          if (staInfo->staScb->psState != PSM_PS_STATE_WAITING_ON)
                          {
                            // if STA is waiting to enter PS mode, its AWD should be 0
                            staInfo->staScb->pssi = pPsBentry->pssi;
                            PSM_recalc_AW(DEV_MODE_STA);  // recalculate common Awake Window
                          }
                        }
              #ifdef DOTHIS
                        u8 numPsSta;
                        u8 *tmpDataPtr;
              
                        tmpDataPtr = dataptr + sizeof(sPowerSaveEntry);
                        numPsSta = (beHdr->beLen - sizeof(sPowerSaveEntry)) / 2;
                        for (i=0; i< numPsSta; i++)
                        {
              //            printf("numPsSta=%bu,beHdr->beLen=%bu, TEI=%bu, pss=0x%bx\n", numPsSta,  beHdr->beLen, tmpDataPtr[
             -i*2], tmpDataPtr[(i*2)+1]);
                        }
              #endif
              /*
                        if (psDebug)
                        {
                          u8 i;
                          u8 *tmpp = dataptr;
              
                          for (i=0;i<beHdr->beLen;i++)
                            printf("0x%bx ", tmpp[i]);
                          printf("\n"); 
                        }
              */
                      }
                      break;
                         }
              #endif
1859   3      
1860   3      
1861   3      #ifdef LLP_POWERSAVE
                          case BEHDR_PWR_SAVE:
                          {
                              if(linkl->hal->hhalCb->psSta && staInfo->staScb)  // STA's PS must be ON
                      {
                        pPsBentry = (sPowerSaveEntry *) dataptr;
                          if (pPsBentry->spsf == TRUE)
                        {
                          if (staInfo->staScb->psState == PSM_PS_STATE_ON)
                          {
                            // CCO wants to disable PS in AVLN
                            hhalCb->psAvln = FALSE; // AVLN PS = OFF
              
              //                      FM_Printf(FM_MMSG, "CENTRAL BCN RX: staInfo=%p, staInfo->staScb=%p, staInfo->staScb->
             -psState=%bu\n", 
              //                staInfo, staInfo->staScb, staInfo->staScb->psState);
              
                            // clear PS mode
                            PSM_ForcePsOff(staInfo->staScb); 
              //              PSM_set_sta_PS(FALSE, 0xF);
                          }
                        }   
                        else
                        {
                          u16 bpCnt = 0;          
                          sPsSchedule tmpAwd;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 32  

              
                          hhalCb->psAvln = TRUE;  // AVLN PS = ON
                          bpCnt = pPsBentry->bpCnt_Hi << 8;
                          bpCnt += pPsBentry->bpCnt_Lo;
              #ifdef PSDEBUG
                          if (psDebug2)
                          {
              //              if (staInfo->staScb->bpCnt && !(staInfo->staScb->bpCnt % staInfo->staScb->commAwd.numBp))
                              printf("RX BpCnt %d (scb->bpCnt=%d) at CCO's NTB=%lu, NTB=%lu\n", bpCnt, staInfo->staScb->bpCnt,(b
             -ts*40)/1000000, 
                                (rtocl(ReadU32Reg(PLC_NTB_REG))*40)/1000000);
                          }
              #endif
                          if (staInfo->staScb->psState == PSM_PS_STATE_OFF)
                          {
                            if (pPsBentry->tpss && (pPsBentry->tpss != PSM_PSS_NOT_CONFIG))
                            {
                              PSM_cvrtPss_Awd(pPsBentry->tpss, &tmpAwd);  // convert PSS to AWD format
                              if (!(bpCnt % tmpAwd.numBp)) // CCO does not necessarily send (bcnCnt mod staInfo->staScb->commAwd
             -.numBp) = 0
                              {
                                // CCO has PSmode enabled
                                // enable STA's PS in a MOD bcn period
              /*
                                if (psDebug2)
                                  printf("Rx Bcn: detect MOD (bpCnt=%d) at NTB=%lu\n", bpCnt, (rtocl(ReadU32Reg(PLC_NTB_REG))*40)/
             -1000000);
              */
                                PSM_enable_PS(staInfo->staScb, pPsBentry->tpss, bpCnt, linkl->mode);      // enable PS
                                PSM_save_PS_to_HalCB(PSM_PS_STATE_ON, pPsBentry->tpss); // save PS data to HALCB
                                memcpy(&staInfo->staScb->commAwd, &tmpAwd, sizeof(sPsSchedule));
                                  FM_Printf(FM_MMSG, "STA PS Mode is now ON (pss = 0x%bx)\n", staInfo->staScb->pss);
                              }
                            }
                          }
                          else
                          {
                            // PS mode is ON, check if pss was changed
                            if (staInfo->staScb->pss != pPsBentry->tpss)
                            {
                              // disable PS mode
                              // if PSS is changed to a different value
                              // the next Rx bcn with MOD will enable PS 
                              // with new PSS
                              PSM_ForcePsOff(staInfo->staScb) ;
                                FM_Printf(FM_MMSG, "STA PS Mode is now OFF\n");
                            }
                            else
                            {
                              // PS resync: make sure that the STA's bpCnt is the same with CCO's
                              // if they are not, it mostly means that STA drifts
                              // we need to resync with CCO
              #ifdef DOMISSINGBPSTART
                              if (((((bts*40)/1000000) - ((lastgCCO_BTS*40)/1000000)) >= (((gHpgpHalCB.curBcnPer*40)/1000000)*2)
             -) &&
                                (staInfo->staScb->bpCnt < bpCnt))
                              {
                                // we missed at least 1 bpStart
                                // assume for now that it's only 1 bpStart is missed
                                printf("MISSING BPSTART: bts=%lu, lastgCCO_BTS=%lu, gHpgpHalCB.curBcnPer=%lu, staInfo->staScb->bp
             -Cnt=%d, bpCnt=%d\n", 
                                  (bts*40)/1000000, (lastgCCO_BTS*40)/1000000, (gHpgpHalCB.curBcnPer*40)/1000000, staInfo->staScb-
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 33  

             ->bpCnt, bpCnt);
                                staInfo->staScb->bpCnt++;
                              }
              #endif
              /*
                              if (psDebug2)
                              {
              //                  if (staInfo->staScb->bpCnt && !(staInfo->staScb->bpCnt % staInfo->staScb->commAwd.numBp))
                                  printf("diffBpCnt=%d BpCnt %d (scb->bpCnt=%d) at CCO's NTB=%lu, NTB=%lu, ZCNTB=%lu\n", diffBpCnt
             -, bpCnt, staInfo->staScb->bpCnt);
                              }
              */
                              if (staInfo->staScb->bpCnt != bpCnt)
                              {
                                  FM_Printf(FM_MMSG, "PS RESYNC: bpCnt = %u, staInfo->staScb->bpCnt = %u, pss=0x%bx, staInfo->st
             -aScb->commAwd.numBp=%u\n", 
                                  bpCnt, staInfo->staScb->bpCnt, staInfo->staScb->pss, staInfo->staScb->commAwd.numBp);
              //                  if (delaySyncCheck > 20)
                                {
                                  staInfo->staScb->bpCnt = bpCnt;
                                  // disable PS for now and will enable it when receives MOD bpCnt from CCO
                                  PSM_ForcePsOff(staInfo->staScb);
                                }
                              }
                            }
                          }
                        }
                      }
                      break;
                         }
              #endif
1971   3      
1972   3                  default:
1973   3                  {
1974   4                  }
1975   3              }
1976   2              //move to the next BEHDR
1977   2              dataptr = dataptr + beHdr->beLen; 
1978   2              beHdr = (sBeHdr *) dataptr;
1979   2              nbe--;
1980   2          }
1981   1      
1982   1          if(snsm->txDiscBcn)
1983   1          {
1984   2              if(SNSM_BuildDiscBcn(snsm, beHdrRef) != STATUS_SUCCESS)
1985   2              {
1986   3                  snsm->txDiscBcn = FALSE;
1987   3              }
1988   2          } 
1989   1      
1990   1      }
1991          
1992          void LINKL_StaProcBcnHandler(void *cookie, sEvent *event,u32 bts)
1993          {
1994   1          sLinkLayer     *linkl = (sLinkLayer *)cookie;
1995   1          sSnsm*         snsm = (sSnsm *)LINKL_GetSnsm(linkl);
1996   1          sHpgpHdr         *hpgpHdr = NULL;
1997   1      
1998   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1999   1      
2000   1          SNSM_ProcBcnHigh(snsm, event->buffDesc.dataptr, hpgpHdr->snid, bts);
2001   1      
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 34  

2002   1          if(snsm->txDiscBcn)
2003   1          {
2004   2              SNSM_TransmitDiscBcn(snsm);
2005   2              snsm->txDiscBcn = FALSE;
2006   2          }
2007   1      }
2008          
2009          
2010          eStatus SNSM_SendMgmtMsg(sSnsm *snsm, u16 mmType)
2011          {
2012   1          eStatus          status = STATUS_FAILURE;
2013   1          sEvent       xdata   *newEvent = NULL;
2014   1          sHpgpHdr        *hpgpHdr = NULL;
2015   1          sCmUaStaInd     *uaStaInfo = NULL;
2016   1          sCcDiscStaInfo  *ccDiscStaInfo = NULL;
2017   1          sCcDiscNetInfo  *ccDiscNetInfo = NULL;
2018   1          u8               numSta = 0;
2019   1          u8               numNet = 0;
2020   1          u8               i = 0;
2021   1          u16              eventSize = 0;
2022   1          u8              *dataptr = NULL;
2023   1          sScb            *staScb = NULL;
2024   1        sStaInfo        *staInfo = NULL;
2025   1      
2026   1        staInfo = snsm->staInfo;
2027   1        
2028   1          switch(mmType)
2029   1          {
2030   2              case EVENT_TYPE_CM_UNASSOC_STA_IND:
2031   2              {
2032   3                  //prepare CM_UNASSOCIATED_STA_IND
2033   3                  eventSize = MAX(sizeof(sCmUaStaInd), HPGP_DATA_PAYLOAD_MIN); 
2034   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
2035   3                  if(newEvent == NULL)
2036   3                  {
2037   4                      FM_Printf(FM_ERROR, "EAF\n");
2038   4                      return STATUS_FAILURE;
2039   4                  }
2040   3                  FM_Printf(FM_MMSG, "SNSM:>>CM_UNASSOC_STA.IND\n");
2041   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
2042   3                  newEvent->eventHdr.type = EVENT_TYPE_CM_UNASSOC_STA_IND;
2043   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff; 
2044   3                  hpgpHdr->tei = 0xFF;
2045   3                  hpgpHdr->mnbc = 1;
2046   3                  hpgpHdr->mcst = 1;
2047   3                  hpgpHdr->macAddr = bcAddr;
2048   3                  hpgpHdr->snid = snsm->staInfo->snid;
2049   3                  hpgpHdr->eks = HPGP_EKS_NONE;
2050   3      
2051   3                  uaStaInfo = (sCmUaStaInd *)newEvent->buffDesc.dataptr; 
2052   3                  memcpy(uaStaInfo->nid, snsm->staInfo->nid, NID_LEN);
2053   3                  uaStaInfo->ccoCap = snsm->staInfo->staCap.fields.ccoCap;
2054   3                  newEvent->buffDesc.datalen += eventSize;
2055   3      
2056   3                  break;
2057   3              }
2058   2              case EVENT_TYPE_CC_DISCOVER_LIST_CNF:
2059   2              {
2060   3                  staScb = snsm->staInfo->staScb;
2061   3                  numSta = staInfo->numDiscSta;
2062   3                  numNet = staInfo->numDiscNet;
2063   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN,
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 35  

2065   3                                  2 + (u16)(numSta*sizeof(sCcDiscStaInfo)) + 
2065   3                                  (u16)(numNet*sizeof(sCcDiscNetInfo))); 
2066   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
2067   3                  if(newEvent == NULL)
2068   3                  {
2069   4                      FM_Printf(FM_ERROR, "EAF\n");
2070   4                      return STATUS_FAILURE;
2071   4                  }
2072   3                  FM_Printf(FM_MMSG, "SNSM:>>CC_DISC_LIST.CNF\n");
2073   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
2074   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_DISCOVER_LIST_CNF;
2075   3      
2076   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff; 
2077   3                  hpgpHdr->tei = snsm->staInfo->ccoScb->tei;
2078   3                  hpgpHdr->macAddr = snsm->staInfo->ccoScb->macAddr; 
2079   3                  hpgpHdr->snid = snsm->staInfo->snid;      
2080   3            hpgpHdr->eks = staInfo->nekEks;
2081   3            
2082   3                  dataptr = newEvent->buffDesc.dataptr; 
2083   3                  //station information
2084   3                  *dataptr = numSta;
2085   3                  dataptr++;
2086   3                  i = 0;
2087   3                  while(numSta && (i < DISC_STA_LIST_MAX))
2088   3                  {
2089   4                      if(staInfo->discStaInfo[i].valid)
2090   4                      { 
2091   5                          ccDiscStaInfo = (sCcDiscStaInfo *)dataptr;
2092   5                          memcpy(ccDiscStaInfo->macAddr, staInfo->discStaInfo[i].macAddr, 
2093   5                                 MAC_ADDR_LEN);
2094   5      
2095   5                          ccDiscStaInfo->tei = staInfo->discStaInfo[i].tei; 
2096   5                          ccDiscStaInfo->sameNet = staInfo->discStaInfo[i].sameNet; 
2097   5                          ccDiscStaInfo->snid = staInfo->discStaInfo[i].snid; 
2098   5                          ccDiscStaInfo->staCap.byte = staInfo->discStaInfo[i].staCap.byte; 
2099   5                          ccDiscStaInfo->sigLevel = 0;//staInfo->discStaInfo[i].sigLevel; 
2100   5                          ccDiscStaInfo->avgBle = 0;//staInfo->discStaInfo[i].avgBle; 
2101   5                          dataptr += sizeof(sCcDiscStaInfo);
2102   5                          newEvent->buffDesc.datalen +=sizeof(sCcDiscStaInfo); 
2103   5                          numSta--;
2104   5                      }
2105   4                      i++;
2106   4                  }
2107   3                  //network information
2108   3                  *dataptr = numNet;
2109   3                  dataptr++;
2110   3                  i = 0;
2111   3                  while(numNet && (i < DISC_NET_LIST_MAX))
2112   3                  {
2113   4                      if(staInfo->discNetInfo[i].valid)
2114   4                      { 
2115   5                          ccDiscNetInfo = (sCcDiscNetInfo *) dataptr;
2116   5                          memcpy(ccDiscNetInfo->nid, staInfo->discNetInfo[i].nid, 
2117   5                                 NID_LEN);
2118   5      
2119   5                          ccDiscNetInfo->snid = staInfo->discNetInfo[i].snid; 
2120   5                          ccDiscNetInfo->hybridMode = staInfo->discNetInfo[i].hybridMode; 
2121   5                          ccDiscNetInfo->numBcnSlots = staInfo->discNetInfo[i].numBcnSlots; 
2122   5                          ccDiscNetInfo->coordStatus = staInfo->discNetInfo[i].coordStatus; 
2123   5                          ccDiscNetInfo->offset = staInfo->discNetInfo[i].offset; 
2124   5                          dataptr += sizeof(sCcDiscNetInfo);
2125   5                          newEvent->buffDesc.datalen +=sizeof(sCcDiscNetInfo); 
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 36  

2126   5                          numNet--;
2127   5                      }
2128   4                      i++;
2129   4                  }
2130   3      
2131   3                  newEvent->buffDesc.datalen = eventSize;
2132   3                                               
2133   3                  break;
2134   3              }
2135   2              default:
2136   2              {
2137   3                  return status;
2138   3              }
2139   2          }
2140   1          //EVENT_Assert(newEvent);
2141   1          assert((newEvent->buffDesc.dataptr >= newEvent->buffDesc.buff)&&
2143   1                 ((newEvent->buffDesc.dataptr - newEvent->buffDesc.buff + 
2143   1                   newEvent->buffDesc.datalen) <= newEvent->buffDesc.bufflen));   
2144   1          //transmit the mgmt msg
2145   1          status =  MUXL_TransmitMgmtMsg(newEvent);
2146   1          //the event will be freed by MUXL if the TX is successful
2147   1          if(status == STATUS_FAILURE)
2148   1          {
2149   2              EVENT_Free(newEvent);
2150   2          }
2151   1          
2152   1          return status;
2153   1      }
2154          
2155          eStatus SNSM_DeliverEvent(sSnsm *snsm, u16 eventType)
2156          {
2157   1          sEvent       *newEvent = NULL;
2158   1          sLinkLayer   *linkl = snsm->linkl;
2159   1      
2160   1          newEvent = EVENT_Alloc(sizeof(snsm->staRole), 0);
2161   1          if(newEvent == NULL)
2162   1          {
2163   2              FM_Printf(FM_ERROR, "EAF\n");
2164   2              return STATUS_FAILURE;
2165   2          }
2166   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
2167   1          newEvent->eventHdr.type = eventType;
2168   1      
2169   1          if(eventType == EVENT_TYPE_NET_DISC_IND)
2170   1          {
2171   2              *(newEvent->buffDesc.dataptr) = snsm->staRole;
2172   2              newEvent->buffDesc.datalen += sizeof(snsm->staRole);
2173   2          }
2174   1      
2175   1          //deliver the event to the upper layer
2176   1      #ifdef CALLBACK
                  linkl->deliverEvent(linkl->eventcookie, newEvent);
              #else
2179   1          CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
2180   1      #endif
2181   1      
2182   1          return STATUS_SUCCESS;
2183   1      }
2184          
2185          
2186          void SNSM_ProcEvent(sSnsm *snsm, sEvent *event)
2187          {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 37  

2188   1          sBcnHdr      *bcnHdr = NULL;
2189   1          u8            becomeCco = FALSE;
2190   1          u8            *bcn = NULL;
2191   1          u8            bcnsrc;
2192   1          u8            staType;
2193   1          sAvlnInfoRef  avlnInfoRef;
2194   1          sEvent       *newEvent = NULL;
2195   1          sHpgpHdr     *hpgpHdr = NULL;
2196   1          sCmUaStaInd  *uaStaInfo = NULL;
2197   1          sScb         *scb = NULL;
2198   1          sStaInfo     *staInfo = NULL; 
2199   1          sCrm         *crm = NULL;
2200   1          sSnam        *snam = NULL;
2201   1      //    sCnam        *cnam = NULL;
2202   1          sRxDesc      rxdesc;
2203   1      //    sLinkLayer   *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2204   1          sLinkLayer   *linkl = snsm->linkl;
2205   1          staInfo = LINKL_GetStaInfo(linkl); 
2206   1          crm = LINKL_GetCrm(linkl);
2207   1          snam = LINKL_GetSnam(linkl);
2208   1      
2209   1      #if 1
2210   1        switch(event->eventHdr.type)
2211   1        {
2212   2          case EVENT_TYPE_CC_BCN_IND:
2213   2          {   
2214   3            sDiscNetInfoRef discNetInfoRef;
2215   3            u8 *dataptr;
2216   3            u8 nbe;     
2217   3            sBeHdr *beHdr;
2218   3            u8 *bcn = (u8*)event->buffDesc.dataptr;
2219   3            u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);
2220   3            
2221   3            hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2222   3            bcnHdr = (sBcnHdr *)bcn;    
2223   3      
2224   3            if (bcnHdr->bt != BEACON_TYPE_CENTRAL)
2225   3            {
2226   4      
2227   4              break;
2228   4      
2229   4            }
2230   3            
2231   3            rxdesc.snid = hpgpHdr->snid;  
2232   3              
2233   3            nbe = bcnHdr->nbe;
2234   3            dataptr = bcn + sizeof(sBcnHdr);
2235   3            beHdr = (sBeHdr *) dataptr;
2236   3                  discNetInfoRef.nid = bcnHdr->nid; 
2237   3                  discNetInfoRef.hybridMode = bcnHdr->nid[NID_LEN]>>6;        
2238   3                  discNetInfoRef.snid = hpgpHdr->snid;
2239   3                  discNetInfoRef.rssi = bcn[PLC_BCNRX_LEN-4-lLen]; 
2240   3                  discNetInfoRef.lqi = bcn[PLC_BCNRX_LEN-3-lLen];
2241   3                  discNetInfoRef.netMode = bcnHdr->nm;
2242   3                  discNetInfoRef.numBcnSlots = bcnHdr->numslots;
2243   3                  discNetInfoRef.slotId = bcnHdr->slotid;
2244   3                  discNetInfoRef.slotUsage= bcnHdr->slotusage;                            
2245   3      #if 1 
2246   3              while(nbe)
2247   3              {
2248   4                  dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
2249   4                  switch (beHdr->beType)
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 38  

2250   4                  {            
2251   5                case BEHDR_VENDOR_SPEC:
2252   5                {
2253   6                  memcpy(&discNetInfoRef.vendor_ota, (u8*)dataptr, sizeof(svendorOta));
2254   6          //        discNetInfoRef.validVendorOta = 1;
2255   6                }
2256   5                break;  
2257   5      
2258   5                default:
2259   5                break;
2260   5                  }
2261   4                  dataptr = dataptr +  beHdr->beLen; 
2262   4                  beHdr = (sBeHdr *) dataptr;
2263   4                  nbe--;        
2264   4              }     
2265   3      #endif      
2266   3            SCB_UpdateDiscNetList(snsm->staInfo->staScb, &discNetInfoRef);
2267   3          }
2268   2          break;
2269   2      
2270   2          default:
2271   2          break;
2272   2        }
2273   1      #endif    
2274   1      
2275   1          switch(snsm->state)
2276   1          {
2277   2              
2278   2              case SNSM_STATE_INIT:
2279   2              {
2280   3                  
2281   3                  if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) &&
2282   3                      (event->eventHdr.type == EVENT_TYPE_SNSM_START) )
2283   3                  {
2284   4                  
2285   4                      staType = *(event->buffDesc.dataptr);
2286   4      
2287   4              syncThres = (staInfo->macAddr[5] / 4);
2288   4                
2289   4                      switch(staType)
2290   4                      {
2291   5                          case LINKL_STA_TYPE_NETDISC:
2292   5                          {
2293   6                              
2294   6                              snsm->enableCcoSelection = 0;
2295   6                              snsm->enableCcoDetection = 1;
2296   6      #ifdef HPGP_HAL
2297   6                              /* set PhyClk */
2298   6                              //HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
2299   6                              
2300   6                              //Device should in STA mode during net discovery     
2301   6                              //HHAL_SetDevMode(DEV_MODE_CCO,gHpgpHalCB.lineMode);
2302   6      #ifndef RELEASE
2303   6                              FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_NETDISC,Set sta\n");
2304   6      #endif
2305   6      
2306   6                              /* start scan */
2307   6                              //HAL_ScanNet(TRUE);
2308   6      #endif
2309   6                             // if(staInfo->lastUserAppCCOState != 2)
2310   6                              {
2311   7                                  STM_StartTimer(snsm->bbtTimer, HPGP_TIME_BBT);
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 39  

2312   7                              }
2313   6                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
2314   6                  STM_StopTimer(snsm->discAgingTimer);
2315   6                                           
2316   6                              STM_StartTimer(snsm->discAgingTimer, 
2317   6                                             HPGP_TIME_DISC_AGING_UNASSOC);  
2318   6      
2319   6      #ifdef SW_RECOVERY
2320   6      
2321   6      
2322   6                  if (gStartDiscStallTimer)
2323   6                  {
2324   7                    gStartDiscStallTimer = 0;
2325   7                    gPastRxBcnCount = gHpgpHalCB.halStats.RxGoodBcnCnt;// Store last bcn count to identify BCN stall
2326   7      
2327   7                    STM_StartTimer(snsm->discStallTimer, DISC_STALL_TIME);
2328   7                    //FM_Printf(FM_ERROR,"DISC STALL Timer Started\n");// only for debug. comment while release
2329   7      
2330   7                  }
2331   6      #endif
2332   6                  gPastRxBcnCount = gHpgpHalCB.halStats.RxGoodBcnCnt;// Store last bcn count to identify BCN stall
2333   6      
2334   6                  snsm->state = SNSM_STATE_NET_DISC;
2335   6                              break;
2336   6                          }
2337   5                          case LINKL_STA_TYPE_UNASSOC:
2338   5                          {
2339   6                          //    if(staInfo->lastUserAppCCOState == 0)
2340   6                              {
2341   7                                  snsm->enableCcoSelection = 1;
2342   7                              }
2343   6                          //    else
2344   6                          //    {
2345   6                          //        snsm->enableCcoSelection = 0; // Joinnet - Only STA
2346   6                          //    }
2347   6                              snsm->enableCcoDetection = 1;
2348   6      #ifdef HPGP_HAL 
2349   6                              /* set PhyClk */
2350   6                              //HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);                  
2351   6      #ifndef RELEASE
2352   6                              FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC\n");
2353   6      #endif
2354   6      
2355   6                              /* start scan */
2356   6                             // HAL_ScanNet(TRUE);
2357   6      #endif
2358   6      
2359   6                  STM_StopTimer(snsm->usttTimer);
2360   6                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI); 
2361   6                  
2362   6                  STM_StopTimer(snsm->discAgingTimer);
2363   6                               
2364   6                              STM_StartTimer(snsm->discAgingTimer, 
2365   6                                           HPGP_TIME_DISC_AGING_UNASSOC);   
2366   6      #ifdef SW_RECOVERY
2367   6                              
2368   6                  if (gStartDiscStallTimer)
2369   6                  {
2370   7                    gStartDiscStallTimer = 0;
2371   7                    gPastRxBcnCount = gHpgpHalCB.halStats.RxGoodBcnCnt;// Store last bcn count to identify BCN stall
2372   7      
2373   7                    STM_StartTimer(snsm->discStallTimer, DISC_STALL_TIME);
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 40  

2374   7                //    FM_Printf(FM_ERROR,"DISC STALL Timer Started\n");// only for debug. comment while release
2375   7      
2376   7                  }
2377   6      #endif    
2378   6                  STM_StopTimer(snsm->scanToAssocTimer);
2379   6                  STM_StartTimer(snsm->scanToAssocTimer, HPGP_JOINNET_TIME);
2380   6      
2381   6      
2382   6                  snsm->state = SNSM_STATE_NET_DISC;
2383   6                              break;
2384   6                          }
2385   5                          case LINKL_STA_TYPE_ASSOC:
2386   5                          {
2387   6      #ifndef RELEASE
2388   6                              FM_Printf(FM_MINFO, "SNSM:Start ASSOC STA\n");
2389   6      #endif
2390   6                              snsm->enableCcoSelection = 0;
2391   6                              snsm->enableCcoDetection = 1;
2392   6                  
2393   6                  snsm->enableBcnLossDetection = 1;
2394   6                  STM_StopTimer(snsm->discAgingTimer);
2395   6                  
2396   6      #ifdef SW_RECOVERY              
2397   6                  gStartDiscStallTimer = 0;
2398   6                  STM_StopTimer(snsm->discStallTimer);
2399   6                  STM_StopTimer(snsm->bcnStallTimer);
2400   6                  gDiscStallCounter = 0;
2401   6      #endif                
2402   6                              STM_StartTimer(snsm->discAgingTimer, 
2403   6                                             HPGP_TIME_DISC_AGING);  
2404   6      
2405   6                  STM_StartTimer(snsm->bcnLossTimer,
2406   6                                             HPGP_TIME_BEACON_LOSS);
2407   6                  
2408   6                              snsm->state = SNSM_STATE_CONN;
2409   6                              break;
2410   6                          }
2411   5      #ifdef UKE
                                  
                                  case LINKL_STA_TYPE_SC_JOIN:
                                  case LINKL_STA_TYPE_SC_ADD:
                                  {                      
                                       
                                      FM_Printf(FM_ERROR, "\n UKE:Push button\n   \
                                               in SNSM_STATE_INIT state\n");
                                      break;    
                                  }
              #endif          
2422   5                          default:
2423   5                          {
2424   6      #ifndef RELEASE
2425   6                              FM_Printf(FM_WARN, "SNSM:unknown sta type(%d)\n", staType);
2426   6      #endif
2427   6                          }
2428   5                      }
2429   4                  }
2430   3                  break;
2431   3              }
2432   2              case SNSM_STATE_NET_DISC:
2433   2              {
2434   3                  //perform network discovery procedure
2435   3                  if(event->eventHdr.eventClass == EVENT_CLASS_MSG)
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 41  

2436   3                  {
2437   4                  u8 cco = 0;
2438   4                  switch(event->eventHdr.type)
2439   4                  {
2440   5      #ifdef UKE      
                              case EVENT_TYPE_CM_SC_JOIN_REQ: //UKE
                              {
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
                                      FM_Printf(FM_MMSG, "SNSM:<<CM_SC_JOIN.REQ\n");
                                      // If associated
                                      if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                      {
                                          //  its assumed that is secMode == JOIN, then device is in sta mode
                                          // if(snsm->enableCcoSelection)
                                          {
                                              //  perform CCO selection   
                                              becomeCco = SNSM_SelectCco(snsm,  event);
                                              // If CCO 
                                              if(becomeCco)
                                              {
              
                                                  SNSM_Stop(snsm);
                                                  
                                                  //(2) stop the SNAM
              
                                                  SNAM_Stop(snam);
                                                          
                                                  snsm->enableCcoSelection = 0;
                                                  snsm->enableCcoDetection = 0;
                                    snsm->netSync = FALSE;
                                    snsm->netScan  = FALSE;
              
                                                  
                                                  staInfo->secMode = SEC_MODE_SC_ADD;
                                                  //generateNmkAndNid(staInfo);
                                                  
                                                  
                                                  STM_StopTimer(snsm->usttTimer);
                                                  STM_StopTimer(snsm->discAgingTimer);
                                                  
                                              }
                                          }
                                      }else
                                          {
              
              
                                          }
                                     
                                      // If SC_ADD mode
                                      if(staInfo->secMode == SEC_MODE_SC_ADD)
                                      {
                                          //send SC_JOIN.CNF
                                          LINKL_SendMgmtMsg(snsm->staInfo, EVENT_TYPE_CM_SC_JOIN_CNF, 
                                                      ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                          
                                          // If CCO start beacon
                                          if(becomeCco)
                                          {
                                              //send event CCO_SEL_IND to the upper layer
              
                                              CNAM_EnableAssocNotification(&linkl->ccoNam,
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 42  

                                                                  ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                              SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_SLCT_IND);
              
                                                  
                                          }
                                          
                                      }
                                      
                                  }
                                  break;
                              }
                              case EVENT_TYPE_CM_SC_JOIN_CNF: //UKE
                              {
                                  FM_Printf(FM_MMSG, "SNSM:<<CM_SC_JOIN.CNF\n");
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
                                      sCmJoinCnf *joinCnf;
              
                                      STM_StopTimer(snsm->bbtTimer);
              
                                      // Save NID
                                      joinCnf = (sCmJoinCnf *) event->buffDesc.dataptr;
                                      memcpy(staInfo->nid, joinCnf->nid, NID_LEN);
                                      
                                      FM_HexDump(FM_HINFO, "NID in JOIN CNF Frame", joinCnf->nid, NID_LEN);
              
                                      snsm->netSync = FALSE;
                                      
                                      gHpgpHalCB.halStats.RxGoodBcnCnt   = 0; // rajan  do we call scanNet here.
              
                                      snsm->netScan  = FALSE;
                                          
                                      snsm->enableCcoSelection = 1;
              
                                      snsm->enableCcoDetection = 1;                        
              
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                   
                                      // not needed as STA will look for nid match
                                      //memcpy(&linkl->akm.ukePeer,  hpgpHdr->macAddr, MAC_ADDR_LEN);
                                          
                                      STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
              
                          STM_StopTimer(snsm->discAgingTimer);
                                      STM_StartTimer(snsm->discAgingTimer, 
                                                       HPGP_TIME_DISC_AGING);
                                      // IMP NOTE: What abt staCap fields
                                  }
                                  break;
                              }
              #endif        
2549   5                          case EVENT_TYPE_CM_UNASSOC_STA_IND:
2550   5                          {   
2551   6                              FM_Printf(FM_MMSG, "SNSM:<<CM_UNASSOC_STA.IND\n");
2552   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2553   6                              uaStaInfo = (sCmUaStaInd *) (event->buffDesc.dataptr);
2554   6                              SNSM_UpdateUaStaList(snsm, uaStaInfo, hpgpHdr->macAddr);
2555   6      
2556   6                              //CCo selection is performed 
2557   6                              //when the STA is unassociated STA
2558   6                  if(
2559   6      #ifdef UKE            
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 43  

                                        (staInfo->secMode != SEC_MODE_SC_JOIN) &&
              #else
2562   6      
2563   6      #endif            
2564   6                                (snsm->enableCcoSelection))
2565   6                              {
2566   7                                  becomeCco = SNSM_SelectCco(snsm, event);
2567   7                                     
2568   7                                  if(becomeCco == TRUE)
2569   7                                  {
2570   8                                                          /*
2571   8      #ifdef NSM_STA_PRINT              
2572   8                                      FM_Printf(FM_MINFO, "SNSM:Auto-selected CCo.Scan Off\n");
2573   8      #endif                
2574   8      #ifdef HPGP_HAL
2575   8      
2576   8                                      HAL_ScanNet(FALSE);
2577   8      #endif
2578   8                                      //(1) stop the SNSM
2579   8                                      STM_StopTimer(snsm->usttTimer);   
2580   8                                      STM_StopTimer(snsm->discAgingTimer);   
2581   8      
2582   8                                      snsm->enableCcoSelection = 0;
2583   8                                      snsm->enableCcoDetection = 0;
2584   8                      snsm->netSync = FALSE;
2585   8                      snsm->netScan  = FALSE;
2586   8                                      snsm->state = SNSM_STATE_INIT;
2587   8                                      //(2) stop the SNAM
2588   8                                      SNAM_Stop(snam);
2589   8                                                              */
2590   8                                      //send event CCO_SEL_IND to the upper layer
2591   8                                      SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_SLCT_IND);
2592   8                                       
2593   8                                  }
2594   7                              }
2595   6                              break;                    
2596   6                          }
2597   5                          default:
2598   5                          {
2599   6                          }
2600   5                      }
2601   4                  }
2602   3                  else //control event
2603   3                  {
2604   4                      switch(event->eventHdr.type)
2605   4                      {
2606   5                          case EVENT_TYPE_SNSM_START:
2607   5                          {
2608   6                              staType = *(event->buffDesc.dataptr);           
2609   6                              switch (staType)
2610   6                              {
2611   7                                  case LINKL_STA_TYPE_UNASSOC:
2612   7                                  {
2613   8                                      if(!snsm->netSync && !snsm->netScan)
2614   8                                      {
2615   9                                      //TODO:does it occur now?
2616   9                          //            if(staInfo->lastUserAppCCOState == 0)
2617   9                                      {
2618  10                                          snsm->enableCcoSelection = 1;
2619  10                                      }
2620   9                           //           else
2621   9                            //          {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 44  

2622   9                            //              snsm->enableCcoSelection = 0; //  Only STA
2623   9                            //          }
2624   9                                      snsm->enableCcoDetection = 1;
2625   9      #ifdef HPGP_HAL
2626   9      #ifndef RELEASE
2627   9                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC 2\n");
2628   9      #endif
2629   9                                      /* TODO: Set PhyClk in HW */
2630   9                                      //HHAL_SetDevMode(linkl->hal, 
2631   9                                      //    DEV_MODE_CCO, LINE_MODE_DC);
2632   9                                      //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, gHpgpHalCB.lineMode);
2633   9                                      /* start scan */
2634   9                                      //HAL_ScanNet(TRUE);
2635   9      #endif
2636   9                                      /* these timers have started in the init state
2637   9                       * thus not need to start the timers again here
2638   9                       */
2639   9                          //          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
2640   9                          //          STM_StartTimer(snsm->discAgingTimer, 
2641   9                          //                         HPGP_TIME_DISC_AGING);   
2642   9                          
2643   9                                      //stay in the net disc state
2644   9                                        STM_StopTimer(snsm->discAgingTimer);
2645   9                  
2646   9                                    STM_StartTimer(snsm->discAgingTimer, 
2647   9                                                 HPGP_TIME_DISC_AGING_UNASSOC);
2648   9                  
2649   9                                      }
2650   8                                      break;
2651   8                                  }
2652   7                                  case LINKL_STA_TYPE_ASSOC:
2653   7                                  {
2654   8      #ifdef HPGP_HAL
2655   8                                      /* stop scan */
2656   8                                      HAL_ScanNet(FALSE);
2657   8      #ifndef RELEASE
2658   8                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_ASSOC\n");
2659   8      #endif
2660   8      #endif
2661   8                                      //it occurs after the STA discover
2662   8                                      //the CCo during the network discovery
2663   8                                      //and unassoicated STA
2664   8                                      STM_StopTimer(snsm->usttTimer);   
2665   8                                      snsm->enableCcoSelection = 0;
2666   8                                      snsm->enableCcoDetection = 0;
2667   8                      
2668   8                      snsm->enableBcnLossDetection = 1;
2669   8                                      snsm->state = SNSM_STATE_CONN;
2670   8                      STM_StopTimer(snsm->discAgingTimer);
2671   8                    
2672   8                      STM_StopTimer(snsm->bcnLossTimer);
2673   8                      
2674   8                      STM_StartTimer(snsm->discAgingTimer, 
2675   8                              HPGP_TIME_DISC_AGING);  
2676   8      
2677   8      
2678   8                      STM_StartTimer(snsm->bcnLossTimer, 
2679   8                              HPGP_TIME_BEACON_LOSS);
2680   8      #ifdef SW_RECOVERY                
2681   8                      STM_StopTimer(snsm->discStallTimer);
2682   8                      STM_StopTimer(snsm->bcnStallTimer);
2683   8                      gDiscStallCounter = 0;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 45  

2684   8      #endif                
2685   8                                  break;
2686   8                              }
2687   7      #ifdef UKE            
                                      case LINKL_STA_TYPE_SC_JOIN:
                                      {
              
                                          FM_Printf(FM_ERROR , "LINKL_STA_TYPE_SC_JOIN\n");
                                          
                                          STM_StopTimer(snsm->discAgingTimer);   
                                          STM_StopTimer(snsm->bbtTimer);
                                          STM_StopTimer(snsm->usttTimer);
                                         if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                          {
                                              // If n/w discovery is on then Stop discovery
                                              // Is associated
                                              // if yes then leave n/w and wait for LEAVE RSP
                                              //  
                                              STM_StartTimer(snsm->bbtTimer, HPGP_TIME_BBT);
                                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
              
                                              snsm->enableCcoSelection = 0;
                                              snsm->enableCcoDetection = 0;
                                              
                                              FM_Printf(FM_ERROR, "SNSM:SEC_MODE_SC_JOIN\n");
                                          }                        
                                          else
                                          {
                                              FM_Printf(FM_ERROR, "SNSM:SEC_MODE_SC or HS\n");
                                          }
                                              break;
                                          }
              #endif              
2717   7                                  default:
2718   7                                  {
2719   8                                  }
2720   7                              }
2721   6                              break;
2722   6                          }
2723   5      
2724   5                          case EVENT_TYPE_SNSM_STOP:
2725   5                          {
2726   6                              //it happens when the STA becomes the CCo after
2727   6                              //network discovery
2728   6                              STM_StopTimer(snsm->usttTimer);   
2729   6                              STM_StopTimer(snsm->bbtTimer);
2730   6                              STM_StopTimer(snsm->discAgingTimer);   
2731   6      
2732   6                              snsm->enableCcoSelection = 0;
2733   6                              snsm->enableCcoDetection = 0;
2734   6                  snsm->netSync = FALSE;
2735   6                  snsm->netScan = FALSE;
2736   6                              HAL_ScanNet(FALSE);
2737   6                              snsm->state = SNSM_STATE_INIT;
2738   6                              break;
2739   6                          }
2740   5      
2741   5                          case EVENT_TYPE_TIMER_BBT_IND:
2742   5                          
2743   5      #ifdef UKE          
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 46  

                                      FM_Printf(FM_ERROR, "nsm:BBT Exp\n");
                                      staInfo->secMode = SEC_MODE_SC;
              
                      //                                              SNSM_DeliverEvent(snsm, EVENT_TYPE_RESTART_IND);
              
                                      snsm->enableCcoSelection = 1;
                                      snsm->enableCcoDetection = 1;
                                                  
              #ifdef NSM_STA_PRINT
                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC From JOIN State\n");
              #endif
                                      STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
              
                          STM_StopTimer(snsm->discAgingTimer);
              
                                      STM_StartTimer(snsm->discAgingTimer, 
                                               HPGP_TIME_DISC_AGING_UNASSOC);
                                      
                                  }
                                  else
              #endif          
2767   5                          {
2768   6                              snsm->staRole = SNSM_DetermineStaRole(snsm);
2769   6                              if( (snsm->staRole == STA_ROLE_ACCO) ||
2770   6                                  (snsm->staRole == STA_ROLE_UCCO) )
2771   6                              {
2772   7                                  //the STA becomes the CCo after network discovery
2773   7      #ifdef HPGP_HAL
2774   7                                  /* stop scan */
2775   7                                  //HAL_ScanNet(FALSE);
2776   7      #ifndef RELEASE
2777   7                                  FM_Printf(FM_MINFO, "nsm:BBT Exp\n");
2778   7      #endif
2779   7      #endif
2780   7                                  //(1) stop the SNSM
2781   7                                  STM_StopTimer(snsm->usttTimer);
2782   7                                  STM_StopTimer(snsm->discAgingTimer);
2783   7      
2784   7                                  snsm->enableCcoSelection = 0;
2785   7                                  snsm->enableCcoDetection = 0;
2786   7                                  //(2) stop the SNAM
2787   7                                  snsm->netSync = FALSE;
2788   7                                  snsm->netScan = FALSE;
2789   7      
2790   7                                  LINKL_StopSta(linkl);
2791   7      
2792   7                                  snsm->state = SNSM_STATE_INIT;
2793   7                              }
2794   6                              SNSM_DeliverEvent(snsm, EVENT_TYPE_NET_DISC_IND);
2795   6                              
2796   6                          }
2797   5                  break;
2798   5                          case EVENT_TYPE_CC_BCN_IND:
2799   5                          {
2800   6                             // FM_Printf(FM_MINFO, "BCN\n");
2801   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2802   6                              bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
2803   6      #ifdef SW_RECOVERY            
2804   6                  STM_StopTimer(snsm->bcnStallTimer);
2805   6                  STM_StartTimer(snsm->bcnStallTimer,BCN_STALL_TIME);
2806   6                  gBcnStallCounter = 0;
2807   6      #endif            
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 47  

2808   6                              //CCO detetection is performed when the STA is
2809   6                              //in network discovery or unassociated STA
2810   6                              bcnsrc = SNSM_DetectCco(snsm, bcnHdr); 
2811   6                              switch(bcnsrc)
2812   6                              {
2813   7                                  case BCN_SRC_CCO:
2814   7                                  {
2815   8                                      /* find my CCo */
2816   8                                      /* save the snid from CCO */
2817   8                                      staInfo->snid = hpgpHdr->snid;
2818   8                      /* stop the timer as no need to 
2819   8                       * transmit the UNASSOCIATED_STA.IND
2820   8                       */
2821   8                      STM_StopTimer(snsm->usttTimer);   
2822   8                                      STM_StopTimer(snsm->bbtTimer);
2823   8                                      
2824   8                                      if ((gHpgpHalCB.nwSelected) && 
2825   8                        (gHpgpHalCB.snid != staInfo->snid))
2826   8                      {
2827   9      
2828   9                        FM_Printf(FM_MINFO,"switch sync snid %bu\n", staInfo->snid);
2829   9      
2830   9                        snsm->netSync = FALSE;
2831   9                        
2832   9                        gHpgpHalCB.nwSelected = 0;
2833   9       
2834   9                        gHpgpHalCB.nwSelectedSnid = staInfo->snid;
2835   9      
2836   9                        snsm->netScan = FALSE;
2837   9                        
2838   9                        
2839   9                      }
2840   8                                      if (snsm->netSync == TRUE)
2841   8                      {
2842   9                                      if((snsm->enableCcoDetection)
2843   9      #ifdef FREQ_DETECT
2844   9                                         && (gHpgpHalCB.gFreqCB.freqDetected == TRUE)
2845   9      #endif
2846   9                                          )
2847   9                                      {
2848  10      #ifdef HPGP_HAL
2849  10                                          /* stop scan */
2850  10                                      //FM_Printf(FM_MINFO,"nsm : enableCcoDetection , Scan OFF\n");
2851  10                        
2852  10                                          //HAL_ScanNet(FALSE);
2853  10                                          //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, LINE_MODE_DC);
2854  10      #endif
2855  10                                          snsm->enableCcoDetection = 0;
2856  10                                          //send event CCO_DISC_IND to the ctrl
2857  10                                          SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_DISC_IND);
2858  10      
2859  10                        STM_StopTimer(snsm->scanToAssocTimer);
2860  10                                          
2861  10                                      }
2862   9                      }
2863   8                      else if(!snsm->netScan)
2864   8                      {
2865   9                          /* since the device has found the CCo, it does not need to
2866   9                         * send an UNASSOCIATED_STA.IND. Thus, 
2867   9                         * (1) change back to the STA
2868   9                         * (2) start scanning to sync with the CCo. 
2869   9                         * Note: when the device is set to scan, it performs Rx only 
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 48  

2870   9                         *       cannot transmit a message.
2871   9                         */
2872   9                         
2873   9                                         FM_Printf(FM_MINFO,"nsm:BCN_SRC_CCO\n");
2874   9                         
2875   9                          //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, LINE_MODE_DC);
2876   9                                          HHAL_SetDevMode(DEV_MODE_STA,gHpgpHalCB.lineMode);
2877   9                          /* start scan for sync */
2878   9                        HAL_ScanNet(TRUE);
2879   9                                          snsm->netScan = TRUE;
2880   9                      }
2881   8                      else if(snsm->netScan)                  
2882   8                      {
2883   9      
2884   9                        /*FIXME: Host App should select the network , during scanning.
2885   9                        Selection could be based on Lqi/Rssi 
2886   9                        Temporarily the selection is done here */       
2887   9                        if(snsm->netScan && !gHpgpHalCB.nwSelected)
2888   9                        {
2889  10                          // TODO FIX THIS
2890  10      
2891  10                          if ((gHpgpHalCB.nwSelectedSnid == 0)  || 
2892  10                            (gHpgpHalCB.nwSelectedSnid == hpgpHdr->snid))
2893  10                          {
2894  11                            if(gHpgpHalCB.halStats.RxGoodBcnCnt >= syncThres ) 
2895  11                            {                
2896  12                              HHAL_SetSnid(hpgpHdr->snid);
2897  12                              FM_Printf(FM_MINFO, "SNSM:Setting STA Snid %bu\n", hpgpHdr->snid); 
2898  12      
2899  12      
2900  12                            }
2901  11                          }
2902  10                        }
2903   9                              
2904   9      
2905   9                      }
2906   8                                      break;
2907   8                                  }
2908   7                                  case BCN_SRC_OTHER_CCO:
2909   7                                  {
2910   8                      u8 *bcn = event->buffDesc.dataptr;
2911   8                      u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);
2912   8         
2913   8                       avlnInfoRef.rssi = bcn[PLC_BCNRX_LEN-4-lLen]; 
2914   8                       avlnInfoRef.lqi = bcn[PLC_BCNRX_LEN-3-lLen];
2915   8                       avlnInfoRef.tei = bcnHdr->stei;
2916   8      
2917   8       
2918   8       //                               hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2919   8                                      avlnInfoRef.nid = bcnHdr->nid;
2920   8                                      avlnInfoRef.snid = hpgpHdr->snid;
2921   8                      avlnInfoRef.slotId = bcnHdr->slotid;
2922   8                                      // If other beacon detected scan network. 
2923   8                                     if(!snsm->netScan)
2924   8                       {
2925   9                                          staInfo->snid = hpgpHdr->snid;
2926   9                          HHAL_SetDevMode(DEV_MODE_STA,gHpgpHalCB.lineMode);
2927   9                                          HAL_ScanNet(TRUE);
2928   9                                          snsm->netScan = TRUE;
2929   9                                      }
2930   8                 
2931   8                         else if(snsm->netScan)                  
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 49  

2932   8                         {
2933   9                           if(snsm->netScan && !gHpgpHalCB.nwSelected)
2934   9                           {
2935  10                             if ((gHpgpHalCB.nwSelectedSnid == 0)  || 
2936  10                               (gHpgpHalCB.nwSelectedSnid == hpgpHdr->snid))
2937  10                             {
2938  11                               if(gHpgpHalCB.halStats.RxGoodBcnCnt >= syncThres ) 
2939  11                               {              
2940  12                                 HHAL_SetSnid(hpgpHdr->snid);
2941  12                                 FM_Printf(FM_MINFO, "SNSM:Setting STA Snid %bu\n", hpgpHdr->snid); 
2942  12                               }
2943  11                             }
2944  10                           }
2945   9                         }
2946   8                                      //update the AVLN list
2947   8                                    //  SNSM_UpdateAvlnList(snsm, &avlnInfoRef); 
2948   8                                      //select PhyClk from AVLN list. 
2949   8                                      //todo: How to get the PhyClk?
2950   8                                      break;     
2951   8                                  }
2952   7                                  default:
2953   7                                  {
2954   8                                  }
2955   7                              }
2956   6                              break;                    
2957   6                          }
2958   5                case EVENT_TYPE_TIMER_JOIN_TIMEOUT:
2959   5                {
2960   6                  FM_Printf(FM_USER,"EVENT_TYPE_TIMER_JOIN_TIMEOUT\n");
2961   6                   SNSM_DeliverEvent(snsm, EVENT_TYPE_JOINNET_TIMEOUT);
2962   6                   
2963   6                  break;
2964   6                }
2965   5                          case EVENT_TYPE_TIMER_USTT_IND:
2966   5                          {
2967   6                              //check AVLN list
2968   6                              if((staInfo->numDiscNet) && (snsm->netSync))
2969   6                            {
2970   7      #ifdef UKE          
                                        if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                            
                                        {
                                            LINKL_SendMgmtMsg(snsm->staInfo,
                                         EVENT_TYPE_CM_SC_JOIN_REQ,
                                         NULL);
              
                                      }
                                      //check AVLN list
                                      else
              #endif            
2982   7                              {
2983   8                                  //select the phyclk from the AVLN list
2984   8                                  //set the phyclk in the MAC
2985   8      
2986   8                                    SNSM_SendMgmtMsg(snsm, 
2987   8                                             EVENT_TYPE_CM_UNASSOC_STA_IND);
2988   8                                }
2989   7      
2990   7                            }
2991   6                  else
2992   6                  {
2993   7                    if(snsm->enableCcoSelection == 1)
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 50  

2994   7                    {          
2995   8                      if(staInfo->numDiscNet == 0)
2996   8                      {
2997   9                      snsm->enableCcoSelection = 0;
2998   9                      // No avln become unassociated CCO
2999   9                      /*
3000   9                      snsm->staRole = STA_ROLE_UCCO;
3001   9                      // stop ustt timer
3002   9                      STM_StopTimer(snsm->usttTimer);
3003   9                    
3004   9                      snsm->enableCcoSelection = 0;
3005   9                      snsm->enableCcoDetection = 0;
3006   9                    
3007   9                      snsm->netSync = FALSE;
3008   9                      snsm->netScan = FALSE;
3009   9                      snsm->state = SNSM_STATE_INIT;
3010   9                    
3011   9                      HAL_ScanNet(FALSE);
3012   9                    
3013   9                      LINKL_StopSta(linkl);
3014   9                    
3015   9                      snsm->state = SNSM_STATE_INIT;
3016   9                            */
3017   9                      SNSM_DeliverEvent(snsm, EVENT_TYPE_UCCO_IND);
3018   9                      break;                  
3019   9                    
3020   9                      }
3021   8                    }
3022   7      
3023   7                            }
3024   6                            //start the USTT timer again
3025   6                            STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
3026   6                            break;
3027   6                        }
3028   5                        case EVENT_TYPE_TIMER_DISC_AGING_IND:
3029   5                        {
3030   6                            SNSM_PerformAging(snsm);
3031   6                      // If no avln then become unassoc CCO
3032   6                      //If device is in USTA state and no avln found then become UCCO
3033   6                      STM_StopTimer(snsm->discAgingTimer);
3034   6                  STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING_UNASSOC);                                 
             -  
3035   6                  
3036   6                                //Using enableCcoSelection to know that we are in USTA mode
3037   6                    if(snsm->enableCcoSelection == 1)
3038   6                                {                  
3039   7                                    if(staInfo->numDiscNet == 0)
3040   7                                    {
3041   8                                        snsm->enableCcoSelection = 0;
3042   8                                          /*
3043   8                                                                    // No avln become unassociated CCO
3044   8                                                                    snsm->staRole = STA_ROLE_UCCO;
3045   8                                                                    // stop ustt timer
3046   8                                                                    STM_StopTimer(snsm->usttTimer);
3047   8                                                                    
3048   8                                                                    snsm->enableCcoSelection = 0;
3049   8                                                                    snsm->enableCcoDetection = 0;
3050   8      
3051   8                                                                    snsm->netSync = FALSE;
3052   8                                                                    snsm->netScan = FALSE;
3053   8                                                                    snsm->state = SNSM_STATE_INIT;
3054   8      
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 51  

3055   8                                                        HAL_ScanNet(FALSE);
3056   8      
3057   8                                                        LINKL_StopSta(linkl);
3058   8      
3059   8                                                                    snsm->state = SNSM_STATE_INIT;
3060   8                                                                          */
3061   8                                        SNSM_DeliverEvent(snsm, EVENT_TYPE_UCCO_IND);
3062   8                                        break;                                
3063   8      
3064   8                                  }
3065   7                              }
3066   6                              //restart the aging timer
3067   6                              
3068   6                              break;
3069   6                          }
3070   5      #ifdef SW_RECOVERY
3071   5                case EVENT_TYPE_TIMER_DISC_STALL_IND:
3072   5                {
3073   6                  //FM_Printf(FM_ERROR,"\nDISC Stall Expired\n");
3074   6                  if((!gHpgpHalCB.halStats.RxGoodBcnCnt) ||
3075   6                     (gHpgpHalCB.halStats.RxGoodBcnCnt - gPastRxBcnCount)< 30)
3076   6                  {
3077   7                    GV701x_Chip_Reset();// Temporary WAR as plc_tx_reset lead to Duplicate CP. Need to remove after DUP
             -_CP resolve [Kiran]
3078   7                    plc_reset_tx();
3079   7                    plc_reset_rx();
3080   7      
3081   7                    gDiscStall++;
3082   7      
3083   7                    //FM_Printf(FM_ERROR,"\nn/w disc\n");
3084   7      
3085   7      //              FM_Printf(FM_USER,"dsle\n");
3086   7                    
3087   7                    if(gDiscStallCounter >= 5)
3088   7                    {
3089   8                      #ifndef RELEASE
3090   8                      FM_Printf(FM_USER,"dsl rst\n");
3091   8                      #endif
3092   8                      GV701x_Chip_Reset();
3093   8                    
3094   8                      //FM_Printf(FM_USER,"HW Reset DISC Stall\n");
3095   8                    }
3096   7                    else
3097   7                    {
3098   8                      #ifndef RELEASE
3099   8                      FM_Printf(FM_USER,"dsl\n");
3100   8                      #endif
3101   8                      gDiscStallCounter++;
3102   8                      STM_StartTimer(snsm->discStallTimer,DISC_STALL_TIME);
3103   8                      //FM_Printf(FM_USER,"HW DISC Stall\n");
3104   8                    }
3105   7                    
3106   7                  }
3107   6                  else
3108   6                  {
3109   7                    STM_StopTimer(snsm->discStallTimer);
3110   7                    gDiscStallCounter = 0;
3111   7                  }
3112   6                  break;
3113   6                }       
3114   5                case EVENT_TYPE_TIMER_BCN_STALL_IND:
3115   5                {
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 52  

3116   6                  plc_reset_tx();
3117   6                  plc_reset_rx();
3118   6                  #ifndef RELEASE
3119   6                  FM_Printf(FM_USER,"\nBSR\n");
3120   6                  #endif
3121   6                  gBcnStall++;
3122   6                  if(gBcnStallCounter >= 20)
3123   6                  {
3124   7                    GV701x_Chip_Reset();
3125   7                    //FM_Printf(FM_USER,"HW Reset BCN Stall\n");
3126   7                  }
3127   6                  else
3128   6                  {
3129   7                    gBcnStallCounter++;
3130   7                    STM_StartTimer(snsm->bcnStallTimer,BCN_STALL_TIME);
3131   7                    //FM_Printf(FM_USER,"HW BCN Stall\n");
3132   7                  }
3133   6                  break;
3134   6                }
3135   5      #endif          
3136   5                          default:
3137   5                          {
3138   6                  break;
3139   6                          }
3140   5                      }
3141   4                  }
3142   3                  break;
3143   3              }
3144   2              case SNSM_STATE_CONN:
3145   2              {
3146   3                  if(event->eventHdr.eventClass == EVENT_CLASS_MSG)
3147   3                  {
3148   4                      switch(event->eventHdr.type)
3149   4                      {
3150   5                         case EVENT_TYPE_CM_UNASSOC_STA_IND:
3151   5                          {   
3152   6                              FM_Printf(FM_MMSG, "SNSM:<<CM_UNASSOC_STA.IND\n");
3153   6      
3154   6                  break;
3155   6                         }
3156   5                          case EVENT_TYPE_CC_DISCOVER_LIST_REQ:
3157   5                          {
3158   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
3159   6      #ifdef P8051
3160   6                 FM_Printf(FM_MMSG, "SNSM:<<<CC_DISC_LIST.REQ(tei: %bu)\n",
3161   6                                     hpgpHdr->tei);
3162   6      #else
                         FM_Printf(FM_MMSG, "SNSM:<<CC_DISC_LIST.REQ(tei: %d)\n",
                                             hpgpHdr->tei);
              #endif
3166   6                              staInfo->staScb->discUpdate = 0;
3167   6                              SNSM_SendMgmtMsg(snsm, EVENT_TYPE_CC_DISCOVER_LIST_CNF);
3168   6                              break;
3169   6                          }
3170   5      #ifdef UKE          
                              case EVENT_TYPE_CM_SC_JOIN_REQ:                    
                              {
                                  if(staInfo->secMode == SEC_MODE_SC_ADD)
                                  {
                                  
                                      FM_Printf(FM_MINFO, "SNSM:<<CM_SC_JOIN.REQ\n");
              
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 53  

                                      if ((!snam->ukePeerNotification) ||
                                          (!memcmp(&((sHpgpHdr*)(event->buffDesc.buff))->macAddr,
                                                     snam->ukePeer, MAC_ADDR_LEN)))
                                      {
                                         LINKL_SendMgmtMsg(snsm->staInfo, EVENT_TYPE_CM_SC_JOIN_CNF, 
                                                      ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                        
                                         SNAM_EnableAssocNtf(snam, 
                                                             ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                         
              
                                     }
                                 }
                                 break;
                              } 
              #endif
3194   5                          
3195   5      #ifdef ROUTE
                                  case EVENT_TYPE_CM_ROUTE_INFO_REQ:
                                  {
                                      ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_CNF, event);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_CNF:
                                  {
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_IND:
                                  {
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_UNREACHABLE_IND:
                                  {
                                      u32 *unreachableNtb = event->buffDesc.dataptr;
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                      ROUTE_procUnreachableInd(&event->buffDesc.dataptr[5], 
                                          event->buffDesc.dataptr[4], hpgpHdr->tei, (u32)*event->buffDesc.dataptr);
                                      break;
                                  }
              #endif // ROUTE
3222   5                          default:
3223   5                          {
3224   6                          }
3225   5                      }
3226   4                  }
3227   3                  else //control event
3228   3                  {
3229   4                      switch(event->eventHdr.type)
3230   4                      {
3231   5      
3232   5                case EVENT_TYPE_BCN_MISS_IND:
3233   5                {
3234   6      
3235   6                  FM_Printf(FM_HINFO, "bcn miss\n");
3236   6      //            SNSM_HandleBcnLoss(snsm, event);
3237   6                  break;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 54  

3238   6                }
3239   5                          case EVENT_TYPE_CC_BCN_IND:
3240   5                          {
3241   6      //                        FM_Printf(FM_MINFO, "SNSM: <<< BEACON.\n");
3242   6                              //perform the STA discovery procedure
3243   6                              //perform network discovery procedure
3244   6      
3245   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
3246   6                              rxdesc.snid = hpgpHdr->snid;  
3247   6                              bcn = event->buffDesc.dataptr;
3248   6                 
3249   6      //                        LINKL_BcnRxHandler(linkl, &rxdesc, bcnHdr);
3250   6      //FM_HexDump(FM_DATA, "SNSM Rx beacon:", bcn, event->buffDesc.datalen);
3251   6                              SNSM_ProcBcnLow(snsm, &rxdesc, bcn);
3252   6      //                        SNSM_ProcBcn(snsm, event);
3253   6      #ifdef HOM
              
                                      switch(snsm->hoSwitch)
                                      {
                                          case HPGP_HO_SWITCH_CCO:
                                          {
                                              FM_Printf(FM_HINFO, "SNSM:become CCo\n");
                                          
                                              staInfo->ccoScb->staStatus.fields.apptCcoStatus = 0;
              
                                              //perform handover switch to the CCo role
                                              //CRM has all SCBs for each STA from the  
                                              //CC_HANDOVER_INFO.IND,
              
                                              staInfo->ccoScb = staInfo->staScb; 
                                              staInfo->ccoScb->staCap.fields.ccoStatus = 1;
              
                                              //SNAM_PerformHoSwitch(snam);
                                              SNAM_Stop(snam);
              
                                              //the following function is moved 
                                              //to the CNAM_START when the CCo starts
                                              //start the tei timer for each STA
                                              //cnam = LINKL_GetCnam(linkl);
                                              //CNAM_PerformHoSwitch(cnam);
                                              
                                              //deliver the event to the upper layer
                                              SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_HO_IND);
              
                                              //Stop SNSM
                                              STM_StopTimer(snsm->usttTimer);
                                              STM_StopTimer(snsm->discAgingTimer); 
                                              STM_StopTimer(snsm->bcnLossTimer);
                              
                                              snsm->enableCcoSelection = 0;
                                              snsm->enableCcoDetection = 0;
                                              snsm->state = SNSM_STATE_INIT;
                                              break;
                                          }
                                          case HPGP_HO_SWITCH_STA: //switch to the third STA
                                          {
              
                                              scb = CRM_AddScb(crm, snsm->nctei);
                                              //scb = CRM_GetScb(crm, snsm->nctei);
                                              if(scb == NULL)
                                              {
                                                  FM_Printf(FM_ERROR, "SNSM:Can't alloc scb CCo\n");
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 55  

                                                  break;
                                              }
                                              
                                              scb->staCap.fields.ccoStatus = 1;
                                              staInfo->ccoScb = scb; 
              #ifdef NSM_STA_PRINT                
              #ifdef P8051
                             FM_Printf(FM_HINFO, "SNSM:switch to the new CCo(tei: %bu)\n",
                                                 scb->tei);
              #else
                             FM_Printf(FM_HINFO, "SNSM:switch to the new CCo(tei: %d)\n",
                                                 scb->tei);
              #endif
              #endif
                                              //for the handover, new CCo MAC address may be 
                                              //known from the CCO_SET_TEI_MAP.IND
                                              //otherwise , we may have a trouble in
                                              //sending CC_ASSOC.REQ for TEI renew.
                                              //Thus, we set HW MAC route table here for CCo`
              #ifdef SIMU
                                              SHAL_AddMacAddrToPortMap(
                                                  HOMEPLUG_GetHal()->shal,
                                                  scb->macAddr, 
                                                  scb->tei);
              #else
                                              /* set the TEI in the data plane */
              
              #endif
                                              snsm->enableCcoDetection = 1;
              
              
                                              break;
                                          }
                                          default:
                                          {
                                          }
                                      }
                                      snsm->hoSwitch = HPGP_HO_SWITCH_NONE;
              #endif
3339   6                              if(snsm->ccoDetected)
3340   6                              {
3341   7                                  //send the event to the SNAM to renew the TEI
3342   7                                  newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 
3343   7                                                         EVENT_HPGP_CTRL_HEADROOM);
3344   7                                  if(newEvent == NULL)
3345   7                                  {
3346   8                                      FM_Printf(FM_ERROR, "EAF\n");
3347   8                                      break;
3348   8                                  }
3349   7                                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
3350   7                                  newEvent->eventHdr.type = EVENT_TYPE_CCO_DISC_IND;
3351   7                                  //send the event to the SNAM
3352   7                                  //LINKL_SendEvent(linkl, newEvent);
3353   7                                  SLIST_Put(&linkl->intEventQueue, &newEvent->link);
3354   7                                  snsm->ccoDetected = 0;
3355   7                              }
3356   6                              break;
3357   6                          }
3358   5      
3359   5                case EVENT_TYPE_TIMER_BEACON_LOSS_IND:
3360   5                {
3361   6      
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 56  

3362   6                    //NOTE: noBcn is reset 
3363   6                              //after the central beacon is received
3364   6                              snsm->noBcn++; 
3365   6      #ifdef UM
3366   6      
3367   6                  if (snsm->noBcn == MAX_NO_BEACON_NW_DISCOVERY)
3368   6                  {
3369   7      
3370   7                    
3371   7                      HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);
3372   7                    
3373   7                  // if(staInfo->lastUserAppCCOState == 0)
3374   7                    {
3375   8      
3376   8                    //printf("\n MAX_NO_BEACON\n");
3377   8                    //LINKL_SendBcnLossInd(MAX_NO_BEACON_NW_DISCOVERY);
3378   8                    //                FM_Printf(FM_ERROR,"n/w discloss");
3379   8                    snsm->noBcn= 0;
3380   8      #ifdef LOG_FLASH
                            logEvent(ISM_ERROR, BCN_LOSS, EVENT_TYPE_BCN_MISS_IND, NULL, 0);
              #endif
3383   8      #if 0
                            memset((u8*)&snsm->avlnInfo, 0x00, 
                                   sizeof(sAvlnInfo) * AVLN_LIST_MAX);
              #endif
3387   8      
3388   8                    staInfo->numDiscNet = 0;
3389   8                    snsm->activeAvln = 0;
3390   8                    SNSM_HandleBcnLoss(snsm, MAX_NO_BEACON_NW_DISCOVERY);
3391   8      
3392   8                    }
3393   7                  //Host_SendIndication(HOST_EVENT_BCN_LOSS, HPGP_MAC_ID, NULL, 0);
3394   7                  }
3395   6                  else if(snsm->noBcn  == MAX_NO_BEACON_BACKUPCCO)
3396   6                  {
3397   7      
3398   7                    //if(staInfo->lastUserAppCCOState == 0)
3399   7                    {
3400   8                    //LINKL_SendBcnLossInd(MAX_NO_BEACON_BACKUPCCO);
3401   8                      SNSM_HandleBcnLoss(snsm, MAX_NO_BEACON_BACKUPCCO);
3402   8      
3403   8                    }
3404   7                    //Host_SendIndication(HOST_EVENT_PRE_BCN_LOSS, HPGP_MAC_ID, NULL, 0);
3405   7                  }
3406   6      
3407   6      #endif          
3408   6      
3409   6      
3410   6                              STM_StartTimer(snsm->bcnLossTimer, HPGP_TIME_BEACON_LOSS);
3411   6      
3412   6                  }
3413   5      
3414   5                  break;
3415   5                  
3416   5                          case EVENT_TYPE_TIMER_DISC_AGING_IND:
3417   5                          {
3418   6                              //SNSM_PerformAging(snsm);
3419   6                              scb = snsm->staInfo->staScb;
3420   6      #ifdef DISC_BCN           
                                      SCB_AgeDiscLists(scb);
              #endif
3423   6                            
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 57  

3424   6                              //restart the aging timer
3425   6                              STM_StopTimer(snsm->discAgingTimer);
3426   6                              STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
3427   6                              break;
3428   6                          }
3429   5                          case EVENT_TYPE_SNSM_STOP:
3430   5                          {
3431   6                              //this happens when the STA leaves the network
3432   6                              STM_StopTimer(snsm->usttTimer);   
3433   6                              STM_StopTimer(snsm->discAgingTimer);   
3434   6      
3435   6                              STM_StopTimer(snsm->bcnLossTimer);
3436   6      
3437   6                              snsm->enableCcoSelection = 0;
3438   6                              snsm->enableCcoDetection = 0;
3439   6                  snsm->netSync = FALSE;
3440   6                  snsm->netScan = FALSE;
3441   6                              snsm->state = SNSM_STATE_INIT;
3442   6                              break;
3443   6                          } 
3444   5                          
3445   5      #ifdef ROUTE
                                  case EVENT_TYPE_ROUTE_UPDATE_TIMEOUT:
                                  {
                                      ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_IND, NULL);
                                      ROUTE_startUpdateTimer();
                                      break;
                                  }
                                  case EVENT_TYPE_ROUTE_HD_DURATION_TIMEOUT:
                                  {
                                      ROUTE_procHdDurationTimeout();
                                      break;
                                  }
              #endif // ROUTE
3458   5                          default:
3459   5                          {
3460   6                              
3461   6                              FM_Printf(FM_HINFO, "SNSM state connect %bu\n",event->eventHdr.type);
3462   6                          }
3463   5                      }
3464   4                  }
3465   3                  break;
3466   3              }
3467   2              default: //SNSM_STATE_INIT
3468   2              {
3469   3                  FM_Printf(FM_HINFO, "SNSM state %bu\n",snsm->state);
3470   3                  //perform no operation
3471   3              }
3472   2          }
3473   1      }
3474          
3475          
3476          
3477          eStatus SNSM_Init(sSnsm *snsm, sLinkLayer *linkl)
3478          {
3479   1          //sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3480   1          
3481   1          snsm->linkl = linkl;
3482   1          snsm->staInfo = LINKL_GetStaInfo(linkl);
3483   1          snsm->crm = LINKL_GetCrm(linkl);
3484   1      
3485   1          snsm->state = SNSM_STATE_INIT;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 58  

3486   1          snsm->staRole = STA_ROLE_UNKNOWN;
3487   1          snsm->nctei = 0;
3488   1          snsm->hoEnabled = 0;
3489   1          snsm->discUpdate = 0;
3490   1          snsm->txDiscBcn = FALSE;
3491   1        snsm->netSync = FALSE;
3492   1        snsm->netScan = FALSE;
3493   1      
3494   1          snsm->hoSwitch = HPGP_HO_SWITCH_NONE;
3495   1      
3496   1        snsm->bcnLossTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
3497   1                                  EVENT_TYPE_TIMER_BEACON_LOSS_IND, linkl);
3498   1      #ifdef SW_RECOVERY
3499   1        snsm->discStallTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3500   1                      EVENT_TYPE_TIMER_DISC_STALL_IND, linkl);
3501   1        snsm->bcnStallTimer  = STM_AllocTimer(HP_LAYER_TYPE_LINK ,
3502   1                      EVENT_TYPE_TIMER_BCN_STALL_IND,linkl);
3503   1      #endif  
3504   1      
3505   1        snsm->scanToAssocTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK ,
3506   1                    EVENT_TYPE_TIMER_JOIN_TIMEOUT, linkl);
3507   1      
3508   1      #ifdef CALLBACK
                  snsm->bbtTimer = STM_AllocTimer(LINKL_TimerHandler,
                                       EVENT_TYPE_TIMER_BBT_IND, linkl);
              #else
3512   1          snsm->bbtTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
3513   1                               EVENT_TYPE_TIMER_BBT_IND, linkl);
3514   1      #endif
3515   1          if(snsm->bbtTimer == STM_TIMER_INVALID_ID)
3516   1          {
3517   2              return STATUS_FAILURE;
3518   2          }
3519   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:bbt timer id:%bu\n", snsm->bbtTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:bbt timer id:%d\n", snsm->bbtTimer);
              #endif
              #endif
3526   1      
3527   1      #ifdef CALLBACK
                  snsm->usttTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                        EVENT_TYPE_TIMER_USTT_IND, linkl);
              #else
3531   1          snsm->usttTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3532   1                                EVENT_TYPE_TIMER_USTT_IND, linkl);
3533   1      #endif
3534   1          if(snsm->usttTimer == STM_TIMER_INVALID_ID)
3535   1          {
3536   2              return STATUS_FAILURE;
3537   2          }
3538   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:ustt timer id: %bu\n", snsm->usttTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:ustt timer id: %d\n", snsm->usttTimer);
              #endif
              #endif
3545   1      
3546   1      #ifdef CALLBACK
                  snsm->discAgingTimer = STM_AllocTimer(LINKL_TimerHandler, 
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 59  

                                             EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
              #else
3550   1          snsm->discAgingTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3551   1                                     EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
3552   1      #endif
3553   1          if(snsm->discAgingTimer == STM_TIMER_INVALID_ID)
3554   1          {
3555   2              return STATUS_FAILURE;
3556   2          }
3557   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:disc aging timer id: %bu\n", snsm->discAgingTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:disc aging timer id: %d\n", snsm->discAgingTimer);
              #endif
              #endif
3564   1      //    snsm->ccoInfo = LINKL_GetCcoInfo(linkLayer);
3565   1          return STATUS_SUCCESS;
3566   1      }
3567          
3568          //Start STA Mode
3569          eStatus SNSM_Start(sSnsm *snsm, u8 staType)
3570          {
3571   1          sEvent *newEvent = NULL;
3572   1          //sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3573   1          newEvent = EVENT_Alloc(sizeof(sSnsmStartEvent), EVENT_HPGP_CTRL_HEADROOM);
3574   1          if(newEvent == NULL)
3575   1          {
3576   2              FM_Printf(FM_ERROR, "SNSM:EAF\n");
3577   2              return STATUS_FAILURE;
3578   2          }
3579   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
3580   1          newEvent->eventHdr.type = EVENT_TYPE_SNSM_START;
3581   1          *(newEvent->buffDesc.dataptr) = staType;
3582   1      //   if(staType == LINKL_STA_TYPE_ASSOC)
3583   1      //    {
3584   1      //        SLIST_Put(&linkl->intEventQueue, &newEvent->link);
3585   1      //    }
3586   1      //    else
3587   1      //    {
3588   1              LINKL_SendEvent(snsm->linkl, newEvent);
3589   1      //        SLIST_Put(&snsm->linkl->intEventQueue, &newEvent->link);
3590   1      
3591   1      //    }
3592   1          return STATUS_SUCCESS;
3593   1      }
3594          
3595          eStatus SNSM_Stop(sSnsm *snsm)
3596          {
3597   1          sEvent *newEvent = NULL;
3598   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3599   1          sLinkLayer *linkl = snsm->linkl;
3600   1      #if 0
                  newEvent = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
                  if(newEvent == NULL)
                  {
                      FM_Printf(FM_ERROR, "SNSM: Cannot allocate an event.\n");
                      return STATUS_FAILURE;
                  }
                  
                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                  newEvent->eventHdr.type = EVENT_TYPE_SNSM_STOP;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 60  

                // FIX: Need to process immediately
                  LINKL_SendEvent(snsm->linkl, newEvent);
              //    SLIST_Put(&linkl->intEventQueue, &newEvent->link);
              #else
3614   1          //this happens when the STA leaves the network
3615   1               STM_StopTimer(snsm->usttTimer);   
3616   1               STM_StopTimer(snsm->discAgingTimer);  
3617   1      
3618   1           
3619   1            STM_StopTimer(snsm->scanToAssocTimer);
3620   1                        
3621   1           
3622   1               STM_StopTimer(snsm->bbtTimer); 
3623   1           STM_StopTimer(snsm->bcnLossTimer);
3624   1      #ifdef SW_RECOVERY     
3625   1             STM_StopTimer(snsm->discStallTimer);
3626   1           STM_StopTimer(snsm->bcnStallTimer);
3627   1           gBcnStallCounter = 0;
3628   1           gDiscStallCounter = 0;
3629   1      #endif
3630   1               snsm->enableCcoSelection = 0;
3631   1               snsm->enableCcoDetection = 0;
3632   1           snsm->enableBcnLossDetection = 0;
3633   1               snsm->netSync = FALSE;
3634   1               snsm->netScan = FALSE;
3635   1           snsm->enableBackupCcoDetection = 0;
3636   1           snsm->activeAvln = 0;
3637   1      
3638   1           gHpgpHalCB.syncComplete   = 0;
3639   1           gHpgpHalCB.nwSelected     = 0;
3640   1      
3641   1           
3642   1           
3643   1      #if 0 //def FREQ_DETECT               
                     gHpgpHalCB.gFreqCB.freqDetected = 0;
              #endif
3646   1      
3647   1               
3648   1           gHpgpHalCB.nwSelectedSnid = 0;
3649   1      
3650   1               snsm->state = SNSM_STATE_INIT;
3651   1          
3652   1      #endif
3653   1      
3654   1          return STATUS_SUCCESS;
3655   1      }
3656          #endif /* STA_FUNC */
3657          //
3658          #if 0
              void SNSM_Start(sSns
              {
                  switch(staType)
                  {
                      case LINKL_STA_TYPE_UNASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          snsm->enableCcoSelection = 1;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 61  

                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_NETDISC:
                      {
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_ASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
                          snsm->state = SNSM_STATE_CONN;
                          break;
                      }
                      case LINKL_STA_TYPE_CONN:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 0;
                          snsm->state = SNSM_STATE_CONN;
                      }
                      default:
                      {
                      }
                  }
              }
              #endif
3712          
3713          
3714          
3715          
3716          /*
3717          void SNSM_StartConn(sSnsm *snsm)
3718          {
3719              STM_StopTimer(snsm->usttTimer);   
3720              snsm->state = SNSM_STATE_CONN;
3721          }
3722          
3723          
3724          void SNSM_LeaveConn(sSnsm *snsm)
3725          {
3726              snsm->state = SNSM_STATE_INIT;
3727          }
3728          */
3729          
3730          
3731          void SNSM_EnableHO(sSnsm *snsm)
3732          {
3733   1          snsm->hoEnabled = 1;
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 62  

3734   1      }
3735          
3736          
3737          void SNSM_EnableCcoDetection(sSnsm *snsm) //detect the central cco
3738          {
3739   1          snsm->enableCcoDetection = 1;
3740   1      }
3741          
3742          /** =========================================================
3743           *
3744           * Edit History
3745           *
3746           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/link/nsm_sta.c,v $
3747           *
3748           * $Log: nsm_sta.c,v $
3749           * Revision 1.50  2015/03/16 11:32:25  ranjan
3750           * Fixes for multiCCo modes switching
3751           * Beacon Rx Reception issue fix
3752           * Verified : Overnight multicco setup and 15 minutes SPI TCP test.
3753           *
3754           * Revision 1.49  2015/02/03 13:11:34  prashant
3755           * Fix CCO Fix STA changes
3756           *
3757           * Revision 1.48  2015/01/19 22:47:53  tri
3758           * Took out LG_WAR
3759           *
3760           * Revision 1.47  2015/01/13 10:31:27  prashant
3761           * LLP firmware changes
3762           *
3763           * Revision 1.46  2015/01/13 02:01:57  tri
3764           * removed psSetFlag
3765           *
3766           * Revision 1.45  2015/01/12 08:22:13  prashant
3767           * Power save Changes
3768           *
3769           * Revision 1.44  2015/01/06 02:51:19  tri
3770           * Fixed PS resync problem
3771           *
3772           * Revision 1.43  2015/01/02 14:55:36  kiran
3773           * 1) Timer Leak fixed while freeing SCB fixed
3774           * 2) Software broadcast supported for LG
3775           * 3) UART Loopback supported for LG
3776           * 4) Keep Alive feature to ageout defunctional STA
3777           * 5) Improved flash API's for NO Host Solution
3778           * 6) Imporved PLC Hang recovery mechanism
3779           * 7) Reduced nested call tree of common path functions
3780           * 8) Code optimization and cleanup (unused arguments, unused local variables)
3781           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
3782           * 10) Use of memory specific pointers instead of generic pointers
3783           *
3784           * Revision 1.42  2014/12/09 07:09:09  ranjan
3785           * - multicco feature under MCCO flag
3786           *
3787           * Revision 1.41  2014/12/08 07:57:12  prashant
3788           * print removed
3789           *
3790           * Revision 1.40  2014/12/04 09:51:16  prashant
3791           * Rssi and Lqi added in beacon processing
3792           *
3793           * Revision 1.39  2014/11/11 14:52:58  ranjan
3794           * 1.New Folder Architecture espically in /components
3795           * 2.Modular arrangment of functionality in new files
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 63  

3796           *    anticipating the need for exposing them as FW App
3797           *    development modules
3798           * 3.Other improvisation in code and .h files
3799           *
3800           * Revision 1.38  2014/10/28 16:27:43  kiran
3801           * 1) Software recovery using Watchdog Timer
3802           * 2) Hardware recovery monitor and policies
3803           * 3) Timer Polling in Control Task and Frame task for better accuracy
3804           * 4) Common memory optimized by reducing prints
3805           * 5) Discovered netlist corruption fixed
3806           * 6) VCO fix in HHAL_AFEInit()
3807           * 7) Idata optimized by removing floating point operation
3808           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
3809           * 9) Beacon processing protected from interrupts
3810           * 10) Corrupted Beacons are dropped
3811           * 11) Some unused arguments removed to improve code size
3812           *
3813           * Revision 1.37  2014/10/15 10:42:51  ranjan
3814           * small fixes in um
3815           *
3816           * Revision 1.36  2014/10/13 10:23:57  prashant
3817           * LG-Uart corruption issue fix
3818           *
3819           * Revision 1.35  2014/09/30 21:45:01  tri
3820           * Added LLP PS
3821           *
3822           * Revision 1.34  2014/09/05 09:28:18  ranjan
3823           * 1. uppermac cco-sta switching feature fix
3824           * 2. general stability fixes for many station associtions
3825           * 3. changed mgmt memory pool for many STA support
3826           *
3827           * Revision 1.33  2014/08/25 07:37:34  kiran
3828           * 1) RSSI & LQI support
3829           * 2) Fixed Sync related issues
3830           * 3) Fixed timer 0 timing drift for SDK
3831           * 4) MMSG & Error Logging in Flash
3832           *
3833           * Revision 1.32  2014/08/12 08:45:43  kiran
3834           * 1) Event fixes
3835           * 2) API to change UART line control parameters
3836           *
3837           * Revision 1.31  2014/07/30 12:26:26  kiran
3838           * 1) Software Recovery for CCo
3839           * 2) User appointed CCo support in SDK
3840           * 3) Association process performance fixes
3841           * 4) SSN related fixes
3842           *
3843           * Revision 1.30  2014/07/22 10:03:52  kiran
3844           * 1) SDK Supports Power Save
3845           * 2) Uart_Driver.c cleanup
3846           * 3) SDK app memory pool optimization
3847           * 4) Prints from STM.c are commented
3848           * 5) Print messages are trimmed as common no memory left in common
3849           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
3850           *
3851           * Revision 1.29  2014/07/16 10:47:40  kiran
3852           * 1) Updated SDK
3853           * 2) Fixed Diag test in SDK
3854           * 3) Ethernet and SPI interfaces removed from SDK as common memory is less
3855           * 4) GPIO access API's added in SDK
3856           * 5) GV701x chip reset command supported
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 64  

3857           * 6) Start network and Join network supported in SDK (Forced CCo and STA)
3858           * 7) Some bug fixed in SDK (CP free, p app command issue etc.)
3859           *
3860           * Revision 1.28  2014/07/10 11:42:45  prashant
3861           * power save commands added
3862           *
3863           * Revision 1.27  2014/07/05 09:16:27  prashant
3864           * 100 Devices support- only association tested, memory adjustments
3865           *
3866           * Revision 1.26  2014/07/04 03:54:14  tri
3867           * Fixed bug in STA
3868           *
3869           * Revision 1.25  2014/06/24 16:26:45  ranjan
3870           * -zigbee frame_handledata fix.
3871           * -added reason code for uppermac host events
3872           * -small cleanups
3873           *
3874           * Revision 1.24  2014/06/23 06:56:44  prashant
3875           * Ssn reset fix upon device reset, Duplicate SNID fix
3876           *
3877           * Revision 1.23  2014/06/19 17:13:19  ranjan
3878           * -uppermac fixes for lvnet and reset command for cco and sta mode
3879           * -backup cco working
3880           *
3881           * Revision 1.22  2014/06/19 07:16:02  prashant
3882           * Region fix, frequency setting fix
3883           *
3884           * Revision 1.21  2014/06/12 13:15:44  ranjan
3885           * -separated bcn,mgmt,um event pools
3886           * -fixed datapath issue due to previous checkin
3887           * -work in progress. neighbour cco detection
3888           *
3889           * Revision 1.20  2014/06/11 13:17:47  kiran
3890           * UART as host interface and peripheral interface supported.
3891           *
3892           * Revision 1.19  2014/06/05 10:26:07  prashant
3893           * Host Interface selection isue fix, Ac sync issue fix
3894           *
3895           * Revision 1.18  2014/06/05 08:38:41  ranjan
3896           * -flash function enabled for uppermac
3897           * - commit command after any change would flash systemprofiles
3898           * - verfied upper mac
3899           *
3900           * Revision 1.17  2014/05/28 10:58:59  prashant
3901           * SDK folder structure changes, Uart changes, removed htm (UI) task
3902           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
3903           *
3904           * Revision 1.16  2014/05/21 23:02:31  tri
3905           * more PS
3906           *
3907           * Revision 1.15  2014/05/20 05:57:45  prashant
3908           * persistent schedule code updated
3909           *
3910           * Revision 1.14  2014/05/12 08:09:57  prashant
3911           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
3912           *
3913           * Revision 1.13  2014/04/21 03:12:04  tri
3914           * more PS
3915           *
3916           * Revision 1.12  2014/04/20 19:51:28  tri
3917           * more PS
3918           *
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 65  

3919           * Revision 1.11  2014/04/11 12:23:55  prashant
3920           * Under PLC_TEST macro Diagnostic Mode code added
3921           *
3922           * Revision 1.10  2014/04/09 21:10:20  tri
3923           * more PS
3924           *
3925           * Revision 1.9  2014/04/09 08:18:10  ranjan
3926           * 1. Added host events for homeplug uppermac indication (Host_SendIndication)
3927           * 2. timer workaround  + other fixes
3928           *
3929           * Revision 1.8  2014/03/27 23:52:06  tri
3930           * more PS
3931           *
3932           * Revision 1.7  2014/03/10 05:58:10  ranjan
3933           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
3934           *
3935           * Revision 1.6  2014/03/08 18:15:26  tri
3936           * added more PS code
3937           *
3938           * Revision 1.5  2014/02/27 10:42:47  prashant
3939           * Routing code added
3940           *
3941           * Revision 1.4  2014/02/26 23:15:14  tri
3942           * more PS code
3943           *
3944           * Revision 1.3  2014/01/28 17:47:21  tri
3945           * Added Power Save code
3946           *
3947           * Revision 1.2  2014/01/10 17:17:53  yiming
3948           * check in Rajan 1/8/2014 code release
3949           *
3950           * Revision 1.6  2014/01/08 10:53:54  ranjan
3951           * Changes for LM OS support.
3952           * New Datapath FrameTask
3953           * LM and UM  datapath, feature verified.
3954           *
3955           * known issues : performance numbers needs revisit
3956           *
3957           * review : pending.
3958           *
3959           * Revision 1.5  2013/10/16 07:43:38  prashant
3960           * Hybrii B Upper Mac compiling issues and QCA fix, added default eks code
3961           *
3962           * Revision 1.4  2013/09/04 14:51:01  yiming
3963           * New changes for Hybrii_A code merge
3964           *
3965           * Revision 1.9  2013/07/12 08:56:37  ranjan
3966           * -UKE Push Button Security Feature.
3967           * Verified : DirectEntry Security Works.Datapath Works.
3968           *                 command SetSecMode for UKE works.
3969           * Added against bug-160
3970           *
3971           * Revision 1.8  2013/05/23 10:09:30  prashant
3972           * Version command added, SPI polling waittime increased, sys_common file added
3973           *
3974           * Revision 1.7  2013/03/22 12:21:49  prashant
3975           * default FM_MASK and FM_Printf modified for USER INFO
3976           *
3977           * Revision 1.6  2013/03/21 07:43:26  ranjan
3978           * Starting NDC on "p reset" command
3979           *
3980           * Revision 1.5  2013/03/14 11:49:18  ranjan
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 66  

3981           * 1.handled cases  for CCo toSTA switch and  viceversa
3982           * 2.UM uses bcntemplate
3983           *
3984           * Revision 1.4  2013/02/15 12:53:57  prashant
3985           * ASSOC.REQ changes for DEVELO
3986           *
3987           * Revision 1.3  2012/12/14 11:06:58  ranjan
3988           * queue added for eth to plc datapath
3989           * removed mgmt tx polling
3990           *
3991           * Revision 1.2  2012/11/19 07:46:24  ranjan
3992           * Changes for Network discovery modes
3993           *
3994           * Revision 1.1  2012/09/05 00:13:08  mark
3995           * separate nsm.c into nsm_cco.c and nsm_sta.c,  reason is nsm.c can't be put into bank
3996           *
3997           * Revision 1.40  2012/08/25 15:12:01  yuanhua
3998           * correct the csma region setting in SNSM when a persistent schedule is received
3999           *
4000           * Revision 1.39  2012/08/25 05:49:15  yuanhua
4001           * fix a potential overwriting of region array in SNSM when receive a beacon.
4002           *
4003           * Revision 1.38  2012/08/24 04:40:12  yuanhua
4004           * set initial regions in CNSM for CCO
4005           *
4006           * Revision 1.37  2012/08/23 04:06:52  yuanhua
4007           * made a fix in SNSM for persistent schedule process
4008           *
4009           * Revision 1.36  2012/08/20 04:57:35  yuanhua
4010           * modify the region entry and add persistent schedule entry for beacon
4011           *
4012           * Revision 1.35  2012/08/03 04:03:23  kripa
4013           * *** empty log message ***
4014           *
4015           * Revision 1.34  2012/08/01 04:56:02  kripa
4016           * Fixed the variable reuse within BuildBeacon regions Bentry, that was causing bcn corruption.
4017           * Committed on the Free edition of March Hare Software CVSNT Client.
4018           * Upgrade to CVS Suite for more features and support:
4019           * http://march-hare.com/cvsnt/
4020           *
4021           * Revision 1.33  2012/07/31 14:53:34  kripa
4022           * Initilalizing snsm->hoSwitch = HPGP_HO_SWITCH_NONE ; it fixes a bug that causes STA to begin a Handover
             - process, soon afer initial sync.
4023           *
4024           * Revision 1.32  2012/07/30 04:37:55  yuanhua
4025           * fixed an issue that an event memory could be overwritten in the HAL when the HAL receives a mgmt messag
             -e.
4026           *
4027           * Revision 1.31  2012/07/15 17:31:07  yuanhua
4028           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
4029           *
4030           * Revision 1.30  2012/07/12 05:47:34  kripa
4031           * Commenting out Disc Bcn dump, as this could interfere with sync.
4032           * Committed on the Free edition of March Hare Software CVSNT Client.
4033           * Upgrade to CVS Suite for more features and support:
4034           * http://march-hare.com/cvsnt/
4035           *
4036           * Revision 1.29  2012/07/08 18:42:20  yuanhua
4037           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
4038           *
4039           * Revision 1.28  2012/06/30 19:53:58  kripa
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 67  

4040           * Commenting out Schedule Bentrys enoding & parsing temporarily.
4041           * Committed on the Free edition of March Hare Software CVSNT Client.
4042           * Upgrade to CVS Suite for more features and support:
4043           * http://march-hare.com/cvsnt/
4044           *
4045           * Revision 1.27  2012/06/30 19:47:39  kripa
4046           * Commenting out Schedule Bentry encoding+parsing temporarily.
4047           * Committed on the Free edition of March Hare Software CVSNT Client.
4048           * Upgrade to CVS Suite for more features and support:
4049           * http://march-hare.com/cvsnt/
4050           *
4051           * Revision 1.26  2012/06/29 03:05:31  kripa
4052           * Commenting out SetCsmaRegions() call temporarily until it has been tested.
4053           * Passing Linemode argument to setDevMode call.
4054           * Committed on the Free edition of March Hare Software CVSNT Client.
4055           * Upgrade to CVS Suite for more features and support:
4056           * http://march-hare.com/cvsnt/
4057           *
4058           * Revision 1.25  2012/06/27 04:28:18  yuanhua
4059           * added region entry in the beacon.
4060           *
4061           * Revision 1.24  2012/06/20 17:57:05  kripa
4062           * Multiple changes to fix bcn sync. May need review later.
4063           * Committed on the Free edition of March Hare Software CVSNT Client.
4064           * Upgrade to CVS Suite for more features and support:
4065           * http://march-hare.com/cvsnt/
4066           *
4067           * Revision 1.23  2012/06/15 04:35:21  yuanhua
4068           * add a STA type of passive unassoc STA. With this STA type, the device acts as a STA during the network 
             -discovery. It performs the network scan for beacons from the CCO, but does not transmit the UNASSOC_STA.IND and does not
             - involve in the CCO selection process. Thus, it joins the existing network.
4069           *
4070           * Revision 1.22  2012/06/14 06:51:50  yuanhua
4071           * still keep discovery aging timer to run after the CCO is found.
4072           *
4073           * Revision 1.21  2012/06/14 06:45:06  yuanhua
4074           * stop the periodic timers after the STA finds the CCo during the network discovery, as no need to transm
             -it an unassociated_sta.ind if the CCO is detected.
4075           *
4076           * Revision 1.20  2012/06/14 06:14:47  yuanhua
4077           * (1) remove the net scan when the device is set to the CCO mode(2) start the net scan when the CCO is fo
             -und, but the STA is not sync with CCO yet.
4078           *
4079           * Revision 1.19  2012/06/13 16:10:06  son
4080           * Commenting out ScanNet() call in Network Discovery state - so that unassocSta.Ind messages can be sent.
4081           * Committed on the Free edition of March Hare Software CVSNT Client.
4082           * Upgrade to CVS Suite for more features and support:
4083           * http://march-hare.com/cvsnt/
4084           *
4085           * Revision 1.18  2012/06/13 06:24:31  yuanhua
4086           * add code for tx bcn interrupt handler integration and data structures for region entry schedule. But th
             -ey are not in execution yet.
4087           *
4088           * Revision 1.17  2012/06/11 14:49:59  yuanhua
4089           * changed the HAL back to the STA mode after finding the CCo during the network discovery so that the CTR
             -LL issues an association request in the HAL STA mode.
4090           *
4091           * Revision 1.16  2012/06/11 06:29:01  yuanhua
4092           * changed HAL_SetBpsto to HAL_SyncNet.
4093           *
4094           * Revision 1.15  2012/06/08 05:50:57  yuanhua
4095           * added snid function.
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 68  

4096           *
4097           * Revision 1.14  2012/06/05 22:37:12  son
4098           * UART console does not get initialized due to task ID changed
4099           *
4100           * Revision 1.13  2012/06/05 07:25:59  yuanhua
4101           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
4102           *
4103           * Revision 1.12  2012/06/04 23:34:02  son
4104           * Added RTX51 OS support
4105           *
4106           * Revision 1.11  2012/05/19 20:32:17  yuanhua
4107           * added non-callback option for the protocol stack.
4108           *
4109           * Revision 1.10  2012/05/19 05:05:15  yuanhua
4110           * optimized the timer handlers in CTRL and LINK layers.
4111           *
4112           * Revision 1.9  2012/05/17 05:05:58  yuanhua
4113           * (1) added the option for timer w/o callback (2) added task id and name.
4114           *
4115           * Revision 1.8  2012/05/01 04:51:09  yuanhua
4116           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
4117           *
4118           * Revision 1.7  2012/05/01 00:18:47  son
4119           * Added _CCO_FUNC_ and _STA_FUNC_ compiler flags
4120           *
4121           * Revision 1.6  2012/04/30 04:05:57  yuanhua
4122           * (1) integrated the HAL mgmt Tx. (2) various updates
4123           *
4124           * Revision 1.5  2012/04/20 01:39:33  yuanhua
4125           * integrated uart module and added compiler flag NMA.
4126           *
4127           * Revision 1.4  2012/04/13 06:15:11  yuanhua
4128           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
4129           *
4130           * Revision 1.3  2012/03/11 17:02:25  yuanhua
4131           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
4132           *
4133           * Revision 1.2  2011/09/09 07:02:31  yuanhua
4134           * migrate the firmware code from the greenchip to the hybrii.
4135           *
4136           * Revision 1.12  2011/09/06 05:01:46  yuanhua
4137           * Made a fix such that the STA continues periodic TEI renew after CCo handover.
4138           *
4139           * Revision 1.11  2011/08/12 23:13:22  yuanhua
4140           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
4141           *
4142           * Revision 1.10  2011/08/09 22:45:44  yuanhua
4143           * changed to event structure, seperating HPGP-related events from the general event defination so that th
             -e general event could be used for other purposes than the HPGP.
4144           *
4145           * Revision 1.9  2011/08/08 22:05:41  yuanhua
4146           * user-selected CCo handover fix
4147           *
4148           * Revision 1.8  2011/08/05 17:06:29  yuanhua
4149           * (1) added an internal queue in Link Layer for communication btw modules within Link Layer (2) Fixed bug
             -s in CCo Handover. Now, CCo handover could be triggered by auto CCo selection, CCo handover messages work fine (3) Made 
             -some modifications in SHAL.
4150           *
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 69  

4151           * Revision 1.7  2011/08/02 16:06:00  yuanhua
4152           * (1) Fixed a bug in STM (2) Made STA discovery work according to the standard, including aging timer. (3
             -) release the resource after the STA leave (4) STA will switch to the backup CCo if the CCo failure occurs (5) At this p
             -oint, the CCo could work with multiple STAs correctly, including CCo association/leave, TEI renew, TEI map updating, dis
             -covery beacon scheduling, discovery STA list updating ang aging, CCo failure, etc.
4153           *
4154           * Revision 1.6  2011/07/30 02:43:35  yuanhua
4155           * (1) Split the beacon process into two parts: one requiring an immdiate response, the other tolerating t
             -he delay (2) Changed the API btw the MUX and SHAL for packet reception (3) Fixed bugs in various modules. Now, multiple 
             -STAs could successfully associate/leave the CCo
4156           *
4157           * Revision 1.5  2011/07/22 18:51:05  yuanhua
4158           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
4159           *
4160           * Revision 1.4  2011/07/16 17:11:23  yuanhua
4161           * (1)Implemented SHOM and CHOM modules, including handover procedure, SCB resource updating for HO (2) Up
             -date SNAM and CNAM modules to support uer-appointed CCo handover (3) Made the SCB resources to support the TEI MAP for t
             -he STA mode and management of associated STA resources (e.g. TEI) (4) Modified SNSM and CNSM to perform all types of han
             -dover switch (CCo handover to the new STA, STA taking over the CCo, STA switching to the new CCo)
4162           *
4163           * Revision 1.3  2011/07/08 22:23:48  yuanhua
4164           * (1) Implemented CNSM, including its state machine, beacon transmission and process, discover beacon sch
             -eduling, auto CCo selection, discover list, handover countdown, etc. (2) Updated SNSM, including discover list processin
             -g, triggering a switch to the new CCo, etc. (3) Updated CNAM and SNAM, adding the connection state in the SNAM, switch t
             -o the new CCo, etc. (4) Other updates
4165           *
4166           * Revision 1.2  2011/06/24 14:33:18  yuanhua
4167           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
4168           *
4169           * Revision 1.1  2011/05/28 06:31:19  kripa
4170           * Combining corresponding STA and CCo modules.
4171           *
4172           * Revision 1.1  2011/05/06 19:10:12  kripa
4173           * Adding link layer files to new source tree.
4174           *
4175           * Revision 1.3  2011/04/23 19:48:45  kripa
4176           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
4177           *
4178           * Revision 1.2  2011/04/23 17:35:36  kripa
4179           * Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
4180           *
4181           * Revision 1.1  2011/04/08 21:42:45  yuanhua
4182           * Framework
4183           *
4184           *
4185           * =========================================================*/
4186          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15391    ----
   CONSTANT SIZE    =   1103    ----
   XDATA SIZE       =     51     528
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   NSM_STA                                                           11/04/2015 20:09:45 PAGE 70  

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
