C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE HAL_HPGP
OBJECT MODULE PLACED IN .\obj\hal_hpgp.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hal\hal_hpgp.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE
                    -) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\f
                    -irmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..
                    -\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmwar
                    -e\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\
                    -..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\
                    -..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..
                    -\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..
                    -\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp
                    -\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\.
                    -.\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compo
                    -nents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flas
                    -h\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\
                    -..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\in
                    -c;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\c
                    -omponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051
                    -,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,H
                    -YBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,H
                    -YBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCC
                    -O,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER
                    -_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\hal_hpgp.lst) TABS(2) OBJE
                    -CT(.\obj\hal_hpgp.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgp.c,v 1.73 2015/01/02 14:55:35 kiran Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgp.c,v $
   5          *
   6          * Description : HPGP Hardware Abstraction Layer implementation
   7          *
   8          * Copyright (c) 2010-2013 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines API interface for accessing HPGP memory mapped registers.
  13          *                           for writing tx descritpors to plc tx queues
  14          *                           for writing beacons to beacon tx fifos
  15          *                           for reading beacons from beacon rx fifos
  16          */
  17          
  18          
  19          #include <stdio.h>
  20          #include <string.h>
  21          #include <intrins.h>
  22          #include "papdef.h"
  23          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  26          #include "hal_common.h"
  27          #include "hal.h"
  28          #include "fm.h"
  29          #include "hal_hpgp.h"
  30          #include "hal_eth.h"
  31          #include "hal_tst.h"
  32          #include "hal_reg.h"
  33          #include "hpgpevt.h"
  34          #include "timer.h"
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 2   

  35          #include "stm.h"
  36          #include "hybrii_tasks.h"
  37          #include "nma.h"
  38          #include "nma_fw.h"
  39          #ifndef HPGP_HAL_TEST
  40          #include "hpgpapi.h"
  41          #endif  //HPGP_HAL_TEST
  42          #include "gv701x_gpiodriver.h"
  43          #include "fm.h"
  44          #ifdef HPGP_HAL_TEST
              #include "hal_cfg.h"
              #else
  47          #include "hal.h"
  48          #endif  //HPGP_HAL_TEST
  49          #include "hal_regs_def.h"
  50          #include "uart.h"
  51          #ifdef NO_HOST
  52          #include "gv701x_flash.h"
  53          #endif
  54          
  55          #ifdef HPGP_MAC_SAP 
  56          #ifdef LINK_STATUS
              #define MAX_LINK_TEST_TX_TIMEOUT 450
              #define LINK_RETRY            1
              #endif  //LINK_STATUS
  60          #endif  //HPGP_MAC_SAP
  61          
  62          #ifdef FREQ_DETECT
  63              u32 AC_MIN_THRESHOLD;
  64              u32 PLC_DC_LINE_CYCLE_FREQENCY  =  0x7A120;
  65          #endif
  66          u32 gBPSTdelta;
  67          u8 gNegativeflag = 0;
  68          u8 gPositiveflag = 0;
  69          u8 firsttime = 0;
  70          u32 goldbpst;
  71          u32 gavg;
  72          u8 zctrack = 0;
  73          u8 zcFlag;
  74          u32 gbpst = 0;
  75          u8 gRollOver;
  76          u32 zcCCONTBold;
  77          u32 gCCO_BTS;
  78          u32 zcCCONTB_OLD;
  79          
  80          u8 avgdone = 0;
  81          u32 avg;
  82          u8 avgcount =0;
  83          
  84          //[YM] Define for LED relay control number
  85          #define Light_4_Relay = 4;
  86          #define Light_6_Relay = 6;
  87          
  88          extern u32 misscnt;
  89          
  90          void sendSingleFrame(u8 mcstMode);  //1 = multicast, 0 unicast
  91          extern void datapath_init();
  92          
  93          extern u16 var1;
  94          //u32 missarr[1000];
  95          u8 testflag = 1;
  96          
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 3   

  97          extern u8 opMode;
  98          #ifdef PLC_TEST
              u8 gSTA_TEI;
              u8 gCount;
              u8 gNumOfSTAAssignedTEI = 1;
              u8 gCCOTest = 0;
              extern u16 gBcnSent;
              eHpgpRoboMod gRoboMode;
              eHpgpRoboModLens gCurrRobomode;
              #define TOTAL_NUM_OF_TX_FRAME  1000
              
                u16 gRobomodeAllLenTest[5][2]= {
              
                  {HPGP_ROBOMD_MINI_100, 100},   
                  {HPGP_ROBOMD_MINI_250, 250}, 
                  //{HPGP_ROBOMD_HS_800, 800}, 
                 // {HPGP_ROBOMD_HS_1000, 1000},
                  {HPGP_ROBOMD_STD_500, 500}, 
                  {HPGP_ROBOMD_HS_800, 800}, 
                  {HPGP_ROBOMD_HS_1000, 1000}, 
              
              
              };   
              #endif
 121          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
              
              u16 gAltRoboLenArr[]={101,401,801,1201};
              u8 gAltEksTstArr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15}; // 7 NEKs, 2 PPEKs, Unenc
              #endif
 126          
 127          #ifdef FREQ_DETECT
 128          u32 PLC_DC_BP_LEN     =           PLC_DC_BP_LEN_60HZ;
 129          u32 PLC_AC_BP_LEN     =           PLC_AC_BP_LEN_60HZ;//0xCB735      //these are for 60 hz AC
 130          u32 PLC_MIN_AC_BPLEN  =           0xCB300;
 131          u32 PLC_MAX_AC_BPLEN  =           0xCBA00; 
 132          #endif
 133          
 134          u32 cnt5 = 0;
 135          u32 oldRetrievedBTS;
 136          u32 oldss1;
 137          u32 OldCCOBpst;
 138          
 139          u32 gBcnPer;
 140          extern u32 gtimer2, gtimer1;
 141          u8 gsyncTimeout;
 142          u8 gBcnMissingRescanCnt;
 143          extern u8 gflag;
 144          sHpgpHalCB gHpgpHalCB;
 145          #ifdef HPGP_HAL_TEST
              extern sHalCB gHalCB;
              sHpgpHalCB *gpHhalCb;
              #endif  //HPGP_HAL_TEST
 149          
 150          #ifdef DEBUG_DATAPATH
 151          extern u8 sigDbg;
 152          #endif
 153          
 154          u32 gbpst1;
 155          u32 gOldBTS;
 156          #ifdef ETH_BRDG_DEBUG
              extern u32 numTxDoneInts;
              extern u8 myDebugFlag;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 4   

              extern u8 myDebugFlag1;
              #endif
 161          
 162          /*u32 TX_RXLatency_TCC[8] = {
 163                             
 164                              0x321e0417,  //TCC =1
 165                             // 0x336F0417,
 166                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
 167                              0x34ca0417,
 168                              0x361F0417,
 169                              0x37750417,
 170                              0x38c20417,
 171                              0x3a180417,
 172                              0x3b740417,  //TCC= 8
 173          
 174          };*/
 175          
 176          //phy image gpphy_3S150_08032013- and onwards uses phy tx latency as 0x04e5 and older phy image uses phy t
             -x latency as 0x0417 
 177          #ifdef B_ASICPLC
 178          //following is for ASIC
 179          u32 TX_RXLatency_TCC[8] = {
 180                          0x30C104DD,   //TCC =1
 181                          0x319304DD,
 182                          0x325504DD,  //TCC =3   326204dd  3255
 183                          0x332604DD,
 184                          0x33F304DD,
 185                          0x34C004DD,
 186                          0x358C04DD,
 187                          0x365A04DD, //TCC= 8
 188          
 189          };
 190          #else
              u32 TX_RXLatency_TCC[8] = {
                                 
                                  0x321e04E5,  //TCC =1
                                 // 0x336F0417,   old phy tx latency 0x0417
                                  0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
                                  0x34ca04E5,
                                  0x361F04E5,
                                  0x377504E5,
                                  0x38c204E5,
                                  0x3a1804E5,
                                  0x3b7404E5,  //TCC= 8
              
              };
              #endif
 205          u8 TCC_REG_485_486_val[8][2] = {
 206                                          {0x40,0x80},
 207                                          {0x80,0x80},
 208                                          {0xc0,0x80},
 209                                          {0x0,0x81},
 210                                          {0x40,0x81},
 211                                          {0x80,0x81},
 212                                          {0xc0,0x81},
 213                                          {0x0,0x82},
 214          
 215          };
 216          u8 gDefNID[NID_LEN] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77};
 217          #define PLC_MaxPeran                    0x1B
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 5   

 218          #define PLC_MinPeran                    0x1C
 219          u16  prevCsmaRgns[HYBRII_MAXSMAREGION_CNT] = {0};
 220          #ifdef CCO_FUNC
 221          #ifdef FREQ_DETECT
 222          #ifdef UM
 223          extern eStatus CNSM_InitRegion(sCnsm *cnsm);
 224          #endif
 225          #endif
 226          #endif
 227          
 228          #ifdef PLC_TEST
              void printmsg(u8* buff, u8 len)
              {
                 u8 i;
                 for(i = 0; i < len; i++)
                 {
                     printf("%bx\t", buff[i]);
                 }
                 printf("\n");
              }
              
              void HHT_ProcessPlcFrame(sSwFrmDesc* plcRxFrmSwDesc)
              {
                  
                  u8 HeaderOffset = sizeof(gHeaderBytes);
                  u8 TestID;
                  u8 NumOFSTAAssignTEI;
                  u8 offset;
                  volatile u8  RxDataBuff[500];
                  volatile u8 TxdataBuff[500];
                  u8 STA_TEI;
                  u8 i;
                  u16 totalDesc ;
                  u16 freeDescCnt ;
                  u32 per;
                  
                                      
                  
                  sHpgpHalCB HpgpHalCB;
                  plcHalStatus plc_halstatus_t;
                  volatile u8 xdata * cellAddr;
                  
                  //printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
                
                
              
                  //  /?! frames should not be considered in statistic so doing minus 1
                  //gHpgpHalCB.halStats.TotalRxGoodFrmCnt--;
                  //gHpgpHalCB.halStats.RxGoodDataCnt--;
                  
                   
                   //WE assume that received data will never be more then 500 bytes since rxdabuff size is 500  and txda
             -tabuff is also 500
                  
                  cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[0].cp);
                  TestID = cellAddr[HeaderOffset + 0];//because first three bytes will be /, ?, !       HeaderOffset = 3
                  strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
                  
                  
                  for(i = 0; i < plcRxFrmSwDesc->cpCount; i++ )
                  {
                       cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[i].cp);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 6   

                       
                       if(i == 0)//if first cp then we have /?! and test ID
                       {
                           offset = HeaderOffset + 1;//since we have stored 
                       }
                       else
                           offset = 0;
                       
                       
                       memcpy(&RxDataBuff[i* HYBRII_CELLBUF_SIZE] ,&cellAddr[offset], HYBRII_CELLBUF_SIZE);
                  }
                  
               
                  
                 // if(plcRxFrmSwDesc->frmInfo.plc.stei == DEFAULT_CCO_TEI )//source is CCO so STA is Rx
                  {
                      
                      //printf("\nSTA : \n");
                      switch(TestID)
                      {
                          case  BROADCAST_CCO_TEI_TESTID:
                          
                    //send STA TEI to CCO
                  //  printf("BROADCAST_CCO_TEI_TESTID\n");
                              NumOFSTAAssignTEI = RxDataBuff[0];
                              STA_TEI = (NumOFSTAAssignTEI + 1);
                              TxdataBuff[HeaderOffset] = ASSIGN_STA_TEI_TESTID;
                              TxdataBuff[HeaderOffset + 1] = STA_TEI;
                              
                              //printf("\n Rx:\n");
                              //printmsg(&cellAddr[0],5);
                              
                              //printf("\n Tx:\n");
                              //printmsg((u8*)&TxdataBuff[0],5);
                              
                              Send_SinglePLCFrame(5, &TxdataBuff[0], STA_TEI, DEFAULT_CCO_TEI);//this frame is sent from
             - sta to cco saying that tei is assign to sta
                              break;
                          
                          case ACK_FOR_STA_TEI_TESTID://3
                              //set robo mode to mini robo
                              //send start PLC data rate test ID
                              
                           //    printf("\n ACK_FOR_STA_TEI_TESTID\n");
                               gSTA_TEI = RxDataBuff[0];
                               HHAL_SetTei(gSTA_TEI);
                               gHpgpHalCB.remoteTei = DEFAULT_CCO_TEI;
                               gHpgpHalCB.selfTei = gSTA_TEI;
                               TxdataBuff[HeaderOffset] = START_PLC_DATA_RATE_TESTID;
                               //printf("\n Tx:\n"); 
                               //printmsg(&TxdataBuff[0],4);
                               
                               CHAL_DelayTicks(400);
                               Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);   //this frmae is sent
             - from cco to sta saying start test to test hardware
                               HHAL_ResetPlcStat();
                              
                              
                          break;
               
                          case DATARATE_TEST_TESTID://5 
                           //   printf("DATARATE_TEST_TESTID\n");
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 7   

                              //send pstat 
                              //after send clear the p stat
                              //printf("\nHeaderOffset = %bu\n", HeaderOffset);
                              
                              // printf("\n cpcounts : %bu\n", plcRxFrmSwDesc->cpCnt);
                              //printf("\n>>>nSTA received ROBO mode frame.\n");
                              TxdataBuff[HeaderOffset] = PSTAT_TESTID;
                              memcpy(&TxdataBuff[HeaderOffset + 1],(char*)&gHpgpHalCB.halStats,sizeof(gHpgpHalCB.halStat
             -s));
                              
              
                            
              
                              totalDesc      = PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH + PLC_TXQ_DEPTH;
                              freeDescCnt    =  (u16)(HHAL_GetPlcTxQFreeDescCnt(0) + HHAL_GetPlcTxQFreeDescCnt(1) + \
                                                   HHAL_GetPlcTxQFreeDescCnt(2) + HHAL_GetPlcTxQFreeDescCnt(3));  
              
                               
              
                              plc_halstatus_t.AddrFilterErrCnt = hal_common_reg_32_read(PLC_ADDRFILTERERRCNT_REG);
                              plc_halstatus_t.FrameCtrlErrCnt = hal_common_reg_32_read(PLC_FCCSERRCNT_REG);
                              plc_halstatus_t.ICVErrCnt = hal_common_reg_32_read(PLC_ICVERRCNT_REG);
                              plc_halstatus_t.PBCSRxErrCnt = hal_common_reg_32_read(PLC_PBCSRXERRCNT_REG);
                              plc_halstatus_t.PBCSTxErrCnt = hal_common_reg_32_read(PLC_PBCSTXERRCNT_REG);
                              plc_halstatus_t.PLCMpduDropCnt = hal_common_reg_32_read(PLC_MPDUDROPCNT_REG);
                              plc_halstatus_t.outStandingDescCnt = totalDesc - freeDescCnt;
                              plc_halstatus_t.FreeCPcount = CHAL_GetFreeCPCnt();
                              plc_halstatus_t.timerIntCnt = gHalCB.timerIntCnt;
                              plc_halstatus_t.bpIntGap = gHpgpHalCB.bpIntGap;
                              plc_halstatus_t.lastNtbB4 = gHpgpHalCB.lastNtbB4;
                              plc_halstatus_t.lastNtbAft = gHpgpHalCB.lastNtbAft;
                              plc_halstatus_t.lastBpst = gHpgpHalCB.lastBpst;
                              
                              
                              memcpy(&TxdataBuff[HeaderOffset + 1 + sizeof(gHpgpHalCB.halStats)],(char*)&plc_halstatus_t
             -,sizeof(plc_halstatus_t)); 
                              
                     
                              
                              
                              //printmsg(&TxdataBuff[0],(sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t))); 
                              //clear the stat
                              HHAL_ResetPlcStat();
                             // printf("\nsize = %x\n", (sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)));
                              
                              //printf("\n >>>STA transmitting its Statistic to CCO...\n");
                              Send_SinglePLCFrame((sizeof(gHpgpHalCB.halStats) + 4 + sizeof(plc_halstatus_t)), &TxdataBu
             -ff[0], gSTA_TEI, DEFAULT_CCO_TEI);
                              
                              
                          break;
                          
                          /*case SEND_SYNC_DATA:
                              //compare and display
                              //send pxmittest dataID DATA_DURING_BCNS_TESTID
                              printf("\nRxGoodBcnCnt = %lu", gHpgpHalCB.halStats.RxGoodBcnCnt);
                              if(gHpgpHalCB.halStats.RxGoodBcnCnt >= NUM_OF_BCNS_FOR_CCO_TEST)
                              {
                                  eth_plc_bridge = 1;
                                  printf("\n\t\t\t\t\t BEACONS RECEIVED SUCCESSFULLY\n");
                                  printf("\n>>>STA Transmitting MINI_ROBO frames to CCO...\n\n");
                                  sendRobomodeFrames(100,1000);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 8   

                                  
                                   
                                  TxdataBuff[3] = SEND_SYNC_DATA;
                                  printmsg(&TxdataBuff[0],4);
                                  Send_SinglePLCFrame(4, &TxdataBuff[0], gSTA_TEI, DEFAULT_CCO_TEI);//broadcast CCO TEI
              
                              }
                              
                          break;
                          
                          case ENABLE_BRIDGE:
                              break;
                          
                        */
              
                              
                              
                      }
                  } 
                //  else//CCO is Rx
                  {
                      //printf("\nCCo : \n");
                      switch(TestID)
                      {
                          case ASSIGN_STA_TEI_TESTID://2
                              
                              //send Ack for STA TEI to STA
                            //  printf("ASSIGN_STA_TEI_TESTID\n");
                              HHAL_SetTei(DEFAULT_CCO_TEI);
                              gHpgpHalCB.selfTei = DEFAULT_CCO_TEI;
                              gSTA_TEI = RxDataBuff[0];
                              gRoboMode = HPGP_ROBOMD_MINI;
                              gHpgpHalCB.remoteTei = gSTA_TEI;
                              TxdataBuff[HeaderOffset] =  ACK_FOR_STA_TEI_TESTID;
                              TxdataBuff[HeaderOffset + 1]  = gSTA_TEI;
                              Send_SinglePLCFrame(5, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
                              
                              
                          break;
                          case START_PLC_DATA_RATE_TESTID://4  tx pxmitttest data    //this is rec from sta that cco has
             - to start test by sending 1000 minirobo frames followed by std robo and hs mode
                            //  printf("START_PLC_DATA_RATE_TESTID\n");
                            label1:  
                            HHAL_ResetPlcStat();
                            gRoboMode = gRobomodeAllLenTest[gCount][0];
                            sendRobomodeFrames(gRobomodeAllLenTest[gCount][1],TOTAL_NUM_OF_TX_FRAME);
                            
                            switch(gRoboMode)
                            {
                              case HPGP_ROBOMD_MINI_100:
                                   // printf("\n>>>CCO Transmitting MINI_ROBO frames to STA...\n");
                                    gCurrRobomode = HPGP_ROBOMD_MINI_100;
                              break;
                              case  HPGP_ROBOMD_MINI_250:
                                   // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");
                                    gCurrRobomode = HPGP_ROBOMD_MINI_250;
                              break;
                              case HPGP_ROBOMD_STD_500:
                                  // printf("\n>>>CCO Transmitting STD_ROBO frames to STA...\n");  
                                   gCurrRobomode = HPGP_ROBOMD_STD_500;
                              break;
                             
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 9   

                              case  HPGP_ROBOMD_HS_800:
                                   //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
                                   gCurrRobomode = HPGP_ROBOMD_HS_800;
                              break;
                              case HPGP_ROBOMD_HS_1000:
                                   //printf("\n>>>CCO Transmitting HS_ROBO frames to STA...\n");   
                                   gCurrRobomode = HPGP_ROBOMD_HS_1000;
                                   //gCount = 0;
                              break;
                               
                            
                          }
                          strncpy(&TxdataBuff[0],&gHeaderBytes[0], sizeof(gHeaderBytes) );
                          HeaderOffset = 3; 
                          TxdataBuff[HeaderOffset] =  DATARATE_TEST_TESTID;
                          //printmsg(&TxdataBuff[0], 4);
                          Send_SinglePLCFrame(4, &TxdataBuff[0],DEFAULT_CCO_TEI, gSTA_TEI);
                        
                              
                              
                              
                          break;
                          case PSTAT_TESTID://6 compare and display it rec all robo mode pstat
                              
                              //compare and display 
                              
                            //  printmsg(&RxDataBuff[0], 20); 
                              //printf("\n>>>CCO Received Statistcs from STA");
                              memcpy((char*)&HpgpHalCB.halStats, &RxDataBuff[0], sizeof(HpgpHalCB.halStats));
                              memcpy((char*)&plc_halstatus_t, &RxDataBuff[(sizeof(gHpgpHalCB.halStats) + 4)], sizeof(plc
             -_halstatus_t)); 
                             // printf("\nSTA Statistic\n\n\n");
                              //HHAL_DisplayPlcStatFromRAM(&HpgpHalCB.halStats, &plc_halstatus_t);
                           
                              
                             // if(HpgpHalCB.halStats.RxGoodDataCnt ==  gHpgpHalCB.halStats.TxDataCnt)
                              //{
                                 
                                  printf("\n\t\t\t\t\t RxGoodDataCnt = %lu\n", HpgpHalCB.halStats.RxGoodDataCnt);
                                   per = TOTAL_NUM_OF_TX_FRAME - HpgpHalCB.halStats.RxGoodDataCnt;
                                  
                                   per = ((per * 100)/TOTAL_NUM_OF_TX_FRAME);
                                 
                                   /*if(per <= 1)
                                      printf("\n\t\t\t\t\tPER is Less athen 1%");
                                   else
                                      printf("\nPER :  %u",per);
                                                                  */
                                  
                                  if(gCurrRobomode == HPGP_ROBOMD_MINI_100 )
                                  {
                                      printf("\n\t\t\t\t\t MINI ROBO MODE PER = %lu",per);
                                  }
                                 
                                  else  if((gCurrRobomode == HPGP_ROBOMD_MINI_250) || (gCurrRobomode == HPGP_ROBOMD_STD_
             -500) )
                                  {
                                      printf("\n\t\t\t\t\t STD ROBO MODE PER = %lu",per);
                                  }
                                  else if((gCurrRobomode == HPGP_ROBOMD_HS_800) || (gCurrRobomode == HPGP_ROBOMD_HS_1000
             -) )
                                  {
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 10  

                                      printf("\n\t\t\t\t\t HS PB ROBO MODE PER = %lu",per);
                                     
                                  }
                                   
                                   printf("%c\n\n",'%');
                                   printf("-----------------------------------------------------------------\n\n");
                                  // printf("\nFrmLen = %d\n\n ", gRobomodeAllLenTest[gCount++][1]);
                                  
                                   HHAL_ResetPlcStat();
                                   
                            //  }
              
                              gCount++;
                              if(gCount == 5)   //since this is last frame test
                              {
                                  gCount = 0;
                                  //oldssn = 0;
                                  printf("\n\t\t\t\t TEST FINISHED, PRESS ENTER");
                                  break;
                                  
                                  
                               }
                             goto label1; 
                              break;
                            
                      }       //end of switch
                  }//end of else
                  
                 
                  for( i=0 ; i< plcRxFrmSwDesc->cpCount ; i++ )
                  {
                          CHAL_DecrementReleaseCPCnt(plcRxFrmSwDesc->cpArr[i].cp);
                  }
                  
              }  
              #endif
 554          
 555          #if defined(HPGP_HAL_TEST) || defined(PLC_TEST) 
              
              void HHT_GetMinMaxLen ( sPlcSimTxTestParams* pTestParams, u8* stdModeSel, u8* minFrmLen, u8* maxFrmLen )
              {
                  if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
                  {
                      if(pTestParams->roboTestMode == MINI_ROBO_TEST)
                      {
                          *minFrmLen =  1 ;
                          *maxFrmLen = pTestParams->frmType?HYBRII_MINIROBO_DATALEN_MAX:HYBRII_MINIROBO_MGMTLEN_MAX;
                      } 
                      else if(pTestParams->roboTestMode == STD_ROBO_TEST) 
                      {
                          *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
                          *maxFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
                          *stdModeSel = 1;
                      } 
                      else if(pTestParams->roboTestMode == HS1PB_ROBO_TEST)
                      {
                          *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
                          *maxFrmLen = pTestParams->frmType ?( HYBRII_STD1PBHSROBO_DATALEN_MAX):(HYBRII_STD1PBHSROBO_MGM
             -TLEN_MAX);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 11  

                          *stdModeSel = 0;
                      }
                      else if(pTestParams->roboTestMode == HS2PB_ROBO_TEST)
                      {
                          *minFrmLen = pTestParams->frmType ? (HYBRII_STD1PBHSROBO_DATALEN_MAX+1):(HYBRII_STD1PBHSROBO_M
             -GMTLEN_MAX+1);
                          *maxFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX):(HYBRII_2PBHSROBO_MGMTLEN_M
             -AX);
                      }
                      else if(pTestParams->roboTestMode == HS3PB_ROBO_TEST)
                      {
                          *minFrmLen = pTestParams->frmType ? (HYBRII_2PBHSROBO_DATALEN_MAX+1):(HYBRII_2PBHSROBO_MGMTLEN
             -_MAX+1);
                          *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
             -AX);
                      }
                      else if(pTestParams->roboTestMode == HSALLPB_ROBO_TEST)
                      {
                          *minFrmLen = pTestParams->frmType ? (HYBRII_MINIROBO_DATALEN_MAX+1):(HYBRII_MINIROBO_MGMTLEN_M
             -AX+1);
                          *maxFrmLen = pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_M
             -AX);
                      }
                  }
                  else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
                  {
                      *stdModeSel = 1;
                      *minFrmLen  = 1;
                      *maxFrmLen  =  pTestParams->frmType ? (HYBRII_3PBHSROBO_DATALEN_MAX):(HYBRII_3PBHSROBO_MGMTLEN_MAX
             -);
                  }
                  else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
                  {
                      *stdModeSel = 1;
                      *minFrmLen  = gAltRoboLenArr[0];
                  }
              }
              
              void HHT_SimulateTx(sPlcSimTxTestParams* pTestParams)
              {
              //  sPlcTxFrmSwDesc plcTxFrmSwDesc;
              //#ifdef Packet_grouping
                  u32             Sw_command_queue[8];
                  u8              cmd_num;
              //#endif  
              //    uPlcTxPktQCAP_Write   cap_write;
              //    uTxCMDQueueWrite      txCmdQueueWrtie;
                  sTxFrmSwDesc    plcTxFrmSwDesc;
                  u8              stdModeSel;
                  u16             stdRoboFrmLenMax;
                  u8              minFrmLen;
                  u8              maxFrmLen;
                  u16             curFrmLen;     
                  eFrmMcstMode    mcstMode;
                  eHpgpHwFrmType  frmType;
                  // mixed mode variables
                  u16             tmpFrmLen;
                  u8              curOffsetDW;
                  u8              curDescLen;
                  u8              eksArrIdx;
                  uAltPlid        altPlid;
                  uAltRoboLenIdx  altRoboLenIdx;        
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 12  

                  eStatus         status;
                  u8              i, c;
                  u8              j;
                  u8              quit; 
                  u16             tmpPayloadLen;
                u8        cp_localBuf[HYBRII_CELLBUF_SIZE]; // local CP buffer
                  u8              dbc_pktchange;
              #ifndef HPGP_HAL_TEST
                  sHaLayer        *hal = HOMEPLUG_GetHal();
              #endif
              
                dbc_pktchange     = 0;
                  quit              = 0;
                  altPlid.val       = 0;
                  altRoboLenIdx.val = 0;
                  eksArrIdx         = 0;
              //#ifdef Packet_grouping0 
                cmd_num           = 0;     
              //#endif
              
                  memset((u8*)&plcTxFrmSwDesc, 0x00, sizeof(plcTxFrmSwDesc));
                  
                  plcTxFrmSwDesc.frmInfo.plc.eks            = pTestParams->eks;       
                  plcTxFrmSwDesc.frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                  plcTxFrmSwDesc.frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_RSV;//HPGP_CONVLYRSAPTYPE_ETH; 
                  plcTxFrmSwDesc.frmInfo.plc.snid = HYBRII_DEFAULT_SNID;
              
                  if(pTestParams->frmType == 0)     
                  {
                          plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_MGMT;
                          frmType                = HPGP_HW_FRMTYPE_MGMT;
                  }
                  else if(pTestParams->frmType == 1)
                  {
                      plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;
                      frmType                       = HPGP_HW_FRMTYPE_MSDU;
                  }
                  else if (pTestParams->frmType == 2) // frmType = 2
                  {
                      plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_SOUND;
                      frmType                = HPGP_HW_FRMTYPE_SOUND;
                      plcTxFrmSwDesc.frmInfo.plc.src     = pTestParams->src;
                      plcTxFrmSwDesc.frmInfo.plc.saf     = pTestParams->saf;
                      plcTxFrmSwDesc.frmInfo.plc.scf     = pTestParams->scf;
                  }
                else if (pTestParams->frmType == HPGP_HW_FRMTYPE_RTS)
                {
                    plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
                      frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_RTS;
                      plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
                }
                else if  (pTestParams->frmType == HPGP_HW_FRMTYPE_CTS)
                  {
                    plcTxFrmSwDesc.frmType        = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
                      frmType                       = HPGP_HW_FRMTYPE_MSDU;  //HPGP_HW_FRMTYPE_CTS;
                      plcTxFrmSwDesc.frmInfo.plc.dt_av = HPGP_DTAV_RTS_CTS;
                }
                  
                  mcstMode           = pTestParams->mcstMode;
                  if(pTestParams->mcstMode == 0)   
                  {
                      plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;       
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 13  

                  }
                  else
                  {
                      plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;
                  }
              
                  if(pTestParams->altPlidTest)
                  {
                      plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->plid; //0;
                  }
                  else
                  {
                      plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;   
                  }                                
                //printf("plid = %d\n",plcTxFrmSwDesc.frmInfo.plc.plid);  //[YM] debug Hybrii_B data pkt Tx
                
                  plcTxFrmSwDesc.frmInfo.plc.stei           = gHpgpHalCB.selfTei;//HYBRII_DEFAULT_TEISTA;
              
              
                  stdModeSel                    = pTestParams->stdModeSel;
              
                  // Incremental/alternating length modes
                  if(pTestParams->frmLen == 0)   //Continuous Tx mode
                  {
                      HHT_GetMinMaxLen(pTestParams, &stdModeSel, &minFrmLen, &maxFrmLen);
                      
                      stdRoboFrmLenMax = plcTxFrmSwDesc.frmType==HPGP_HW_FRMTYPE_MSDU?(HYBRII_STD1PBHSROBO_DATALEN_MAX):
             -(HYBRII_STD1PBHSROBO_MGMTLEN_MAX);               
                      curFrmLen = minFrmLen;
                      FM_Printf(FM_LINFO,"\nStarting from len = %u\n",curFrmLen);
                  }
                  else
                  {
                      // fixed length test
                      curFrmLen = pTestParams->frmLen;
                  }
                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = stdModeSel;
                  curOffsetDW  = pTestParams->offsetDW;
                  curDescLen   = pTestParams->descLen; 
                  gHpgpHalCB.halStats.CurTxTestFrmCnt = 0;
                
                  //for each frame
                  while(1)
                  {
                      u8  frmData = 0;
                      tmpFrmLen   = 0;
                      tmpPayloadLen = 0;
              
                      if (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
                      {
                          if(pTestParams->frmLen <= 136)
                              plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //136;
                          else
                              plcTxFrmSwDesc.frmLen = pTestParams->frmLen; //520;
                      }
                      else
                      {
                          // check for mgmt frm max len, in case this is inclen & altfrmtype test
                          plcTxFrmSwDesc.frmLen         =  (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT && curFrmLen 
             -> HYBRII_3PBHSROBO_MGMTLEN_MAX) ? \
                                                            HYBRII_3PBHSROBO_MGMTLEN_MAX : curFrmLen ;  
                      }   
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 14  

                  
                      //[YM] Add DBC Code
                    if (pTestParams->dbc)
                    {
                        if (pTestParams->pattern == 1)  // One RoBo + One Mini RoBo
                        {
                              if (dbc_pktchange > 1)
                        dbc_pktchange = 0;
                      if (dbc_pktchange == 0)
                            {
                                plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  //Std RoBo
                            }
                      else if (dbc_pktchange == 1)
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      }
                        }
                    else if (pTestParams->pattern == 2)  // Three Mini RoBo
                    {
                          plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                    }
                    else if (pTestParams->pattern == 3)  //Two MiniRoBo + One HS RoBo 1 PB
                    {
                      if ((dbc_pktchange == 0)|(dbc_pktchange == 1))
                            {
                                plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
                            }
                      else
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      }
                    }
                    else if (pTestParams->pattern == 4)  //One MiniRoBo + One HS RoBo 2PB
                    {
                      if (dbc_pktchange == 0)
                            {
                                plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
                            }
                      else
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      }
                    }
                    else if (pTestParams->pattern == 5)  //Two HS RoBo with 1 PB
                    {
                            plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
                    }
                    else if (pTestParams->pattern == 6)  //One Mini RoBo + One HS RoBo with 3 PB
                    {
              
                      if (dbc_pktchange == 0)
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_MINIROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 15  

                      }
                      else
                      {
                        plcTxFrmSwDesc.frmLen =  HYBRII_3PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      } 
                    }
                    else if (pTestParams->pattern == 7)  //One RoBo + One HS RoBo with 1 PB
                    {
                      if (dbc_pktchange == 0)
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;  
                      }
                      else
                      {
                        plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      } 
                    }
                    else if (pTestParams->pattern == 8)  //One HSRoBo with 1 PB + One HSRoBo with 2 PB
                    {
                      if (dbc_pktchange == 0)
                      {
                          plcTxFrmSwDesc.frmLen =  HYBRII_STD1PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;  
                      }
                      else
                      {
                        plcTxFrmSwDesc.frmLen =  HYBRII_2PBHSROBO_DATALEN_MAX;
                          plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                      }
                    }
                      }
              
                          plcTxFrmSwDesc.cpCount        = 0; 
                    plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = pTestParams->plid>0 ? HPGP_PPB_CAP123 : HPGP_PPB_CAP0;
                          plcTxFrmSwDesc.frmInfo.plc.mcstMode       = mcstMode;       
                  
                      if (mcstMode > 0)
                          plcTxFrmSwDesc.frmInfo.plc.phyPendBlks = HPGP_PPB_MCFRPT;
                        else
                            plcTxFrmSwDesc.frmInfo.plc.phyPendBlks    = (pTestParams->plid > 0) ? HPGP_PPB_CAP123 : HPGP_
             -PPB_CAP0;             
              
                  
                      if(pTestParams->altPlidTest)
                      {
                          pTestParams->plid = (gHpgpHalCB.halStats.CurTxTestFrmCnt & 0x3) ; //plid value will be changed
             - in sequence;
                          plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;    
                      }
                  else
                    plcTxFrmSwDesc.frmInfo.plc.plid  = pTestParams->plid;
                                  
                      // create cp descriptors
                      while(tmpFrmLen < plcTxFrmSwDesc.frmLen)
                      {       
                          u8        cp;
                          u8        tmpOffsetDW;
                          u8        tmpOffsetByte;
                          u8        tmpDescLen;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 16  

                          u8        remDescLen;
                          u8        actualDescLen;
                          volatile u8 xdata *       cellAddr;
              
                          tmpOffsetDW =      curOffsetDW;
                          tmpDescLen  =      curDescLen; 
                          // Fetch CP
                    //printf("(C)\n");
                          do
                          {
                              status = CHAL_RequestCP(&cp);
              #ifdef _FIXME_
              #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')
                              {
                                  // Realease CPs fetched so far for current frame -- tbd
                                  quit = 1;
                                  break;
                              }
              
              #endif
                          }while (status != STATUS_SUCCESS);
                          // check for user initiated exit task
                          if(quit)
                          {
                              break;
                          }
                    
                          i = plcTxFrmSwDesc.cpCount;
                          // test offset and desc len - only for first CPs
                          if((i==0 || i==1) && (pTestParams->frmType != 2))
                          //if(i==0 || i==1)
                          { 
                              if(pTestParams->altOffsetDescLenTest)
                              {
                                  curOffsetDW--;
                                  curDescLen+=4;    
                                  tmpOffsetDW =      curOffsetDW;  
                                  tmpDescLen  =      curDescLen;  
                                  if( curOffsetDW==0 )
                                  {
                                      curOffsetDW  = pTestParams->offsetDW; // 0
                                      curDescLen   = pTestParams->descLen;  //HYBRII_DEFAULT_SNID;
              //                        FM_Printf(FM_LINFO,"OffsetDW & DescLen resetting to %bu & %bu respectively\n", c
             -urOffsetDW, curDescLen);
                                  }
                              } //printf("curOffsetDW = %bu, tempDescLen=%bu\n", tmpOffsetDW, tmpDescLen);              
             -              
                          }
                          else if(pTestParams->frmType == 2)
                          {
                                tmpOffsetDW =      0;  
                                tmpDescLen  =      curDescLen;  
                          }
                          else
                          {
                              tmpOffsetDW = 0;
                              tmpDescLen  = HYBRII_CELLBUF_SIZE;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 17  

                          }
              
                          tmpOffsetByte = tmpOffsetDW << 2;
                          actualDescLen =  (plcTxFrmSwDesc.frmLen-tmpFrmLen)>tmpDescLen ? tmpDescLen : (plcTxFrmSwDesc.f
             -rmLen-tmpFrmLen);
                          remDescLen    =  actualDescLen;
              
                          if(( i==0 || i==1 ) && tmpOffsetDW != 0)
                          {
                            //  FM_Printf(FM_LINFO,"curFrmLen = %u, curOffsetDW = %bu, curDescLen=%bu, free CPCnt = %bu\
             -n", 
                            //                               plcTxFrmSwDesc.frmLen, tmpOffsetDW, actualDescLen, CHAL_Get
             -FreeCPCnt());
                          }
                          //FM_Printf(FM_LINFO,"curOffsetByte = %bu, curDescLen=%bu\n", tmpOffsetByte, actualDescLen);
                          
                          // Fill Buffer with pattern
              #ifdef MEM_PROTECTION
                    // Get local CP buffer
                    cellAddr = &cp_localBuf[0];
              #else
                          cellAddr = CHAL_GetAccessToCP(cp);
              #endif
                    memset(&cp_localBuf[0], 0, HYBRII_CELLBUF_SIZE);  // clear read buf for every new test
                       //   FM_Printf(FM_LINFO,"cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.hal
             -Stats.TxSeqNum);
                          //printf("cp = %bu, cellAddr=%08lX, seqNum=%bu\n",cp,(u32)cellAddr, gHpgpHalCB.halStats.TxSeqN
             -um);
                    
                          // Add Seq Num as first byte of first CP
                          if ( i==0 )
                          {
                              if (pTestParams->frmType != 2)
                              {
              #if  PLC_BCNDATA_FIXED_PATTERN
                              cellAddr[tmpOffsetByte] = 0xBB;
                              // Start frame data from seq num.
                              frmData   = (u8)(gHpgpHalCB.halStats.TxSeqNum+1);   
              
              #elif PLC_DATA_FIXED_PATTERN
              
                              cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
                              // Alternatig frame bytes
                              frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0xAA : 0x55 ;
              #endif        
                              tmpOffsetByte +=1;
                              remDescLen    -=1; 
                              }
                              else 
                              {                     
                                  //cellAddr[tmpOffsetByte] = (u8)((gHpgpHalCB.halStats.TxSeqNum + 1) & 0xFF);
                                  // Alternatig frame bytes
                                  frmData = ((gHpgpHalCB.halStats.TxSeqNum + 1) & 0x01) ?  0x00 : 0x00 ;
               
                                  //tmpOffsetByte +=1;
                                  //remDescLen    -=1; 
                              }
                          }
              
                          if (pTestParams->frmType == 2) // Sound packet 
                          {
                              for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 18  

                              {    
                                  cellAddr[j] = 0x0;
                              }
                          }
                          else
                          {
                              for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
                              {
                  #if  PLC_BCNDATA_FIXED_PATTERN
                                  cellAddr[j] = 0xBB;
                  #elif PLC_DATA_FIXED_PATTERN                    
                                  cellAddr[j] = frmData;
                                  frmData     = _cror_(frmData, 1);
                  #else
                                  cellAddr[j] = frmData++;
                  #endif
                              }
                          }
              #if 0       
                          // [YM] debug message
                    printf("CP len: %bu, offset=%bu\n", remDescLen, tmpOffsetByte);                         
                    
                          for( j=tmpOffsetByte ; j<tmpOffsetByte+remDescLen ; j++)
                          {
                              printf("0X%bx ", cellAddr[j]);
                      if ((j>0) && ((j % 20) == 0))
                        printf("\n");
                          } 
              #endif                              
                    //printf("\n");
                          plcTxFrmSwDesc.cpArr[i].offsetU32 = tmpOffsetDW;
                          plcTxFrmSwDesc.cpArr[i].len       = actualDescLen; 
                          tmpFrmLen                        += plcTxFrmSwDesc.cpArr[i].len; 
                          plcTxFrmSwDesc.cpArr[i].cp        = cp;
                          plcTxFrmSwDesc.cpCount++;
                          tmpPayloadLen += (plcTxFrmSwDesc.cpArr[i].len - tmpOffsetByte);
              
                          // Alternate Encryption Test Mode
                          if(pTestParams->secTestMode == ALT_UNENC_NEK)
                          {
                              plcTxFrmSwDesc.frmInfo.plc.eks = (plcTxFrmSwDesc.frmInfo.plc.eks  >= HPGP_MAX_NEKS) ? 0  :
             - (plcTxFrmSwDesc.frmInfo.plc.eks + 1);
                          }
                          else if(pTestParams->secTestMode == ALT_UNENC_NEK_PPEK)
                          {
                              plcTxFrmSwDesc.frmInfo.plc.eks  = gAltEksTstArr[eksArrIdx++];
                              plcTxFrmSwDesc.frmInfo.plc.dtei = gHpgpHalCB.remoteTei;
                          }
              
              #ifdef MEM_PROTECTION
                    // now copy the CP local buf to the actual CP memory
                    if (HHAL_CP_Put_Copy(cp, cellAddr, HYBRII_CELLBUF_SIZE) == STATUS_FAILURE)
                    {
                      printf("HHT_SimulateTx: Failed to put a copy of CP %bu. Continue with nex CP\n", cp);
                      continue;
                    }
              #endif
                      } 
                    
                  
              #ifdef Packet_grouping0
                      //[YM] Check multiple packet queueing is requested or not
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 19  

                      if (gHpgpHalCB.plcMultiPktTest > 1 )
                      {
                              cmd_num++;
              
                      //printf("1-0. cmd_num = %bu \n", cmd_num);
                              /*  Write PLC Command Queue Write Register to trigger HW Tx */
                              txCmdQueueWrtie.reg = 0;
                              txCmdQueueWrtie.s.txQ = pTestParams->plid;
                            txCmdQueueWrtie.s.txCap = pTestParams->plid;
                            txCmdQueueWrtie.s.txRobo = pTestParams->stdModeSel;
              #ifdef ETH_BRDG_DEBUG
                      if (myDebugFlag)
                      {
                        //printf("txCmdQueueWrtie.reg = %lx\n",txCmdQueueWrtie.reg);
                      //printf("txCmdQueueWrtie.s.txQ = %bu\n", txCmdQueueWrtie.s.txQ);
                      printf("txCmdQueueWrtie.s.txCap = %bu\n", txCmdQueueWrtie.s.txCap);
                      //printf("txCmdQueueWrtie.s.txRobo = %bu\n", txCmdQueueWrtie.s.txRobo);
                      }
              #endif  //ETH_BRDG_DEBUG
                      //WriteU32Reg(PLC_CMDQ_REG, txCmdQueueWrtie.reg);
                      //[YM] store command queue setting value to a software queue, will write all stored command queue sett
             -ing value to 
                      //command queue later
                      Sw_command_queue[cmd_num - 1] = txCmdQueueWrtie.reg;
                      if (cmd_num > (gHpgpHalCB.plcMultiPktTest - 1))
                        {
                                     u8 p;
                           
                           // Write all the store command settings in sw command queue [64] to HW command queue register
                           for (p = 0; p < gHpgpHalCB.plcMultiPktTest; p++)
                            {
                               WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
              #ifndef MPER               
                             printf("Write PLC_CMDQ_REQ = %u\n", Sw_command_queue[p]);
              #endif  //MPER
                            }
                           if (cmd_num > 0)
              #ifndef MPER              
                               printf("1. Write PLC_CMDQ_REG %bu times\n", cmd_num);
              #endif  //MPER
                           cmd_num = 0;
                           gHpgpHalCB.plcMultiPktTest = 0;
                        }
                      }
              #endif  //Packet_grouping0  
                      // check for user initiated exit task
                      if(status == STATUS_SUCCESS)
                      {
                                 u16 pkt_retry = 0;
                          do
                          {
                              // Transmit the frame;
                              //printf("(D)\n");
              #ifdef HPGP_HAL_TEST
                              status = HHAL_PlcTxQWrite(&plcTxFrmSwDesc);
              #else
                              status = HHAL_PlcTxQWrite(hal, &plcTxFrmSwDesc);
              #endif
                      if (status == STATUS_FAILURE)
                      {
                        pkt_retry++;
                        //printf("Write PLC Tx Q failed, %bu times, cp = %bu\n", pkt_retry, plcTxFrmSwDesc.cpCount);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 20  

                        // [YM] - retry the packet transmission until it failed too many times
              
                                  CHAL_DelayTicks(64);
                        if (pkt_retry > 2000)   //[YM] extended delay loop, high PER condition will make Tx stop too quick
                        {
              #ifndef MPER          
                                      printf("\nWrite PLC Tx Q failed, cp = %bu, Quit!!\n", plcTxFrmSwDesc.cpCount);
              #endif
                            quit = 1;
                            break;
                        }
                      }
                              // check for user initiated exit task from infinite loop
              #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')              
                              {
                                  // if TxQWrite failed, release CPs for current frame -- tbd
                                  quit = 1;
                                  break;
                              }
                          } while(status == STATUS_FAILURE);
                            pkt_retry = 0;
                      }
              
                   
                      if(status == STATUS_SUCCESS)
                      {
                          gHpgpHalCB.halStats.CurTxTestFrmCnt++;
                          gHpgpHalCB.halStats.TxSeqNum++;
              
                          // check for alternating plid
                          plcTxFrmSwDesc.frmInfo.plc.plid = pTestParams->altPlidTest ? altPlid.s.plid++ : pTestParams->p
             -lid;
              
                          // check for alternating frametype
                          if(pTestParams->altFrmTypeTest)
                          {
                              plcTxFrmSwDesc.frmType = (plcTxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MSDU) ? HPGP_HW_FRMTYP
             -E_MGMT : HPGP_HW_FRMTYPE_MSDU;
                          }
                          else
                          {
                              plcTxFrmSwDesc.frmType = frmType;
                          }
              
                          // check for alternating mcstMode
                          if(pTestParams->altMcstTest)
                          {
                              if(mcstMode == 2)
                              {
                                  mcstMode = 0;
                                  plcTxFrmSwDesc.frmInfo.plc.dtei           = gHpgpHalCB.remoteTei;         
                              }
                              else
                              {
                                  mcstMode++;
                                  plcTxFrmSwDesc.frmInfo.plc.dtei           = 0xFF;       
                              }
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 21  

                          }
              
                    if (!pTestParams->dbc)
                    {
                          // check for incremental length single robo
                          if(pTestParams->lenTestMode == INC_LEN_SINGLE_ROBO)
                          {
                              curFrmLen++;
                              if(curFrmLen > maxFrmLen)
                              {
                                  FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
                                  curFrmLen = minFrmLen;
                              }
                          }             
                          // check for incremental length all robo
                          else if(pTestParams->lenTestMode == INC_LEN_ALL_ROBO)
                          {
                              curFrmLen++;            
                              if(curFrmLen > stdRoboFrmLenMax && plcTxFrmSwDesc.frmInfo.plc.stdModeSel)
                              {
                                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 0;
                                  curFrmLen                 = HYBRII_MINIROBO_DATALEN_MAX+1;
                                  FM_Printf(FM_LINFO,"Switching to HS Mode; len = %u\n",curFrmLen);
                                  
                              }
                              // restart inc len test
                              if(curFrmLen > maxFrmLen)
                              {
                                  FM_Printf(FM_LINFO,"\nCur Frame Len = %u, Starting over from len %u\n",curFrmLen-1,min
             -FrmLen);
                                  curFrmLen                 = minFrmLen;
                                  plcTxFrmSwDesc.frmInfo.plc.stdModeSel = 1;                  
                              }
                          } 
                          // check for fixed length alternating robo
                          else if(pTestParams->lenTestMode == FIXED_LEN_ALT_ROBO)
                          {
                              curFrmLen  = gAltRoboLenArr[altRoboLenIdx.s.idx++];
                          }
                    }
                    else  //DBC Test
                    {
                        if (dbc_pktchange == 0)
                        dbc_pktchange = 1;
                      else if (dbc_pktchange == 1)
                        dbc_pktchange = 2;
                      else
                        dbc_pktchange = 0;
                    }
                      
                      }
                  
                      if((gHpgpHalCB.halStats.CurTxTestFrmCnt & (u32)(0xFF)) == 0)
                      {  
                          printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b
             -\b\b\b");
                          printf("Sent %ld, Received %ld HPGP frames.", gHpgpHalCB.halStats.CurTxTestFrmCnt, gHpgpHalCB.
             -halStats.TotalRxGoodFrmCnt - gHpgpHalCB.halStats.RxGoodBcnCnt);
                      }
              
                  
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 22  

                      if(!pTestParams->contMode)
                      {
                          pTestParams->numFrames--;
              //      printf(" Remaining Tx packet number = %ld\n",pTestParams->numFrames);
                          if(!pTestParams->numFrames)
                          {
                              quit = 1;
                          }
                      }
              
                  
                      if(!quit && pTestParams->delay != 0xFF)
                      {
                          u32 delay64ticks = pTestParams->delay;
                          if(delay64ticks == 0)
                          {
                              printf("press c to continue\n");
                              while(1)
                              {
              #ifdef HPGP_HAL_TEST
                                  u8 userInput = CHT_Poll();
              #else
                                  u8 userInput = poll_key();
              #endif
                                  if( userInput == 'c' || userInput == 'C')
                                  {
                                      // exit delay loop and resume transmission
                                      break;                      
                                  }
                                  else if( userInput == 'q' || userInput == 'Q')
                                  {
                                      // exit delay loop and quite transmission
                                      quit = 1;
                                      break;
                                  }
                              }
                          }
                          else
                          while(delay64ticks--)
                          {
                              CHAL_DelayTicks(64);
                              // check for user initiated exit task from infinite loop
                              
              #ifdef HPGP_HAL_TEST
                              c = CHT_Poll();
              #else
                              c = poll_key();
              #endif
                              if( c == 'q')              
                              {
                                  quit = 1;
                                  break;
                              }
                          }  
                      }
                  
                      if(quit )//|| CHAL_GetFreeCPCnt() < 100 || HHAL_GetPlcTxQFreeDescCnt(plcTxFrmSwDesc.plid) < 32 )
                      {
              //#ifdef Packet_grouping0
                      //[YM] write sw command queue setting values to HW command queue
                      //printf("2. Write PLC_CMDQ_REG %bu times\n", cmd_num);
                  while (cmd_num > 0)
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 23  

                  {
                                     u8 p;
                           
                           //printf("(F)\n");
                           // Write all the store command settings in sw command queue [64] to HW command queue register
                           for (p = 0; p < cmd_num; p++)
                               WriteU32Reg(PLC_CMDQ_REG, Sw_command_queue[p]);
                           cmd_num--;
                  }
              //#endif
              
              
                         // printf("Sent %ld HPGP frames.\n", gHpgpHalCB.halStats.CurTxTestFrmCnt);
                         // printf("Quit Tx: Free CP Cnt = %bu, curFrmLen = %u\n", CHAL_GetFreeCPCnt(), curFrmLen);
                          break;
                      }       
                  } // while(1)   
              }
              
              #endif
1314          /*u32 TX_RXLatency_TCC[8] = {
1315                             
1316                              0x321e0417,  //TCC =1
1317                             // 0x336F0417,
1318                              0x336F04E5, //this is according to new phy image gpphy_3S150_08032013- tx latency incr
             -eased to 50microsec from 41.8 microsec
1319                              0x34ca0417,
1320                              0x361F0417,
1321                              0x37750417,
1322                              0x38c20417,
1323                              0x3a180417,
1324                              0x3b740417,  //TCC= 8
1325          
1326          };*/
1327          
1328          
1329          
1330          
1331          #ifdef POWER_SAVE
              extern u16 psNoTxFrm;
              
              void HHAL_SetTxRxEn(u8 mode)
              {
                  uPlcStatusReg         plcStatus;
              
                  if (mode == TxRxEnState.state)
                  { IRQ_DISABLE_INTERRUPT();  // this function can also be called from timer interrupt
                      plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
                    
                      // mode = 0: enable, 1: disable
                  if (mode == 1)
                  {
                    // disable TxRxEn
                        plcStatus.s.nTxEn  = 1;
                        plcStatus.s.nRxEn = 1;
                        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Disabled\n");
                        if (gHpgpHalCB.devMode == DEV_MODE_STA)
                    {
                            // STA: we just disabled TxRxEn, set a timer to wake
                            // up and enable them again so we can receive
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 24  

                            // next beacon. Only do this for STA, CCO uses the BCN Tx
                      // interrupt and BCN Sent interrupt to wake up
                            TxRxEnState.StarttimerIntCnt = gHalCB.timerIntCnt;
                            TxRxEnState.StartRxGoodBcnCnt = gHpgpHalCB.halStats.RxGoodBcnCnt;
                        }
                  }
                  else
                  {
                    // enable TxRxEn
                      plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                        plcStatus.s.nTxEn  = 0;
                    //plcStatus.s.randomBackoff = 1;  //added by YM 
                    // below is sequence to re-enable RxEn
                      plcStatus.s.rxSoftReset = 1;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                      CHAL_DelayTicks(10);
                      plcStatus.s.rxSoftReset = 0;
                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
                    if (ethDebugON)
                          printf("TxRxEn Enabled\n");
                  }
                      TxRxEnState.state = !mode;    // State =  0: Disabled, 1: Enabled
                      IRQ_ENABLE_INTERRUPT();
                }
              }
              
              // HHAL_DisTxRxEn is called by the HW timer interrupt every 4 ms
              void HHAL_DisTxRxEn()
              {
                 if (!plc_powersave || TxRxEnState.state ||
                    (gHpgpHalCB.devMode == DEV_MODE_CCO))
                  // this timer ISR is only used in STA
                     return;
                  
                  if(gHalCB.timerIntCnt >= (TxRxEnState.StarttimerIntCnt + 18))
                  {
                      // STA should receive a central beacon every 33 ms 
                      // (50 Mhz) or 44 ms (60 Mhz). gHalCB.timerIntCnt is
                      // incremented every timer interrupt cycle, ie. 4ms.
                      // Enable TxRxEn so it can receive the next beacon 
                  if (ethDebugON)
                  {
                     printf("Timer INT:ON TxRxEn\n");
                     printf("Timer INT:gHalCB.timerIntCnt=%lu,TxRxEnState.StarttimerIntCnt=%lu\n", gHalCB.timerIntCnt, TxR
             -xEnState.StarttimerIntCnt);
                  } 
                      HHAL_SetTxRxEn(0);
                  }
              }
              #endif     //POWER_SAVE
1404          
1405          // this is specific to Hybrii B
1406          void set_plc_paramter(u8 sel, u32 u32Val)
1407          {
1408   1          union {
1409   1              u8  chval[4];
1410   1              u32 reg;
1411   1          }  val;
1412   1      
1413   1          val.reg = 0;
1414   1          val.chval[0] = sel;
1415   1      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 25  

1416   1          WriteU32Reg(PLC_PLCPARASEL_REG, val.reg);
1417   1          WriteU32Reg(PLC_PARA_DATAWR_REG, ctorl(u32Val));
1418   1      }
1419          
1420          
1421          /*******************************************************************
1422          * NAME :            HHAL_mpiRxReset
1423          *
1424          * DESCRIPTION :     Reset mpi Rx MAC block
1425          *
1426          * INPUTS :
1427          *       PARAMETERS:
1428          *      
1429          *
1430          * OUTPUTS :
1431          *       None
1432          *
1433          */
1434          /*  Hybrii A only
1435          void HHAL_mpiRxReset(void)
1436          {
1437              uPlcResetReg plcReset;
1438          
1439              plcReset.reg = 0;
1440              plcReset.s.mpiRxReset = 1;
1441              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1442              CHAL_DelayTicks(2);
1443              plcReset.reg = 0;
1444              WriteU32Reg(PLC_RESET_REG, plcReset.reg);
1445          }*/
1446          
1447          
1448          /*******************************************************************
1449          * NAME :            HHAL_PhyPgmRoboMd
1450          *
1451          * DESCRIPTION :     Programs Rx to a particular Robo Md.
1452          *
1453          * INPUTS :
1454          *       PARAMETERS:
1455          *           eHpgpRpoboMod roboMd
1456          *
1457          * OUTPUTS :
1458          *       None
1459          *
1460          */
1461          void HHAL_PhyPgmRoboMd(eRegFlag enbRoboMdPgm, ePlcPhyRxRoboMod roboMd, ePlcNumPBs numPBs)
1462          {
1463   1          uPhyRxEnbRoboReg  phyRxEnbRobo;
1464   1          uPhyRxRoboMdReg   phyRxRoboMd;
1465   1          uPhyNumPBReg      phyNumPBs;
1466   1      
1467   1          // Write Rx Robo Mode override bit.
1468   1          phyRxEnbRobo.reg         = ReadU8Reg(PLC_RXROBOENB_REG);
1469   1          phyRxEnbRobo.s.enbRobo   = enbRoboMdPgm;
1470   1          WriteU8Reg(PLC_RXROBOENB_REG, phyRxEnbRobo.reg);
1471   1      
1472   1          // Write Rx Robo Mode.
1473   1          if(enbRoboMdPgm)
1474   1          {
1475   2              phyRxRoboMd.reg          = ReadU8Reg(PLC_RXROBOMD_REG);
1476   2              phyRxRoboMd.s.roboMd     = roboMd;
1477   2              WriteU8Reg(PLC_RXROBOMD_REG, phyRxRoboMd.reg);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 26  

1478   2      
1479   2              // Write Number of PBs
1480   2              if( roboMd == PLCPHY_ROBOMD_HS )
1481   2              {
1482   3                  phyNumPBs.reg          = ReadU8Reg(PLC_RXNUMPB_REG);
1483   3                  phyNumPBs.s.enbNumPBs  = 1; 
1484   3                  phyNumPBs.s.numPBs     = numPBs;
1485   3                  WriteU8Reg(PLC_RXNUMPB_REG, phyNumPBs.reg);
1486   3              }
1487   2          }        
1488   1      }
1489          
1490          /*******************************************************************
1491          * NAME :            HHAL_SetACLine50HzFlag
1492          *
1493          * DESCRIPTION :     Sets or Clears CpuSwStatus.acLine50Hz flag.
1494          *
1495          * INPUTS :
1496          *       PARAMETERS:
1497          *           eRegFlag acLin50Hz
1498          *
1499          * OUTPUTS :
1500          *       None
1501          *
1502          */
1503          /*void HHAL_SetACLine50HzFlag(eRegFlag acLin50Hz)
1504          {
1505              uPlcLineControlReg plcLineCtrl;
1506          
1507              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1508              plcLineCtrl.s.acCycle50Hz = acLin50Hz;
1509              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
1510          } */
1511          
1512          /*******************************************************************
1513          * NAME :            HHAL_SetPlcDevMode()
1514          *
1515          * DESCRIPTION :     Sets PLC Device Mode.
1516          *
1517          * INPUTS :
1518          *       PARAMETERS:
1519          *           eRegFlag regFlag
1520          *
1521          * OUTPUTS :
1522          *       None
1523          *
1524          */
1525          void HHAL_SetPlcDevMode(ePlcDevMode plcDevMode)
1526          {
1527   1          uPlcDevCtrlReg PlcDevCtrl;
1528   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1529   1          PlcDevCtrl.s.plcDevMode = plcDevMode;
1530   1          WriteU32Reg(PLC_DEVCTRL_REG,PlcDevCtrl.reg);
1531   1      }
1532          
1533          
1534          #ifdef FREQ_DETECT
1535          void FREQDET_FreqSetting(u8 frequency)
1536          {
1537   1      
1538   1        
1539   1       
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 27  

1540   1        FM_Printf(FM_MINFO,"freq %bu \n", frequency );
1541   1                     
1542   1          if(frequency == FREQUENCY_50HZ)
1543   1          {                
1544   2              gHpgpHalCB.lineFreq = FREQUENCY_50HZ;
1545   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1546   2              {
1547   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_50HZ;
1548   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_50HZ;                    
1549   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1550   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
1551   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1))); // HW multiples it by 2
1552   3              }
1553   2              else
1554   2              {
1555   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_50HZ; 
1556   3                  //WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1557   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1558   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1))); // HW multiples it by 2
1559   3                  PLC_MIN_AC_BPLEN  =           MIN_50HZ_BPLEN;
1560   3                  PLC_MAX_AC_BPLEN  =           MAX_50HZ_BPLEN; 
1561   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_50Hz;
1562   3              }
1563   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_SET);
1564   2              
1565   2              //WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1566   2          }
1567   1          else // 60 hz
1568   1          {                
1569   2              gHpgpHalCB.lineFreq = FREQUENCY_60HZ;
1570   2              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1571   2              {
1572   3                PLC_DC_LINE_CYCLE_FREQENCY = DC_60HZ;   
1573   3                  PLC_DC_BP_LEN = PLC_DC_BP_LEN_60HZ;                    
1574   3                  WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
1575   3                  gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;                    
1576   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1))); // HW multiples it by 2
1577   3              }
1578   2              else
1579   2              {
1580   3                  PLC_AC_BP_LEN = PLC_AC_BP_LEN_60HZ; 
1581   3      //            WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
1582   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
1583   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1))); // HW multiples it by 2
1584   3                  PLC_MIN_AC_BPLEN  =           0xCB300;
1585   3                  PLC_MAX_AC_BPLEN  =           0xCBA00; 
1586   3                  AC_MIN_THRESHOLD = AC_MIN_THRESHOLD_60Hz;//this is done just to avoid noise or spike while det
             -ecting zero cross
1587   3              }
1588   2      //        HHAL_SetACLine50HzFlag(REG_FLAG_CLR);                
1589   2          }
1590   1      /*#ifndef HPGP_HAL_TEST
1591   1          CTRLL_SendFreqDetectedEvent();
1592   1      #endif*/
1593   1      }
1594          
1595          #endif
1596          /*******************************************************************
1597          * NAME :            HHAL_GetPlcDevMode
1598          *
1599          * DESCRIPTION :     Returns PLC Device Mode.
1600          *
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 28  

1601          * INPUTS :
1602          *       None
1603          *
1604          * OUTPUTS :
1605          *       None
1606          *
1607          */
1608          ePlcDevMode HHAL_GetPlcDevMode()
1609          {
1610   1          uPlcDevCtrlReg PlcDevCtrl;
1611   1      
1612   1          PlcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
1613   1      
1614   1          return((ePlcDevMode)PlcDevCtrl.s.plcDevMode);
1615   1      }
1616          
1617          
1618          /*******************************************************************
1619          * NAME :            HHAL_SetSWStatReqScanFlag
1620          *
1621          * DESCRIPTION :     Sets or clears PLC Scan Mode.
1622          *
1623          * INPUTS :
1624          *       PARAMETERS:
1625          *           eRegFlag scanEnb
1626          *
1627          * OUTPUTS :
1628          *       None
1629          *
1630          */
1631          void HHAL_SetSWStatReqScanFlag(eRegFlag scanEnb)
1632          {
1633   1          uPlcLineControlReg plcLineCtrl;
1634   1          uPlcDevCtrlReg  plcDevCtrl;
1635   1      
1636   1          plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
1637   1          plcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1638   1          plcLineCtrl.s.reqScanning = scanEnb;
1639   1          //gHpgpHalCB.scanEnb    = scanEnb;   
1640   1          if(scanEnb && !gHpgpHalCB.scanEnb)
1641   1          {
1642   2              plcDevCtrl.s.snidValid    = 1;  // ask TRI
1643   2              gHpgpHalCB.syncComplete   = 0;
1644   2              gHpgpHalCB.halStats.RxGoodBcnCnt   = 0;
1645   2              gHpgpHalCB.halStats.syncTestValIdx = 0;
1646   2              //gHpgpHalCB.nwSelected     = 0;
1647   2      #ifndef RELEASE
1648   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Enable\n");
1649   2      #endif
1650   2      
1651   2          }
1652   1          if(!scanEnb)
1653   1          {
1654   2      #ifndef RELEASE
1655   2              FM_Printf(FM_MINFO, "SetSWStatReqScanFlag:Scan Disable\n");
1656   2      #endif
1657   2      
1658   2          }
1659   1          gHpgpHalCB.scanEnb    = scanEnb;
1660   1      #ifdef QCA  
                  WriteU32Reg(PLC_LINECTRL_REG,plcLineCtrl.reg);
                  WriteU32Reg(PLC_DEVCTRL_REG,plcDevCtrl.reg);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 29  

              #endif
1664   1        
1665   1      }
1666          
1667          
1668          /*******************************************************************
1669          * NAME :            HHAL_GetTei
1670          *
1671          * DESCRIPTION :     Sets local TEI.
1672          *
1673          * INPUTS :
1674          *       PARAMETERS:
1675          *           None
1676          *
1677          * OUTPUTS :
1678          *       u8 tei
1679          *
1680          */
1681          u8 HHAL_GetTei()
1682          {
1683   1          uPlcDevCtrlReg PlcDevCtrl;
1684   1          u8             stei;
1685   1          
1686   1          PlcDevCtrl.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1687   1          stei = PlcDevCtrl.s.stei;
1688   1      
1689   1          return stei;         
1690   1      }
1691          
1692          /*******************************************************************
1693          * NAME :            HHAL_SetTei
1694          *
1695          * DESCRIPTION :     Sets local TEI.
1696          *
1697          * INPUTS :
1698          *       PARAMETERS:
1699          *           u8 tei
1700          *
1701          * OUTPUTS :
1702          *       None
1703          *
1704          */
1705          void HHAL_SetTei(u8 stei)
1706          {
1707   1          uPlcDevCtrlReg PlcDevCtrlReg;
1708   1      #ifdef HPGP_HAL_TEST
                  gHpgpHalCB.selfTei  = stei;
              #else
1711   1          gHpgpHalCB.tei  = stei;
1712   1      #endif   //HPGP_HAL_TEST
1713   1          PlcDevCtrlReg.reg   = ReadU32Reg(PLC_DEVCTRL_REG);
1714   1          PlcDevCtrlReg.s.stei = stei;
1715   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1716   1      }
1717          
1718          /*******************************************************************
1719          * NAME :            HHAL_GetSnid
1720          *
1721          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1722          *
1723          * INPUTS :
1724          *       PARAMETERS:
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 30  

1725          *           eRegFlag regFlag
1726          *
1727          * OUTPUTS :
1728          *       None
1729          *
1730          */
1731          u8 HHAL_GetSnid()
1732          {
1733   1          uPlcDevCtrlReg PlcDevCtrlReg;
1734   1          u8             snid;
1735   1      
1736   1          PlcDevCtrlReg.reg       = ReadU32Reg(PLC_DEVCTRL_REG);
1737   1          snid                 = PlcDevCtrlReg.s.snid;
1738   1      
1739   1          return snid;
1740   1      }
1741          
1742          /*******************************************************************
1743          * NAME :            HHAL_SetSnid
1744          *
1745          * DESCRIPTION :     Sets SNID of the network local device has joined/created.
1746          *
1747          * INPUTS :
1748          *       PARAMETERS:
1749          *           u8 snid
1750          *
1751          * OUTPUTS :
1752          *       None
1753          *
1754          */
1755          void HHAL_SetSnid(u8 snid)
1756          {
1757   1      #ifdef MCCO
1758   1        if (gHpgpHalCB.devMode == DEV_MODE_PCCO)
1759   1        {
1760   2          HHAL_SetPassSnid(snid);
1761   2        }
1762   1        else
1763   1      #endif    
1764   1        {
1765   2      
1766   2        uPlcDevCtrlReg PlcDevCtrlReg;
1767   2      
1768   2          gHpgpHalCB.snid      = snid;
1769   2          PlcDevCtrlReg.reg    = ReadU32Reg(PLC_DEVCTRL_REG);
1770   2          PlcDevCtrlReg.s.snid = snid;
1771   2          if(gHpgpHalCB.devMode == DEV_MODE_CCO || !gHpgpHalCB.scanEnb)
1772   2          {
1773   3              PlcDevCtrlReg.s.snidValid = 1;
1774   3              FM_Printf(FM_MINFO, "SetSnid:%bu\n", snid);
1775   3      
1776   3        }
1777   2        else
1778   2        {        
1779   3              gHpgpHalCB.nwSelected  = 1;
1780   3              PlcDevCtrlReg.s.snidValid = 1;
1781   3        }
1782   2        
1783   2        gHpgpHalCB.nwSelectedSnid = snid;
1784   2          
1785   2        WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1786   2      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 31  

1787   2        }
1788   1      
1789   1      }
1790          
1791          #ifdef MCCO
1792          
1793          void HHAL_ClearPassSnid()
1794          {
1795   1        uPlcDevCtrlReg PlcDevCtrlReg;
1796   1      
1797   1        PlcDevCtrlReg.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1798   1        PlcDevCtrlReg.s.passCordValid = 0;
1799   1        WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1800   1      }
1801          
1802          
1803          void HHAL_DisablePassSnid()
1804          {
1805   1        uPlcDevCtrlReg PlcDevCtrlReg;
1806   1      
1807   1        PlcDevCtrlReg.reg  = ReadU32Reg(PLC_DEVCTRL_REG);
1808   1        
1809   1      
1810   1        PlcDevCtrlReg.s.passCordValid = 0;
1811   1        
1812   1        WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1813   1      
1814   1      }
1815          
1816          void HHAL_SetPassSnid(u8 snid)
1817          {
1818   1          uPlcDevCtrlReg PlcDevCtrlReg;
1819   1      
1820   1          gHpgpHalCB.passSnid  = snid;  
1821   1          gHpgpHalCB.snid      = snid;  //TODO RAJAN. do we need to set snid
1822   1        
1823   1          PlcDevCtrlReg.reg    = ReadU32Reg(PLC_DEVCTRL_REG);
1824   1          PlcDevCtrlReg.s.passSNID = snid;
1825   1      
1826   1        gHpgpHalCB.nwSelected  = 1;
1827   1      
1828   1        gHpgpHalCB.nwSelectedSnid = snid;
1829   1          
1830   1        PlcDevCtrlReg.s.passCordValid = 1;
1831   1        PlcDevCtrlReg.s.snidValid = 1;
1832   1         
1833   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1834   1      }
1835          
1836          
1837          void HHAL_SetNWSnid(u8 snid)
1838          {
1839   1          uPlcDevCtrlReg PlcDevCtrlReg;
1840   1        
1841   1          PlcDevCtrlReg.reg    = ReadU32Reg(PLC_DEVCTRL_REG);
1842   1          PlcDevCtrlReg.s.snid = snid;
1843   1      
1844   1          PlcDevCtrlReg.s.snidValid = 1;
1845   1        
1846   1          WriteU32Reg(PLC_DEVCTRL_REG, PlcDevCtrlReg.reg);
1847   1      }
1848          
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 32  

1849          #endif
1850          
1851          void HHAL_DisableLMBcnBuf(u8 bcnType)
1852          {
1853   1         gHpgpHalCB.lmBcn.txBitmap &= ~((1 << bcnType));
1854   1      }
1855          
1856          void HHAL_SetLMBcnBuf(u8 *buff, u8 bcnType, u8 bpstoOffset)
1857          {
1858   1          if (bcnType == BEACON_TYPE_CENTRAL)
1859   1          {
1860   2              memcpy(&gHpgpHalCB.lmBcn.cBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.cBcn.bcnBuff));
1861   2              gHpgpHalCB.lmBcn.cBcn.bpstoOffset = bpstoOffset;
1862   2      
1863   2      
1864   2          }
1865   1      #if 0 
                  else
                  if (bcnType == BEACON_TYPE_DISCOVER)
                  {
                      memcpy(&gHpgpHalCB.lmBcn.dBcn.bcnBuff, buff, sizeof(gHpgpHalCB.lmBcn.dBcn.bcnBuff));
                      gHpgpHalCB.lmBcn.dBcn.bpstoOffset = bpstoOffset;
                  }
              #endif
1873   1      
1874   1          gHpgpHalCB.lmBcn.txBitmap |= (1 << bcnType);
1875   1      }   
1876          
1877          /*******************************************************************
1878          * NAME :            HHAL_SetCsmaRegions
1879          *
1880          * DESCRIPTION :     Sets CSMA Regions - takes effect only next BPST.
1881          *                   Startime,EndTime,Duration in units of ATU = 10.24uS
1882          *                   Starttime is number of ATUs from EndTime of prev region.
1883          *
1884          * INPUTS :
1885          *       PARAMETERS:
1886          *           eRegFlag regFlag
1887          *
1888          * OUTPUTS :
1889          *       None
1890          *
1891          */
1892          void HHAL_SetCsmaRegions(sCsmaRegion* regionArr, u8 regionCnt)
1893          {
1894   1          uCSMARegionReg  csmaRegion;
1895   1          u8 i;
1896   1          u8 csmaRegionCnt;
1897   1      
1898   1          csmaRegionCnt = HYBRII_MAXSMAREGION_CNT < regionCnt ? HYBRII_MAXSMAREGION_CNT: regionCnt;
1899   1          //for (j=0; j<csmaRegionCnt; j++) {
1900   1         //     FM_Printf(FM_USER, "region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n", 
1901   1          //        j, regionArr[j].startTime, regionArr[j].endTime, regionArr[j].rxOnly);
1902   1         // }
1903   1          for( i=0 ; i<csmaRegionCnt ; i++ )
1904   1          {
1905   2              csmaRegion.s.csma_start_time_lo = 0;//regionArr[i].startTime & CSMAREG_STARTTMLO_MASK;
1906   2              csmaRegion.s.csma_start_time_hi = 0;//(regionArr[i].startTime & CSMAREG_STARTTMHI_MASK) >> CSMAREG
             -_STARTTMHI_POS ;
1907   2              csmaRegion.s.csma_rxOnly      = regionArr[i].rxOnly;
1908   2              csmaRegion.s.csma_endtime_lo  = regionArr[i].endTime & CSMAREG_DURATIONLO_MASK;
1909   2              csmaRegion.s.csma_endtime_hi  = (regionArr[i].endTime & CSMAREG_DURATIONHI_MASK) >> CSMAREG_DURATI
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 33  

             -ONHI_POS ;
1910   2              csmaRegion.s.csma_hybrid    = regionArr[i].hybridMd;
1911   2              switch(i)
1912   2              {
1913   3                  case 0:
1914   3                      WriteU32Reg(PLC_CSMAREGION0_REG, csmaRegion.reg);
1915   3                      break;
1916   3                  case 1:
1917   3                      WriteU32Reg(PLC_CSMAREGION1_REG , csmaRegion.reg);
1918   3                      break;
1919   3                  case 2:
1920   3                      WriteU32Reg(PLC_CSMAREGION2_REG, csmaRegion.reg);
1921   3                      break;
1922   3                  case 3:
1923   3                      WriteU32Reg(PLC_CSMAREGION3_REG, csmaRegion.reg);
1924   3                      break;
1925   3                  case 4:
1926   3                      WriteU32Reg(PLC_CSMAREGION4_REG, csmaRegion.reg);
1927   3                      break;
1928   3                  case 5:
1929   3                      WriteU32Reg(PLC_CSMAREGION5_REG, csmaRegion.reg);
1930   3                      break;
1931   3                  default:
1932   3                      {
1933   4      
1934   4                      }
1935   3      
1936   3              }
1937   2          }
1938   1      }
1939          
1940          
1941          /*******************************************************************
1942          * NAME :            HHAL_SetDiagMode
1943          *
1944          * DESCRIPTION :     Sets or clears PLC Tx/Rx Diagnostic mode operation.
1945          *
1946          * INPUTS :
1947          *       PARAMETERS:
1948          *           eRegFlag regFlag
1949          *
1950          * OUTPUTS :
1951          *       None
1952          *
1953          */
1954          void HHAL_SetDiagMode(eRegFlag regFlag)
1955          {
1956   1          uPlcStatusReg plcStatus;
1957   1      
1958   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1959   1          if(regFlag)
1960   1          {
1961   2              gHpgpHalCB.diagModeEnb = 1;
1962   2          }
1963   1          else
1964   1          {
1965   2              gHpgpHalCB.diagModeEnb = 0;
1966   2          }
1967   1          plcStatus.s.contTxDiag = regFlag;
1968   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1969   1      }
1970          
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 34  

1971          /*******************************************************************
1972          * NAME :            HHAL_SetDiagModeNoSack
1973          *
1974          * DESCRIPTION :     Enables or Disables ACK during Diagnostic mode operation.
1975          *
1976          * INPUTS :
1977          *       PARAMETERS:
1978          *           eRegFlag regFlag
1979          *
1980          * OUTPUTS :
1981          *       None
1982          *
1983          */
1984          void HHAL_SetDiagModeNoSack(eRegFlag regFlag)
1985          {
1986   1          uPlcStatusReg plcStatus;
1987   1      
1988   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1989   1          plcStatus.s.noSackDiag = regFlag;
1990   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1991   1      }
1992          
1993          
1994          /*******************************************************************
1995          * NAME :            HHAL_GetPlcTxQFreeDescCnt
1996          *
1997          * DESCRIPTION :     Returns no: of dwords available in a given PLC CAP Tx Q.
1998          *
1999          * INPUTS :
2000          *       PARAMETERS:
2001          *           eRegFlag regFlag
2002          *
2003          * OUTPUTS :
2004          *       None
2005          *
2006          */
2007          u8 HHAL_GetPlcTxQFreeDescCnt(eHpgpPlidValue plid)
2008          {
2009   1          uCapTxQStatusReg capTxQStat;
2010   1          u8 freeDescCnt;
2011   1          u8* descCntArr;
2012   1      
2013   1          capTxQStat.reg = ReadU32Reg(PLC_QDSTATUS_REG);
2014   1      
2015   1          descCntArr = (u8*)&capTxQStat.reg;
2016   1          freeDescCnt = PLC_TXQ_DEPTH - descCntArr[plid];
2017   1          //printf("PLCTxQStatusReg = 0x%08lX, PLCTxQ[%bu].freeDescCnt = %bu\n", SwapU32(capTxQStat.reg),plid, f
             -reeDescCnt);
2018   1          return  freeDescCnt;
2019   1      }
2020          
2021          
2022          // txBcn starts with 16 bytes avFC & has to be zero padded
2023          // bcnLen is always 136
2024          // Always give a non-zero valid bpstoValueOffset: minimum is 16 byte AVFC + 12 byte BcnHdr + 1 byte NBE + 
             -2 bytes BEHDR,BELEN of BPSTO BENTRY
2025          //                                                            = 33 (ie., 34thth byte)
2026          eStatus HHAL_AddNEK(u8 eks, u8 nek[PLC_AES_KEYLEN] )
2027          {
2028   1          uAesLutAddrReg      aesLutAddr;
2029   1          uAesLutDataReg      aesLutData;
2030   1          uAesKeyLutAddrReg   aesKeyLutAddr;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 35  

2031   1          uAesKeyLutDataReg   aesKeyLutData;
2032   1          uAesCpuCmdStatReg   aesCpuCmd;
2033   1      
2034   1          u8                  i,j;
2035   1          u8                  arrIdx;
2036   1      
2037   1          arrIdx          = 0;
2038   1      
2039   1        FM_HexDump(FM_LINK,"NEK", nek,PLC_AES_KEYLEN);
2040   1          // Wait for Cpu Aes Lut access grant.
2041   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2042   1          aesCpuCmd.s.cpuTblReq = 1;
2043   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2044   1      /*
2045   1          CHAL_DelayTicks(100);
2046   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2047   1          if(!aesCpuCmd.s.cpuTblGnt)
2048   1          {
2049   1              printf("Add NEK failed\n");  //[YM] Add debug message of set NEK failure
2050   1              return STATUS_FAILURE;
2051   1          }
2052   1      */
2053   1          // Write Key to the Key LUT.
2054   1          for(i=0; i<4; i++)
2055   1          {
2056   2              aesKeyLutAddr.reg     = 0;
2057   2              aesKeyLutAddr.sNek.isNek = 1;
2058   2              aesKeyLutAddr.sNek.idx   = i;
2059   2              aesKeyLutAddr.sNek.eks   = (eks & 0x7);
2060   2              WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
2061   2             // FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.reg), (PL
             -C_AESKEYLUTADDR_REG));
2062   2              for(j=0 ; j<4 ; j++)
2063   2              {
2064   3                  aesKeyLutData.s.key[j] = nek[arrIdx++];       
2065   3              }
2066   2              WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
2067   2           //   FM_Printf(FM_LINFO,"Wrote key dw        0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.reg), (PL
             -C_AESKEYLUTDATA_REG));
2068   2          }
2069   1      
2070   1          // Write Aes LUT Addr corres. to NEK.
2071   1          aesLutAddr.reg        = 0;
2072   1          aesLutAddr.sNek.eks   = eks;
2073   1          aesLutAddr.sNek.isNek = 1;
2074   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2075   1      #ifndef RELEASE
2076   1          FM_Printf(FM_LINFO,"Wrote AesLutAddr dw 0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (PLC_AESLUTA
             -DDR_REG));
2077   1      #endif
2078   1      
2079   1          // Set the NEK as valid.
2080   1          aesLutData.reg        = 0;
2081   1          aesLutData.sNek.valid = 0xFF;
2082   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2083   1      #ifndef RELEASE
2084   1          FM_Printf(FM_LINFO,"Wrote keyAddr dw    0x%08lX to reg#0x%08lX\n\n", rtocl(aesLutData.reg), (PLC_AESLU
             -TDATA_REG));
2085   1      #endif
2086   1      
2087   1          // Release CPU Lock on AES LUT
2088   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 36  

2089   1          aesCpuCmd.s.cpuTblGnt = 0;
2090   1          aesCpuCmd.s.cpuTblReq = 0;
2091   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
2092   1      
2093   1          return STATUS_SUCCESS;
2094   1      }
2095           
2096          eStatus HHAL_RemoveNEK(u8 eks)
2097          {
2098   1      
2099   1          uAesLutAddrReg      aesLutAddr;
2100   1          uAesLutDataReg      aesLutData;
2101   1          uAesCpuCmdStatReg   aesCpuCmd;
2102   1          eStatus             status;
2103   1      
2104   1          // Wait for Cpu Aes Lut access grant.
2105   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2106   1          aesCpuCmd.s.cpuTblReq = 1;
2107   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2108   1      /*
2109   1          CHAL_DelayTicks(100);
2110   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2111   1          if(!aesCpuCmd.s.cpuTblGnt || eks > 7)
2112   1          {
2113   1              return STATUS_FAILURE;
2114   1          }
2115   1      */
2116   1          // Write Aes LUT Addr corres. to NEK.
2117   1          aesLutAddr.reg     = 0;
2118   1          aesLutAddr.sNek.eks   = eks;
2119   1          aesLutAddr.sNek.isNek = 1;
2120   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2121   1      
2122   1          // Set the NEK as invalid.
2123   1          aesLutData.reg        = 0;
2124   1          aesLutData.sNek.valid = 0x0;
2125   1          WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg); 
2126   1      
2127   1          // Release CPU Lock on AES LUT
2128   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2129   1          aesCpuCmd.s.cpuTblGnt = 0;
2130   1          aesCpuCmd.s.cpuTblReq = 0;
2131   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2132   1      
2133   1          return status;
2134   1      }
2135           
2136          eStatus HHAL_AddPPEK(u8 eks, u8 ppek[PLC_AES_KEYLEN], u8 tei)
2137          {
2138   1          uAesLutAddrReg      aesLutAddr;
2139   1          uAesLutDataReg      aesLutData;
2140   1          uAesKeyLutAddrReg   aesKeyLutAddr;
2141   1          uAesKeyLutDataReg   aesKeyLutData;
2142   1          uAesCpuCmdStatReg   aesCpuCmd;
2143   1          eStatus             status;
2144   1          u8                  i,j;
2145   1          u8                  arrIdx;
2146   1          u8                  keyNum;
2147   1          u8                  region;
2148   1      
2149   1          arrIdx          = 0;
2150   1      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 37  

2151   1          status  = STATUS_SUCCESS;
2152   1          // Wait for Cpu Aes Lut access grant.
2153   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2154   1          aesCpuCmd.s.cpuTblReq = 1;
2155   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2156   1      /*
2157   1          CHAL_DelayTicks(100);
2158   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2159   1          if(!aesCpuCmd.s.cpuTblGnt)
2160   1          {
2161   1              return STATUS_FAILURE;
2162   1          }
2163   1      */
2164   1          if(eks != 8 && eks != 9 )  // EKS = 0b1000 or 0b1001
2165   1          {
2166   2              status = STATUS_FAILURE;
2167   2          }
2168   1          else
2169   1          {
2170   2               region                  = eks & 0x01;
2171   2      
2172   2              // Write AesLutAddr corres to the tei.
2173   2              aesLutAddr.reg          = 0;
2174   2              aesLutAddr.sPpek.tei    = tei;
2175   2              aesLutAddr.sPpek.isNek  = 0;
2176   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2177   2      #ifndef RELEASE
2178   2              FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to   reg#0x%08lX\n", rtocl(aesLutAddr.reg), (P
             -LC_AESLUTADDR_REG));
2179   2      #endif
2180   2              // Read back AesLutData corres to the tei.
2181   2              aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2182   2      #ifndef RELEASE
2183   2              FM_Printf(FM_MINFO, "Readback AesLutData dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (P
             -LC_AESLUTDATA_REG));
2184   2      #endif
2185   2              if(aesLutData.sPpek.valid)
2186   2              {
2187   3                   // Overwrite the current Key. So retrive Index of current key.
2188   3                   keyNum = aesLutData.sPpek.keyNum;
2189   3              }
2190   2              else
2191   2              {
2192   3                  // Find an available Key Index to add the new PPEK.
2193   3                  for(i=0 ; i<32 ; i++)
2194   3                  {
2195   4                      if( (gHpgpHalCB.ppekValidReg & BIT(i)) == 0)
2196   4                      {
2197   5                          keyNum = i;
2198   5                          gHpgpHalCB.ppekValidReg |= BIT(i);
2199   5                          break;
2200   5                      }                    
2201   4                  }
2202   3                  if(i == 32)
2203   3                  {
2204   4                      // All 32 KeyEntries in selected PPEK Region are currently in use.
2205   4                      // PPEK Table full.
2206   4                      status = STATUS_FAILURE;
2207   4                  }
2208   3              }
2209   2          }
2210   1      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 38  

2211   1          if(status == STATUS_SUCCESS)
2212   1          {
2213   2              // Write Key to the Key LUT.
2214   2              for(i=0; i<4; i++)
2215   2              {
2216   3                  aesKeyLutAddr.reg          = 0;
2217   3                  aesKeyLutAddr.sPpek.isNek  = 0;
2218   3                  aesKeyLutAddr.sPpek.idx    = i;
2219   3                  aesKeyLutAddr.sPpek.keyNum = keyNum;
2220   3                  aesKeyLutAddr.sPpek.region = region;
2221   3                  WriteU32Reg(PLC_AESKEYLUTADDR_REG, aesKeyLutAddr.reg );
2222   3         //         FM_Printf(FM_MINFO, "Wrote keyAddr dw       0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutAddr.r
             -eg), (PLC_AESKEYLUTADDR_REG));
2223   3                  for(j=0 ; j<4 ; j++)
2224   3                  {
2225   4                      aesKeyLutData.s.key[j] = ppek[arrIdx++];       
2226   4                  }
2227   3                  WriteU32Reg(PLC_AESKEYLUTDATA_REG, aesKeyLutData.reg);
2228   3         //         FM_Printf(FM_MINFO, "Wrote key dw           0x%08lX to reg#0x%08lX\n", rtocl(aesKeyLutData.r
             -eg), (PLC_AESKEYLUTDATA_REG));
2229   3              }
2230   2      
2231   2              // Write Aes LUT Addr corres to PPEK.
2232   2              aesLutAddr.reg          = 0;
2233   2              aesLutAddr.sPpek.tei    = tei;
2234   2              aesLutAddr.sPpek.isNek  = 0;
2235   2              WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2236   2        //      FM_Printf(FM_MINFO, "Wrote AesLutAddr dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutAddr.reg), (P
             -LC_AESLUTADDR_REG));
2237   2          
2238   2              // Set the PPEK valid.
2239   2              //aesLutData.reg           = 0;
2240   2              aesLutData.sPpek.keyNum  = keyNum;
2241   2              aesLutData.sPpek.valid   = 1;
2242   2              if(region == 0)
2243   2              {
2244   3                  aesLutData.sPpek.region0 = 1;
2245   3              }
2246   2              else
2247   2              {
2248   3                  aesLutData.sPpek.region1 = 1;
2249   3              }
2250   2      
2251   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutData.reg);    
2252   2        //      FM_Printf(FM_MINFO, "Wrote AesLutData dw    0x%08lX to reg#0x%08lX\n", rtocl(aesLutData.reg), (P
             -LC_AESLUTDATA_REG));
2253   2          }
2254   1      
2255   1          // Release CPU Lock on AES LUT
2256   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2257   1          aesCpuCmd.s.cpuTblGnt = 0;
2258   1          aesCpuCmd.s.cpuTblReq = 0;
2259   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2260   1      
2261   1          return status;
2262   1      }
2263          
2264          
2265          eStatus HHAL_RemovePPEK(u8 eks, u8 tei)
2266          {
2267   1          uAesLutAddrReg      aesLutAddr;
2268   1          uAesLutDataReg      aesLutData;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 39  

2269   1          uAesCpuCmdStatReg   aesCpuCmd;
2270   1          eStatus             status;
2271   1          u8                  region;
2272   1      
2273   1          // Wait for Cpu Aes Lut access grant.
2274   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2275   1          aesCpuCmd.s.cpuTblReq = 1;
2276   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2277   1      
2278   1          CHAL_DelayTicks(100);
2279   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2280   1          if(eks < 8 || eks > 9)
2281   1          {
2282   2              return STATUS_FAILURE;
2283   2          }
2284   1          region                  = eks & 0x01;
2285   1      
2286   1          // Write Aes LUT Addr corres. to PPEK.
2287   1          aesLutAddr.reg         = 0;
2288   1          aesLutAddr.sPpek.tei   = tei;
2289   1          aesLutAddr.sPpek.isNek = 0;
2290   1          WriteU32Reg(PLC_AESLUTADDR_REG, aesLutAddr.reg);
2291   1      
2292   1          // Read back AesLutData corres to the tei.
2293   1          aesLutData.reg          = ReadU32Reg(PLC_AESLUTDATA_REG);
2294   1      //    FM_Printf(FM_MINFO,"Read back dw 0x%08lX from reg#0x%08lX\n", rtocl(aesLutData.reg), (PLC_AESLUTDATA
             -_REG));
2295   1      
2296   1          if(aesLutData.sPpek.valid)
2297   1          {
2298   2              if(region == 0)
2299   2              {
2300   3                  aesLutData.sPpek.region0 = 0;
2301   3              }
2302   2              else
2303   2              {
2304   3                  aesLutData.sPpek.region1 = 0;
2305   3              }
2306   2              if(aesLutData.sPpek.region0 == 0 && aesLutData.sPpek.region1 == 0)
2307   2              {
2308   3                   // Set the PPEK as invalid.
2309   3                  aesLutData.reg         = 0;
2310   3                  aesLutData.sPpek.valid = 0x0;
2311   3                  
2312   3              }
2313   2              WriteU32Reg(PLC_AESLUTDATA_REG, aesLutAddr.reg); 
2314   2          }
2315   1          else
2316   1          {
2317   2              status = STATUS_FAILURE;
2318   2          }
2319   1      
2320   1          // Release CPU Lock on AES LUT
2321   1          aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
2322   1          aesCpuCmd.s.cpuTblGnt = 0;
2323   1          aesCpuCmd.s.cpuTblReq = 0;
2324   1          WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
2325   1      
2326   1          return status;
2327   1      }
2328          
2329          #ifdef HPGP_HAL_TEST
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 40  

              void HHAL_SetDefAddrConfig()
              {
              #if defined(Flash_Config) && defined(Z_P_BRIDGE)    
              
                      gHpgpHalCB.selfTei   = sysConfig.defaultSTEI;
                      gHpgpHalCB.remoteTei = sysConfig.defaultDTEI;
                  gHpgpHalCB.snid      = sysConfig.defaultNID[0];
              
              #else 
                if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                  {
                      gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
                      gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
                  }else
                  {
                      gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
                      gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
                  }
                  gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
              #endif  //Flash_Config && Z_P_BRIDGE
              #ifndef QCA
                
                  HHAL_SetTei(gHpgpHalCB.selfTei);
              
                  HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other chip
             - snid should be set once we receive bcn from cco and should not get set at power on because 
              #endif
                      gHpgpHalCB.syncComplete   = 1;
              }
              #endif  //HPGP_HAL_TEST
2359          
2360          void HHAL_ClearBcnInit()
2361          {
2362   1          gHpgpHalCB.bcnInitDone = 0;
2363   1          //FM_Printf(FM_MINFO, "HHAL_ClearBcnInit\n");
2364   1      
2365   1      }
2366          
2367          void HHAL_SetBcnInit()
2368          {
2369   1          gHpgpHalCB.bcnInitDone = 1;
2370   1          FM_Printf(FM_MINFO, "HHAL_SetBcnInit\n");
2371   1      
2372   1      }
2373          
2374          void HHAL_PowerSaveConfig()
2375          {
2376   1          uPlcLineControlReg plcLineCtrl;
2377   1        
2378   1        plcLineCtrl.reg = ReadU32Reg(PLC_POWERSAVE_REG);
2379   1        
2380   1      }
2381          
2382          /*******************************************************************
2383          * NAME :            HHAL_SetDevMode
2384          *
2385          * DESCRIPTION :     Sets Default PLC Device configuration.
2386          *
2387          * INPUTS :
2388          *       PARAMETERS:
2389          *           eRegFlag regFlag
2390          *
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 41  

2391          * OUTPUTS :
2392          *       None
2393          *
2394          */
2395          
2396          void HHAL_SetDevMode(eDevMode devMode, eLineMode lineMode)
2397          {
2398   1      
2399   1      
2400   1          sCsmaRegion      csmaRegArr[5]; 
2401   1          uPlcLineControlReg plcLineCtrl;
2402   1          
2403   1         
2404   1        
2405   1          memset(csmaRegArr, 0, 5*sizeof(sCsmaRegion));
2406   1          // Added by Varsha
2407   1       
2408   1        FM_Printf(FM_MINFO, "lineMode %bu\n", lineMode);
2409   1        
2410   1          if(lineMode == LINE_MODE_DC)
2411   1          {
2412   2              gHpgpHalCB.lineMode = LINE_MODE_DC;
2413   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
2414   2              //gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2415   2              WriteU32Reg(PLC_DCLINECYCLE_REG, ctorl(PLC_DC_LINE_CYCLE_FREQENCY));
2416   2          WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_DC_BP_LEN >> 1)));
2417   2              WriteU32Reg(PLC_HWBCNPERCUR_REG, ctorl(PLC_DC_BP_LEN));
2418   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2419   2              plcLineCtrl.s.dcmode = 1;
2420   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2421   2               gsyncTimeout = DC_SYNC_TIMEOUT;
2422   2               gBcnMissingRescanCnt = DC_BCN_MISSING_RESCAN_CNT;  //60*4= 240= 240/40= 6 bcn missing
2423   2              //gHpgpHalCB.bPerAvgInitDone = 1;
2424   2          }
2425   1          else
2426   1          {
2427   2              gHpgpHalCB.lineMode = LINE_MODE_AC;
2428   2            gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN;
2429   2        
2430   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2431   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((PLC_AC_BP_LEN >> 1)));
2432   2              
2433   2              set_plc_paramter(PLC_MaxPeran,PLC_MAX_AC_BPLEN);
2434   2              set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2435   2              
2436   2              plcLineCtrl.reg = ReadU32Reg(PLC_LINECTRL_REG);
2437   2              plcLineCtrl.s.dcmode = 0;
2438   2              WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg);
2439   2               gsyncTimeout = AC_SYNC_TIMEOUT;
2440   2               gBcnMissingRescanCnt = AC_BCN_MISSING_RESCAN_CNT;  //30*4= 120= 120/33.33= 3 bcn missing
2441   2            set_plc_paramter(PLC_MinPeran,PLC_MIN_AC_BPLEN);
2442   2          }
2443   1      #ifdef MCCO
2444   1        if(devMode == DEV_MODE_PCCO)
2445   1        {
2446   2          gHpgpHalCB.devMode   = DEV_MODE_PCCO;
2447   2          // Write PLC Devmode register.
2448   2          //cpuSwStatus.reg = ReadU32Reg(CPU_SWSTATUS_REG);
2449   2      
2450   2          HHAL_SetPlcDevMode(CCO_COORDINATING);
2451   2        
2452   2      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 42  

2453   2          gHpgpHalCB.perSumCnt     = 0;
2454   2          gHpgpHalCB.bPerAvgInitDone = 0;
2455   2          
2456   2      #ifdef HPGP_HAL_TEST
                  setCSMA_onCCO();                      
              #endif
2459   2        }
2460   1        else
2461   1      #endif
2462   1       
2463   1        if(devMode == DEV_MODE_CCO)
2464   1          {
2465   2              gHpgpHalCB.devMode   = DEV_MODE_CCO;
2466   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode CCo\n");
2467   2      
2468   2              // Write PLC Devmode register.
2469   2              //cpuSwStatus.reg = ReadU32Reg(CPU_SWSTATUS_REG);
2470   2              if(lineMode == LINE_MODE_AC)
2471   2              {
2472   3                  //cpuSwStatus.s.plcDevMode = CCO_ACLINE;            
2473   3                  HHAL_SetPlcDevMode(CCO_ACLINE);
2474   3                  // Set AC cycle frequency
2475   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2476   3      /*#ifdef AC_LINECYCLE_50HZ
2477   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2478   3      #else                   
2479   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2480   3      #endif   */ //AC_LINECYCLE_50HZ         
2481   3                  gHpgpHalCB.perSumCnt       = 0;
2482   3                  gHpgpHalCB.bPerAvgInitDone = 0;
2483   3              }
2484   2              else
2485   2              {
2486   3                  
2487   3                  HHAL_SetPlcDevMode(CCO_DCLINE);
2488   3                  //HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2489   3              }
2490   2      #ifdef HPGP_HAL_TEST
                      setCSMA_onCCO();                                          
              #endif
2493   2          }
2494   1          else
2495   1          {
2496   2              gHpgpHalCB.devMode   = DEV_MODE_STA;
2497   2              //FM_Printf(FM_MINFO, "HHAL_SetDevMode: Dev Mode Sta\n");
2498   2      
2499   2      
2500   2              // Write PLC Devmode register.
2501   2              if(lineMode == LINE_MODE_AC)
2502   2              {
2503   3                  HHAL_SetPlcDevMode(STA_CSMANW);
2504   3                  gHpgpHalCB.lineMode = LINE_MODE_AC;
2505   3      /*#ifdef AC_LINECYCLE_50HZ
2506   3                  HHAL_SetACLine50HzFlag(REG_FLAG_SET);
2507   3      #else                   
2508   3                  HHAL_SetACLine50HzFlag(REG_FLAG_CLR);
2509   3      #endif   */ //AC_LINECYCLE_50HZ       
2510   3             
2511   3              }
2512   2              else
2513   2              {
2514   3                  HHAL_SetPlcDevMode(STA_DCLINE);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 43  

2515   3                  gHpgpHalCB.lineMode = LINE_MODE_DC;
2516   3              }     
2517   2      #ifdef HPGP_HAL_TEST    
                   setCSMA_onSTA();
              #endif
2520   2      
2521   2                
2522   2          }
2523   1        
2524   1         /* csmaRegArr[0].startTime  = 0;
2525   1          csmaRegArr[0].bcnRegion  = (devMode == DEV_MODE_STA) ? 1 : 0;
2526   1          csmaRegArr[0].duration   = 0x2FF;
2527   1          csmaRegArr[0].hybridMd   = 1;    
2528   1          
2529   1          csmaRegArr[2].startTime  = 0;
2530   1          csmaRegArr[2].bcnRegion  = (devMode == DEV_MODE_STA ) ? 1 : 0;
2531   1          csmaRegArr[2].duration   = gHpgpHalCB.bcnInitDone ? 0 : 0x5A3;
2532   1          csmaRegArr[2].hybridMd   = gHpgpHalCB.bcnInitDone ? 0 : 1;  
2533   1          
2534   1          csmaRegArr[3].startTime  = 0;
2535   1          csmaRegArr[3].bcnRegion  = 0;
2536   1          csmaRegArr[3].duration   = 0;//0x04A9//0xFF;
2537   1          csmaRegArr[3].hybridMd   = 0;//1;                         
2538   1          // Write CSMA Regions - mixed mode.
2539   1          if(lineMode == LINE_MODE_AC) 
2540   1          {
2541   1      
2542   1          csmaRegArr[1].startTime  = 0;
2543   1          csmaRegArr[1].bcnRegion  = 0;
2544   1          csmaRegArr[1].duration   = 0x4A1;
2545   1          csmaRegArr[1].hybridMd   = 1;
2546   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2547   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_AC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2548   1          }
2549   1          else
2550   1          {
2551   1          csmaRegArr[1].startTime  = 0;
2552   1          csmaRegArr[1].bcnRegion  = 0;
2553   1          csmaRegArr[1].duration   = 0x6A1;
2554   1          csmaRegArr[1].hybridMd   = 1;
2555   1      //    WriteU32Reg(PLC_SS1TIMEOUT_REG, ctorl(PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES));
2556   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_DC_BP_LEN - PLC_LATE_BCN_SYNC_THRES);
2557   1      
2558   1          }
2559   1          //HHAL_SetCsmaRegions(csmaRegArr,4);
2560   1         
2561   1          WriteU8Reg(0x47F, 0x4);  // PHY AGC Threshold - For auto switch robo on RX
2562   1          */
2563   1      }
2564          
2565          
2566          
2567          
2568          // Write AFE registers wian SPI registers in PHY address space
2569          void HHAL_AFEInit()
2570          {
2571   1        mac_utils_spi_write(0x4, 0x32);// vco fix kiran based on Jenny's recommendation
2572   1      #ifdef B_ASICPLC
2573   1          // [YM] 1.8GHz VCO Calibrate
2574   1          mac_utils_spi_write(0x4, 0x20);
2575   1          mac_utils_spi_write(0x4, 0x4);   //[YM] temporary disable AFE calibration
2576   1      #endif  
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 44  

2577   1      
2578   1      #ifdef B2_ASICPLC
                  // [YM] 1.8GHz VCO Calibrate
                  mac_utils_spi_write(0x4, 0x20);
                  mac_utils_spi_write(0x4, 0x24);   //[YM] temporary disable AFE calibration    
              #endif  
2583   1      
2584   1      /*
2585   1      #if defined(HYBRII_HPGP) && defined(HYBRII_802154)
2586   1          // Program fix gain for PLC
2587   1      #ifndef HYBRII_B
2588   1          mac_utils_spi_write(0x3a, 0x0a);
2589   1          mac_utils_spi_write(0x3b, 0x72);
2590   1      #endif
2591   1      #endif   //defined(HYBRII_HPGP) && defined(HYBRII_802154)
2592   1      */
2593   1      #ifdef _LED_DEMO_
                  WriteU8Reg(0x406, 0x00);
                  CHAL_DelayTicks(SPI_WRITE_DELAY);
                  WriteU8Reg(0x406, 0x7F);
              #endif  //_LED_DEMO_
2598   1      }
2599          
2600          
2601          void hal_hpgp_soft_reset ()
2602          {
2603   1          uPlcStatusReg  plcStatus;
2604   1          
2605   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
2606   1          plcStatus.s.txSoftReset = 1;
2607   1          plcStatus.s.rxSoftReset = 1;
2608   1      
2609   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2610   1      
2611   1          CHAL_DelayTicks(100);
2612   1          plcStatus.s.txSoftReset = 0;
2613   1          plcStatus.s.rxSoftReset = 0;
2614   1      
2615   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
2616   1      }
2617          
2618          
2619          
2620             
2621          eStatus HHAL_SyncNet(u8 *bpsto) 
2622          {
2623   1          uBpstoReg    bpstoReg;
2624   1          //u32          ntb1,ntb2;
2625   1          u32          bpstoVal; //, latency;
2626   1          u32          bpst;
2627   1          u32          ss1;
2628   1      //    u32          offset;
2629   1      //    u32          ss2MinusSs1;
2630   1      //    u32 bps;
2631   1          u32 NTB_delta;
2632   1      //    u32 x;
2633   1      //    u32 E_CCOBTS;
2634   1          u32 BcnPer;
2635   1          u32 CCOBpst;
2636   1          u32 RetrievedBTS;
2637   1          u8 rollover_snapshot1 = 0;
2638   1          u8 rollover_retriveBTS = 0;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 45  

2639   1          u32 ToatalLatency;
2640   1        u32 missingBcnThreshold;
2641   1        u32 minVal=PLC_MIN_AC_BPLEN; // defaulted to AC BP Len (60 Hz)
2642   1        u32 maxVal=PLC_MAX_AC_BPLEN;
2643   1      
2644   1        eStatus      ret = STATUS_FAILURE;
2645   1      
2646   1                           
2647   1      
2648   1          if (!gHpgpHalCB.nwSelected)
2649   1              return ret;    
2650   1      
2651   1       
2652   1        
2653   1          // Process further if the beacon has been snapshot.
2654   1          if(gHpgpHalCB.snapShot)
2655   1          {   
2656   2              bpstoReg.s.bpsto0 = bpsto[0];
2657   2              bpstoReg.s.bpsto1 = bpsto[1];
2658   2              bpstoReg.s.bpsto2 = bpsto[2];
2659   2      
2660   2              bpstoVal = ((u32)(bpsto[2])<<16) + ((u32)(bpsto[1])<<8) + (u32)bpsto[0];
2661   2              //WriteU32Reg(PLC_BPSTOFFSET_REG, ctorl(bpstoVal));     
2662   2              
2663   2              ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2664   2           
2665   2               //ss2 = rtocl(ReadU32Reg(PLC_NTB_REG)); 
2666   2              // printf("\n ssdif= %lu", ((ss1-oldss1) * 40));
2667   2               
2668   2      
2669   2              if(gHpgpHalCB.syncComplete)//normal operation
2670   2              {
2671   3                   if(ss1 < oldss1)
2672   3                      rollover_snapshot1 = 1;
2673   3              }   
2674   2              oldss1 = ss1;
2675   2              RetrievedBTS = gCCO_BTS + PLC_PHY_RXLATENCY_FOR_TCC3;  //PLC_PHY_RXLATENCY_FOR_TCC2;//normal as we
             -ll as cpu scan operation
2676   2               
2677   2               
2678   2              if(gHpgpHalCB.syncComplete)//normal operation
2679   2              {
2680   3                  if(RetrievedBTS < oldRetrievedBTS)
2681   3                      rollover_retriveBTS = 1;
2682   3              } 
2683   2              
2684   2              oldRetrievedBTS = RetrievedBTS; 
2685   2              
2686   2              if(RetrievedBTS > ss1)  //sta slower then cco
2687   2              {
2688   3                  if(rollover_retriveBTS)
2689   3                  {
2690   4                      NTB_delta = RetrievedBTS + (0xffffffff - ss1);
2691   4                  }
2692   3                  else 
2693   3                  {
2694   4                      NTB_delta = (RetrievedBTS - ss1);
2695   4                   
2696   4                  }
2697   3                  if(NTB_delta > 10)
2698   3                  {
2699   4                      gHpgpHalCB.halStats.STAlagCCOCount++;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 46  

2700   4                  }
2701   3              
2702   3              }
2703   2              else  //sta is faster then cco so take 2's complement
2704   2              {
2705   3              
2706   3                  if(rollover_snapshot1 )
2707   3                  {
2708   4                      NTB_delta = 0xffffffff - (ss1 + (0xffffffff - RetrievedBTS)) + 1;
2709   4                  }
2710   3                  else  
2711   3                  {
2712   4                      NTB_delta = 0xffffffff - (ss1 - RetrievedBTS) + 1;     //taken 2's complement
2713   4                      
2714   4                     
2715   4                  }
2716   3                  if((ss1 - RetrievedBTS) > 10)
2717   3                  {
2718   4                      gHpgpHalCB.halStats.STAleadCCOCount++;
2719   4                  } 
2720   3              }
2721   2              
2722   2      //        WriteU32Reg( PLC_NTBADJ_REG, ctorl(NTB_delta));  move this down to after check BCN_PER_THRESHOLD
             - - Tri
2723   2               
2724   2            
2725   2                                                 
2726   2              //ss1   = rtocl(ReadU32Reg(PLC_BCNSNAPSHOT1_REG));
2727   2      
2728   2             
2729   2              //ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC2 + bpstoVal);
2730   2              ToatalLatency = (PLC_PHY_RXLATENCY_FOR_TCC3+ bpstoVal);
2731   2           
2732   2      
2733   2      
2734   2      #ifdef QCA    
                      ss1 += NTB_delta;//rajan
              #endif             
2737   2      
2738   2              if( ss1 > ToatalLatency)
2739   2              {
2740   3                  if(rollover_snapshot1)
2741   3                      CCOBpst = ss1 + (0xffffffff - ToatalLatency); 
2742   3                   else
2743   3                      CCOBpst = (ss1 - ToatalLatency);
2744   3              }
2745   2              else
2746   2              {
2747   3                    CCOBpst = ss1 + (0xffffffff - ToatalLatency + 1); 
2748   3              }
2749   2              
2750   2             
2751   2             if(CCOBpst > OldCCOBpst)
2752   2              BcnPer =  (CCOBpst - OldCCOBpst);
2753   2             else
2754   2                  BcnPer = ((0xffffffff - OldCCOBpst) + CCOBpst);
2755   2             
2756   2             OldCCOBpst = CCOBpst; 
2757   2            // printf("\n bcn per = %lu",BcnPer); 
2758   2      
2759   2             //missingBcnThreshold = gHpgpHalCB.curBcnPer * 1.5;    // ie. 1.5 bcn in NTB units               
2760   2           missingBcnThreshold = ((gHpgpHalCB.curBcnPer * 3)>>1);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 47  

2761   2             if(BcnPer > missingBcnThreshold)
2762   2             {
2763   3              // If we miss BCN_PER_THRESHOLD, skip the 1st good bcn
2764   3            // will start calculating beginning of 2nd good bcn
2765   3      //           printf("\n Hit HI BCN THRESHOLD. BcnPer = %lu, missingBcnThreshold=%lu", BcnPer, missingBcnTh
             -reshold);
2766   3            
2767   3             return STATUS_SUCCESS; 
2768   3      
2769   3             }
2770   2      
2771   2           // make sure that the value of BcnPER fall within acceptable range
2772   2      #ifdef FREQ_DETECT
2773   2           if (gHpgpHalCB.curBcnPer == PLC_DC_BP_LEN_50HZ)
2774   2           {
2775   3                  minVal = MIN_50HZ_BPLEN;
2776   3                  maxVal = MAX_50HZ_BPLEN; 
2777   3           }
2778   2      #endif      
2779   2           if ((BcnPer >= minVal) && (BcnPer <= maxVal))
2780   2             {
2781   3              // calculated bcnPER must be within acceptable range
2782   3                  gBcnPer = BcnPer;
2783   3             }
2784   2             else
2785   2             {
2786   3              // if not within range, use default value
2787   3      #ifndef MPER            
2788   3      //            printf("BCNPER = 0x%lx\n", BcnPer);
2789   3      #endif
2790   3               gBcnPer = gHpgpHalCB.curBcnPer;              
2791   3             }
2792   2      EA = 0;        
2793   2              WriteU32Reg( PLC_NTBADJ_REG, ctorl(NTB_delta));  
2794   2      
2795   2              //whenever we receives bcn we write sw per avg reg = bcnper/2 
2796   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gBcnPer >> 1))); 
2797   2      EA = 1;         
2798   2             
2799   2             // ss2MinusSs1 = (ss2 > ss1) ? (ss2 - ss1) : (0xFFFFFFFF - ss1 + ss2);
2800   2             // if(ss2MinusSs1 <= (gBcnPer - 1000) )
2801   2              {
2802   3                   bpst = CCOBpst + gBcnPer;// + var1;
2803   3                   gbpst1 = bpst;
2804   3                     
2805   3      
2806   3      #ifdef QCA             
                           bpst -= NTB_delta; //rajan
              #endif               
2809   3              EA = 0;        
2810   3              WriteU32Reg(PLC_BPST_REG, ctorl(bpst)); 
2811   3              EA = 1;      
2812   3      
2813   3                   gHpgpHalCB.halStats.BcnSyncCnt++;  
2814   3                   gtimer2 = 0;//reset second timer at every bcn receive
2815   3                   gtimer1 = 0; 
2816   3                   misscnt = 0;
2817   3               }  
2818   2                  
2819   2              }
2820   1      
2821   1             
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 48  

2822   1              if(gHpgpHalCB.syncComplete)
2823   1              {
2824   2                  ret = STATUS_SUCCESS;
2825   2              }
2826   1      
2827   1              if(!gHpgpHalCB.syncComplete && (gHpgpHalCB.halStats.BcnSyncCnt))
2828   1              {
2829   2                  gHpgpHalCB.syncComplete = 1;
2830   2                 // CHAL_DelayTicks(80);// Kiran: need to review. Blocking
2831   2                  HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);  
2832   2                 // CHAL_DelayTicks(20);// Kiran: need to review    TODO RAJAN
2833   2      #ifdef MCCO 
2834   2      
2835   2            if (gHpgpHalCB.devMode == DEV_MODE_PCCO)
2836   2            {
2837   3      
2838   3              gHpgpHalCB.bPerAvgInitDone = 1;
2839   3            }
2840   2      #endif
2841   2      
2842   2              }      
2843   1       
2844   1               //gtimer2 = 0;//reset second timer at every bcn receive
2845   1               //gtimer1 = 0;
2846   1               
2847   1               return ret;
2848   1      }
2849          // end of Hybrii B
2850          
2851          
2852          #if 0
              
              void HHAL_ProcessPlcTxDone()
              {
              
                  u8 tailIdx;
                  sTxFrmSwDesc  *lpPlcTxFrmSwDesc;
                  sHpgpHalCB *hhalCb; 
              #ifndef HPGP_HAL_TEST    
                  sHaLayer *hal;
              #endif     //HPGP_HAL_TEST
                  volatile u32 val;
                  volatile u8 *val1; 
              
                  
              #ifdef HPGP_HAL_TEST
                  hhalCb = &gHpgpHalCB;
              #else
                  hal = (sHaLayer*)HOMEPLUG_GetHal();
              
                  hhalCb = hal->hhalCb;
              #endif     //HPGP_HAL_TEST
              
                
                  val = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
              
                  val1 = (u8*)&val;
              
                  if ((*val1) & 0x40)
                  {
              #ifdef ETH_BRDG_DEBUG
                  numTxDoneInts++;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 49  

              #endif
                      WriteU8Reg(PLC_MEDIUMINTSTATUS_REG, 0x40);         
                         
                                  
                      tailIdx = (hhalCb->gPendingTail & 0x7F);
                      lpPlcTxFrmSwDesc =  &hhalCb->gPending[tailIdx];
              
                      if (lpPlcTxFrmSwDesc->frmInfo.plc.status == PLC_TX_PENDING)
                      {
                          lpPlcTxFrmSwDesc->frmInfo.plc.status = PLC_TX_DONE;            
              #ifdef DEBUG_DATAPATH                        
                          if (sigDbg)
                              FM_Printf(FM_ERROR," plc txDone t:%bu\n",hhalCb->gPendingTail);
              #endif   //DEBUG_DATAPATH         
                      }
              
                      
                  }
              
              }
              
              #endif
2906          
2907          
2908          void plc_init_parameters ()
2909          {
2910   1          uPlcIfs0Reg         plcIfs0;
2911   1          uPlcIfs1Reg         plcIfs1;
2912   1      
2913   1          //set_plc_paramter(PLC_PHYLATENCY_SEL,  PLC_PHYLATENCY_INIT_VALUE); 
2914   1        // Added by Varsha
2915   1        
2916   1      //      u32 laten_initval;
2917   1      //     u32 rx_lat = PLC_PHY_RXLATENCY;
2918   1      //     u32 tx_lat = PLC_PHY_TXLATENCY;
2919   1          
2920   1        set_plc_paramter(PLC_TIMINGPARAM_SEL, PLC_TIMINGPARAM_INIT_VALUE);
2921   1      
2922   1          set_plc_paramter(PLC_MPIRXTIMEOUT_SEL, PLC_MPIRXTIMOUT_INIT_VALUE);
2923   1      
2924   1          set_plc_paramter(PLC_MPITXTIMEOUT_SEL, PLC_MPITXTIMOUT_INIT_VALUE);
2925   1      
2926   1          set_plc_paramter(PLC_CPUSCAN_TIMEOUT_SEL, PLC_CPUSCANTIMOUT_INIT_VALUE);
2927   1      
2928   1          set_plc_paramter(PLC_500USCNT_SEL, PLC_500US_COUNT);
2929   1      
2930   1        //Added by Varsha
2931   1        
2932   1           /*  laten_initval = PLC_PHY_RXLATENCY;
2933   1           laten_initval = laten_initval << 16;
2934   1           laten_initval += PLC_PHY_TXLATENCY;
2935   1           printf("\n latenval = %lu", laten_initval); */
2936   1           set_plc_paramter(PLC_PHYLATENCY_SEL,   TX_RXLatency_TCC[2]);  //tcc =3
2937   1        
2938   1          // IFS Registers 
2939   1          plcIfs0.reg          = 0;
2940   1          plcIfs0.s.clksPerUs  = HPGP_CLKsPerUs_DEF;
2941   1          plcIfs0.s.cifs_av    = HPGP_CIFSAV_DEF;
2942   1          plcIfs0.s.rifs_av    = HPGP_RIFSAV_DEF;
2943   1          plcIfs0.s.b2bifs     = HPGP_B2BIFS_DEF;
2944   1          set_plc_paramter(PLC_IFS0_SEL, plcIfs0.reg);
2945   1      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 50  

2946   1        
2947   1          plcIfs1.reg          = 0;
2948   1          plcIfs1.s.bifs       = HPGP_BIFS_DEF;
2949   1          plcIfs1.s.aifs       = HPGP_AIFS_DEF;
2950   1          set_plc_paramter(PLC_IFS1_SEL, plcIfs1.reg);
2951   1      
2952   1          
2953   1          set_plc_paramter(PLC_IFS2_SEL, PLC_IFS2_INIT_VALUE);
2954   1      
2955   1          set_plc_paramter(PLC_IFS3_SEL, PLC_IFS3_INIT_VALUE);
2956   1      
2957   1      
2958   1        // FL_AV Registers
2959   1          // Adding 1 to the actual values, since MAC HW is using a "<" comparison with each of these feilds.
2960   1          set_plc_paramter(PLC_FLAV0_SEL, PLC_FLAV0_INIT_VALUE);
2961   1        
2962   1          set_plc_paramter(PLC_FLAV1_SEL, PLC_FLAV1_INIT_VALUE);
2963   1      
2964   1          set_plc_paramter(PLC_FLAV2_SEL, PLC_FLAV2_INIT_VALUE);
2965   1      
2966   1          set_plc_paramter(PLC_FLAV3_SEL, PLC_FLAV3_INIT_VALUE);
2967   1      
2968   1        set_plc_paramter(PLC_FLAV4_SEL, PLC_FLAV4_INIT_VALUE);
2969   1      
2970   1      
2971   1        // 0x11 is used for Early Wake Count, 0x12 and 0x13 are not being used
2972   1      //    set_plc_paramter(PLC_CRSRDYDLY0_SEL, PLC_CRSDLY0_1_INIT_VALUE); 
2973   1      //    set_plc_paramter(PLC_CRSRDYDLY1_SEL, PLC_CRSDLY2_3_INIT_VALUE);
2974   1      //    set_plc_paramter(PLC_CRSRDYDLY2_SEL, PLC_CRSDLY3_PRS_INIT_VALUE);
2975   1          set_plc_paramter(PLC_CRSRDYDLY0_SEL, 0); 
2976   1      
2977   1          set_plc_paramter(PLC_WAITCRS_SEL, PLC_WAITCRS_INIT_VALUE);
2978   1      
2979   1          set_plc_paramter(PLC_TXRX_TURNAROUND_SEL, PLC_TXRX_TURNAROUND_INIT_VALUE);
2980   1      
2981   1        set_plc_paramter(PLC_PKTTIME_SEL, PLC_PKTTIME_INIT_VALUE);
2982   1        set_plc_paramter(PLC_EIFS_SEL, PLC_EIFS_INIT_VALUE);
2983   1        set_plc_paramter(PLC_VCSPARAM0_SEL, PLC_VCSPARAM0_INIT_VALUE);
2984   1        set_plc_paramter(PLC_VCSPARAM1_SEL, PLC_VCSPARAM1_INIT_VALUE);
2985   1        set_plc_paramter(PLC_VCSPARAM2_SEL, PLC_VCSPARAM2_INIT_VALUE);
2986   1          set_plc_paramter(PLC_MaxPeran,PLC_MaxPeran_INIT_VALUE);
2987   1        set_plc_paramter(PLC_MinPeran,PLC_MinPeran_INIT_VALUE);
2988   1      }
2989          
2990          #ifdef HPGP_HAL_TEST
              void HHAL_Init()
              #else
2993          void HHAL_Init(sHaLayer *hal, sHpgpHalCB **ppHhalCb)
2994          #endif
2995          {
2996   1          uPlcStatusReg       plcStatus;
2997   1          uPlcLineControlReg  plcLineCtrl;  
2998   1        
2999   1      //  uPlcDevCtrlReg      plcDeviceCtrl;
3000   1          uAesCpuCmdStatReg   aesCpuCmd;
3001   1        uPlcSMCounterReg    plcSMCnt;
3002   1          u16 i;
3003   1      
3004   1      //  u32                RegValue;
3005   1      #ifdef POWERSAVE
                u8 byteVal;
              #endif
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 51  

3008   1      
3009   1      #ifndef HPGP_HAL_TEST
3010   1          gHpgpHalCB.hal = hal;
3011   1          
3012   1          *ppHhalCb = &gHpgpHalCB;
3013   1      #endif    //HPGP_HAL_TEST
3014   1      
3015   1          plcStatus.reg              = 0;
3016   1          plcStatus.s.crsBypass      = 0;
3017   1          plcStatus.s.soundEnable    = 0;
3018   1          plcStatus.s.plcTxQSwCtrl   = 1; 
3019   1      #ifndef MPER
3020   1          plcStatus.s.randomBackoff = 1;  // Upper mac discovey beacon collision with datapath test. so have to 
             -enable randomBackoff
3021   1      #else
                  plcStatus.s.randomBackoff = 0; 
              #endif
3024   1        //plcStatus.s.plcTxQHwCtrl   = 1;
3025   1        plcStatus.s.mpiChkFlush    = 1;
3026   1      #ifdef _AES_SW_
                  plcStatus.s.hwAesResetEnb  = 1;
              #endif
3029   1      // [YM] plcStatus.s.plcRxEnSwCtrl is used only on Hybrii_A 
3030   1      //    plcStatus.s.plcRxEnSwCtrl  = 1;
3031   1          WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3032   1        plcStatus.s.soundEnable    = 1;
3033   1        WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3034   1          // Program PLC_PHYLATENCY_SEL Init Value
3035   1          plc_init_parameters();
3036   1      
3037   1       
3038   1        
3039   1           plcLineCtrl.reg = 0;
3040   1           plcLineCtrl.s.usTimerMark = 0;
3041   1           plcLineCtrl.s.cpuFreq = 0;//25 mhz
3042   1           //plcLineCtrl.s.dcmode = 1;
3043   1           plcLineCtrl.s.hybernate = 1;
3044   1      
3045   1      #ifdef PLC_SW_SYNC
3046   1           plcLineCtrl.s.swSync = 1;
3047   1           plcLineCtrl.s.swPER = 1;
3048   1      //      plcLineCtrl.s.swSync = 0;
3049   1          // plcLineCtrl.s.swPER = 0;
3050   1      #endif
3051   1          WriteU32Reg(PLC_LINECTRL_REG, plcLineCtrl.reg); 
3052   1        
3053   1          WriteU32Reg(PLC_MAXRETRYCNT_REG, ctorl(PLC_MAXRETRYCNT_INIT_VALUE));
3054   1        
3055   1        WriteU32Reg(CPU_ETHERSA0_REG, ctorl(CPU_ETHERSA0_INIT_VALUE));
3056   1        
3057   1        WriteU32Reg(CPU_ETHERSA1_REG, ctorl(CPU_ETHERSA1_INIT_VALUE));
3058   1        
3059   1        WriteU8Reg(ETHMAC_MACMODE_REG, 0);
3060   1        WriteU8Reg(ETHMAC_TXDEFPARM_REG, 0xC);
3061   1        WriteU8Reg(ETHMAC_TXCTL1_REG, 0x11);
3062   1        WriteU8Reg(ETHMAC_RXCTL_REG, 0xF);
3063   1        
3064   1        WriteU32Reg(PLC_EARLYHPGPBPINT_REG, ctorl(PLC_EARLYHPGPBPINT_INIT_VALUE));
3065   1      
3066   1         
3067   1           // Initialize SSN Memory - 256*4 DWORDS
3068   1           for(i=0;i<1024;i++) 
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 52  

3069   1           {
3070   2             WriteU32Reg(PLC_SSNMEMADDR_REG, ctorl(i));
3071   2             WriteU32Reg(PLC_SSNMEMDATA_REG, 0); 
3072   2           }
3073   1         
3074   1           // Wait for Cpu Aes Lut access grant
3075   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
3076   1           aesCpuCmd.s.cpuTblReq = 1;
3077   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG,aesCpuCmd.reg);
3078   1         
3079   1           CHAL_DelayTicks(100);
3080   1         
3081   1           // Initialize PPEK Addr table  - 256 bytes
3082   1           for(i=0;i<256;i++)  
3083   1           {
3084   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(i));
3085   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
3086   2           }
3087   1         
3088   1           // Initialize NEK Valid table - 8 bytes
3089   1           for(i=0;i<8;i++)  
3090   1           {
3091   2             WriteU32Reg(PLC_AESLUTADDR_REG, ctorl(256+i));
3092   2             WriteU32Reg(PLC_AESLUTDATA_REG, 0);
3093   2           }
3094   1         
3095   1           // Initilaize AES Key Table  - 1024 DWORDS
3096   1           // only 1152 DWORDS actually used to store keys
3097   1           for(i=0;i<1024;i++) 
3098   1           {
3099   2             WriteU32Reg(PLC_AESKEYLUTADDR_REG, ctorl(i));
3100   2             WriteU32Reg(PLC_AESKEYLUTDATA_REG, 0);
3101   2           }
3102   1         
3103   1           // Release CPU Lock on AES LUT
3104   1           aesCpuCmd.reg = ReadU32Reg(PLC_AESCPUCMDSTAT_REG);
3105   1           aesCpuCmd.s.cpuTblGnt = 0;
3106   1           aesCpuCmd.s.cpuTblReq = 0;
3107   1           WriteU32Reg(PLC_AESCPUCMDSTAT_REG, aesCpuCmd.reg);
3108   1      
3109   1      
3110   1      
3111   1          // Initialize HPGP HAL Control Blok  
3112   1          gHpgpHalCB.diagModeEnb       = 0;
3113   1          gHpgpHalCB.bcnInitDone       = 0;
3114   1          gHpgpHalCB.ppekValidReg      = 0;
3115   1          gHpgpHalCB.syncComplete      = 0;
3116   1          gHpgpHalCB.scanEnb           = 0;
3117   1          gHpgpHalCB.swSyncEnb         = 0;
3118   1          gHpgpHalCB.lastNtbB4         = 0;
3119   1          gHpgpHalCB.lastNtbAft        = 0;
3120   1          gHpgpHalCB.lastBpst          = 0;
3121   1          gHpgpHalCB.lastBcnRxTime     = 0;
3122   1          gHpgpHalCB.bcnPerSum         = 0;
3123   1          gHpgpHalCB.curBcnPer         = 0;
3124   1          gHpgpHalCB.perSumCnt         = 0;
3125   1          gHpgpHalCB.bPerAvgInitDone   = 0;
3126   1          gHpgpHalCB.bBcnNotSent       = 0; 
3127   1          gHpgpHalCB.BcnTxWaitTimeoutCnt = 0;
3128   1          gHpgpHalCB.nwSelected        = 0;
3129   1        gHpgpHalCB.nwSelectedSnid = 0;
3130   1          gHpgpHalCB.bTxPending        = 0;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 53  

3131   1          //gHpgpHalCB.bBcnTxPending     = 0;
3132   1          gHpgpHalCB.BcnLateCnt = 0;
3133   1      #ifndef HPGP_HAL_TEST 
3134   1          gHpgpHalCB.tei               = 0;
3135   1      #else
                  memcpy(gHpgpHalCB.nid, gDefNID, NID_LEN);
              #endif  
3138   1          gHpgpHalCB.plcTx10FC.reg = HPGP_HP10FC_DEF;
3139   1      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                  gHpgpHalCB.psAvln            = TRUE;
                  gHpgpHalCB.psInSleepMode     = FALSE;
              #endif
3143   1      #ifdef LLP_POWERSAVE
                  gHpgpHalCB.psSta             = TRUE;
                gHpgpHalCB.savedPsMode.psState = PSM_PS_STATE_OFF;
                gHpgpHalCB.savedPsMode.pss   = PSM_PSS_NOT_CONFIG;
              #endif
3148   1      
3149   1      
3150   1          // Setup default network as DC mode CCo & configure default addr
3151   1          // HPGP stack will overwrite in due course.
3152   1      #ifdef HPGP_HAL_TEST
                  HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
                  HHAL_SetDefAddrConfig();
              #else
3156   1          if (opMode == UPPER_MAC)
3157   1          {
3158   2            HHAL_SetSnid(0);
3159   2            HHAL_SetDevMode(DEV_MODE_STA, gHpgpHalCB.lineMode);//LINE_MODE_DC);
3160   2          }
3161   1          else
3162   1          {
3163   2               HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
3164   2               if(gHpgpHalCB.devMode == DEV_MODE_CCO)
3165   2               {
3166   3                   gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEICCO;
3167   3                   gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEISTA;
3168   3               }else
3169   2               {
3170   3                   gHpgpHalCB.selfTei   = HYBRII_DEFAULT_TEISTA;
3171   3                   gHpgpHalCB.remoteTei = HYBRII_DEFAULT_TEICCO;
3172   3               }
3173   2               gHpgpHalCB.snid      = HYBRII_DEFAULT_SNID;
3174   2            
3175   2               HHAL_SetTei(gHpgpHalCB.selfTei);
3176   2       
3177   2               HHAL_SetSnid(gHpgpHalCB.snid); // this is done because when we communicate with quqlcomm or other
             - chip snid should be set once we receive bcn from cco and should not get set at power on because 
3178   2          }
3179   1      #endif
3180   1      
3181   1      #if 0
                  //[YM] set RSSI-FIFO lock for sound packet
                  WriteU32Reg(PLC_RSSI_REG, ctorl(0x1));
              #endif
3185   1      
3186   1          // Setting for Hybrii ASIC
3187   1          WriteU8Reg(0x401, 0x03);   //Enable GAFE SPI
3188   1          WriteU8Reg(0x402, 0x10);
3189   1          // ADC PLC Clk flip
3190   1          mac_utils_spi_write(0x29,0x04);   //added by varsha
3191   1        // Enable Sync timeout 
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 54  

3192   1          WriteU8Reg(0x483, 0x33);
3193   1        //WriteU8Reg(0x483, 0x13);
3194   1      #ifdef B_FPGA   
                  WriteU8Reg(0x4d9, 0x67); //For FPGA only, extra delay
                  WriteU8Reg(0x4d8, 0x84);
                
                //Sync threshold
                  //WriteU8Reg(0x48a, 0x90);     //should be re-check for ASIC, commented out for FPGA
                
                //Energy detection and AGC Saturation Threshold
                  WriteU8Reg(0x479, 0x52); 
              #endif
3204   1      // Add Sync threshold - Rachel 0317-2014
3205   1          //WriteU8Reg(0x478, 0x11);    // For long range
3206   1        WriteU8Reg(0x478, 0x05);    // Jenny new setting 03242014
3207   1        WriteU8Reg(0x484, 0x52);
3208   1        //WriteU8Reg(0x48A, 0xCA);
3209   1        WriteU8Reg(0x48A, 0xFF);     // Jenny new setting 03242014
3210   1        WriteU8Reg(0x48B, 0x00);
3211   1        WriteU8Reg(0x4DE, 0xF0);     // Jenny new setting 03242014
3212   1        WriteU8Reg(0x4DF, 0xFF);     // Jenny new setting 03242014
3213   1        WriteU8Reg(0x4E0, 0xFF);     // Jenny new setting 03242014
3214   1        
3215   1      #if 1    
3216   1          // Add init setting for Rachel - YMCHEN 09262013
3217   1          WriteU8Reg(0x48c, 0xcb);
3218   1        WriteU8Reg(0x48d, 0x96);
3219   1        WriteU8Reg(0x48e, 0x2d);
3220   1        WriteU8Reg(0x48f, 0x5b);
3221   1        WriteU8Reg(0x490, 0xb6);
3222   1        WriteU8Reg(0x491, 0x6c);
3223   1        WriteU8Reg(0x492, 0xd9);
3224   1        WriteU8Reg(0x493, 0xb2);
3225   1        WriteU8Reg(0x494, 0x65);
3226   1        WriteU8Reg(0x495, 0xcb);
3227   1        WriteU8Reg(0x496, 0x96);
3228   1        WriteU8Reg(0x497, 0x2d);
3229   1        WriteU8Reg(0x498, 0x5b);
3230   1        WriteU8Reg(0x499, 0xb6);
3231   1        WriteU8Reg(0x49a, 0x6c);
3232   1        WriteU8Reg(0x49b, 0xd9);
3233   1        WriteU8Reg(0x49c, 0xb2);
3234   1        WriteU8Reg(0x49d, 0x65);
3235   1        WriteU8Reg(0x49e, 0xcb);
3236   1        WriteU8Reg(0x49f, 0x96);
3237   1        WriteU8Reg(0x4a0, 0x2d);
3238   1        WriteU8Reg(0x4a1, 0x5b);
3239   1        WriteU8Reg(0x4a2, 0xb6);
3240   1        WriteU8Reg(0x4a3, 0x74);
3241   1        WriteU8Reg(0x4a4, 0xc9);
3242   1        WriteU8Reg(0x4a5, 0xe2);
3243   1        WriteU8Reg(0x4a6, 0x45);
3244   1        WriteU8Reg(0x4a7, 0x0b);
3245   1        WriteU8Reg(0x4a8, 0x17);
3246   1        WriteU8Reg(0x4a9, 0xcc);
3247   1        WriteU8Reg(0x4aa, 0x9d);
3248   1        WriteU8Reg(0x4ab, 0x33);
3249   1        WriteU8Reg(0x4ac, 0x7b);
3250   1        WriteU8Reg(0x4ad, 0xd6);
3251   1        WriteU8Reg(0x4ae, 0xcc);
3252   1        WriteU8Reg(0x4af, 0x19);
3253   1        WriteU8Reg(0x4b0, 0x53);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 55  

3254   1        WriteU8Reg(0x4b1, 0xa7);
3255   1        WriteU8Reg(0x4b2, 0x4c);
3256   1        WriteU8Reg(0x4b3, 0x9e);
3257   1        WriteU8Reg(0x4b4, 0x34);
3258   1        WriteU8Reg(0x4b5, 0x71);
3259   1        WriteU8Reg(0x4b6, 0xc2);
3260   1        WriteU8Reg(0x4b7, 0xd8);
3261   1        WriteU8Reg(0x4b8, 0x31);
3262   1        WriteU8Reg(0x4b9, 0xa3);
3263   1        WriteU8Reg(0x4ba, 0x47);
3264   1        WriteU8Reg(0x4bb, 0x8d);
3265   1        WriteU8Reg(0x4bc, 0x1c);
3266   1        WriteU8Reg(0x4bd, 0x31);
3267   1        WriteU8Reg(0x4be, 0x74);
3268   1        WriteU8Reg(0x4bf, 0xc8);
3269   1        WriteU8Reg(0x4c0, 0xe0);
3270   1        WriteU8Reg(0x4c1, 0x41);
3271   1        WriteU8Reg(0x4c2, 0x03);
3272   1        WriteU8Reg(0x4c3, 0x07);
3273   1        WriteU8Reg(0x4c4, 0x14);
3274   1        WriteU8Reg(0x4c5, 0x2d);
3275   1        WriteU8Reg(0x4c6, 0x52);
3276   1        WriteU8Reg(0x4c7, 0xb8);
3277   1        WriteU8Reg(0x4c8, 0x50);
3278   1        WriteU8Reg(0x4c9, 0xc1);
3279   1        WriteU8Reg(0x4ca, 0x02);
3280   1        WriteU8Reg(0x4cb, 0x41);
3281   1        WriteU8Reg(0x4cc, 0x83);
3282   1        WriteU8Reg(0x4cd, 0x04);
3283   1        WriteU8Reg(0x4ce, 0x0e);
3284   1        WriteU8Reg(0x4cf, 0x14);
3285   1        WriteU8Reg(0x4d0, 0x30);
3286   1        WriteU8Reg(0x4d1, 0x80);
3287   1        WriteU8Reg(0x4d2, 0x51);
3288   1        WriteU8Reg(0x4d3, 0x23);
3289   1        WriteU8Reg(0x4d4, 0x86);
3290   1        WriteU8Reg(0x4d5, 0x0d);
3291   1        WriteU8Reg(0x4d6, 0x19);
3292   1        WriteU8Reg(0x4d7, 0x04);
3293   1      #endif 
3294   1      #if 0
                  // Disable ADC hold - Rachel 0318-2014
                WriteU8Reg(0x4FA, 0x01);
                WriteU8Reg(0x44D, 0x0);
                WriteU8Reg(0x44F, 0x0);
                WriteU8Reg(0x4FA, 0x0); 
              #endif
3301   1      #ifdef B_ASICPLC
3302   1          mac_utils_spi_write(0x16,0x01);    // Enable PLC mode for AFE
3303   1          mac_utils_spi_write(0x36,0x12);   //added by YM, Jenny suggested 
3304   1      #endif
3305   1          //He li provided following regs for DC Offset setting
3306   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3307   1           mac_utils_spi_write(0x3a,0x08);   //added by varsha
3308   1           mac_utils_spi_write(0x3b,0x40);   //added by varsha 
3309   1           mac_utils_spi_write(0x18,0xa0);   //added by varsha
3310   1         // add delay > 100us
3311   1         CHAL_DelayTicks(6400);
3312   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3313   1           mac_utils_spi_write(0x2f,0x00);   //added by varsha
3314   1           mac_utils_spi_write(0x3a,0x0f);   //added by varsha 
3315   1           mac_utils_spi_write(0x3b,0x74);   //added by varsha
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 56  

3316   1           mac_utils_spi_write(0x18,0xc0);   //added by varsha
3317   1         // add delay > 100us
3318   1         CHAL_DelayTicks(6400);
3319   1           mac_utils_spi_write(0x18,0x00);   //added by varsha
3320   1         
3321   1      #ifdef B_ASICPLC
3322   1           mac_utils_spi_write(0x36,0x0);   //added by YM, Jenny suggested 
3323   1           mac_utils_spi_write(0x16,0x0);
3324   1      #endif
3325   1      
3326   1      //#ifdef B_FPGA
3327   1           WriteU8Reg(0x47F, 0x05);
3328   1      //#endif
3329   1           WriteU8Reg(0x485, TCC_REG_485_486_val[2][0]);  //TCC =3
3330   1           WriteU8Reg(0x486, TCC_REG_485_486_val[2][1]);
3331   1      
3332   1      //#ifdef HPGP_HAL_TEST // WAR: code reactivated to reduce loss in lower mac
3333   1      //    WriteU8Reg(0x478, 0x61); 
3334   1      //#else
3335   1      //    WriteU8Reg(0x478, 0x51); 
3336   1      //#endif  
3337   1      
3338   1      #if 0
                  // [YM] PHY setting for Hybrii_B FPGA HP101/HP11 Detection 
                  if (gHpgpHalCB.HP101Detection)
                  {
                     plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);   
                   plcStatus.s.HP10Detect = 1;         //Enable MAC for HP10 detection
                     WriteU32Reg(PLC_STATUS_REG,plcStatus.reg);
                      
                      WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
                      tmp = ReadU8Reg(0x46F);
                      WriteU8Reg(0x46F, tmp&0xF7);  //Enable HP101 detection bit
                      WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
                  } 
              #endif
3352   1          
3353   1        // [YM] Based on Jayesh's suggestion 0307-2014
3354   1              WriteU8Reg(0x4F8, 0x01);  //Set to high-bank phy memory
3355   1              WriteU8Reg(0x46F, 0xB);  //Enable HP101 detection bit
3356   1              WriteU8Reg(0x4F8, 0x0);  //Set back to low-bank phy memory    
3357   1      #ifdef B_FPGA    
                  // Energy Detection Threshold
                  WriteU8Reg(0x478, 0x69);  //WAR: code should be deactivated to reduce loss in lower mac // according to
             - geetha comments 11/6/2012
              #endif
3361   1      //#ifdef MPER    
3362   1          mac_utils_spi_write(0x34,0x0);   //Set default txpowermode = 2 (High Tx Power Mode)
3363   1        mac_utils_spi_write(0x35,0xF);   //added by YM 0211-2014
3364   1      //#else 
3365   1      //  mac_utils_spi_write(0x34,0x08);    //Set default txpowermode = 0 (Auto Power Mode)
3366   1      //    mac_utils_spi_write(0x35,0x30);   //added by YM 0211-2014
3367   1      //#endif  //MPER
3368   1      
3369   1      #ifndef B_ASICPLC    
                // [YM] Set timeout value, based on He Li suggest
                WriteU8Reg(0x4DF, 0xCA);
              #endif  //B_ASICPLC
3373   1      
3374   1      #ifdef ER_TEST  
                //[YM] change new setting value for long range 11-21-2013, make it as default for GV7013
                  WriteU8Reg(0x48a, 0xEA);   //the same as current default value
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 57  

                  WriteU8Reg(0x48b, 0x00);
                  WriteU8Reg(0x484, 0x52);
                  WriteU8Reg(0x478, 0x11);
                  WriteU8Reg(0x483, 0x33);
                WriteU8Reg(0x4E0, 0xFF);
                WriteU8Reg(0x4DF, 0xFF);
                  //[YM] add new setting value for LED, 01-09-2014
                  WriteU8Reg(0x4F0, 0x80);  //Turn off SCO in PHY, Extend Range
              #endif
3386   1          // Force Hybrid Mode  
3387   1      //    WriteU8Reg(0x4EB, 0x18);  
3388   1      
3389   1      
3390   1          // Reset/Init Statistics
3391   1          HHAL_ResetPlcStat();
3392   1         
3393   1          //WriteU8Reg(0xF07,0x01);           // csma 
3394   1      #ifndef B_ASICPLC
                  WriteU8Reg(0x423,0xC3);
              ////////////////////////////////////////////////////////////////
                 //WriteU8Reg(0xF07,0x01);
                 //WriteU8Reg(0xF06,0x00);
              #else
3400   1         //WriteU8Reg(0xF07,0xC1);
3401   1         //WriteU8Reg(0xF06,0x00);
3402   1         WriteU8Reg(0x423,0x81);
3403   1      #endif
3404   1         
3405   1          HHAL_AFEInit();
3406   1      
3407   1      //Set default Rx power mode to 1 - Reduce ADC power consumption
3408   1          mac_utils_spi_write(0x26, 0x1C);   //added by Yiming, 0211-2013
3409   1      
3410   1        // init CP Map
3411   1        for (i = 0; i < HYBRII_CPCOUNT_MAX; i++)
3412   1        {
3413   2          uPlcCpMapIdx plcCpMapIdx;
3414   2          uPlcCpMap plcCpMap;
3415   2      //    uPlcCpuWrCp plcCpuWrCp;
3416   2      
3417   2          plcCpMapIdx.reg = 0;
3418   2          plcCpMapIdx.s.cp_map_idx = i;
3419   2          WriteU32Reg(CPU_CPUSAGECNTIDX_REG, plcCpMapIdx.reg);
3420   2      
3421   2          plcCpMap.reg = 0;
3422   2          plcCpMap.s.cp_map = 1;
3423   2          WriteU32Reg(CPU_CPUSAGECNT_REG, plcCpMap.reg);
3424   2      
3425   2      //    CHAL_DecrementReleaseCPCnt(i);
3426   2        }
3427   1      //    WriteU32Reg(PLC_LINECTRL_REG,ctorl(0x400));
3428   1      
3429   1        // init Hang Counter Int.
3430   1        plcSMCnt.reg = RTOCL(PLC_SM_MAX_CLK_CNT);
3431   1        plcSMCnt.s.enable = TRUE;
3432   1        WriteU32Reg(PLC_SM_MAXCNT, plcSMCnt.reg);
3433   1          
3434   1      // [YM] For Hybrii_B LLP LED project
3435   1      #ifdef POWERSAVE_NO
                  byteVal = ReadU8Reg(0x422);
                byteVal |= 0x8;
                  WriteU8Reg(0x422,byteVal);
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 58  

              #endif
3440   1      }
3441          
3442              
3443          void HHAL_ResetPlcStat()
3444          {   
3445   1          memset(&gHpgpHalCB.halStats, 0, sizeof(shpgpHalStats));
3446   1          
3447   1          // Clear Err Count registers
3448   1          WriteU32Reg(PLC_ADDRFILTERERRCNT_REG, 0);
3449   1          WriteU32Reg(PLC_FCCSERRCNT_REG, 0);
3450   1          WriteU32Reg(PLC_PBCSRXERRCNT_REG, 0);
3451   1          WriteU32Reg(PLC_PBCSTXERRCNT_REG, 0);
3452   1          WriteU32Reg(PLC_ICVERRCNT_REG, 0);  
3453   1          WriteU32Reg(PLC_MPDUDROPCNT_REG, 0);  
3454   1        
3455   1        gHalCB.qc_no_1st_desc = 0; 
3456   1        gHalCB.qc_too_many_desc = 0; 
3457   1        gHalCB.qc_no_desc = 0; 
3458   1        gHalCB.qc_no_grant = 0; 
3459   1          gHalCB.cp_no_grant_alloc_cp = 0;
3460   1          gHalCB.cp_no_grant_free_cp = 0;
3461   1          gHalCB.cp_no_grant_write_cp = 0;
3462   1          gHalCB.cp_no_grant_read_cp = 0;
3463   1      }
3464          
3465          // Internal functios 
3466          
3467          void hhal_setStaSnidValid()
3468          {
3469   1          uPlcDevCtrlReg plcDevCtrl;
3470   1      
3471   1          if(gHpgpHalCB.devMode == DEV_MODE_STA)
3472   1          {
3473   2              plcDevCtrl.reg = ReadU32Reg(PLC_DEVCTRL_REG);
3474   2              plcDevCtrl.s.snidValid = 1;
3475   2              WriteU32Reg(PLC_DEVCTRL_REG, plcDevCtrl.reg);
3476   2          }   
3477   1      }
3478          
3479          void hal_hpgp_mac_monitoring (void)
3480          {
3481   1          u32             sm_status1;
3482   1          u32             sm_status2;
3483   1      
3484   1          uPlcMedStatReg  plcMedStat;
3485   1      
3486   1      /*    if(gHpgpHalCB.halStats.bcnSyncCnt == 1 && ReadU32Reg(PLC_FCCSERRCNT_REG)!=0)
3487   1          {
3488   1              // Reset mpi Rx
3489   1              HHAL_mpiRxReset();
3490   1              //FM_Printf(FM_MINFO,"Resetting Mpi Rx\n");
3491   1          }*/
3492   1          if (gHpgpHalCB.halStats.macTxStuckCnt > 1000) {
3493   2              //printf("\nMAC Tx Stucked");
3494   2          }
3495   1          if (gHpgpHalCB.halStats.macRxStuckCnt > 1000) {
3496   2              //printf("\nMAC Rx Stucked");
3497   2          }
3498   1          //sm_status1 = ReadU32Reg(PLC_SMSHADOW1_REG);// & 0x00003fff;
3499   1          sm_status1 =  hal_common_reg_32_read(PLC_SMSHADOW1_REG);
3500   1          sm_status2 = ReadU32Reg(PLC_SMSHADOW2_REG); //& 0x03ffffff;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 59  

3501   1      
3502   1          if (sm_status1 == 0 && sm_status2 == 0) {
3503   2              plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG);
3504   2              if (plcMedStat.s.phyActive) {
3505   3                  gHpgpHalCB.halStats.phyStuckCnt++;
3506   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3507   4                      //printf("\nPhy Stucked");
3508   4                      // gHpgpHalCB.halStats.macHangRecover1++;
3509   4                      //gHpgpHalCB.halStats.macRxStuckCnt = 0;
3510   4                      /*
3511   4                       * MAC is idle but Phy is stuck. Reset the PHY
3512   4                       * by dropping RX Enable
3513   4                       */
3514   4                      //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3515   4                      //plcStatus.s.nRxEn = 1;
3516   4                      //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3517   4                  }
3518   3              } else {
3519   3                  gHpgpHalCB.halStats.phyStuckCnt = 0;
3520   3              }
3521   2              if (plcMedStat.s.mpiRxEn == 0) {
3522   3                  gHpgpHalCB.halStats.mpiRxStuckCnt++;
3523   3                  if (gHpgpHalCB.halStats.phyStuckCnt++ > 500) {
3524   4                      //printf("\nMPI RX Stucked");
3525   4                  }
3526   3              } else {
3527   3                  gHpgpHalCB.halStats.mpiRxStuckCnt = 0;
3528   3              }
3529   2          } else {
3530   2              if (sm_status2 != 0) {
3531   3                  gHpgpHalCB.halStats.smTxStuckCnt++;
3532   3                  if (gHpgpHalCB.halStats.smTxStuckCnt > 1000) {
3533   4                      //printf("\nSM TX Stucked");
3534   4                  }
3535   3              } else {
3536   3                  gHpgpHalCB.halStats.smTxStuckCnt = 0;
3537   3              }
3538   2              if (sm_status1 != 0) {
3539   3                  gHpgpHalCB.halStats.smRxStuckCnt++;
3540   3                  if (gHpgpHalCB.halStats.smRxStuckCnt > 1000) {
3541   4                     // printf("\nSM RX Stucked");
3542   4                  }
3543   3              } else {
3544   3                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
3545   3              }
3546   2          }
3547   1      }
3548          
3549          #ifndef HPGP_HAL_TEST
3550          
3551          eStatus  HHAL_BcnRxIntHandler(sHaLayer *hal, sEvent *event)
3552          {
3553   1          sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
3554   1          u32              *pValue32 = NULL;
3555   1          u32               value32 = 0;
3556   1          sHybriiRxBcnHdr*  pRxBcnHdr = NULL;
3557   1          u8                i;
3558   1          uPlcStatusReg     plcStatus;
3559   1          eStatus           ret = STATUS_SUCCESS;
3560   1          sHpgpHdr         *hpgpHdr = NULL;
3561   1          sHpgpHalCB       *hhalCb = hal->hhalCb;
3562   1        u8         *rxArr;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 60  

3563   1          u8               u8val;
3564   1          
3565   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3566   1      
3567   1          hhalCb->halStats.BcnRxIntCnt++;
3568   1      
3569   1          //FM_Printf(FM_MINFO, "HHAL_BcnRxIntHandler : Bcn received, SnapShot = %bu, Id = %lX\n", pRxBcnHdr->sn
             -apShot, rtocl(ReadU32Reg(PLC_IDENTIFIER_REG)));
3570   1      
3571   1          // Confirm that Bcn Rx Fifo is not emplty.
3572   1          // plcStatus.s.bcnRxFifoStat;
3573   1          /* read the beacon Rx descriptor first */
3574   1          value32 = ReadU32Reg(PLC_BCNRXFIFO_REG);
3575   1          pRxBcnHdr = (sHybriiRxBcnHdr*)&value32;
3576   1          hhalCb->snapShot = pRxBcnHdr->snapShot;
3577   1          /* then, read the beacon */
3578   1        pValue32  = (u32 *)(event->buffDesc.dataptr);
3579   1      #ifdef UM
3580   1        if(1 == eth_plc_sniffer)
3581   1        {
3582   2            pValue32  += ((sizeof(sEth2Hdr) + sizeof(hostHdr_t)) / sizeof(u32)); // Ethernet header + Hybrii head
             -er
3583   2        }
3584   1      #endif
3585   1      
3586   1        for ( i = 0; i < (BEACON_LEN >> 2); i++)
3587   1          {
3588   2              pValue32[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
3589   2          }
3590   1        event->buffDesc.datalen = BEACON_LEN;
3591   1          //plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3592   1          //plcStatus.s.decBcnRxCnt = 1;
3593   1          //WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
3594   1          u8val = ReadU8Reg(PLC_STATUS_REG+1);
3595   1        u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
3596   1        WriteU8Reg(PLC_STATUS_REG+1, u8val);
3597   1        rxArr = event->buffDesc.dataptr;
3598   1      #ifdef UM 
3599   1      #ifdef HYBRII_ETH
                if(1 == eth_plc_sniffer)
                {
                    EHT_FromPlcBcnTx(rxArr, PLC_BCNRX_LEN);
                }
                else
              #endif
3606   1      #endif
3607   1          {
3608   2              // Update statistics.
3609   2      
3610   2                  /* TODO: if consective good beacons are received */
3611   2      
3612   2      
3613   2              if(pRxBcnHdr->fccsCorrect)
3614   2              {
3615   3                  hhalCb->bcnDetectFlag = 1;
3616   3                  pFrmCtrlBlk = (sFrmCtrlBlk*) (event->buffDesc.dataptr);
3617   3                  hhalCb->bts = ((u32)(pFrmCtrlBlk->bts[3])<<24) + 
3618   3                                ((u32)(pFrmCtrlBlk->bts[2])<<16) + 
3619   3                                ((u32)(pFrmCtrlBlk->bts[1])<<8) + 
3620   3                                 (u32)(pFrmCtrlBlk->bts[0]);                      
3621   3                  /* TODO: Adjust NTB in the device */
3622   3                     gCCO_NTB =  hhalCb->bts;   
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 61  

3623   3      
3624   3                     gHpgpHalCB.bcnmisscnt = 0;
3625   3                     gCCO_BTS =  hhalCb->bts;
3626   3          // Extract Bto, ded
3627   3          
3628   3      //            HHAL_AdjustNextBcnTime(hal, pFrmCtrlBlk->bto);
3629   3              }
3630   2              // Update statistics.
3631   2              if (pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && 
3632   2                  !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && 
3633   2                  !pRxBcnHdr->rsv3 && !pRxBcnHdr->rsv4 )  
3634   2              {  
3635   3                  hhalCb->halStats.TotalRxGoodFrmCnt++;
3636   3                  hhalCb->halStats.RxGoodBcnCnt++;
3637   3      
3638   3                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
3639   3              //            hpgpHdr->tei = rxdesc->ste;
3640   3                  hpgpHdr->snid = pFrmCtrlBlk->snid;
3641   3                  {
3642   4                      event->buffDesc.dataptr += sizeof(sFrmCtrlBlk); 
3643   4                      event->buffDesc.datalen -= sizeof(sFrmCtrlBlk); 
3644   4                      /* process the high priority portion of the beacon */
3645   4      #ifdef CALLBACK
                              hal->procBcn(hal->bcnCookie, event);
              #else
3648   4                      if (hhalCb->devMode == DEV_MODE_CCO)
3649   4                      {
3650   5      #ifdef CCO_FUNC
3651   5                          LINKL_CcoProcBcnHandler(hal->bcnCookie, event, hhalCb->bts);
3652   5      #endif
3653   5                      }
3654   4                      else 
3655   4                      {
3656   5      #ifdef STA_FUNC
3657   5                          LINKL_StaProcBcnHandler(hal->bcnCookie, event, hhalCb->bts);
3658   5      #endif
3659   5                      }
3660   4      #endif
3661   4                  }
3662   3              } 
3663   2              else
3664   2              {
3665   3                  hhalCb->halStats.RxErrBcnCnt++;
3666   3                  /* bad beacon is received, thus the beacon is lost */
3667   3                  /* TODO: adjust the next becaon period using bto */
3668   3                  hhalCb->bcnDetectFlag = 0;
3669   3                  ret = STATUS_FAILURE;
3670   3              }
3671   2      
3672   2          }
3673   1          // Any more beacons ?
3674   1      //    plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3675   1      
3676   1          return ret;
3677   1      }
3678          
3679          u8 HHAL_GetBcnCnt()
3680          {
3681   1          uPlcStatusReg     plcStatus;
3682   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
3683   1          return plcStatus.s.plcBcnCnt;
3684   1      }
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 62  

3685          
3686          
3687          
3688          eStatus HHAL_PrepareTxFrame(sHaLayer *hal, sTxDesc *txInfo, 
3689                                      sSwFrmDesc *txFrmSwDesc)
3690          {
3691   1          //FM_Printf(FM_MINFO, ">>>PrepareTxFrame:\n");
3692   1      
3693   1          if(txInfo->mnbc)
3694   1          {
3695   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
3696   2          }
3697   1          else if ((txInfo->mcst == 1) || (txInfo->dtei == 0xFF))
3698   1          {
3699   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
3700   2          }   
3701   1          else
3702   1          {
3703   2              txFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
3704   2          }
3705   1        
3706   1      //printf("HHAL_PrepareTxFrame=%bu, txInfo->dtei=%bu\n", HHAL_PrepareTxFrame, txInfo->dtei);
3707   1          txFrmSwDesc->frmInfo.plc.dtei = txInfo->dtei;
3708   1          txFrmSwDesc->frmInfo.plc.stei = hal->hhalCb->tei;
3709   1          txFrmSwDesc->frmInfo.plc.eks = txInfo->eks;
3710   1      
3711   1          txFrmSwDesc->frmInfo.plc.clst = HPGP_CLST_ETH;
3712   1          txFrmSwDesc->frmInfo.plc.plid = txInfo->plid;
3713   1          txFrmSwDesc->frmInfo.plc.mfStart = txInfo->mfStart;
3714   1          txFrmSwDesc->frmInfo.plc.mfEnd = txInfo->mfEnd;
3715   1         
3716   1          if (txInfo->plid == PRI_LINK_ID_0) 
3717   1              txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP0;
3718   1          else
3719   1              txFrmSwDesc->frmInfo.plc.phyPendBlks = HPGP_PPB_CAP123;
3720   1      
3721   1          txFrmSwDesc->frmInfo.plc.roboMode = txInfo->roboMode;
3722   1      
3723   1      
3724   1        txFrmSwDesc->frmInfo.plc.snid = txInfo->snid;
3725   1      
3726   1      
3727   1      #if 0
                  if (txInfo->roboMode == HPGP_ROBOMD_MINI)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_136;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_MINIROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else if (txInfo->roboMode == HPGP_ROBOMD_STD)
                  {
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      txFrmSwDesc->frmInfo.plc.flav = HPGP_STDROBO_FLAV;
                      txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                  }
                  else
                  {
                      /* HS ROBO */
                      txFrmSwDesc->frmInfo.plc.roboMode = HPGP_ROBOMD_HS;
                      txFrmSwDesc->frmInfo.plc.pbsz = HPGP_PHYBLKSIZE_520;
                      if (txInfo->numPbs == 1)
                      {
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 63  

                          txFrmSwDesc->frmInfo.plc.flav = HPGP_1PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_ONE_PB;
                      }
                      else if (txInfo->numPbs == 2)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_2PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_TWO_PB;
                      }
                      else if (txInfo->numPbs == 3)
                      {
                          txFrmSwDesc->frmInfo.plc.flav = HPGP_3PBHSROBO_FLAV;
                          txFrmSwDesc->frmInfo.plc.numPBs = PLC_THREE_PB;
                      }
                      else 
                      {
                          FM_Printf(FM_ERROR,"HHAL: PB Num Err");
                          return STATUS_FAILURE;
                      }
                  }
              #endif
3767   1      
3768   1          //FM_Printf(FM_MINFO, "<<<PrepareTxFrame:\n");
3769   1      
3770   1          return STATUS_SUCCESS;      
3771   1      }
3772          
3773          #endif
3774          
3775          
3776          /*******************************************************************
3777          * NAME :            HHAL_AdjustNextBcnTime
3778          *
3779          * DESCRIPTION :     The function is called at STA side passing the bto as input.
3780          *                   It adjusts the BP Length based on the 2's complement bto value
3781          *                   that CCo sends in the FC.bto[0] field.
3782          *
3783          */
3784          void HHAL_AdjustNextBcnTime(u16 *bto)
3785          {
3786   1          u16 btoVal = le16_to_cpu(*bto);
3787   1          if (gHpgpHalCB.lineMode == LINE_MODE_AC)
3788   1          {   
3789   2              // bto is a negative 2's complement value.
3790   2              if( btoVal > 0x8000)
3791   2              {
3792   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN - (0x10000 - btoVal);
3793   3              }
3794   2      
3795   2              // bto is a positive 2's complement value
3796   2              else if( btoVal != 0x8000)
3797   2              {
3798   3                  gHpgpHalCB.curBcnPer = PLC_AC_BP_LEN + btoVal;       
3799   3              }
3800   2              
3801   2              //printf("bpLen = %lx, bto=%bx%02bx, %x\n", gHpgpHalCB.curBcnPer, pFrmCtrlBlk->bto0[1], pFrmCtrlBl
             -k->bto0[0], bto);
3802   2      
3803   2              if(gHpgpHalCB.devMode == DEV_MODE_STA)
3804   2              {
3805   3                  WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
3806   3            WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gHpgpHalCB.curBcnPer >> 1))); // HW multiples it by 2
3807   3      
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 64  

3808   3              }
3809   2          }
3810   1          else
3811   1          {
3812   2              gHpgpHalCB.curBcnPer = PLC_DC_BP_LEN;
3813   2          }
3814   1      }
3815          
3816          #ifdef UM 
3817               
3818          eStatus CHAL_WriteFrame(sSwFrmDesc *txFrmSwDesc,sBuffDesc *buffdesc)
3819          {
3820   1          s16 resLen = buffdesc->datalen;
3821   1          u8  numCps = txFrmSwDesc->cpCount;
3822   1          u16 cellLen = 0;
3823   1          u8  i = 0;
3824   1          u8  *dataptr = buffdesc->dataptr;
3825   1          volatile u8 XDATA *cellBlk = NULL;
3826   1          sCpSwDesc *cpDesc = NULL;
3827   1      
3828   1      
3829   1          while ((resLen > 0) && (i < numCps))
3830   1          {
3831   2              cpDesc = &txFrmSwDesc->cpArr[i];
3832   2              cellBlk = CHAL_GetAccessToCP(cpDesc->cp);
3833   2              cellLen = MIN(HYBRII_CELLBUF_SIZE, resLen);
3834   2              memcpy (cellBlk, dataptr, cellLen);
3835   2              cpDesc->offsetU32 = 0; 
3836   2              cpDesc->len = (u8)cellLen; 
3837   2              dataptr += cellLen;
3838   2              resLen -= cellLen;
3839   2              i++;
3840   2          }
3841   1      
3842   1          if ((resLen > 0) && (i >= numCps))
3843   1          {
3844   2           //   FM_Printf(FM_ERROR, "CHAL: frame len and cp number mismatch.\n");
3845   2          }
3846   1          return STATUS_SUCCESS;
3847   1      }
3848          
3849          #endif
3850          
3851          
3852          void doSynchronization()
3853          {
3854   1           
3855   1         u32 zcCCONTB;
3856   1           
3857   1           zcCCONTB =  rtocl(ReadU32Reg(PLC_ZCNTB_REG));
3858   1      
3859   1      
3860   1           if(firsttime == 0)
3861   1           {
3862   2              firsttime = 1;
3863   2              zcCCONTBold = zcCCONTB; 
3864   2              return;
3865   2           }
3866   1      
3867   1         gHpgpHalCB.syncComplete = 1;
3868   1         
3869   1           if(zcCCONTB > zcCCONTBold)
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 65  

3870   1              gHpgpHalCB.curBcnPer   = (zcCCONTB - zcCCONTBold);
3871   1           
3872   1      
3873   1           if((gHpgpHalCB.lineMode == LINE_MODE_AC) && (gHpgpHalCB.curBcnPer  < AC_MIN_THRESHOLD))
3874   1           {
3875   2              return;
3876   2           } 
3877   1           
3878   1           zcCCONTBold = zcCCONTB; 
3879   1            
3880   1          if( gHpgpHalCB.devMode == DEV_MODE_CCO && gHpgpHalCB.lineMode == LINE_MODE_AC )
3881   1          {
3882   2              
3883   2              //printf("\n BP = %lu", (gHpgpHalCB.curBcnPer * 40));
3884   2              if( gHpgpHalCB.curBcnPer < PLC_MIN_AC_BPLEN )
3885   2              {
3886   3                  gHpgpHalCB.curBcnPer = PLC_MIN_AC_BPLEN;
3887   3              }
3888   2              else if( gHpgpHalCB.curBcnPer > PLC_MAX_AC_BPLEN )
3889   2              {
3890   3                  gHpgpHalCB.curBcnPer = PLC_MAX_AC_BPLEN;
3891   3              }
3892   2      
3893   2              gHpgpHalCB.bcnPerSum += gHpgpHalCB.curBcnPer;
3894   2              gHpgpHalCB.perSumCnt ++;
3895   2      
3896   2              if( gHpgpHalCB.perSumCnt == PLC_BCNPERAVG_CNT )
3897   2              {
3898   3                  gHpgpHalCB.bPerAvgInitDone = 1;
3899   3                  avgdone = 1;
3900   3              }
3901   2             
3902   2              if(avgdone)
3903   2              {
3904   3                   avgdone = 0;
3905   3                   gavg       = gHpgpHalCB.bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
3906   3                   gHpgpHalCB.bcnPerSum = 0;
3907   3                   gHpgpHalCB.perSumCnt = 0;
3908   3              }
3909   2              WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl((gavg >> 1)));
3910   2               
3911   2           }
3912   1      
3913   1          // Prepare and send beacon here for now.
3914   1          // This will eventually be done by hpgp nsm module.
3915   1              if(gHpgpHalCB.lineMode == LINE_MODE_DC)
3916   1              {
3917   2                  gHpgpHalCB.bPerAvgInitDone = 1;
3918   2                   gavg       =   PLC_DC_BP_LEN; 
3919   2              }
3920   1      
3921   1            if(gHpgpHalCB.bPerAvgInitDone)
3922   1          {
3923   2                
3924   2              if(gHpgpHalCB.devMode == DEV_MODE_CCO)
3925   2            {
3926   3             
3927   3                if(zctrack == 0)
3928   3                      {
3929   4                       
3930   4                          gbpst =  gavg  + zcCCONTB + MAC_PROCESSING_CLOCK ;// + 0x1BAFF;//1365 is bpsto
3931   4                          zctrack = 1;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 66  

3932   4                          WriteU32Reg(PLC_BPST_REG, ctorl(gbpst));
3933   4                     
3934   4                      }
3935   3                      else
3936   3                      {
3937   4                      
3938   4                           avgcount++;
3939   4                           if(zcCCONTB >  gbpst)
3940   4                           {
3941   5                              
3942   5                               if(gNegativeflag)
3943   5                               {
3944   6                                 gNegativeflag = 0;
3945   6                                 gPositiveflag = 1; 
3946   6                                
3947   6                               }
3948   5                               gBPSTdelta = zcCCONTB - gbpst;
3949   5                              
3950   5                              if(gBPSTdelta > 400)//16 micro sec
3951   5                              {
3952   6                                  
3953   6                                   gNegativeflag = 0;
3954   6                                   gPositiveflag = 1;
3955   6                               }
3956   5                              
3957   5                           }
3958   4                           else
3959   4                           {
3960   5                               if(gPositiveflag)
3961   5                               {
3962   6                                 gNegativeflag = 1;
3963   6                                 gPositiveflag = 0; 
3964   6                                
3965   6                               }
3966   5                               gBPSTdelta =  gbpst - zcCCONTB;
3967   5                               
3968   5                               if(gBPSTdelta > 400)//4 micro sec
3969   5                               {
3970   6                                  gNegativeflag = 1;
3971   6                                  gPositiveflag = 0;
3972   6                                 
3973   6                               }   
3974   5                              
3975   5                            }
3976   4                       
3977   4                       } 
3978   3                   }
3979   2               
3980   2            } 
3981   1      
3982   1      }  
3983          
3984          #ifdef FREQ_DETECT
3985          void FREQDET_DetectFrequencyUsingZC()
3986          {   
3987   1          static u8 count = 0;
3988   1          static u8 valid60Hz =0;
3989   1          static u8 valid50Hz =0;
3990   1          u32  zcCCONTB;
3991   1          static u32 zcCCONTBOld = 0;
3992   1          u32 linecyclePer;
3993   1          u8 freq;
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 67  

3994   1          
3995   1      //    uPlcMedInterruptReg PlcMedInterruptReg;
3996   1         
3997   1      #ifdef UM
3998   1          sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3999   1      #endif
4000   1          count++;
4001   1      
4002   1        
4003   1          zcCCONTB = rtocl(ReadU32Reg(PLC_ZCC_CCONTB_REG));
4004   1      
4005   1        if (count == 1)
4006   1        {
4007   2          zcCCONTBOld = zcCCONTB;
4008   2          return;
4009   2      
4010   2        }
4011   1          //zcCCONTB =  rtocl(ReadU32Reg(PLC_NTB_REG));
4012   1          linecyclePer = (((zcCCONTB - zcCCONTBOld) * 40) / 2);
4013   1           freq = (1000000000/ linecyclePer);
4014   1          // printf("\n freq = %lu\n", ((zcCCONTB - zcCCONTBOld) * 40)); 
4015   1          zcCCONTBOld = zcCCONTB;
4016   1         
4017   1      
4018   1          if((freq <= MAX_60HZ_FREQ) && (freq >= MIN_60HZ_FREQ))
4019   1          {
4020   2              valid60Hz++;
4021   2          }
4022   1          else if((freq <= MAX_50HZ_FREQ) && (freq >= MIN_50HZ_FREQ))
4023   1          {
4024   2                valid50Hz++;
4025   2          }
4026   1        else
4027   1        {
4028   2          printf("\nfl:%bu ", freq);
4029   2        }
4030   1       
4031   1      
4032   1          if(count == 8)
4033   1          { 
4034   2              //Retrycnt++;
4035   2      
4036   2          count = 0;
4037   2          
4038   2              gHpgpHalCB.gFreqCB.freqDetected = TRUE; 
4039   2              if(valid50Hz > FREQUENCY_ZC_MAX_COUNT)
4040   2              {
4041   3                
4042   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4043   3                  FREQDET_FreqSetting(FREQUENCY_50HZ);            
4044   3                  printf("\n50 HZ detected\n");
4045   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4046   3              }
4047   2              else if(valid60Hz > FREQUENCY_ZC_MAX_COUNT)
4048   2              {
4049   3                
4050   3                  //gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4051   3                  FREQDET_FreqSetting(FREQUENCY_60HZ);            
4052   3                  printf("\n60 HZ detected\n");
4053   3                  FM_Printf(FM_ERROR, "\n fre= %bu",freq); 
4054   3              }
4055   2              else
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 68  

4056   2              {
4057   3                 //do not set any default frequency ,insted keep on retrying and based on   gHpgpHalCB.gFreqCB.f
             -reqDetected flag Upper MAc will recognised that freq is not being detected for some problem
4058   3      #ifdef UM
4059   3                 //sHaLayer *hal = HOMEPLUG_GetHal();
4060   3             
4061   3                 printf("\n No Frequency detected" );
4062   3                 printf("\n switching to DC ...%bu ", freq);
4063   3                 
4064   3                 gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4065   3             
4066   3             gHpgpHalCB.lineMode = LINE_MODE_DC;
4067   3             gHpgpHalCB.lineFreq = FREQUENCY_50HZ;      
4068   3             
4069   3             HHAL_SetDevMode(gHpgpHalCB.devMode, LINE_MODE_DC);
4070   3             
4071   3             FREQDET_FreqSetting(gHpgpHalCB.lineFreq);
4072   3      #if 0 //def  MULTI_CCO_NW
                  //     linkl->ccoNsm.slotId = 0; TODO RAJAN should we comment it
              #endif
4075   3                 //gHpgpHalCB.gFreqCB.freqDetectUsingZC = TRUE;
4076   3      #endif
4077   3      
4078   3              }
4079   2      #ifdef UM
4080   2      #ifdef CCO_FUNC
4081   2              CNSM_InitRegion(&linkl->ccoNsm);
4082   2      #endif
4083   2      #else
                  
              if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                  setCSMA_onCCO();
              else
                  setCSMA_onSTA();
              
              #endif
4091   2      
4092   2             
4093   2          }
4094   1      }
4095          
4096          void FREQDET_DetectFrequencyUsingBcn(u8 snid)
4097          {
4098   1      #ifndef HPGP_HAL_TEST
4099   1          //sHaLayer *hal = HOMEPLUG_GetHal();
4100   1      #endif 
4101   1          u32     calcBCNper;
4102   1         // static u8 bcnCnt = 0;
4103   1      
4104   1         if ((!gHpgpHalCB.nwSelected) || (gHpgpHalCB.nwSelectedSnid != snid))
4105   1          {
4106   2          return;
4107   2          }
4108   1         
4109   1          calcBCNper = gCCO_BTS - gOldBTS;
4110   1      
4111   1          //printf("\n bp = %lu", calcBCNper);
4112   1          gOldBTS = gCCO_BTS;
4113   1         // bcnCnt++;
4114   1      
4115   1       
4116   1              if(gHpgpHalCB.halStats.BcnSyncCnt >= FREQUENCY_BCN_MAX_COUNT)   //set the frequency after syncing 
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 69  

             -four bcns
4117   1              {
4118   2                  if(((calcBCNper * 40) > MIN_50HZ_BCNPER) && ((calcBCNper * 40) < MAX_50HZ_BCNPER))//38 ms   it
             - is 50 Hz that means bcnper is 40 ms
4119   2                  {                
4120   3                      //gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4121   3                      FREQDET_FreqSetting(FREQUENCY_50HZ);                
4122   3                      printf("\n BCN 50 HZ detected\n");
4123   3                     // bcnCnt = 0;
4124   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4125   3      
4126   3                  }
4127   2                  else if(((calcBCNper * 40) < MIN_50HZ_BCNPER))//33.33 ms , 60 hz
4128   2                  {             
4129   3                     // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4130   3                      printf("\n bp = %lu",(calcBCNper * 40));
4131   3      
4132   3                      FREQDET_FreqSetting(FREQUENCY_60HZ);                
4133   3                      printf("\nBCN 60 HZ detected\n");
4134   3                      //bcnCnt = 0;
4135   3                      gHpgpHalCB.gFreqCB.freqDetected = TRUE;
4136   3                    
4137   3                  }
4138   2              }
4139   1          
4140   1      
4141   1      }
4142          //#endif 
4143          
4144          //#ifdef FREQ_DETECT
4145          void FREQDET_FreqDetectInit(void)
4146          {    
4147   1         // gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4148   1         // gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4149   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4150   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4151   1          //HHAL_SetPlcDevMode(STA_CSMANW);
4152   1         
4153   1      //   gHpgpHalCB.bcnInitDone =1;
4154   1          //HHT_DevCfg();
4155   1      
4156   1      }
4157          
4158          void FREQDET_FreqDetectReset(void)
4159          {    
4160   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingBcn = FALSE;
4161   1        //  gHpgpHalCB.gFreqCB.freqDetectUsingZC = FALSE;
4162   1          gHpgpHalCB.gFreqCB.freqDetected = FALSE;
4163   1      
4164   1         // gHpgpHalCB.gFreqCB.frequency = FREQUENCY_50HZ; // 50Hz
4165   1      }
4166          
4167          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14364    ----
   CONSTANT SIZE    =    473    ----
   XDATA SIZE       =    569     404
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   HAL_HPGP                                                          11/04/2015 20:09:42 PAGE 70  

   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
