C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NAM
OBJECT MODULE PLACED IN .\obj\nam.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\link\nam.c LARGE OBJECTADVANCED OPTIMIZE(9
                    -,SPEED) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\.
                    -.\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\
                    -hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\f
                    -irmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigb
                    -ee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\i
                    -nc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\
                    -inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support
                    -;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\driver
                    -s\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;.
                    -.\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..
                    -\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\driver
                    -s\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utiliti
                    -es;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\
                    -nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\.
                    -.\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRI
                    -I_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYN
                    -C,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DE
                    -TECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRU
                    -PT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,RE
                    -GISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\nam.lst) TABS(2) OBJ
                    -ECT(.\obj\nam.obj)

line level    source

   1          /** ==========================================================
   2           *
   3           * @file cnam.c
   4           * 
   5           *  @brief Network Access Manager 
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * =========================================================*/
  11          
  12          #include <string.h>
  13          #include <assert.h>
  14          #include "papdef.h"
  15          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  18          #include "list.h"
  19          #include "hpgpdef.h"
  20          #include "hal.h"
  21          #include "nma.h"
  22          #include "linkl.h"
  23          #include "nam.h"
  24          #include "nsm.h"
  25          #include "crm.h"
  26          #include "timer.h"
  27          #include "stm.h"
  28          #include "hpgpevt.h"
  29          #include "nma.h"
  30          #include "nma_fw.h"
  31          #include "hpgpapi.h"
  32          #include "fm.h"
  33          #include "muxl.h"
  34          #include "hal.h"
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 2   

  35          #include "frametask.h"
  36          #include "linkl.h"
  37          #ifdef SIMU
              #include "sdrv.h"
              #endif
  40          #ifdef UM
  41          #include "gv701x_osal.h"
  42          #endif
  43          #include "hybrii_tasks.h"
  44          #include "sys_common.h"
  45          #include "hpgp_msgs.h"
  46          #include "event_fw.h"
  47          
  48          
  49          //#define HPGP_TIME_TEI_REUSE        300000  //5 minutes
  50          //#define HPGP_TIME_TEI_REUSE        6000  //5 minutes
  51          #define HPGP_TIME_TEI_REUSE       50  //5 minutes
  52          
  53          #define HPGP_TIME_USER_APPT_CCO    60000   //1 minute
  54          #define HPGP_TIME_ASSOC            1000     //100 ms
  55          #define HPGP_IDENTIFY_CAP_TIME               500
  56          
  57          #ifdef KEEP_ALIVE
  58          #define HPGP_TIME_KEEP_ALIVE      2000 //30000 // 30sec
  59          #define KEEP_ALIVE_HIT_COUNT      3
  60          #endif
  61          
  62          //15 minutes: default lease time for STA associated but not authenticated
  63          #define HPGP_TIME_TEI_LEASE_NOAUTH_MIN        1//0x0F 
  64          //48 hours: default lease time for STA associated and authenticated
  65          #define HPGP_TIME_TEI_LEASE_AUTH_MIN          0xB40 
  66          
  67          
  68          #define HPGP_ASSOC_RESULT_SUCCESS         0   //resource found/allocated
  69          #define HPGP_ASSOC_RESULT_TEMP_NO_RES     1   //resource temporarily exhausted
  70          #define HPGP_ASSOC_RESULT_NO_RES          2   //resource permanently exhausted
  71          #define HPGP_ASSOC_RESULT_UNKNOWN         3   //due to other reason
  72          
  73          
  74          #define HPGP_TEI_MAP_MODE_NEW             0   // new STA
  75          #define HPGP_TEI_MAP_MODE_ADD             1   // add STA
  76          #define HPGP_TEI_MAP_MODE_DELETE          2   // add STA
  77          
  78          #define HPGP_TEI_MAP_STATUS_ASSOC         0x0
  79          #define HPGP_TEI_MAP_STATUS_AUTH          0x1
  80          #define HPGP_TEI_MAP_STATUS_DISASSOC      0x2
  81          #define HPGP_TEI_MAP_STATUS_INVALID       0xFF
  82          
  83          
  84          #define HPGP_CCO_APPT_REQ_APPT_HO      0x00   //Appoint CCo and handover
  85          #define HPGP_CCO_APPT_REQ_UNAPPT       0x01   //unappoint
  86          #define HPGP_CCO_APPT_REQ_UNAPPT_HO    0x01   //unappoint CCo and handover
  87          
  88          //CCO APPOINT CNF RESULT
  89          #define HPGP_CCO_APPT_CNF_ACCEPT       0x00   //accept
  90          #define HPGP_CCO_APPT_CNF_REJECT       0x01   //reject
  91          #define HPGP_CCO_APPT_CNF_UNKNOWN_STA  0x02   //unknown user-appointed STA
  92          #define HPGP_CCO_APPT_CNF_APPT_CCO     0x03   //CCO is user appointed already
  93          #define HPGP_CCO_APPT_CNF_CCO_UNAPPT   0x04   //CCo is unappointed  
  94          #define HPGP_CCO_APPT_CNF_CCO_NOT_APPT 0x05   //CCo is not user-appointed 
  95          #define HPGP_CCO_APPT_CNF_OTHERS       0x06   //unknown user-appointed STA
  96          #define HPGP_CCO_APPT_CNF_UNAPPT_HO    0x07   //CCo is unappointed and handover
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 3   

  97          #define HPGP_CCO_APPT_CNF_UNKNOWN_STA2 0x08   //unknown user-appointed STA and
  98                                                        //continue as a user-appointed CCo
  99          
 100          #define HPGP_CCO_BACKUP_REQ_APPOINT    0
 101          #define HPGP_CCO_BACKUP_REQ_RELEASE    1
 102          #ifdef LOG_FLASH
              extern u16 scbFreeReason;
              #endif
 105          /* --------------------------
 106           * CCO network access manager
 107           * -------------------------- */
 108          
 109          
 110          
 111          typedef struct backupCCoParam
 112          {
 113              u8    dstTei;         //destination STA
 114              u8   *dstMacAddr;     //adestination STA
 115              u8    action;
 116          } sBackupCCoParam;
 117          
 118          
 119          typedef struct assocCnfParam
 120          {
 121              u8    result;
 122              u8    staTei;
 123              u16   teiLeaseTime;
 124              u8    dstTei;         //destination STA
 125              u8   *dstMacAddr;     //adestination STA
 126          } sAssocCnfParam;
 127          
 128          typedef struct leaveIndParam
 129          {
 130              u8    reason;
 131              u8    dstTei;         //destination STA
 132              u8   *dstMacAddr;     //destination STA
 133          } sLeaveIndParam;
 134          
 135          
 136          typedef struct leaveCnfParam
 137          {
 138              u8    dstTei;         //destination STA
 139              u8   *dstMacAddr;     //destination STA
 140          } sLeaveCnfParam;
 141          
 142          
 143          typedef struct teiMapIndParam
 144          {
 145              u8    mode;   
 146              u8    staTei;         //add or delete STA
 147              u8   *staMacAddr;     //add or delete STA
 148              u8    staStatus;      //add or delete STA
 149              u8    dstTei;         //destination STA
 150              u8   *dstMacAddr;     //destination STA
 151          } sTeiMapIndParam;
 152          
 153          typedef struct ccoApptCnfParam
 154          {
 155              u8    result;
 156              u8    dstTei;         //destination STA
 157              u8   *dstMacAddr;     //destination STA
 158          } sCcoApptCnfParam;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 4   

 159          
 160          typedef union mgmtMsgParamRef
 161          {
 162              sAssocCnfParam  *assocCnf;
 163              sLeaveIndParam  *leaveInd;  
 164              sLeaveCnfParam  *leaveCnf;  
 165              sTeiMapIndParam *teiMapInd;
 166              sCcoApptCnfParam *ccoApptCnf;
 167            sBackupCCoParam  *ccoBackupReq;
 168          } uMgmtMsgParamRef;
 169          
 170          extern void LINKL_TimerHandler(u16 type, void *cookie);
 171          #ifdef ROUTE
              extern void ROUTE_preparteAndSendUnreachable(sScb *scb);
              extern eStatus ROUTE_sendRouteInfoReq(sScb *scb);
              extern void ROUTE_initLrtEntry(sScb *scb);
              #endif
 176          extern eStatus IDENTIFY_sendFrm(u16 mmType, sEvent *reqEvent, sScb *scb);
 177          extern eStatus IDENTIFY_procFrm(u16 mmType, sEvent *reqEvent);
 178          extern eStatus NMA_SendCcoApptCnf(sNma *nma, u8 result);
 179          
 180          #ifdef CCO_FUNC
 181          
 182          //#define FM_Printf(x,y,z)   
 183          
 184          eStatus CNAM_SendMgmtMsg(sCnam *cnam, u16 mmType, void *msgParam)
 185          {
 186   1          eStatus           status = STATUS_FAILURE;
 187   1          sEvent        xdata    *newEvent = NULL;
 188   1          sHpgpHdr          *hpgpHdr = NULL;
 189   1          sCcAssocCnf       *assocCnf = NULL;
 190   1          sCcLeaveInd       *leaveInd = NULL;
 191   1          sTeiMap           *teiMap = NULL;
 192   1          sCcTeiMapInd      *teiMapInd = NULL;
 193   1          sCcCcoApptCnf     *ccoApptCnf = NULL;
 194   1        sCcBackupReq      *ccoBackUpReq = NULL;
 195   1          uMgmtMsgParamRef   mgmtMsgParam;
 196   1          sScb              *scbIter = NULL;
 197   1          u8                *dataptr = NULL;
 198   1          u16                freeLen = 0;
 199   1          u8                 numSta = 0;
 200   1          u16                eventSize = 0;
 201   1      //    sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 202   1          sLinkLayer        *linkl = cnam->linkl;
 203   1          sStaInfo          *staInfo = LINKL_GetStaInfo(linkl);
 204   1          
 205   1        //FM_HexDump(FM_USER,"cMtype",(u8*)&mmType, 2);
 206   1      
 207   1          switch(mmType)
 208   1          {
 209   2              case EVENT_TYPE_CC_ASSOC_CNF:
 210   2              {
 211   3      #ifdef LOG_FLASH
                          u8 buff[2];
              #endif
 214   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sCcAssocCnf)); 
 215   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
 216   3                  if(newEvent == NULL)
 217   3                  {
 218   4                      //FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 219   4                      return STATUS_FAILURE;
 220   4                  }
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 5   

 221   3                  mgmtMsgParam.assocCnf = (sAssocCnfParam *)msgParam;
 222   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 223   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_ASSOC_CNF;
 224   3      
 225   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 226   3                  hpgpHdr->tei =  mgmtMsgParam.assocCnf->dstTei; //TODO
 227   3                  hpgpHdr->macAddr =  mgmtMsgParam.assocCnf->dstMacAddr;
 228   3                  hpgpHdr->snid = staInfo->snid;
 229   3            
 230   3            hpgpHdr->eks = HPGP_EKS_NONE;
 231   3      
 232   3                  assocCnf = (sCcAssocCnf *)(newEvent->buffDesc.dataptr); 
 233   3      
 234   3                  assocCnf->result = mgmtMsgParam.assocCnf->result; 
 235   3                  assocCnf->staTei = mgmtMsgParam.assocCnf->staTei; 
 236   3                  memcpy(assocCnf->nid, staInfo->nid, NID_LEN);
 237   3                  assocCnf->snid = staInfo->snid;
 238   3                  assocCnf->leaseTime = mgmtMsgParam.assocCnf->teiLeaseTime;  
 239   3      
 240   3                  newEvent->buffDesc.datalen += eventSize;
 241   3      #ifdef LOG_FLASH
                          buff[0] = assocCnf->result;            
                          buff[1] = assocCnf->staTei;
                          
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_ASSOC_CNF, buff, 2);
              #endif
 247   3                  FM_Printf(FM_MMSG, "CNAM:>>CC_ASSOC.CNF(tei:%bu)\n",
 248   3                                      hpgpHdr->tei);
 249   3                  break;
 250   3              }
 251   2              case EVENT_TYPE_CC_LEAVE_CNF:
 252   2              {
 253   3                  newEvent = EVENT_MgmtAlloc(HPGP_DATA_PAYLOAD_MIN, 
 254   3                                         EVENT_HPGP_MSG_HEADROOM);
 255   3                  if(newEvent == NULL)
 256   3                  {
 257   4      //                FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 258   4                      return STATUS_FAILURE;
 259   4                  }
 260   3                  mgmtMsgParam.leaveCnf = (sLeaveCnfParam *)msgParam;  
 261   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 262   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_LEAVE_CNF;
 263   3      
 264   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 265   3                  hpgpHdr->tei = mgmtMsgParam.leaveCnf->dstTei; //TODO
 266   3                  hpgpHdr->macAddr = mgmtMsgParam.leaveCnf->dstMacAddr;
 267   3                  hpgpHdr->snid = staInfo->snid;
 268   3      
 269   3            hpgpHdr->eks = staInfo->nekEks;
 270   3                  
 271   3          
 272   3                  newEvent->buffDesc.datalen += HPGP_DATA_PAYLOAD_MIN;
 273   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_CNF, &hpgpHdr->tei, 1);
              #endif
 276   3      #ifdef P8051
 277   3                  FM_Printf(FM_MMSG, "CNAM:>>CC_LEAVE.CNF(tei:%bu)\n",
 278   3                                      hpgpHdr->tei);
 279   3      #else
                          FM_Printf(FM_MMSG, "CNAM:>>CC_LEAVE.CNF(tei:%d)\n",
                                              hpgpHdr->tei);
              #endif
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 6   

 283   3                  break;
 284   3              }
 285   2              case EVENT_TYPE_CC_LEAVE_IND:
 286   2              {
 287   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sCcLeaveInd)); 
 288   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
 289   3                  if(newEvent == NULL)
 290   3                  {
 291   4      //                FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 292   4                      return STATUS_FAILURE;
 293   4                  }
 294   3      
 295   3                  mgmtMsgParam.leaveInd = (sLeaveIndParam *)msgParam;  
 296   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 297   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_LEAVE_IND;
 298   3      
 299   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 300   3                  hpgpHdr->tei = mgmtMsgParam.leaveInd->dstTei; //TODO
 301   3                  hpgpHdr->macAddr = mgmtMsgParam.leaveInd->dstMacAddr;
 302   3                  hpgpHdr->snid = staInfo->snid;
 303   3      
 304   3            hpgpHdr->eks = staInfo->nekEks;
 305   3                  
 306   3                  leaveInd = (sCcLeaveInd *)(newEvent->buffDesc.dataptr); 
 307   3                  memcpy(leaveInd->nid, staInfo->nid, NID_LEN);
 308   3                  leaveInd->reason = mgmtMsgParam.leaveInd->reason;
 309   3      
 310   3                  newEvent->buffDesc.datalen += eventSize;
 311   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_IND, &hpgpHdr->tei, 1);
              #endif
 314   3      #ifdef P8051
 315   3                  FM_Printf(FM_MMSG, "CNAM:>>CC_LEAVE.IND(tei:%bu)\n",
 316   3                                      hpgpHdr->tei);
 317   3      #else
                          FM_Printf(FM_MMSG, "CNAM:>>CC_LEAVE.IND(tei:%d)\n",
                                              hpgpHdr->tei);
              #endif
 321   3                  break;
 322   3              }
 323   2              case EVENT_TYPE_CC_SET_TEI_MAP_IND:
 324   2              {
 325   3                  mgmtMsgParam.teiMapInd = (sTeiMapIndParam *)msgParam;  
 326   3      
 327   3                  if( mgmtMsgParam.teiMapInd->mode == HPGP_TEI_MAP_MODE_NEW)
 328   3                  {
 329   4                      //send the SET_TEI_MAP.IND to the new STA
 330   4                      numSta = CRM_GetScbNum(cnam->crm);
 331   4                  }
 332   3                  else
 333   3                  {
 334   4                      numSta = 1;
 335   4                  }
 336   3      
 337   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, (2+(u16)(sizeof(sTeiMap)*numSta))); 
 338   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
 339   3                  if(newEvent == NULL)
 340   3                  {
 341   4        //                FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 342   4                      return STATUS_FAILURE;
 343   4                  }
 344   3      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 7   

 345   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 346   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_SET_TEI_MAP_IND;
 347   3      
 348   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 349   3                  hpgpHdr->tei =  mgmtMsgParam.teiMapInd->dstTei;
 350   3                  hpgpHdr->macAddr =  mgmtMsgParam.teiMapInd->dstMacAddr;
 351   3                  hpgpHdr->snid = staInfo->snid;
 352   3            hpgpHdr->eks = HPGP_EKS_NONE;
 353   3            hpgpHdr->mcst = 1;
 354   3                  
 355   3      
 356   3                  //build the message
 357   3                  dataptr = newEvent->buffDesc.dataptr;
 358   3                  teiMapInd = (sCcTeiMapInd *) dataptr;
 359   3                  teiMapInd->mode = mgmtMsgParam.teiMapInd->mode;
 360   3                  teiMapInd->numSta = numSta; 
 361   3                  newEvent->buffDesc.datalen += 2;
 362   3                  dataptr += 2;
 363   3      
 364   3                  freeLen = eventSize - 2;//newEvent->buffDesc.bufflen - 2 - 
 365   3                            //(newEvent->buffDesc.dataptr - newEvent->buffDesc.buff);
 366   3      
 367   3                  if( mgmtMsgParam.teiMapInd->mode == HPGP_TEI_MAP_MODE_NEW)
 368   3                  {
 369   4                      //send the SET_TEI_MAP.IND to the new STA
 370   4                      while( (freeLen >= sizeof(sTeiMap)) && numSta)
 371   4                      {
 372   5                          teiMap = (sTeiMap *) dataptr;
 373   5                          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
 374   5                          if(scbIter == NULL)
 375   5                          {
 376   6      //                        FM_Printf(FM_ERROR, "CNAM: imcompatible in CRM.\n");
 377   6                              EVENT_Free(newEvent);
 378   6                              return STATUS_FAILURE;
 379   6                          }
 380   5      
 381   5                          teiMap->tei = scbIter->tei; 
 382   5                          memcpy(teiMap->macAddr, scbIter->macAddr, MAC_ADDR_LEN); 
 383   5                          teiMap->status = scbIter->staStatus.fields.authStatus; 
 384   5                          dataptr += sizeof(sTeiMap);
 385   5                          newEvent->buffDesc.datalen += sizeof(sTeiMap);
 386   5                          freeLen -= sizeof(sTeiMap);
 387   5      
 388   5                          numSta--;
 389   5                      }
 390   4                      if((freeLen > 0)&&numSta)
 391   4                      {
 392   5      //                    FM_Printf(FM_ERROR, "CNAM: imcompatible with numSta.\n");
 393   5                          EVENT_Free(newEvent);
 394   5                          return STATUS_FAILURE;
 395   5                      }
 396   4                  }
 397   3                  else
 398   3                  {
 399   4      
 400   4                      teiMapInd->teiMap.tei = mgmtMsgParam.teiMapInd->staTei; 
 401   4                      memcpy(teiMapInd->teiMap.macAddr, mgmtMsgParam.teiMapInd->staMacAddr, MAC_ADDR_LEN); 
 402   4                      teiMapInd->teiMap.status = mgmtMsgParam.teiMapInd->staStatus; 
 403   4                      newEvent->buffDesc.datalen += sizeof(sTeiMap); 
 404   4                  }
 405   3      
 406   3                  newEvent->buffDesc.datalen = MAX(HPGP_DATA_PAYLOAD_MIN, newEvent->buffDesc.datalen);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 8   

 407   3          #ifdef P8051
 408   3                  FM_Printf(FM_MMSG, "CNAM:>>SET_TEI_MAP.IND(tei:%bu)\n",
 409   3          #else
                          FM_Printf(FM_MMSG, "CNAM:>>SET_TEI_MAP.IND(tei:%d)\n",
                  #endif
 412   3                                      hpgpHdr->tei);
 413   3                  break;
 414   3              }
 415   2      #ifdef APPOINT
                      case EVENT_TYPE_CC_CCO_APPOINT_CNF:
                      {
                          eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sCcCcoApptCnf)); 
                          newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
                          if(newEvent == NULL)
                          {
                              FM_Printf(FM_ERROR, "AErr\n");
                              return STATUS_FAILURE;
                          }
                          mgmtMsgParam.ccoApptCnf = (sCcoApptCnfParam *)msgParam;
                          newEvent->eventHdr.type = EVENT_TYPE_CC_CCO_APPOINT_CNF;
                          newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
              
                          hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                          hpgpHdr->tei =  mgmtMsgParam.ccoApptCnf->dstTei; //TODO
                          hpgpHdr->macAddr =  mgmtMsgParam.ccoApptCnf->dstMacAddr;
                          hpgpHdr->snid = staInfo->snid;
                    hpgpHdr->eks = staInfo->nekEks;
              
                          ccoApptCnf = (sCcCcoApptCnf *)(newEvent->buffDesc.dataptr); 
                          ccoApptCnf->result = mgmtMsgParam.ccoApptCnf->result;
                          newEvent->buffDesc.datalen += eventSize;
                          FM_Printf(FM_MMSG, "CNAM:>>CCO_APPOINT.CNF(tei:%bu)\n",
                                              hpgpHdr->tei);
                          break;
                      }
              #endif
 443   2              case EVENT_TYPE_CC_BACKUP_APPOINT_REQ:
 444   2              {
 445   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(ccoBackUpReq)); 
 446   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
 447   3                  if(newEvent == NULL)
 448   3                  {
 449   4                      FM_Printf(FM_ERROR, "AErr\n");
 450   4                      return STATUS_FAILURE;
 451   4                  }
 452   3                  mgmtMsgParam.ccoBackupReq = (sBackupCCoParam*)msgParam;
 453   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_BACKUP_APPOINT_REQ;
 454   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 455   3      
 456   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 457   3                  hpgpHdr->tei =  mgmtMsgParam.ccoBackupReq->dstTei; //TODO
 458   3                  hpgpHdr->macAddr =  mgmtMsgParam.ccoBackupReq->dstMacAddr;
 459   3                  hpgpHdr->snid = staInfo->snid;
 460   3      
 461   3            hpgpHdr->eks = staInfo->nekEks;
 462   3      
 463   3                  ccoBackUpReq = (sCcBackupReq*)(newEvent->buffDesc.dataptr); 
 464   3                  ccoBackUpReq->action = mgmtMsgParam.ccoBackupReq->action;
 465   3                  newEvent->buffDesc.datalen += eventSize;
 466   3                  FM_Printf(FM_MMSG, "CNAM:>>BACKUP_APPOINT_REQ:(tei:%bu)\n",
 467   3                                      hpgpHdr->tei);
 468   3                  break;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 9   

 469   3              }
 470   2              default:
 471   2              {
 472   3              }
 473   2          }
 474   1      
 475   1        
 476   1          //EVENT_Assert(newEvent);
 477   1          assert((newEvent->buffDesc.dataptr >= newEvent->buffDesc.buff)&&
 479   1                 ((newEvent->buffDesc.dataptr - newEvent->buffDesc.buff + 
 479   1                   newEvent->buffDesc.datalen) <= newEvent->buffDesc.bufflen));  
 480   1        
 481   1      
 482   1          //transmit the mgmt msg
 483   1          status =  MUXL_TransmitMgmtMsg(newEvent);
 484   1          //the event will be freed by MUXL if the TX is successful
 485   1          if(status == STATUS_FAILURE)
 486   1          {
 487   2              EVENT_Free(newEvent);
 488   2          }
 489   1      
 490   1          return status;
 491   1      }
 492          
 493          extern u8 bcAddr[];
 494          
 495          #if 1
 496          
 497          eStatus CNAM_SendTeiMapInd(sCnam *cnam, sScb *scb, u8 operation)
 498          {
 499   1          sScb              *scbIter = NULL;
 500   1          sTeiMapIndParam    teiMapIndParam;
 501   1          u8                 txInd = 1;
 502   1        sScb *minRssiScb = NULL;
 503   1        u8 minRssi = 200;
 504   1      
 505   1        scbIter = CRM_GetNextScb(cnam->crm, scbIter);
 506   1          while(scbIter)
 507   1        {
 508   2      
 509   2          if (scbIter != cnam->staInfo->staScb)
 510   2          {
 511   3      
 512   3            if (scbIter->rssiLqi.s.rssi < minRssi)
 513   3            {
 514   4              minRssiScb = scbIter;
 515   4              
 516   4            //  FM_Printf(FM_ERROR,"mrssi %bu \n", minRssi);
 517   4        
 518   4              minRssi = scbIter->rssiLqi.s.rssi;
 519   4            }
 520   3      
 521   3          }
 522   2          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
 523   2        
 524   2        }
 525   1      
 526   1      //  FM_Printf(FM_ERROR,"mrssi %bu \n", minRssi);
 527   1          scbIter = minRssiScb;
 528   1        
 529   1          if(scbIter)
 530   1          {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 10  

 531   2              if(1)//scbIter->tei != cnam->staInfo->ccoScb->tei)
 532   2              {
 533   3                  txInd = 1;
 534   3      //        teiMapIndParam.scb = scbIter;    //destination sta
 535   3                  teiMapIndParam.dstTei = scbIter->tei;         //destination STA
 536   3                  teiMapIndParam.dstMacAddr = bcAddr; //destination STA
 537   3                  teiMapIndParam.staTei = scb->tei;
 538   3                  teiMapIndParam.staMacAddr = scb->macAddr;
 539   3                  teiMapIndParam.staStatus = scb->staStatus.fields.authStatus;
 540   3                  if (operation ==  HPGP_TEI_MAP_MODE_ADD)
 541   3                  { 
 542   4                      /*Compiler warning suppression*/
 543   4      #if 1
 544   4                      if(1)//scbIter->tei == scb->tei)
 545   4                      {
 546   5                          teiMapIndParam.mode = HPGP_TEI_MAP_MODE_NEW; 
 547   5                      }
 548   4      #else               
                              else
                                
                              {
                                  teiMapIndParam.mode = HPGP_TEI_MAP_MODE_ADD; 
                              }
              #endif                
 555   4                  }
 556   3                  else
 557   3                  {
 558   4                      if(scbIter->tei != scb->tei)
 559   4                      {
 560   5                          teiMapIndParam.mode = HPGP_TEI_MAP_MODE_DELETE; 
 561   5                          teiMapIndParam.staStatus = HPGP_TEI_MAP_STATUS_DISASSOC;
 562   5                      }
 563   4                      else
 564   4                      {
 565   5                          txInd = 0;
 566   5                      }
 567   4                  }
 568   3      
 569   3                  if(txInd)
 570   3                  {
 571   4                      CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_SET_TEI_MAP_IND, 
 572   4                                       &teiMapIndParam);
 573   4                  }
 574   3              }
 575   2      
 576   2          //    scbIter = CRM_GetNextScb(cnam->crm, scbIter);
 577   2          } //end of while
 578   1          return STATUS_SUCCESS;
 579   1      
 580   1      }
 581          
 582          
 583          
 584          
 585          #else
              
              eStatus CNAM_SendTeiMapInd(sCnam *cnam, sScb *scb, u8 operation)
              {
                  sScb              *scbIter = NULL;
                  sTeiMapIndParam    teiMapIndParam;
                  u8                 txInd = 1;
                
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 11  

                  scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                  while(scbIter)
                  {
                      if(scbIter->tei != cnam->staInfo->ccoScb->tei)
                      {
                          txInd = 1;
              //        teiMapIndParam.scb = scbIter;    //destination sta
                          teiMapIndParam.dstTei = scbIter->tei;         //destination STA
                          teiMapIndParam.dstMacAddr = scbIter->macAddr; //destination STA
                          teiMapIndParam.staTei = scb->tei;
                          teiMapIndParam.staMacAddr = scb->macAddr;
                          teiMapIndParam.staStatus = scb->staStatus.fields.authStatus;
                          if (operation ==  HPGP_TEI_MAP_MODE_ADD)
                          { 
                              if(scbIter->tei == scb->tei)
                              {
                                  teiMapIndParam.mode = HPGP_TEI_MAP_MODE_NEW; 
                              }
                              else
                              {
                                  teiMapIndParam.mode = HPGP_TEI_MAP_MODE_ADD; 
                              }
                          }
                          else
                           {
                              if(scbIter->tei != scb->tei)
                              {
                                  teiMapIndParam.mode = HPGP_TEI_MAP_MODE_DELETE; 
                                  teiMapIndParam.staStatus = HPGP_TEI_MAP_STATUS_DISASSOC;
                              }
                              else
                              {
                                  txInd = 0;
                              }
                          }
              
                          if(txInd)
                          {
                              CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_SET_TEI_MAP_IND, 
                                               &teiMapIndParam);
                          }
                      }
              
                      scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                  } //end of while
                  return STATUS_SUCCESS;
              
              }
              
              
              #endif
 644          
 645          void CNAM_ProcEvent(sCnam *cnam, sEvent *event)
 646          {
 647   1          sEvent            *newEvent = NULL;
 648   1          sHpgpHdr          *hpgpHdr = NULL;
 649   1          sHpgpHdr          *newHpgpHdr = NULL;
 650   1          sCcAssocReq       *assocReq = NULL;
 651   1          sCcCcoApptReq     *ccoApptReq = NULL;
 652   1          sCcoHoReqEvent    *ccoHoReqEvent = NULL;
 653   1          sCcoHoRspEvent    *ccoHoRspEvent = NULL;
 654   1        sCcBackupCnf      *ccoBackUpCnf = NULL;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 12  

 655   1          sScb              *scb = NULL;
 656   1          sScb              *scbIter = NULL;
 657   1          sAssocCnfParam     assocCnfParam;
 658   1          sLeaveIndParam     leaveIndParam;
 659   1          sLeaveCnfParam     leaveCnfParam;
 660   1          sCcoApptCnfParam   ccoApptCnfParam;
 661   1          sLinkLayer        *linkl = NULL;
 662   1          sStaInfo          *staInfo = NULL;
 663   1          u8                 txCcoApptCnf;
 664   1          sCnsm             *cnsm = NULL;
 665   1          u16                numSta = 0;
 666   1          static u8         scbFoundFlag = 0;
 667   1      
 668   1          /*Compiler warning suppression*/  
 669   1          ccoApptCnfParam = ccoApptCnfParam;
 670   1          txCcoApptCnf = txCcoApptCnf;
 671   1      //    linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 672   1          linkl = cnam->linkl;
 673   1          staInfo = LINKL_GetStaInfo(linkl);
 674   1         
 675   1      
 676   1          if(cnam->state == CNAM_STATE_INIT)
 677   1          {
 678   2      #ifdef NAM_PRINT  
              //        FM_Printf(FM_WARN, "CNAM not ready\n");
              #endif    
 681   2              return;
 682   2          }
 683   1      
 684   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
 685   1          if( event->eventHdr.eventClass == EVENT_CLASS_MSG) 
 686   1          {
 687   2              switch(event->eventHdr.type)
 688   2              {
 689   3                  case EVENT_TYPE_CC_ASSOC_REQ:
 690   3                  {
 691   4              assocReq = (sCcAssocReq *)event->buffDesc.dataptr; 
 692   4      
 693   4              assocReq->nid[NID_LEN - 1] &= NID_EXTRA_BIT_MASK;
 694   4              if (memcmp(assocReq->nid, staInfo->nid, NID_LEN))
 695   4              {
 696   5                break;
 697   5              }
 698   4      
 699   4      
 700   4              
 701   4                      FM_Printf(FM_MMSG, "CNAM:<<CC_ASSOC.REQ(tei:%bu)\n",
 702   4                                hpgpHdr->tei);
 703   4                      //process this event at any time regardless of STA state 
 704   4                      assocCnfParam.staTei = 0;
 705   4                      assocCnfParam.dstTei = 0;
 706   4                      assocCnfParam.dstMacAddr = hpgpHdr->macAddr;
 707   4                      
 708   4      #ifdef LOG_FLASH
                              logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_ASSOC_REQ, hpgpHdr->macAddr, MAC_ADDR_LEN);
              #endif
 711   4                      if(assocReq->reqType == 0)
 712   4                      {
 713   5                          scb = CRM_FindScbMacAddr(hpgpHdr->macAddr);
 714   5                          if(scb == NULL) 
 715   5                          {
 716   6                              //this is a new request
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 13  

 717   6                              scb = CRM_AllocScb(cnam->crm);
 718   6                              scbFoundFlag = 0;
 719   6      #ifdef POWERSAVE
                                      if(scb)
                                      {                            
                            PSM_resetScbPs(scb);  // set SCB's PS data to init state 
                          }
              #endif
 725   6      #ifdef ROUTE
                                      if(scb)
                                      {                            
                                          ROUTE_initLrtEntry(scb);
                                          scb->lrtEntry.nTei = scb->tei;
                                          scb->lrtEntry.rnh = 0;
                                      }
              #endif
 733   6                          }
 734   5                          else
 735   5                          {
 736   6                              scbFoundFlag = 1;
 737   6                          }
 738   5                          if(scb)
 739   5                          {
 740   6      //                        scb->uMaxSSN = 0;
 741   6                              scb->uMinSSN = 0;
 742   6                              scb->uWrapAround = 0;
 743   6                              if(scbFoundFlag == 0)
 744   6                              {
 745   7                                  //allocate a tei lease timer for the STA
 746   7      #ifdef CALLBACK
                                          scb->teiTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                                              EVENT_TYPE_TIMER_TEI_IND, scb);
              #else
 750   7                                  scb->teiTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
 751   7                                                      EVENT_TYPE_TIMER_TEI_IND, scb);
 752   7      #endif
 753   7                              }
 754   6                              if(scb->teiTimer != STM_TIMER_INVALID_ID)
 755   6                              {
 756   7                                  scb->staCap.fields.ccoCap = assocReq->ccoCap;
 757   7                                  scb->staCap.fields.proxyNetCap = assocReq->proxyNetCap;
 758   7                                  memcpy(scb->macAddr, hpgpHdr->macAddr, 
 759   7                                         MAC_ADDR_LEN);
 760   7                                  assocCnfParam.result = HPGP_ASSOC_RESULT_SUCCESS;
 761   7                                  assocCnfParam.teiLeaseTime = cnam->teiLeaseTime;
 762   7                                  assocCnfParam.staTei = scb->tei;
 763   7                                  assocCnfParam.dstTei = 0xFF;
 764   7                                  if(scbFoundFlag == 0)
 765   7                                  {
 766   8      #ifdef SIMU                            
                                              //call SHAL to add tei to the port MAP by macaddr?
                                              //add requester tei to the Port Map in SHAL
                                             SHAL_AddTeiToPortMap(HOMEPLUG_GetHal()->shal,
                                              scb->macAddr, scb->tei);
              #endif
 772   8         
 773   8                               }
 774   7                               
 775   7      #if 0
              #ifdef P8051
                  FM_Printf(FM_HINFO,"CNAM: STA MAC Address: %bx:%bx:%bx:%bx:%bx:%bx\n",
              #else
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 14  

                 FM_Printf(FM_HINFO,"CNAM: STA MAC Address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
              #endif
                                      scb->macAddr[0], scb->macAddr[1],
                                      scb->macAddr[2], scb->macAddr[3],
                                      scb->macAddr[4], scb->macAddr[5]);
              #endif
 785   7                               
 786   7                              linkl->akm.peerTei = scb->tei;
 787   7                              linkl->akm.peerMacAddr = scb->macAddr;
 788   7      
 789   7                              }
 790   6                              else
 791   6                              {
 792   7                                  assocCnfParam.result = HPGP_ASSOC_RESULT_TEMP_NO_RES;
 793   7                                  STM_FreeTimer(scb->teiTimer);
 794   7                                  scb->teiTimer = STM_TIMER_INVALID_ID;
 795   7      #ifdef LOG_FLASH
                                          scbFreeReason = ASSOC_NO_RESOURCE;
              #endif
 798   7                                  CRM_FreeScb(cnam->crm, scb);
 799   7                                  scb = NULL;
 800   7                              }
 801   6                          }
 802   5                          else
 803   5                          {
 804   6                              // scb = NULL;
 805   6                              assocCnfParam.result = HPGP_ASSOC_RESULT_TEMP_NO_RES;
 806   6                          }
 807   5      
 808   5                          if ( CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_ASSOC_CNF, 
 809   5                                                &assocCnfParam) == STATUS_SUCCESS)
 810   5                          {
 811   6                              //start the lease timer
 812   6                              if(scb)
 813   6                              {
 814   7                                  //TODO: we need to check the lease timer
 815   7                                  //so that it does not exceed our timer limit
 816   7      
 817   7      
 818   7      
 819   7                    if(!scbFoundFlag)
 820   7                      cnam->numSta++;
 821   7      
 822   7      #ifndef AKM
 823   7                                  scb->staStatus.fields.authStatus = 1;
 824   7      #endif
 825   7                    STM_StopTimer(scb->teiTimer);
 826   7                                  STM_StartTimer(scb->teiTimer, 
 827   7                                                 cnam->teiLeaseTime*60000);
 828   7      #ifdef NAM_PRINT              
              #ifdef P8051
                            FM_Printf(FM_HINFO, "CNAM:lease(tei:%bu,time:0x%lx)\n",
              #else
                            FM_Printf(FM_HINFO, "CNAM:lease(tei:%d,time:0x%08x)\n",
              #endif
                                   scb->tei, assocCnfParam.teiLeaseTime*60000);
              #endif
 836   7      //FM_Printf(FM_HINFO, "CNAM: accNotif %bu\n",cnam->accNotification);   
 837   7                                  if(cnam->accNotification)
 838   7                                  {
 839   8      #ifdef UKE              
                                              {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 15  

                                                  if ((scbFoundFlag == 0) &&
                                                       (!memcmp(&cnam->ukePeer, &scb->macAddr, MAC_ADDR_LEN)))
                                                  {
              
                                                      //send the event to the SNAM to renew the TEI
                                                      newEvent = EVENT_Alloc(MAC_ADDR_LEN, 
                                                                         EVENT_HPGP_CTRL_HEADROOM);
                                                      if(newEvent == NULL)
                                                      {
                                                          FM_Printf(FM_ERROR, 
                                                                  "EAllocErr\n");
                                                          break;
                                                      }
                                                      
                                                      newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                                                      newEvent->eventHdr.type = EVENT_TYPE_ASSOC_IND;
                                                  
                                                      
                                                      hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                                                      hpgpHdr->scb = (sScb*)scb;
              
                                                      memcpy(newEvent->buffDesc.dataptr,
                                                             cnam->ukePeer, MAC_ADDR_LEN);
                                          
                                                      newEvent->buffDesc.datalen = MAC_ADDR_LEN;
              
                                                      SLIST_Put(&linkl->intEventQueue, &newEvent->link);
              
                                                     // LINKL_SendEvent(linkl, newEvent);
              
                                                 }
                                              }
              #endif                
 874   8                                      newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
 875   8                                      if(newEvent)
 876   8                                      {
 877   9                                          newEvent->eventHdr.eventClass = 
 878   9                                              EVENT_CLASS_CTRL;
 879   9                                          newEvent->eventHdr.type = EVENT_TYPE_NET_ACC_IND;
 880   9                                          //eeliver the event to the upper layer
 881   9      #ifdef CALLBACK
                                                  linkl->deliverEvent(linkl->eventcookie, newEvent);
              #else
 884   9                                          CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
 885   9      #endif
 886   9                                          cnam->accNotification = 0;
 887   9                                      }
 888   8                                      else
 889   8                                      {
 890   9                                          FM_Printf(FM_ERROR, "EAllocErr\n");
 891   9                                      }
 892   8                                  }
 893   7                    scb->namState = STA_NAM_STATE_CONN;
 894   7                                  scb->homState = STA_HOM_STATE_IDLE;
 895   7      
 896   7                    {
 897   8      
 898   8                      hostEvent_peerAssocInd assocInd;
 899   8      
 900   8                      memcpy(&assocInd.macAddress, (u8*)&scb->macAddr, MAC_ADDR_LEN);
 901   8                      assocInd.tei = scb->tei;
 902   8      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 16  

 903   8                      Host_SendIndication(HOST_EVENT_TYPE_PEER_ASSOC_IND, HPGP_MAC_ID,
 904   8                                (u8*)&assocInd, sizeof(assocInd));
 905   8      
 906   8                    }
 907   7      #ifdef MCCO
 908   7                    //linkl->ccoNsm.bcnUpdate = 1;
 909   7      #endif
 910   7                    
 911   7      
 912   7                    if(scbFoundFlag == 1)
 913   7                    {
 914   8                      if (linkl->ccoNam.backupCCoCfg.scb == scb)
 915   8                        linkl->ccoNam.backupCCoCfg.scb = NULL;  
 916   8                    }
 917   7      
 918   7      #if 0               
                                          //if(scbFoundFlag == 0) // send tei map ind on every assoc req(if it is not re
             -new), if device reset
                                          {
                                              //update the TEI map
                                              CNAM_SendTeiMapInd(cnam, 
                                                              scb, 
                                                              HPGP_TEI_MAP_MODE_ADD);
                      
                                          }
              #endif
 928   7                                 
 929   7                              }
 930   6                          }
 931   5                          else if(scbFoundFlag == 0)                            
 932   5                          {
 933   6                              //release resource
 934   6                              if(scb)
 935   6                              {
 936   7                                  STM_FreeTimer(scb->teiTimer);
 937   7                                  STM_FreeTimer(scb->staTimer);
 938   7                                  scb->teiTimer = STM_TIMER_INVALID_ID;
 939   7                                  scb->staTimer = STM_TIMER_INVALID_ID;                            
 940   7      #ifdef LOG_FLASH
                                          scbFreeReason = ASSOC_CNF_FAILED;
              #endif              
 943   7                    cnam->numSta--;
 944   7      
 945   7                                  CRM_FreeScb(cnam->crm, scb);
 946   7                                  scb = NULL;
 947   7                              }
 948   6                              
 949   6                          }
 950   5                      }
 951   4                      else  //renew
 952   4                      {
 953   5                          //search through the CRM to get the scb
 954   5                          //scb = CRM_GetScb(cnam->crm, event->eventHdr.stei);
 955   5                          scb = (sScb *)(hpgpHdr->scb);
 956   5                          if(scb)
 957   5                          {
 958   6                              //save MAC address for TEI renew too 
 959   6                              //in case of CCo handover
 960   6                              scb->staCap.fields.ccoCap = assocReq->ccoCap;
 961   6                              scb->staCap.fields.proxyNetCap = assocReq->proxyNetCap;
 962   6                              memcpy(scb->macAddr, hpgpHdr->macAddr, 
 963   6                                     MAC_ADDR_LEN);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 17  

 964   6                              assocCnfParam.staTei = scb->tei;
 965   6                              assocCnfParam.result = HPGP_ASSOC_RESULT_SUCCESS;
 966   6                        
 967   6                              // check if the sta is auth
 968   6                              if(scb->staStatus.fields.authStatus)
 969   6                              {
 970   7                                  assocCnfParam.teiLeaseTime = cnam->teiLeaseTimeAuth;
 971   7                              }
 972   6                              else //unauth
 973   6                              {
 974   7                                  assocCnfParam.teiLeaseTime = cnam->teiLeaseTime;
 975   7                              }
 976   6                              assocCnfParam.dstTei = scb->tei;
 977   6                              assocCnfParam.dstMacAddr = scb->macAddr;
 978   6                              //restart the TEI release timer
 979   6                              STM_StopTimer(scb->teiTimer);
 980   6                              STM_StartTimer(scb->teiTimer, 
 981   6                                             assocCnfParam.teiLeaseTime*60000);
 982   6      #ifdef NAM_PRINT            
              #ifdef P8051
              FM_Printf(FM_HINFO, "CNAM:lease(0x%lx)\n",
              #else
              FM_Printf(FM_HINFO, "CNAM:lease(0x%.8x)\n",
              #endif
                                   assocCnfParam.teiLeaseTime*60000);
              #endif                    
 990   6                          }
 991   5                          else
 992   5                          {
 993   6                              assocCnfParam.dstTei = hpgpHdr->tei;
 994   6                              assocCnfParam.dstMacAddr = hpgpHdr->macAddr;
 995   6                              assocCnfParam.result = HPGP_ASSOC_RESULT_UNKNOWN;
 996   6                          }
 997   5      
 998   5                          CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_ASSOC_CNF, 
 999   5                                                 &assocCnfParam);
1000   5                CNAM_SendTeiMapInd(cnam, 
1001   5                            scb, 
1002   5                          HPGP_TEI_MAP_MODE_ADD);     
1003   5      
1004   5                
1005   5                
1006   5                      }
1007   4                      break;
1008   4                  }
1009   3      
1010   3            case EVENT_TYPE_CC_BACKUP_APPOINT_CNF:
1011   3            {
1012   4              scb = (sScb *)(hpgpHdr->scb);
1013   4              if(scb)
1014   4              {
1015   5                
1016   5                
1017   5      //          FM_Printf(FM_MMSG, "CNAM:<<BACKUP_APPOINT_CNF(tei:%bu)\n",
1018   5        //              scb->tei);
1019   5      
1020   5                if (scb->namState == STA_NAM_STATE_CONN)
1021   5      
1022   5                {
1023   6                  ccoBackUpCnf = (sCcBackupCnf*)event->buffDesc.dataptr;
1024   6      
1025   6                  if (!ccoBackUpCnf->result) 
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 18  

1026   6                  {  //Success
1027   7                    scb->staCap.fields.backupCcoStatus = 1;
1028   7                     
1029   7                    cnam->backupCCoCfg.result = 0;
1030   7      
1031   7                    break;
1032   7          
1033   7                  }
1034   6      
1035   6                }
1036   5              
1037   5                cnam->backupCCoCfg.scb = NULL;
1038   5      
1039   5                cnam->backupCCoCfg.result = 1;  
1040   5                  
1041   5                CNAM_SelectBackupCCo(cnam, scb);
1042   5                
1043   5              }
1044   4      
1045   4              break;
1046   4            }
1047   3      #ifdef APPOINT
                          case EVENT_TYPE_CC_CCO_APPOINT_REQ: // user appointed CCO
                          {
                              scb = (sScb *)(hpgpHdr->scb);
                              if(scb && (scb->namState == STA_NAM_STATE_CONN))
                              {
              //                FM_Printf(FM_MMSG, "CNAM:<<CCO_APPOINT.REQ(tei:%bu)\n",
                //                                  scb->tei);
                                  //process the event only in STA_STATE_IDLE
                                  ccoApptReq = (sCcCcoApptReq *)event->buffDesc.dataptr; 
              
                                  txCcoApptCnf  = 0;
                                  if(ccoApptReq->reqType == HPGP_CCO_APPT_REQ_APPT_HO)
                                  {
                                      //(1) am I an user appointed CCO already?
              //                      if(ccoInfo->appointedCco)
                                      if(staInfo->ccoScb->staStatus.fields.apptCcoStatus)
                                      {
                                          //already a user appointed CCo
                                          ccoApptCnfParam.result = 
                                              HPGP_CCO_APPT_CNF_APPT_CCO;      
                                          //send a negaive CC_CCO_APPOINT_CNF response
                                          txCcoApptCnf = 1;
                                      }
                                      else
                                      {
              
                                          //(2) check if the appointed STA is associated 
                                          scbIter = NULL;
                                          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                                          while(scbIter)
                                          {
                                              if(memcmp(ccoApptReq->macAddr, 
                                                     scbIter->macAddr, MAC_ADDR_LEN) == 0)
                                              {
                                                  break;
                                              }
                                              scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                                          }
                                          if(scbIter == NULL)
                                          {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 19  

                                              //unknown user-appointed STA
                                              ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_UNKNOWN_STA;      
                                              //send a negaive CC_CCO_APPOINT_CNF response
                                              txCcoApptCnf = 1;
                                          }
                                          else
                                          {
                                              //CCo is appointed and perform handover
              //                                ccoInfo->ccoScb->staStatus.fields.apptCcoStatus = 1;
              //                                ccoInfo->appointedCco = 1;
                                              //success, send a CC_HANDOVER.REQ
                                             txCcoApptCnf  = 0;
                                          }
                                      }
                                  }
                                  else if(ccoApptReq->reqType == HPGP_CCO_APPT_REQ_UNAPPT)
                                  {
                                      //if(ccoInfo->appointedCco)
                                      if(staInfo->ccoScb->staStatus.fields.apptCcoStatus)
                                      { 
                                          //ccoInfo->appointedCco = 0;
                                          staInfo->ccoScb->staStatus.fields.apptCcoStatus = 0;
                                          //CCo is unappointed
                                          ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_CCO_UNAPPT;      
                                      }
                                      else
                                      {
                                          //CCo is not a user appointed Cco
                                          ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_CCO_NOT_APPT;      
                                      }
                                      txCcoApptCnf = 1;
                                  }
                                  else if(ccoApptReq->reqType == 
                                              HPGP_CCO_APPT_REQ_UNAPPT_HO)
                                  {
                                      //check if the appointed STA is associated 
                                      scbIter = NULL;
                                      scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                                      while(scbIter)
                                      {
                                          if(memcmp(ccoApptReq->macAddr, 
                                                 scbIter->macAddr, MAC_ADDR_LEN) == 0)
                                          {
                                              break;
                                          }
                                          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
                                      }
                                      if(scbIter == NULL)
                                      {
                                          //unknown user-appointed STA
                                          ccoApptCnfParam.result = 
                                              HPGP_CCO_APPT_CNF_UNKNOWN_STA2;      
                                          //send a negaive CC_CCO_APPOINT_CNF response
                                          txCcoApptCnf = 1;
                                      }
                                      else
                                      {
                                          //ccoInfo->appointedCco = 0;
                                          staInfo->ccoScb->staStatus.fields.apptCcoStatus = 0;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 20  

                                          //success, send a CC_HANDOVER.REQ
                                          txCcoApptCnf = 0;
                                      }
                                  }
                                  else
                                  {
              #ifdef NAM_PRINT                    
                                      FM_Printf(FM_ERROR, "CNAM:unknown req\n");
              #endif
                                  }
              
                                  if(txCcoApptCnf)
                                  {
                                      ccoApptCnfParam.dstTei = hpgpHdr->tei;
                                      ccoApptCnfParam.dstMacAddr = hpgpHdr->macAddr;
                                      CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_CCO_APPOINT_CNF, 
                                                       &ccoApptCnfParam);
                                  }
                                  else
                                  {
                                      //initiate the CCO handover
                                      newEvent = EVENT_Alloc(sizeof(sCcoHoReqEvent), 
                                                             EVENT_HPGP_CTRL_HEADROOM);
                                      if(newEvent == NULL)
                                      {
                                          FM_Printf(FM_ERROR, "AErr\n");
                                          break ;
                                      }
              
              
                                      cnam->ccoApptOrigScb = scb;
                                  
              //                    scbIter->hoTrigger = HO_TRIGGER_TYPE_USER;
                                      newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                                      newEvent->eventHdr.type = EVENT_TYPE_CCO_HO_REQ;
              
                                      newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
              
                                      newHpgpHdr->scb = scbIter;
                                      ccoHoReqEvent = (sCcoHoReqEvent *)(newEvent->buffDesc.dataptr); 
                                      ccoHoReqEvent->reason = HPGP_HO_REASON_CCO_APPT;
                                      newEvent->buffDesc.datalen +=sizeof(sCcoHoReqEvent);
                                      EVENT_Assert(newEvent);
                                      //LINKL_SendEvent(linkl, newEvent);
                                      SLIST_Put(&linkl->intEventQueue, &newEvent->link);
                                      scbIter->namState = STA_NAM_STATE_WAITFOR_CCO_HO_RSP;
                                  }
                              }
                              break;
                          }
              #endif
1201   3                  case EVENT_TYPE_CC_LEAVE_REQ:
1202   3                  {
1203   4                      //process the event only in STA_STATE_IDLE
1204   4                      //search through the CRM to get the scb
1205   4                      //scb = CRM_GetScb(cnam->crm, event->eventHdr.stei);
1206   4                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1207   4                      scb = (sScb *)(hpgpHdr->scb);
1208   4              
1209   4              FM_Printf(FM_MMSG, "CNAM:<<LEAVE.REQ(tei:%bu)\n",
1210   4                                          scb->tei);
1211   4      #ifdef LOG_FLASH
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 21  

                              logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_REQ, &scb->tei, 1);
              #endif
1214   4                      if(scb && (scb->namState == STA_NAM_STATE_CONN))
1215   4                      {
1216   5                          leaveCnfParam.dstTei = scb->tei;
1217   5                          leaveCnfParam.dstMacAddr = scb->macAddr;
1218   5                          //stop the TEI release timer
1219   5                          STM_StopTimer(scb->teiTimer);
1220   5            
1221   5                          //start the TEI reuser timer
1222   5                          STM_StartTimer(scb->teiTimer, 
1223   5                                         HPGP_TIME_TEI_REUSE);
1224   5                          scb->namState = STA_NAM_STATE_RELEASE;
1225   5                
1226   5                          CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_LEAVE_CNF, 
1227   5                                                 &leaveCnfParam);
1228   5                          //update the TEI map
1229   5                          CNAM_SendTeiMapInd(cnam, scb, HPGP_TEI_MAP_MODE_DELETE);
1230   5      
1231   5                { 
1232   6                  hostEvent_peerLeave_t pLeave;
1233   6                
1234   6                  memcpy(pLeave.macAddress, scb->macAddr, MAC_ADDR_LEN);
1235   6                  pLeave.tei = scb->tei;
1236   6                  pLeave.reason = HOST_EVENT_PEER_LEAVE_REASON_PEER_LEAVING;
1237   6                
1238   6                
1239   6                  Host_SendIndication(HOST_EVENT_PEER_STA_LEAVE, HPGP_MAC_ID, (u8*)&pLeave,
1240   6                            sizeof(hostEvent_peerLeave_t));
1241   6                
1242   6                }
1243   5      
1244   5      #ifdef ROUTE
                                  ROUTE_preparteAndSendUnreachable(scb);                    
              #endif
1247   5      
1248   5                          //Remove MAC addr from scb list
1249   5                          //hal hpgp tx uses mac address so we cannot nullify here
1250   5      //                    memset(&scb->macAddr, 0, MAC_ADDR_LEN);
1251   5      
1252   5      #ifdef SIMU
                                  //NOTE: if the CC_LEAVE_REQ is retransmitted
                                  //it would not processed
                                  SHAL_DeletePortMap(HOMEPLUG_GetHal()->shal,
                                                     scb->tei);
              #else
1258   5                          //call the HAL to remove TEI 
1259   5      #endif
1260   5                      }
1261   4                      else
1262   4                      {
1263   5      #ifdef NAM_PRINT        
                                  FM_Printf(FM_ERROR, "CNAM:no scb for leaving STA\n");
              #endif          
1266   5                      }
1267   4      #ifdef POWERSAVE
                      PSM_resetScbPs(scb);  // set SCB's PS data to init state 
              #endif
1270   4                      break;
1271   4                  }
1272   3      #ifdef STA_ID     
                          case EVENT_TYPE_CM_STA_IDENTIFY_REQ:                    
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 22  

                          {
                              IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_REQ, event);
                              break;
                          }
                          case EVENT_TYPE_CM_STA_IDENTIFY_CNF:                    
                          {
                              IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_CNF, event);
                              break;
                          }
                          case EVENT_TYPE_CM_STA_IDENTIFY_IND:                    
                          {
                              IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_IND, event);
                              break;
                          }
              #endif      
1289   3      #ifdef KEEP_ALIVE
1290   3            case EVENT_TYPE_VENDOR_KEEP_ALIVE_IND:
1291   3            {
1292   4              if(((sScb *)(hpgpHdr->scb)) != NULL)
1293   4              {
1294   5                if(((sScb *)(hpgpHdr->scb))->tei == hpgpHdr->tei)
1295   5                {
1296   6                  ((sScb *)(hpgpHdr->scb))->hit = 1;
1297   6                  ((sScb *)(hpgpHdr->scb))->hitCount = 0;
1298   6                }
1299   5              }
1300   4              //FM_Printf(FM_USER,"CNAM<<<Keep Alive:%bu\n",hpgpHdr->tei);
1301   4              break;
1302   4            }
1303   3      #endif
1304   3                  default:
1305   3                  {
1306   4                  }
1307   3              }
1308   2          }
1309   1          else // control message
1310   1          {
1311   2              switch(event->eventHdr.type)
1312   2              {
1313   3      
1314   3            case EVENT_TYPE_CNAM_STOP_REQ:
1315   3            {   
1316   4              sLeaveIndParam leaveIndParam;
1317   4      #ifdef NAM_PRINT
                      FM_Printf(FM_USER,"EVENT_TYPE_CNAM_STOP_REQ\n");
              #endif        
1320   4              scbIter = CRM_GetNextScb(cnam->crm, NULL);
1321   4            
1322   4              if (LINKL_QueryAnySta(linkl))
1323   4              {
1324   5                  // Nothing to do
1325   5                  
1326   5                cnam->state = CNAM_STATE_SHUTTINGDOWN;
1327   5              }
1328   4              else
1329   4              {
1330   5                sEvent *newEvent;
1331   5                  newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
1332   5                  if(newEvent)
1333   5                  {       
1334   6                      newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1335   6      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 23  

1336   6                  cnam->state = CNAM_STATE_INIT;
1337   6                  newEvent->eventHdr.type = EVENT_TYPE_NET_EXIT_IND;
1338   6      
1339   6                      CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);   
1340   6                      
1341   6                  }
1342   5      #if 0 //this happens in linkl_poststopcco
              
                        if(staInfo->ccoScb != NULL)
                        {
                          CRM_FreeScb(&linkl->ccoRm, staInfo->ccoScb);
                        }
              
              #endif
1350   5                  break;
1351   5              }
1352   4                                  
1353   4              while(scbIter)
1354   4              {
1355   5                if(scbIter->tei != staInfo->tei)
1356   5                {
1357   6                  
1358   6                            leaveIndParam.reason = HPGP_LEAVE_IND_REASON_CCO_DOWN;
1359   6                            leaveIndParam.dstTei = scbIter->tei;
1360   6                            leaveIndParam.dstMacAddr = scbIter->macAddr;
1361   6                            STM_StopTimer(scbIter->teiTimer);
1362   6      
1363   6                            //start the TEI reuser timer
1364   6                            STM_StartTimer(scbIter->teiTimer, 
1365   6                                           50);
1366   6                            scbIter->namState = STA_NAM_STATE_RELEASE;
1367   6      
1368   6                            //send the CC_LEAVE.IND
1369   6      
1370   6      //          FM_Printf(FM_USER,"cdown\n");
1371   6                
1372   6                            CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_LEAVE_IND, 
1373   6                                                   &leaveIndParam);
1374   6              
1375   6                }
1376   5              
1377   5                scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1378   5              } //end of while
1379   4              
1380   4      
1381   4              break;
1382   4              
1383   4            }
1384   3      
1385   3              
1386   3              case EVENT_TYPE_TIMER_TEI_IND:
1387   3            case EVENT_TYPE_STA_AGEOUT:
1388   3                  {
1389   4                      //process the event at any time 
1390   4                      //tei lease timer
1391   4                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1392   4                      scb = (sScb *)(hpgpHdr->scb);
1393   4      #ifdef POWERSAVE 
                      if (scb->psState == PSM_PS_STATE_ON)
                      {
              //          printf("CNAM_ProcEvent: event type %d with PS on (tei: %bu). Don't send LEAVE.IND\n",
              //                      event->eventHdr.type, scb->tei);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 24  

                        break;
                      }
              #endif
1401   4                      //release the resource
1402   4                      if(scb->namState == STA_NAM_STATE_CONN)
1403   4                      {
1404   5                          leaveIndParam.reason = HPGP_LEAVE_IND_REASON_TEI_EXP;
1405   5                          leaveIndParam.dstTei = scb->tei;
1406   5                          leaveIndParam.dstMacAddr = scb->macAddr;
1407   5                          STM_StopTimer(scb->teiTimer);
1408   5      
1409   5                          //start the TEI reuser timer
1410   5                          STM_StartTimer(scb->teiTimer, 
1411   5                                         HPGP_TIME_TEI_REUSE);
1412   5                          scb->namState = STA_NAM_STATE_RELEASE;
1413   5      
1414   5                
1415   5                { 
1416   6                  hostEvent_peerLeave_t pLeave;
1417   6                
1418   6                  memcpy(pLeave.macAddress, scb->macAddr, MAC_ADDR_LEN);
1419   6                  pLeave.tei = scb->tei;
1420   6                  pLeave.reason = HOST_EVENT_PEER_LEAVE_REASON_TEI_TIMEOUT;
1421   6                
1422   6                
1423   6                  Host_SendIndication(HOST_EVENT_PEER_STA_LEAVE, HPGP_MAC_ID, (u8*)&pLeave,
1424   6                            sizeof(hostEvent_peerLeave_t));
1425   6                
1426   6                }
1427   5      
1428   5                          //send the CC_LEAVE.IND
1429   5      //                                    FM_Printf(FM_USER,"age\n");
1430   5                          CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_LEAVE_IND, 
1431   5                                                 &leaveIndParam);
1432   5                          //update the TEI map
1433   5                          CNAM_SendTeiMapInd(cnam, scb, HPGP_TEI_MAP_MODE_DELETE);
1434   5      
1435   5                { 
1436   6                  hostEvent_peerLeave_t pLeave;
1437   6                
1438   6                  memcpy(pLeave.macAddress, scb->macAddr, MAC_ADDR_LEN);
1439   6                  pLeave.tei = scb->tei;
1440   6                  pLeave.reason = HOST_EVENT_PEER_LEAVE_REASON_PEER_LEAVING;
1441   6                
1442   6                
1443   6                  Host_SendIndication(HOST_EVENT_PEER_STA_LEAVE, HPGP_MAC_ID, (u8*)&pLeave,
1444   6                            sizeof(hostEvent_peerLeave_t));
1445   6                
1446   6                }
1447   5                
1448   5                          
1449   5      #ifdef ROUTE
                                   ROUTE_preparteAndSendUnreachable(scb);                    
              #endif
1452   5      
1453   5                CNAM_BackupCCoAgeOut(cnam, scb);
1454   5                          //Remove MAC addr from scb list
1455   5                          memset(&scb->macAddr, 0, MAC_ADDR_LEN);
1456   5      
1457   5      #ifdef SIMU
                                  //NOTE: if the CC_LEAVE_REQ is retransmitted
                                  //it may not be processed
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 25  

                                  SHAL_DeletePortMap(HOMEPLUG_GetHal()->shal,
                                                     scb->tei);
              #else
1463   5                          //call the HAL to remove TEI
1464   5      #endif
1465   5                      }
1466   4                      else if( scb->namState == STA_NAM_STATE_RELEASE)
1467   4                      { 
1468   5      #ifdef NAM_PRINT        
              #ifdef P8051
                                  FM_Printf(FM_MINFO, 
                                            "CNAM:free the scb for leaving STA(tei: %bu)\n",
                                            scb->tei);
              #else
                                  FM_Printf(FM_MINFO, 
                                            "CNAM:free the scb for leaving STA(tei: %d)\n",
                                            scb->tei);
              #endif
              #endif
1479   5                CNAM_BackupCCoAgeOut(cnam, scb);
1480   5      
1481   5                          // STA_NAM_STATE_RELEASE:
1482   5                          STM_FreeTimer(scb->teiTimer);
1483   5                          STM_FreeTimer(scb->staTimer);
1484   5                          scb->teiTimer = STM_TIMER_INVALID_ID;
1485   5                          scb->staTimer = STM_TIMER_INVALID_ID;
1486   5                         
1487   5                          cnsm = LINKL_GetCnsm(linkl);
1488   5                          CNSM_UpdateDiscBcnSched(cnsm, scb);
1489   5                          
1490   5      #ifdef LOG_FLASH
                                  scbFreeReason = STA_AGEOUT;
              #endif
1493   5                cnam->numSta--;
1494   5                          CRM_FreeScb(cnam->crm, scb);
1495   5      
1496   5      #ifdef MCCO         
1497   5                //linkl->ccoNsm.bcnUpdate = 1;
1498   5      #endif              
1499   5                          // If last STA leave network Become unassoc
1500   5      
1501   5                          if (LINKL_QueryAnySta(linkl))
1502   5                          {
1503   6                              // Nothing to do
1504   6                          }
1505   5                          else
1506   5                          {
1507   6                              newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
1508   6                              if(newEvent)
1509   6                              {
1510   7                                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1511   7      
1512   7                    if (cnam->state == CNAM_STATE_SHUTTINGDOWN)
1513   7                    {
1514   8                      cnam->state = CNAM_STATE_INIT;
1515   8                      newEvent->eventHdr.type = EVENT_TYPE_NET_EXIT_IND;
1516   8      
1517   8                    }
1518   7                    else
1519   7                    {
1520   8                      newEvent->eventHdr.type = EVENT_TYPE_NO_STA_IND;
1521   8                    }
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 26  

1522   7                            
1523   7      
1524   7                    CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
1525   7                    
1526   7                              }
1527   6                          }
1528   5                           
1529   5                      }
1530   4                   
1531   4                      break;
1532   4                  }
1533   3                  case EVENT_TYPE_CCO_SELECT_IND: 
1534   3                  {
1535   4                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1536   4                      scb = (sScb *)(hpgpHdr->scb);
1537   4                      if(scb && (scb->namState == STA_NAM_STATE_CONN))
1538   4                      {
1539   5                
1540   5                      //initiate the CCO handover
1541   5                          newEvent = EVENT_Alloc(sizeof(sCcoHoReqEvent), 
1542   5                                                 EVENT_HPGP_CTRL_HEADROOM);
1543   5                          if(newEvent == NULL)
1544   5                          {
1545   6                              FM_Printf(FM_ERROR, "EAllocErr\n");
1546   6                              break ;
1547   6                          }
1548   5      //                    scb->hoTrigger = HO_TRIGGER_TYPE_AUTO;
1549   5                          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1550   5                          newEvent->eventHdr.type = EVENT_TYPE_CCO_HO_REQ;
1551   5                          newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
1552   5      
1553   5                          newHpgpHdr->scb = scb;
1554   5                          ccoHoReqEvent = (sCcoHoReqEvent *)(newEvent->buffDesc.dataptr); 
1555   5                          ccoHoReqEvent->reason = HPGP_HO_REASON_CCO_SLCT;
1556   5                          newEvent->buffDesc.datalen +=sizeof(sCcoHoReqEvent);
1557   5                          EVENT_Assert(newEvent);
1558   5                          //LINKL_SendEvent(linkl, newEvent);
1559   5                          SLIST_Put(&linkl->intEventQueue, &newEvent->link);
1560   5                          scb->namState = STA_NAM_STATE_WAITFOR_CCO_HO_RSP;
1561   5                      }
1562   4                      break;
1563   4                  }
1564   3      #ifdef HOM
                          case EVENT_TYPE_CCO_HO_RSP: 
                          {
                              //process the event only in STA_STATE_IDLE
                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                              scb = (sScb *)(hpgpHdr->scb);
                              if(scb && (scb->namState == STA_NAM_STATE_WAITFOR_CCO_HO_RSP))
                              {
                                  if(cnam->ccoApptOrigScb)
                                  {
                                      ccoApptCnfParam.dstTei = cnam->ccoApptOrigScb->tei;
                                      ccoApptCnfParam.dstMacAddr = 
                                          cnam->ccoApptOrigScb->macAddr;
                                      ccoHoRspEvent = (sCcoHoRspEvent *)(event->buffDesc.dataptr); 
                                      if( ccoHoRspEvent->reason == HPGP_HO_REASON_CCO_APPT)
                                      {
                                          if(ccoHoRspEvent->result == TRUE)
                                          {
                                              ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_ACCEPT;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 27  

                                          }
                                          else
                                          {
                                              ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_REJECT;
                                          }
                                      }
                                      else if( ccoHoRspEvent->reason == HPGP_HO_REASON_CCO_SLCT)
                                      {
                                          if(ccoHoRspEvent->result == TRUE)
                                          {
                                              //CCo is un-appointed and perform handover
                                              ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_UNAPPT_HO;
                                          }
                                          else
                                          {
                                              //not defined in the standard
                                              ccoApptCnfParam.result = 
                                                  HPGP_CCO_APPT_CNF_REJECT;
                                          }
                                      }
              
                                      CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_CCO_APPOINT_CNF, 
                                                       &ccoApptCnfParam);
                                      cnam->ccoApptOrigScb = NULL;
                                  }
                                  //else it is triggered by the auto CCo selection
                              }
                              break;
                          }
              #endif
1616   3      #ifdef KEEP_ALIVE     
1617   3            case EVENT_TYPE_TIMER_KEEP_LIVE_IND:
1618   3            {
1619   4                sScb          *scb = NULL;
1620   4                   
1621   4              if(cnam->state == CNAM_STATE_READY)
1622   4              {
1623   5                scb = CRM_GetNextScb(cnam->crm, scb);
1624   5                  while(scb)
1625   5                  {
1626   6                    if(scb->tei != staInfo->tei)
1627   6                  {
1628   7                      if(scb->hit == 1)
1629   7                      {
1630   8                      scb->hit = 0;
1631   8                    }
1632   7                    else
1633   7                    {
1634   8                      if (scb->hitCount < KEEP_ALIVE_HIT_COUNT)
1635   8                      {
1636   9                        scb->hitCount++;
1637   9                      }
1638   8                      else
1639   8                      { 
1640   9                        sLeaveIndParam     leaveIndParam;
1641   9                        leaveIndParam.reason = HPGP_LEAVE_IND_REASON_RSVD;// Keep Alive is our feature, not defined in sp
             -ec
1642   9                            leaveIndParam.dstTei = scb->tei;
1643   9                            leaveIndParam.dstMacAddr = scb->macAddr;
1644   9                            STM_StopTimer(scb->teiTimer);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 28  

1645   9      
1646   9                                    //start the TEI reuser timer
1647   9                            STM_StartTimer(scb->teiTimer, 
1648   9                                                   HPGP_TIME_TEI_REUSE);
1649   9                            scb->namState = STA_NAM_STATE_RELEASE;
1650   9      
1651   9      //                  FM_Printf(FM_USER,"kplv\n");
1652   9                        CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_LEAVE_IND, 
1653   9                                                           &leaveIndParam);
1654   9                                    //update the TEI map
1655   9                            CNAM_SendTeiMapInd(cnam, scb, HPGP_TEI_MAP_MODE_DELETE);
1656   9      
1657   9                        { 
1658  10                          hostEvent_peerLeave_t pLeave;
1659  10      
1660  10                          memcpy(pLeave.macAddress, scb->macAddr, MAC_ADDR_LEN);
1661  10                          pLeave.tei = scb->tei;
1662  10                          pLeave.reason = HOST_EVENT_PEER_LEAVE_REASON_PEER_LEAVING;
1663  10      
1664  10      
1665  10                          Host_SendIndication(HOST_EVENT_PEER_STA_LEAVE, HPGP_MAC_ID, (u8*)&pLeave,
1666  10                                    sizeof(hostEvent_peerLeave_t));
1667  10      
1668  10                        }
1669   9      
1670   9                        //FM_Printf(FM_USER,"Entry Removed:%bu\n",scb->tei);//remove entry
1671   9                      }
1672   8                      
1673   8                    }
1674   7                    }
1675   6                  scb = CRM_GetNextScb(cnam->crm, scb);
1676   6                }
1677   5                  STM_StartTimer(cnam->staAgingTimer,HPGP_TIME_KEEP_ALIVE);
1678   5              }
1679   4              break;
1680   4            }
1681   3      #endif      
1682   3                  default:
1683   3                  {
1684   4                      break;
1685   4                  }
1686   3              }
1687   2          }
1688   1      }
1689          
1690          void CNAM_BackupCCoAgeOut(sCnam *cnam, sScb *scb)
1691          {
1692   1      
1693   1        if (cnam->backupCCoCfg.scb  == scb)
1694   1        {
1695   2          scb->staCap.fields.backupCcoStatus = 0;
1696   2          scb->staCap.fields.backupCcoCap = 0;
1697   2          cnam->backupCCoCfg.scb = NULL;
1698   2          
1699   2          CNAM_SelectBackupCCo(cnam, scb);
1700   2        }
1701   1              
1702   1      
1703   1      }
1704          
1705          eStatus CNAM_SelectBackupCCo(sCnam *cnam, sScb *scbIter)
1706          {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 29  

1707   1        sBackupCCoParam    ccoBackupReq;
1708   1      
1709   1        
1710   1        scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1711   1      
1712   1      
1713   1        while(scbIter)
1714   1        {
1715   2      
1716   2          if((scbIter->tei != cnam->staInfo->ccoScb->tei) &&
1717   2               (scbIter->staCap.fields.backupCcoCap))
1718   2          {
1719   3      
1720   3            ccoBackupReq.dstTei = scbIter->tei;
1721   3            ccoBackupReq.dstMacAddr = scbIter->macAddr;
1722   3            ccoBackupReq.action = HPGP_CCO_BACKUP_REQ_APPOINT;
1723   3      
1724   3            cnam->backupCCoCfg.scb = scbIter;
1725   3            
1726   3            CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_BACKUP_APPOINT_REQ,
1727   3                     &ccoBackupReq);
1728   3      
1729   3            return STATUS_SUCCESS;
1730   3            
1731   3      
1732   3          }
1733   2      
1734   2          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1735   2        } //end of while
1736   1      
1737   1        return STATUS_FAILURE;
1738   1      
1739   1        
1740   1      }
1741          
1742          eStatus CNAM_ReleaseBackupCCo()
1743          {
1744   1        sBackupCCoParam    ccoBackupReq;
1745   1        sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1746   1        sCnam *cnam = &linkl->ccoNam;
1747   1        sScb *scbIter = NULL;
1748   1        
1749   1        scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1750   1      
1751   1        while(scbIter)
1752   1        {
1753   2          if((scbIter->tei != cnam->staInfo->ccoScb->tei) &&
1754   2               (scbIter->staCap.fields.backupCcoStatus))
1755   2          {
1756   3      
1757   3              ccoBackupReq.dstTei = scbIter->tei;
1758   3              ccoBackupReq.dstMacAddr = scbIter->macAddr;
1759   3              ccoBackupReq.action = HPGP_CCO_BACKUP_REQ_RELEASE;
1760   3      
1761   3              cnam->backupCCoCfg.scb = NULL;
1762   3              
1763   3              CNAM_SendMgmtMsg(cnam, EVENT_TYPE_CC_BACKUP_APPOINT_REQ,
1764   3                       &ccoBackupReq);
1765   3      
1766   3              return STATUS_SUCCESS;
1767   3              
1768   3            
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 30  

1769   3          }
1770   2      
1771   2          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1772   2        } //end of while
1773   1      
1774   1        return STATUS_FAILURE;
1775   1      
1776   1        
1777   1      }
1778          
1779          
1780          
1781          void CNAM_EnableAssocNotification(sCnam *cnam, u8 *macAddr)
1782          {
1783   1      
1784   1          sLinkLayer        *linkl = NULL;
1785   1          sStaInfo          *staInfo = NULL;
1786   1      
1787   1      
1788   1          /*Compiler warning suppression*/
1789   1          macAddr = macAddr;
1790   1          cnam->accNotification = 1;
1791   1      
1792   1      
1793   1      #ifdef UKE    
                  linkl = cnam->linkl;
                  staInfo = LINKL_GetStaInfo(linkl);
              
              
                  memcpy((u8*)&cnam->ukePeer, macAddr, MAC_ADDR_LEN);
              #endif
1800   1      
1801   1          
1802   1      }
1803          
1804          void CNAM_Stop(sCnam *cnam)
1805          {
1806   1        sEvent *newEvent;
1807   1        
1808   1        newEvent = EVENT_Alloc(MAC_ADDR_LEN, 
1809   1                     EVENT_HPGP_CTRL_HEADROOM);
1810   1        if(newEvent == NULL)
1811   1        {
1812   2          FM_Printf(FM_ERROR, 
1813   2              "CNAM:EallocErr\n");
1814   2          return;
1815   2        }
1816   1        
1817   1        newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1818   1        newEvent->eventHdr.type = EVENT_TYPE_CNAM_STOP_REQ;
1819   1        
1820   1        newEvent->buffDesc.datalen = 0;
1821   1        SLIST_Put(&cnam->linkl->eventQueue, &newEvent->link);
1822   1      
1823   1      }
1824          
1825          
1826          void  CNAM_Start(sCnam *cnam, u8 ccoType)
1827          {
1828   1          sScb *scbIter = NULL;
1829   1      
1830   1      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 31  

1831   1          //if(ccoType == LINKL_CCO_TYPE_HO)
1832   1          //{
1833   1          //}
1834   1          if (ccoType == LINKL_CCO_TYPE_UNASSOC)
1835   1          {
1836   2              cnam->accNotification = 1;
1837   2          }
1838   1          else
1839   1          {
1840   2              cnam->accNotification = 0;
1841   2              //start the tei timer for each STA due to handover
1842   2              //Note: if tei timer starts already (e.g. in when CCo is associated), 
1843   2              //it would not take an affect
1844   2              scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1845   2              while(scbIter)
1846   2              {
1847   3                  if(scbIter->tei != cnam->staInfo->ccoScb->tei)
1848   3                  {
1849   4                      STM_StartTimer(scbIter->teiTimer, cnam->teiLeaseTime*60000);
1850   4                  }
1851   3              
1852   3                  scbIter = CRM_GetNextScb(cnam->crm, scbIter);
1853   3              }
1854   2          }
1855   1      #ifdef KEEP_ALIVE
1856   1        //FM_Printf(FM_USER,"CNAM STA aging timer started\n");
1857   1        STM_StartTimer(cnam->staAgingTimer,HPGP_TIME_KEEP_ALIVE);
1858   1      #endif
1859   1          cnam->state = CNAM_STATE_READY;
1860   1      }
1861          
1862          
1863          eStatus CNAM_Init(sCnam *cnam, sLinkLayer *linkl)
1864          {
1865   1          cnam->linkl = linkl;
1866   1      
1867   1          cnam->staInfo = LINKL_GetStaInfo(linkl);
1868   1          cnam->crm = LINKL_GetCrm(linkl);
1869   1      
1870   1          cnam->state = CNAM_STATE_INIT;
1871   1          cnam->accNotification = 0;
1872   1          cnam->teiLeaseTime = HPGP_TIME_TEI_LEASE_NOAUTH_MIN;   //15 minutes
1873   1          cnam->teiLeaseTimeAuth = HPGP_TIME_TEI_LEASE_AUTH_MIN; //48 hours
1874   1      
1875   1        cnam->backupCCoCfg.scb = NULL;
1876   1      //    cnam->ccoInfo = LINKL_GetCcoInfo(linkLayer);
1877   1      #ifdef KEEP_ALIVE
1878   1        cnam->staAgingTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
1879   1                    EVENT_TYPE_TIMER_KEEP_LIVE_IND,linkl);
1880   1        if(cnam->staAgingTimer == STM_TIMER_INVALID_ID)
1881   1        {
1882   2          return STATUS_FAILURE;
1883   2        }
1884   1      #endif
1885   1      
1886   1          return STATUS_SUCCESS;
1887   1      }
1888          
1889          #endif /* CCO_FUNC */
1890          
1891          /* --------------------------
1892           * STA network access manager
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 32  

1893           * -------------------------- */
1894          
1895          #ifdef STA_FUNC
1896          
1897          
1898          #ifdef UKE
              void SNAM_EnableAssocNtf(sSnam *snam, u8 *macAddr)
              {
                  sLinkLayer    *linkl = snam->linkl;
                  sStaInfo      *staInfo = LINKL_GetStaInfo(linkl);
              
                  snam->ukePeerNotification = 1;
                  
                  memcpy(&snam->ukePeer, macAddr, MAC_ADDR_LEN);
              
              }
              #endif
1910          eStatus SNAM_SendMgmtMsg(sSnam *snam, u16 mmType)
1911          {
1912   1          eStatus        status = STATUS_FAILURE;
1913   1          sEvent      xdata  *newEvent = NULL;
1914   1          sHpgpHdr      *newHpgpHdr = NULL;
1915   1          sCcAssocReq   *assocReq = NULL;
1916   1          sCcLeaveReq   *leaveReq = NULL;
1917   1          sCcCcoApptReq *ccoApptReq = NULL;
1918   1        sCcBackupCnf  *ccoBackupCnf = NULL;
1919   1          u16            eventSize = 0;
1920   1      //    sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1921   1          sLinkLayer    *linkl = snam->linkl;
1922   1          sStaInfo      *staInfo = LINKL_GetStaInfo(linkl);
1923   1      
1924   1          //build the CC_ASSOC.REQ
1925   1          eventSize = MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sMgmtMsg));
1926   1          newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
1927   1          if(newEvent == NULL)
1928   1          {
1929   2              FM_Printf(FM_ERROR, "EAllocErr\n");
1930   2              return STATUS_FAILURE;
1931   2          }
1932   1      
1933   1          newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
1934   1          switch(mmType)
1935   1          {
1936   2            case EVENT_TYPE_CC_BACKUP_APPOINT_CNF:
1937   2            
1938   2            newEvent->eventHdr.type = EVENT_TYPE_CC_BACKUP_APPOINT_CNF;
1939   2            
1940   2                  newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
1941   2                  newHpgpHdr->tei = staInfo->ccoScb->tei;
1942   2                  newHpgpHdr->macAddr = staInfo->ccoScb->macAddr;
1943   2                  newHpgpHdr->snid = staInfo->snid;
1944   2      
1945   2            newHpgpHdr->eks = staInfo->nekEks;
1946   2               
1947   2                  ccoBackupCnf = (sCcBackupCnf *)(newEvent->buffDesc.dataptr); 
1948   2                  ccoBackupCnf->result = snam->backupCCoCfg.result; //usre request
1949   2                  newEvent->buffDesc.datalen += HPGP_DATA_PAYLOAD_MIN;
1950   2      #ifdef P8051
1951   2                  FM_Printf(FM_MMSG, "SNAM:>>BACKUP_APPOINT_CNF(tei:%bu)\n",
1952   2                                     newHpgpHdr->tei);
1953   2      #else
                          FM_Printf(FM_MMSG, "SNAM:>>BACKUP_APPOINT_CNF(tei:%d)\n",
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 33  

                                             newHpgpHdr->tei);
              #endif
1957   2                
1958   2            break;
1959   2            
1960   2              case EVENT_TYPE_CC_ASSOC_REQ:
1961   2              {
1962   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_ASSOC_REQ;
1963   3               
1964   3      
1965   3                  newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
1966   3      #ifdef QCA
                          newHpgpHdr->tei = 0xFF;
              #else
1969   3                  newHpgpHdr->tei = staInfo->ccoScb->tei;
1970   3      #endif
1971   3                  newHpgpHdr->macAddr = staInfo->ccoScb->macAddr;
1972   3                  newHpgpHdr->snid = staInfo->snid;
1973   3      
1974   3                  if (snam->teiRenew)
1975   3                  {
1976   4                      newHpgpHdr->eks = staInfo->nekEks;
1977   4                  }
1978   3                  else
1979   3                  {
1980   4                      newHpgpHdr->eks = HPGP_EKS_NONE;
1981   4                  }
1982   3       
1983   3                  assocReq = (sCcAssocReq *)(newEvent->buffDesc.dataptr); 
1984   3                  assocReq->reqType = snam->teiRenew; //new request    
1985   3                  memcpy(assocReq->nid, staInfo->nid, NID_LEN);
1986   3      
1987   3            //FM_HexDump(FM_USER,"nidtx", assocReq->nid, NID_LEN);
1988   3                  assocReq->ccoCap = staInfo->staCap.fields.ccoCap;
1989   3                  assocReq->proxyNetCap = 0;
1990   3                  newEvent->buffDesc.datalen +=MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sCcAssocReq));            
1991   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_ASSOC_REQ, NULL, 0);
              #endif
1994   3                  FM_Printf(FM_MMSG, "SNAM:>>CC_ASSOC.REQ(tei:%bu)\n",
1995   3                                     newHpgpHdr->tei);
1996   3                  break;
1997   3              }
1998   2              case EVENT_TYPE_CC_LEAVE_REQ:
1999   2              {
2000   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_LEAVE_REQ;
2001   3      
2002   3                  newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
2003   3                  newHpgpHdr->tei = staInfo->ccoScb->tei;
2004   3                  newHpgpHdr->macAddr = staInfo->ccoScb->macAddr;
2005   3                  newHpgpHdr->snid = staInfo->snid;
2006   3                  if (staInfo->staStatus.fields.authStatus)
2007   3                  {
2008   4                      newHpgpHdr->eks = staInfo->nekEks;
2009   4                  }
2010   3                  else
2011   3                  {
2012   4                      newHpgpHdr->eks = HPGP_EKS_NONE;
2013   4                  }
2014   3      
2015   3                  leaveReq = (sCcLeaveReq *)(newEvent->buffDesc.dataptr); 
2016   3                  leaveReq->reason = snam->leaveReq.reason; //usre request
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 34  

2017   3                  newEvent->buffDesc.datalen += HPGP_DATA_PAYLOAD_MIN;
2018   3      #ifdef LOG_FLASH
                          logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_REQ, &newHpgpHdr->tei, 1);
              #endif
2021   3      #ifdef P8051
2022   3                  FM_Printf(FM_MMSG, "SNAM:>>CC_LEAVE.REQ(tei:%bu)\n",
2023   3                                     newHpgpHdr->tei);
2024   3      #else
                          FM_Printf(FM_MMSG, "SNAM:>>CC_LEAVE.REQ(tei:%d)\n",
                                             newHpgpHdr->tei);
              #endif
2028   3                  break;
2029   3              }
2030   2      #ifdef APPOINT
                      case EVENT_TYPE_CC_CCO_APPOINT_REQ:
                      {
                          newEvent->eventHdr.type = EVENT_TYPE_CC_CCO_APPOINT_REQ;
              
                          newHpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                          newHpgpHdr->tei = staInfo->ccoScb->tei;
                          newHpgpHdr->macAddr = staInfo->ccoScb->macAddr;
                          newHpgpHdr->snid = staInfo->snid;
                    newHpgpHdr->eks = staInfo->nekEks;
              
              
                          ccoApptReq = (sCcCcoApptReq *)(newEvent->buffDesc.dataptr); 
                          memcpy(ccoApptReq, &snam->ccoApptReq, sizeof(sCcCcoApptReq));
                          newEvent->buffDesc.datalen +=MAX(HPGP_DATA_PAYLOAD_MIN, sizeof(sCcCcoApptReq));
              #ifdef P8051
                          FM_Printf(FM_MMSG, "SNAM:>>CCO_APPOINT.REQ(tei:%bu)\n",
                                             newHpgpHdr->tei);
              #else
                          FM_Printf(FM_MMSG, "SNAM:>>CCO_APPOINT.REQ(tei:%d)\n",
                                             newHpgpHdr->tei);
              #endif
                          break;
                      }
              #endif
2055   2      #ifdef KEEP_ALIVE       
2056   2          case EVENT_TYPE_VENDOR_KEEP_ALIVE_IND:
2057   2          {
2058   3               
2059   3                  //FM_Printf(FM_USER, "SNSM:>>CC_VD_KEEP_ALIVE.IND\n");
2060   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
2061   3                  newEvent->eventHdr.type = EVENT_TYPE_VENDOR_KEEP_ALIVE_IND;
2062   3      
2063   3                  newHpgpHdr      = (sHpgpHdr *)newEvent->buffDesc.buff; 
2064   3                  newHpgpHdr->tei   = snam->staInfo->ccoScb->tei;
2065   3                  newHpgpHdr->macAddr = snam->staInfo->ccoScb->macAddr; 
2066   3                  newHpgpHdr->snid  = snam->staInfo->snid;      
2067   3            newHpgpHdr->eks   = staInfo->nekEks;
2068   3            newEvent->buffDesc.datalen += HPGP_DATA_PAYLOAD_MIN;
2069   3            break;
2070   3          }
2071   2      #endif    
2072   2              default:
2073   2              {
2074   3              }
2075   2          }
2076   1          EVENT_Assert(newEvent);
2077   1          //transmit the mgmt msg
2078   1          status = MUXL_TransmitMgmtMsg(newEvent);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 35  

2079   1          //the event is freed by MUXL if the TX is successful
2080   1          if(status == STATUS_FAILURE)
2081   1          {
2082   2              EVENT_Free(newEvent);
2083   2          }
2084   1      
2085   1          return status;
2086   1      }
2087          
2088          
2089          eStatus SNAM_DeliverEvent(sSnam *snam, u16 eventType, uEventBody *eventBody)
2090          {
2091   1          sEvent       *newEvent = NULL;
2092   1      //    sLinkLayer   *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2093   1          sLinkLayer   *linkl = snam->linkl;
2094   1      
2095   1          newEvent = EVENT_Alloc(sizeof(uEventBody), 0);
2096   1          if(newEvent == NULL)
2097   1          {
2098   2              FM_Printf(FM_ERROR, "SNAM:EAllocErr\n");
2099   2              return STATUS_FAILURE;
2100   2          }
2101   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
2102   1          newEvent->eventHdr.type = eventType;
2103   1       
2104   1          switch(eventType)
2105   1          {
2106   2              case EVENT_TYPE_NET_LEAVE_IND:
2107   2              {
2108   3                  *(newEvent->buffDesc.dataptr) = eventBody->netLeaveInd.reason;
2109   3            newEvent->buffDesc.datalen = 1;
2110   3        
2111   3                  break;
2112   3              }
2113   2              case EVENT_TYPE_NET_ACC_RSP:
2114   2              {
2115   3                  *(newEvent->buffDesc.dataptr) = eventBody->netAccRsp.result;
2116   3            newEvent->buffDesc.datalen = 1;           
2117   3              
2118   3                  break;
2119   3              }
2120   2              default:
2121   2              {
2122   3                 //event with null event body:
2123   3                 //EVENT_TYPE_NET_LEAVE_RSP
2124   3              }
2125   2          }
2126   1      
2127   1          //deliver the event to the upper layer
2128   1      #ifdef CALLBACK
                  linkl->deliverEvent(linkl->eventcookie, newEvent);
              #else
2131   1          CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
2132   1      #endif
2133   1          
2134   1          return STATUS_SUCCESS;
2135   1      }
2136          
2137          
2138          //Process CC_SET_TEI_MAP.IND: update tei map table
2139          void SNAM_ProcTeiMapInd(sSnam *snam,  sCcTeiMapInd *teiMapInd)
2140          {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 36  

2141   1          sTeiMap       *teiMap = NULL;
2142   1          u8             numSta;
2143   1      //    sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2144   1          sLinkLayer    *linkl = snam->linkl;
2145   1          sCrm          *crm = LINKL_GetCrm(linkl);
2146   1        sStaInfo   *staInfo  = LINKL_GetStaInfo(linkl);
2147   1          sScb          *scb = NULL;
2148   1      
2149   1          switch (teiMapInd->mode)
2150   1          {
2151   2              case HPGP_TEI_MAP_MODE_NEW: 
2152   2              {
2153   3                  //update entire tei map table
2154   3                  numSta = teiMapInd->numSta;  
2155   3                  teiMap = &teiMapInd->teiMap;
2156   3                  while(numSta)
2157   3                  {
2158   4                      scb = CRM_AddScb(crm, teiMap->tei);
2159   4                      if(scb)
2160   4                      {
2161   5                          memcpy(scb->macAddr, teiMap->macAddr, MAC_ADDR_LEN);
2162   5                          scb->staStatus.fields.authStatus = teiMap->status;
2163   5      
2164   5                scb->namState = STA_NAM_STATE_CONN;
2165   5                          teiMap++;
2166   5                          numSta--;
2167   5      #ifdef ROUTE
                                  if(scb != staInfo->staScb)
                                  {                        
                                      ROUTE_initLrtEntry(scb);                                                
                                  }
                                  
              #endif
2174   5                          if(scb != staInfo->staScb)
2175   5                          {
2176   6      #ifdef STA_ID
              
                                      scb->identityCapUpdated = FALSE;
                                      scb->identityCapUpdatedRetry = 3;
                                      
                                      STM_StartTimer(snam->identifyCapTimer,HPGP_IDENTIFY_CAP_TIME);
              #else
2183   6                              scb->identityCapUpdated = TRUE;
2184   6                              scb->identityCapUpdatedRetry = 0;
2185   6      #endif
2186   6                          }
2187   5      //                    scb->uMaxSSN = 0;
2188   5                          scb->uMinSSN = 0;
2189   5                          scb->uWrapAround = 0;
2190   5      
2191   5      
2192   5                if(scb->teiTimer == STM_TIMER_ID_NULL)
2193   5                {
2194   6                  scb->teiTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
2195   6                    EVENT_TYPE_TIMER_TEI_IND, scb);
2196   6                }
2197   5      
2198   5      
2199   5                      }
2200   4                      else
2201   4                      {
2202   5                          FM_Printf(FM_ERROR, "SNAM:can't add scb\n");
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 37  

2203   5                          break;
2204   5                      }
2205   4                  }
2206   3                  break;
2207   3              }
2208   2              case HPGP_TEI_MAP_MODE_ADD:
2209   2              {
2210   3                  teiMap = &teiMapInd->teiMap;
2211   3                  scb = CRM_AddScb(crm, teiMap->tei);
2212   3                  if(scb)
2213   3                  {
2214   4                      sHpgpHdr *hpgpHdr;
2215   4      
2216   4                      /*Compiler warning suppression*/
2217   4                      hpgpHdr = hpgpHdr;
2218   4                    
2219   4                      memcpy(scb->macAddr, teiMap->macAddr, MAC_ADDR_LEN);
2220   4                      scb->staStatus.fields.authStatus = teiMap->status;
2221   4                      
2222   4      #ifdef ROUTE
                              ROUTE_initLrtEntry(scb);                
                              
              #endif
2226   4      //                scb->uMaxSSN = 0;
2227   4                      scb->uMinSSN = 0;
2228   4                      scb->uWrapAround = 0;
2229   4                      
2230   4      
2231   4              scb->namState = STA_NAM_STATE_CONN;
2232   4      #ifdef STA_ID
                              scb->identityCapUpdated = FALSE;
                              scb->identityCapUpdatedRetry = 3;
                                
                              STM_StartTimer(snam->identifyCapTimer,HPGP_IDENTIFY_CAP_TIME);
              #else
2238   4                      scb->identityCapUpdated = TRUE;
2239   4                      scb->identityCapUpdatedRetry = 0;
2240   4      #endif
2241   4      
2242   4      #ifdef UKE 
                              if ((snam->ukePeerNotification) &&
                                   (!memcmp(&snam->ukePeer, &teiMap->macAddr, MAC_ADDR_LEN )))
                              {
              
                                  {
                                          sEvent *newEvent;
                                          
                                          //send the event to the SNAM to renew the TEI
                                          newEvent = EVENT_Alloc(MAC_ADDR_LEN, 
                                                                 EVENT_HPGP_CTRL_HEADROOM);
                                          if(newEvent == NULL)
                                          {
                                              FM_Printf(FM_ERROR, "SNAM:EAllocErr\n");
                                              break;
                                          }
                                          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                                          newEvent->eventHdr.type = EVENT_TYPE_ASSOC_IND;
                                          hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                                          hpgpHdr->scb = (sScb*)scb;
              
                                          //send the event to the SNAM
                                          //LINKL_SendEvent(linkl, newEvent);
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 38  

                                          memcpy(newEvent->buffDesc.dataptr,snam->ukePeer, MAC_ADDR_LEN);
                                          newEvent->buffDesc.datalen = MAC_ADDR_LEN;
              
                                          snam->ukePeerNotification = 0;
                                          
                                          //SLIST_Put(&linkl->intEventQueue, &newEvent->link);
                                          LINKL_SendEvent(linkl, newEvent);
                                          
                              
                                      }
                              }
              #endif        
2277   4      
2278   4              if(scb->teiTimer == STM_TIMER_ID_NULL)
2279   4              {
2280   5                scb->teiTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
2281   5                            EVENT_TYPE_TIMER_TEI_IND, scb);
2282   5              }
2283   4      
2284   4                  }
2285   3                  
2286   3                  break;
2287   3              }
2288   2              case HPGP_TEI_MAP_MODE_DELETE: 
2289   2              {
2290   3      
2291   3                  //remove it from the TEI MAP
2292   3                  teiMap = &teiMapInd->teiMap;
2293   3                  scb = CRM_GetScb(crm, teiMap->tei);
2294   3                  if(scb)
2295   3                  {
2296   4      //                scb->uMaxSSN = 0;
2297   4                      scb->uMinSSN = 0;
2298   4                      scb->uWrapAround = 0;
2299   4                  
2300   4      #ifdef ROUTE
                          ROUTE_preparteAndSendUnreachable(scb);            
              #endif  // ROUTE
2303   4      #ifdef LOG_FLASH
                          scbFreeReason = TEI_MAP_DELETE;
              #endif      
2306   4                  CRM_FreeScb(crm, scb);
2307   4      
2308   4            { 
2309   5              hostEvent_peerLeave_t pLeave;
2310   5      
2311   5              memcpy(pLeave.macAddress, scb->macAddr, MAC_ADDR_LEN);
2312   5              pLeave.tei = scb->tei;
2313   5              pLeave.reason = 0;
2314   5      
2315   5                
2316   5      
2317   5              Host_SendIndication(HOST_EVENT_PEER_STA_LEAVE, HPGP_MAC_ID, (u8*)&pLeave,
2318   5                          sizeof(hostEvent_peerLeave_t));
2319   5      
2320   5            }
2321   4      #ifdef NAM_PRINT
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNAM:rm SCB(tei: %bu) TEI map\n", teiMap->tei);
              #else
              FM_Printf(FM_ERROR, "SNAM:rm SCB(tei: %d) TEI map\n", teiMap->tei);
              #endif
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 39  

              #endif
2328   4                  //TODO: shall we remove it from the discovered sta list right now?
2329   4                  //Or let it age out later 
2330   4                  }
2331   3                  break;
2332   3              }
2333   2              default:
2334   2              {
2335   3              }
2336   2          }
2337   1      
2338   1      }
2339          
2340          //extern void SNSM_clearBlackList();
2341          
2342          //extern void SNSM_blackListCCo(u8 snid);
2343          
2344          void SNAM_StartTEIRenew()
2345          {
2346   1        sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2347   1        
2348   1        sSnam         *snam = &linkl->staNam;
2349   1        
2350   1        sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
2351   1      
2352   1      
2353   1        u32 renewTime = (staInfo->macAddr[5] * 40);
2354   1        STM_StopTimer(snam->teiTimer);
2355   1        STM_StartTimer(snam->teiTimer, renewTime);
2356   1      
2357   1      
2358   1      }
2359          
2360          void SNAM_ProcEvent(sSnam *snam, sEvent *event)
2361          {
2362   1          u8             staType;
2363   1          u8             txCcoApptRsp;
2364   1          sCcAssocCnf   *assocCnf = NULL;
2365   1          sCcLeaveInd   *leaveInd = NULL;
2366   1          sCcTeiMapInd  *teiMapInd = NULL;
2367   1          sCcCcoApptReq *ccoApptReq = NULL;
2368   1          sCcCcoApptCnf *ccoApptCnf = NULL;
2369   1        sCcBackupReq  *ccoBackupReq;
2370   1          sEvent        *newEvent = NULL;
2371   1          sHpgpHdr      *hpgpHdr = NULL;
2372   1          uEventBody    eventBody;
2373   1          u16           eventType;
2374   1          sScb          *scb = NULL;
2375   1      //    sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2376   1          sLinkLayer    *linkl = snam->linkl;
2377   1          sStaInfo      *staInfo = LINKL_GetStaInfo(linkl);
2378   1          sCrm          *crm = LINKL_GetCrm(linkl);
2379   1          sNma          *nma = HOMEPLUG_GetNma();
2380   1      //    sSnsm         *snsm = LINKL_GetSnsm(linkl);
2381   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2382   1      
2383   1          /*Compiler warning suppression*/
2384   1          txCcoApptRsp = txCcoApptRsp;
2385   1          
2386   1          switch(snam->state)
2387   1          {
2388   2              case SNAM_STATE_INIT:
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 40  

2389   2              {
2390   3                  if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL)&& 
2391   3                      (event->eventHdr.type == EVENT_TYPE_SNAM_START) )
2392   3                  {
2393   4                      staType = *(event->buffDesc.dataptr);
2394   4       #ifdef NAM_PRINT                 
              FM_Printf(FM_ERROR, "SNAM:Start(staType: %bu)\n", staType);
              #endif
2397   4                      if(staType == LINKL_STA_TYPE_ASSOC)
2398   4                      {
2399   5      #ifdef NAM_PRINT        
              FM_Printf(FM_ERROR, "SNAM:Start as ASSOC STA\n");
              #endif
2402   5                          //handover, role from the CCo to the STA 
2403   5                          snam->state = SNAM_STATE_CONN;
2404   5      #ifdef KEEP_ALIVE     
2405   5                STM_StopTimer(snam->keepAlive);
2406   5                STM_StartTimer(snam->keepAlive,
2407   5                                       HPGP_TIME_KEEP_ALIVE);
2408   5      #endif  
2409   5                      }
2410   4                      else 
2411   4                      {
2412   5                          //for net disc and unassociated STA,
2413   5                          //transit to the ready state 
2414   5                          //as the upper layer may issue net access request 
2415   5                          //when it finds the CCo
2416   5                          snam->state = SNAM_STATE_READY;
2417   5                      }
2418   4                      //if(staType == LINKL_STA_TYPE_UNASSOC)
2419   4                  }
2420   3                  break;
2421   3              }
2422   2              case SNAM_STATE_READY:
2423   2              {
2424   3                  if( event->eventHdr.eventClass == EVENT_CLASS_CTRL)
2425   3                  {
2426   4                      switch(event->eventHdr.type)
2427   4                      {
2428   5                          case EVENT_TYPE_NET_ACC_REQ: 
2429   5                          {
2430   6      //                if(staInfo->staScb == NULL)
2431   6      //                {
2432   6                              snam->teiRenew = 0;
2433   6      //                }
2434   6      //                else
2435   6      //                {
2436   6                          //in case of CCo handover changing the CCo to STA 
2437   6      //                    snam->teiRenew = 1;
2438   6      //                }
2439   6                              SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_ASSOC_REQ);
2440   6      
2441   6                              /* regardless of tx success, do the retransmission */
2442   6                              STM_StartTimer(snam->accTimer, HPGP_TIME_ASSOC);
2443   6                              snam->txRetryCnt++; 
2444   6                              snam->state = SNAM_STATE_WAITFOR_CC_ASSOC_RSP;
2445   6                              
2446   6                        
2447   6      
2448   6                              break;
2449   6                          }
2450   5                          case EVENT_TYPE_SNAM_STOP: 
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 41  

2451   5                          {
2452   6                              LINKL_StopSta(linkl);
2453   6                              snam->state = SNAM_STATE_INIT;
2454   6                              break;
2455   6                          }
2456   5                          default:
2457   5                          {
2458   6                          }
2459   5                      }
2460   4                  }
2461   3                  break;
2462   3              }
2463   2              case SNAM_STATE_CONN:
2464   2              {
2465   3                  if( event->eventHdr.eventClass == EVENT_CLASS_MSG) 
2466   3                  {
2467   4                      switch(event->eventHdr.type)
2468   4                      {
2469   5      
2470   5                case EVENT_TYPE_CC_BACKUP_APPOINT_REQ:
2471   5                {
2472   6      #ifndef LG_WAR
2473   6      //            FM_Printf(FM_MMSG, "SNAM:<<BACKUP_APPOINT_REQ:(tei:%bu)\n", 
2474   6        //                                                  hpgpHdr->tei);
2475   6      
2476   6                  ccoBackupReq = (sCcBackupReq*)event->buffDesc.dataptr;
2477   6      
2478   6                  if (ccoBackupReq->action == HPGP_CCO_BACKUP_REQ_APPOINT)
2479   6                  {
2480   7      
2481   7                    if (staInfo->staCap.fields.backupCcoCap)
2482   7                    {
2483   8                      snam->backupCCoCfg.result = 0;
2484   8                      staInfo->staCap.fields.backupCcoStatus = 1;
2485   8      
2486   8      
2487   8                      Host_SendIndication(HOST_EVENT_SELECTED_BACKUP_CCO, HPGP_MAC_ID, NULL, 0);
2488   8      
2489   8                    }
2490   7                    else
2491   7                    {               
2492   8                      snam->backupCCoCfg.result = 1;                
2493   8                    }
2494   7      
2495   7                  }
2496   6                  else
2497   6                  if (ccoBackupReq->action == HPGP_CCO_BACKUP_REQ_RELEASE)
2498   6                  {
2499   7      
2500   7                    if (staInfo->staCap.fields.backupCcoStatus)
2501   7                    {
2502   8                      snam->backupCCoCfg.result = 0;
2503   8                      staInfo->staCap.fields.backupCcoStatus = 0;
2504   8      
2505   8                    }
2506   7                    else
2507   7                    {               
2508   8                      snam->backupCCoCfg.result = 1;                
2509   8                    }
2510   7      
2511   7                  }
2512   6      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 42  

2513   6                  SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_BACKUP_APPOINT_CNF);
2514   6      #endif
2515   6      
2516   6                  break;
2517   6                                      
2518   6      
2519   6      
2520   6                }
2521   5                
2522   5                          case EVENT_TYPE_CC_LEAVE_IND:
2523   5                          {                      
2524   6                          
2525   6                      
2526   6                              FM_Printf(FM_MMSG, "SNAM:<<CC_LEAVE_IND(tei:%bu)\n", 
2527   6                                                          hpgpHdr->tei);
2528   6      #ifdef LOG_FLASH
                                      logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_IND, &hpgpHdr->tei, 1);
              #endif
2531   6                              
2532   6                              STM_StopTimer(snam->teiTimer);
2533   6                              //SNSM_LeaveConn(&linkl->staNsm);
2534   6                              SNSM_Stop(&linkl->staNsm);
2535   6      #ifdef AKM
              
                          AKM_Stop(&linkl->akm);
              #endif
2539   6                              //CRM_FreeScb(crm, staInfo->staScb);
2540   6                              //remove the TEI MAP
2541   6                              CRM_Init(crm);
2542   6                              staInfo->staScb = NULL;
2543   6                              staInfo->ccoScb = NULL;
2544   6      
2545   6                              
2546   6                              //set the MAC routing table to stop the data path
2547   6                            
2548   6                              //stop the SHOM
2549   6      
2550   6                              leaveInd = (sCcLeaveInd *)(event->buffDesc.dataptr); 
2551   6                              eventBody.netLeaveInd.reason = leaveInd->reason;
2552   6                              
2553   6                    CHAL_DelayTicks(300000); // give time to cco to STOP beaconing
2554   6           
2555   6                              SNAM_DeliverEvent(snam, EVENT_TYPE_NET_LEAVE_IND,
2556   6                                                &eventBody);
2557   6                              
2558   6                              //stay the state    
2559   6                              snam->state = SNAM_STATE_READY;
2560   6                              break;
2561   6                          }
2562   5                          case EVENT_TYPE_CC_SET_TEI_MAP_IND:
2563   5                          {
2564   6      #ifdef P8051
2565   6                      FM_Printf(FM_MMSG, "SNAM:<<SET_TEI_MAP.IND(tei:%bu)\n",
2566   6                                                  hpgpHdr->tei);
2567   6      #else
                              FM_Printf(FM_MMSG, "SNAM:<<SET_TEI_MAP.IND(tei:%d)\n",
                                                          hpgpHdr->tei);
              #endif
2571   6                              teiMapInd = (sCcTeiMapInd *)event->buffDesc.dataptr; 
2572   6                              SNAM_ProcTeiMapInd(snam, teiMapInd);
2573   6                              break;
2574   6                          }
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 43  

2575   5      #ifdef APPOINT
                                  case EVENT_TYPE_CC_CCO_APPOINT_CNF:
                                  {
              #ifdef P8051
                         //      FM_Printf(FM_MMSG, "SNAM:<<CCO_APPOINT.CNF(tei:%bu)\n",
                           //                               hpgpHdr->tei);
              #else
                             //  FM_Printf(FM_MMSG, "SNAM:<<CCO_APPOINT.CNF(tei:%d)\n",
                               //                           hpgpHdr->tei);
              #endif
              
                                      snam->apptTxRetryCnt = 0; 
                                      STM_StopTimer(snam->apptTimer); 
                                      STM_FreeTimer(snam->apptTimer); 
                                      
                                      ccoApptCnf = (sCcCcoApptCnf *)(event->buffDesc.dataptr);
              #ifdef NMA
                                      /* respond to the NMA */
                                      NMA_SendCcoApptCnf(nma, ccoApptCnf->result);
              #endif
              /*
                                      eventBody.ccoApptRsp.result = ccoApptCnf->result;
                                      SNAM_DeliverEvent(snam, EVENT_TYPE_CCO_APPOINT_RSP,
                                                        &eventBody);
              */ 
              
                                      break;
                                  }
              #endif
2604   5      #ifdef STA_ID         
                                  case EVENT_TYPE_CM_STA_IDENTIFY_REQ:                    
                                  {
                                      IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_REQ, event);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_STA_IDENTIFY_CNF:                    
                                  {
                                      IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_CNF, event);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_STA_IDENTIFY_RSP:                    
                                  {
                                      IDENTIFY_procFrm(EVENT_TYPE_CM_STA_IDENTIFY_RSP, event);
                                      break;
                                  }
              #endif          
2621   5                          default:
2622   5                          {
2623   6                             // FM_Printf(FM_HINFO, "SNAM:%bu\n",event->eventHdr.type);
2624   6                          }
2625   5                      }
2626   4                  }
2627   3                  else if( event->eventHdr.eventClass == EVENT_CLASS_CTRL) 
2628   3                  {
2629   4                      switch(event->eventHdr.type)
2630   4                      {
2631   5      #ifdef APPOINT
                                  case EVENT_TYPE_CCO_APPOINT_REQ: // user appointed CCO
                                  {
                                      snam->apptTxRetryCnt = 0; 
              #ifdef CALLBACK
                                      snam->apptTimer = STM_AllocTimer(LINKL_TimerHandler,
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 44  

                                                            EVENT_TYPE_TIMER_APPT_IND, linkl);
              #else
                                      snam->apptTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
                                                            EVENT_TYPE_TIMER_APPT_IND, linkl);
              #endif
              
                                      txCcoApptRsp = 0;
                                      if(snam->apptTimer != STM_TIMER_INVALID_ID)
                                      {
                                          
                                          ccoApptReq = (sCcCcoApptReq *)(event->buffDesc.dataptr); 
                                          memcpy(&snam->ccoApptReq, ccoApptReq, 
                                                 sizeof(sCcCcoApptReq));
              
                                          if(SNAM_SendMgmtMsg(snam, 
                                                              EVENT_TYPE_CC_CCO_APPOINT_REQ)
                                              == STATUS_SUCCESS)
                                          {
                                              STM_StartTimer(snam->apptTimer, 
                                                             HPGP_TIME_USER_APPT_CCO);
                                              snam->apptTxRetryCnt++; 
                                              //snam->state = SNAM_STATE_WAITFOR_CC_CCO_APPOINT_CNF;
                                              //stay in the same state as it takes a time for rsp?
                                          }
                                          else
                                          {
                                              txCcoApptRsp = 1;
                                              STM_StopTimer(snam->apptTimer); 
                                              STM_FreeTimer(snam->apptTimer); 
                                          }
                                      }
                                      else
                                      {
                                          txCcoApptRsp = 1;
                                      }
                                      if(txCcoApptRsp)
                                      {
                                          //TODO: the result could be various due to
                                          //different request type. 
                                          //Here we simply use one and fix it later
                                          eventBody.ccoApptRsp.result = 
                                              HPGP_CCO_APPT_CNF_REJECT;
                                          SNAM_DeliverEvent(snam, EVENT_TYPE_CCO_APPOINT_RSP,
                                                            &eventBody);
                                      }
              
                                      break;
                                  }
              #endif
2686   5      /*
2687   5                          case EVENT_TYPE_CCO_HO_IND: //switch to the new CCO: renew 
2688   5                          {
2689   5                              //wait for the central beacon coming first
2690   5                              SNSM_EnableCcoDetection(snsm);
2691   5                              break; 
2692   5                          }
2693   5      */
2694   5                          case EVENT_TYPE_TIMER_TEI_IND: //tei lease expires: renew 
2695   5                          case EVENT_TYPE_CCO_DISC_IND:  //handover to new CCO: renew
2696   5                          {
2697   6                              snam->teiRenew = 1;
2698   6                              if(SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_ASSOC_REQ)
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 45  

2699   6                                      == STATUS_SUCCESS)
2700   6                              {
2701   7                                  STM_StartTimer(snam->accTimer, HPGP_TIME_ASSOC);
2702   7                                  snam->txRetryCnt++; 
2703   7                                  snam->state = SNAM_STATE_WAITFOR_CC_ASSOC_RSP;
2704   7                              }
2705   6                              break;
2706   6                          }
2707   5                          case EVENT_TYPE_NET_LEAVE_REQ:
2708   5                          {
2709   6      #ifdef AKM            
                           AKM_Stop(&linkl->akm);
              #endif
2712   6                   linkl->staNsm.enableBcnLossDetection = 0;
2713   6      #ifdef POWERSAVE
                                  scb = (sScb *)(hpgpHdr->scb);
                          if (scb->psState != PSM_PS_STATE_OFF)
                          {
                            // send PS_EXIT.REQ
                            PSM_set_sta_PS(FALSE, 0xF);
                            PSM_resetScbPs(scb);  // set SCB's PS data to init state 
                          }
              #endif
2722   6                              snam->leaveReq.reason = HPGP_LEAVE_REQ_REASON_USER_REQ;
2723   6      #ifndef MULTIDEV
2724   6                              if(SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_LEAVE_REQ) 
2725   6                                      == STATUS_SUCCESS)
2726   6      #endif                
2727   6                              {
2728   7      #ifndef MULTIDEV
2729   7                                  STM_StartTimer(snam->accTimer, HPGP_TIME_ASSOC);
2730   7                                  snam->txRetryCnt++; 
2731   7                                  snam->state = SNAM_STATE_WAITFOR_CC_LEAVE_RSP;
2732   7      #else
                                     snam->state = SNAM_STATE_READY;
                                          {
                                              STM_StopTimer(snam->teiTimer);
              #ifdef HOM
                              SHOM_Stop(&linkl->staHom);
              #endif
                                              SNAM_DeliverEvent(snam, EVENT_TYPE_NET_LEAVE_RSP, NULL);
                                              snam->stopDataPath = 0;
                                          }
              #endif
2743   7                              }
2744   6                              break;
2745   6                          }
2746   5      #ifdef APPOINT
                                  case EVENT_TYPE_TIMER_APPT_IND:
                                  {
                                      if( snam->apptTxRetryCnt <= HPGP_TX_RETRY_MAX)
                                      { 
                                          //resend the message
                                          SNAM_SendMgmtMsg( snam, 
                                                            EVENT_TYPE_CC_CCO_APPOINT_REQ);
              
                                          STM_StartTimer(snam->apptTimer, 
                                                         HPGP_TIME_USER_APPT_CCO);
                                          snam->apptTxRetryCnt++; 
                                          //stay in the same CONN state
                                      }
                                      else
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 46  

                                      {
                                          //retry exhausted
                                          snam->apptTxRetryCnt = 0; //reset
                                          STM_FreeTimer(snam->apptTimer); 
                                          //stay in the same CONN state
                                      }
                                      break;
                                  }
              #endif
2770   5                          case EVENT_TYPE_SNAM_STOP: 
2771   5                          {
2772   6                              //stop the SNAM Tei lease timer
2773   6                              LINKL_StopSta(linkl);
2774   6                              STM_StopTimer(snam->teiTimer);
2775   6                              snam->state = SNAM_STATE_INIT;
2776   6                              break; 
2777   6                          }
2778   5                          case EVENT_TYPE_AUTH_CPLT:
2779   5                          {   
2780   6      #ifdef STA_ID
                                        IDENTIFY_sendFrm(EVENT_TYPE_CM_STA_IDENTIFY_IND, NULL, staInfo->ccoScb);
              #endif
2783   6      #ifdef ROUTE
                                        if(staInfo->identifyCaps.routingCap == TRUE)
                                        {
                                            ROUTE_startUpdateTimer();
                                        }
              #endif
2789   6                                break;
2790   6                          }
2791   5      #ifdef STA_ID
              
                                  case EVENT_TYPE_IDENTIFY_CAP_TIMEOUT:
                        {
                                      scb = CRM_GetNextScb(&linkl->ccoRm, scb);
                                      while(scb)
                                      {
                                          if(scb->identityCapUpdated == FALSE)
                                          {
                                              if( scb->identityCapUpdatedRetry)
                                              {
                                                  IDENTIFY_sendFrm(EVENT_TYPE_CM_STA_IDENTIFY_REQ, NULL, scb);
                                                  scb->identityCapUpdatedRetry--;
                                              }
                                              else
                                              {
                                                  scb->identityCapUpdated = TRUE;
                                              }
                                              break;
                                          }
                                          scb = CRM_GetNextScb(&linkl->ccoRm, scb);
                                      }
                                      if(scb != NULL)
                                      {
                                          STM_StartTimer(snam->identifyCapTimer,HPGP_IDENTIFY_CAP_TIME);
                                      }
                                      break;
                        }
              #endif          
2820   5      #ifdef KEEP_ALIVE                   
2821   5                case EVENT_TYPE_TIMER_KEEP_LIVE_IND:
2822   5                {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 47  

2823   6                  SNAM_SendMgmtMsg(snam,EVENT_TYPE_VENDOR_KEEP_ALIVE_IND);
2824   6                  STM_StartTimer(snam->keepAlive,HPGP_TIME_KEEP_ALIVE);
2825   6                  break;
2826   6                }
2827   5      #endif
2828   5                          default:
2829   5                          {
2830   6                          }
2831   5                      }
2832   4                  }
2833   3                  break;
2834   3              }
2835   2              case SNAM_STATE_WAITFOR_CC_ASSOC_RSP:
2836   2              {
2837   3                  if( event->eventHdr.eventClass == EVENT_CLASS_MSG) 
2838   3                  {
2839   4                      switch(event->eventHdr.type)
2840   4                      {
2841   5                          case EVENT_TYPE_CC_ASSOC_CNF:
2842   5                          {
2843   6      #ifdef LOG_FLASH
                                      u8 buff[2];
              #endif
2846   6                          FM_Printf(FM_MMSG, "SNAM:<<CC_ASSOC.CNF(tei:%bu)\n", 
2847   6                                                  hpgpHdr->tei);
2848   6                              //process the CC_ASSOC.CNF
2849   6                              assocCnf = (sCcAssocCnf *)event->buffDesc.dataptr; 
2850   6      #ifdef LOG_FLASH
                                      buff[0] = assocCnf->result;
                                      buff[1] = assocCnf->staTei;
                                      logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_ASSOC_CNF, buff, 2);
              #endif
2855   6                              if(assocCnf->result == 0)
2856   6                              {
2857   7                                  //success
2858   7                                  //This is the first time that we know 
2859   7                                  //CCo MAC address unless we send a query to the CCo
2860   7                                  //So, save it
2861   7      #ifdef NAM_PRINT              
              #ifdef P8051
                  FM_Printf(FM_HINFO,"cco MAC:%bx:%bx:%bx:%bx:%bx:%bx\n",
              #else
                  FM_Printf(FM_HINFO,"cco MAC:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
              #endif
              
                            staInfo->ccoScb->macAddr[0], staInfo->ccoScb->macAddr[1],
                            staInfo->ccoScb->macAddr[2], staInfo->ccoScb->macAddr[3],
                            staInfo->ccoScb->macAddr[4], staInfo->ccoScb->macAddr[5]);
              
              #endif
2873   7      
2874   7                                  memcpy( staInfo->ccoScb->macAddr, 
2875   7                                          hpgpHdr->macAddr, MAC_ADDR_LEN);
2876   7      
2877   7                                  snam->txRetryCnt = 0; //reset
2878   7                                  STM_StopTimer(snam->accTimer);
2879   7                                  staInfo->tei = assocCnf->staTei;
2880   7                                  staInfo->snid = assocCnf->snid;
2881   7                    scb = CRM_AddScb(crm, assocCnf->staTei);
2882   7                                  if(scb)
2883   7                                  {
2884   8                                      //it is done for renew too in case of CCo HO
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 48  

2885   8                                      memcpy(scb->macAddr, staInfo->macAddr,
2886   8                                             MAC_ADDR_LEN);
2887   8                                      scb->staStatus.byte = staInfo->staStatus.byte;
2888   8                                      scb->staCap.byte = staInfo->staCap.byte;
2889   8      #ifdef POWERSAVE
                                            if(!snam->teiRenew) 
                              {
                                // first time doing the Assoc.Req, init all variables
                                PSM_resetScbPs(scb);  // set SCB's PS data to init state 
                              }
              #endif
2896   8      
2897   8                                      staInfo->staScb = scb;  
2898   8                                      scb->identityCapUpdated = TRUE;
2899   8                                      scb->identityCapUpdatedRetry = 3;
2900   8      
2901   8                                      HAL_SetTei(HOMEPLUG_GetHal(), scb->tei);
2902   8                                  }
2903   7                                  else
2904   7                                  {
2905   8                                      break;  //should not happen
2906   8                                  }
2907   7      
2908   7                                  snam->state = SNAM_STATE_CONN;
2909   7                    //SNSM_clearBlackList();
2910   7      
2911   7                                  //start/restart the lease timer. 
2912   7                                  //5 minutes earlier than 
2913   7                                  //the assigned lease time expiration 
2914   7                                  STM_StopTimer(snam->teiTimer); 
2915   7      
2916   7                      if(!snam->teiRenew) 
2917   7                                  {
2918   8                                    
2919   8                      hostEvent_assocInd assocInd;
2920   8                                    
2921   8      
2922   8                      memcpy(&assocInd.ccoAddress,
2923   8                           &staInfo->ccoScb->macAddr, MAC_ADDR_LEN);
2924   8                      memcpy(&assocInd.nid, &staInfo->nid, NID_LEN);
2925   8                      assocInd.tei = assocCnf->staTei;
2926   8      
2927   8                                      staInfo->ccoScb->uMinSSN = 0;
2928   8                                      staInfo->ccoScb->uWrapAround = 0;
2929   8      #ifndef AKM               
2930   8                      
2931   8                      staInfo->staStatus.fields.authStatus = 1; 
2932   8      #endif                
2933   8      
2934   8                      Host_SendIndication(HOST_EVENT_TYPE_ASSOC_IND, HPGP_MAC_ID,
2935   8                                (u8*)&assocInd, sizeof(assocInd));
2936   8                        
2937   8                                      //this is the first CC_ASSOC.REQ
2938   8                                      //success
2939   8                                      //TODO: should place the event in the
2940   8                                      //internal queue, instead of calling 
2941   8                                      
2942   8                                      SNSM_Start(&linkl->staNsm, 
2943   8                                                 LINKL_STA_TYPE_ASSOC);
2944   8      #ifdef KEEP_ALIVE     
2945   8                      STM_StopTimer(snam->keepAlive);
2946   8                      STM_StartTimer(snam->keepAlive,
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 49  

2947   8                            HPGP_TIME_KEEP_ALIVE);
2948   8      #endif  
2949   8      
2950   8                                      //set MAC rounting table to start the traffic
2951   8      
2952   8                                      /* start the SHOM */
2953   8      #ifdef HOM
                                SHOM_Start(&linkl->staHom);
              #endif
2956   8                    
2957   8                                      /* start the AKM */
2958   8      // UKE                                AKM_Start(&linkl->akm, LINKL_STA_MODE_STA, 0);    
2959   8         
2960   8       
2961   8                                      //deliver a successful response to the upper 
2962   8                                      //layer. may trigger auth process
2963   8                                      eventBody.netAccRsp.result = 0;
2964   8                                      SNAM_DeliverEvent(snam, EVENT_TYPE_NET_ACC_RSP,
2965   8                                                &eventBody);
2966   8      #ifdef ROUTE
                                              if(scb)
                                              {
                                                  ROUTE_initLrtEntry(scb);
                                                  scb->lrtEntry.nTei = scb->tei;                                    
                                                  scb->lrtEntry.rnh = 0;                                    
                                              }                               
                                              
              #endif
2975   8      #ifndef AKM
2976   8                            SNAM_StartTEIRenew();
2977   8      #endif
2978   8      
2979   8                                  }
2980   7                    else
2981   7                    {
2982   8                      STM_StartTimer(snam->teiTimer, 
2983   8                            (assocCnf->leaseTime)*60000 - 5000 );
2984   8      #ifdef NAM_PRINT                      
              #ifdef P8051
                              FM_Printf(FM_HINFO, "SNAM:start the tei lease timer(0x%lx)\n",
              #else
                              FM_Printf(FM_HINFO, "SNAM:start the tei lease timer(0x%.8x)\n",
              #endif
              
                              (assocCnf->leaseTime)*60000 - 5000);
              #endif
2993   8                      Host_SendIndication(HOST_EVENT_TEI_RENEWED, HPGP_MAC_ID, (u8*)&staInfo->tei, 1);
2994   8                    }
2995   7                                  //else, it is renew, we do not do anything
2996   7                                  snam->teiRenew = 0;  //reset
2997   7                              }
2998   6                              else
2999   6                              {
3000   7                                
3001   7                    //SNSM_blackListCCo(assocCnf->snid);                
3002   7                              }
3003   6                              //for all other cases, stay in the same state and
3004   6                              //retry when the access timer expires.
3005   6                           
3006   6                              break;
3007   6                          }
3008   5                          default:
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 50  

3009   5                          {
3010   6                          }
3011   5                      }
3012   4                  }
3013   3                  else  //control event
3014   3                  {
3015   4                      switch(event->eventHdr.type)
3016   4                      {
3017   5                          case EVENT_TYPE_TIMER_ACC_IND:
3018   5                          {
3019   6                              if( snam->txRetryCnt <= HPGP_TX_RETRY_MAX)
3020   6                              { 
3021   7                                  //resend the message
3022   7                                  SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_ASSOC_REQ);
3023   7                                  STM_StartTimer(snam->accTimer, HPGP_TIME_ASSOC);
3024   7                                  snam->txRetryCnt++; 
3025   7                                  //stay in the same state
3026   7                                  //snam->state = SNAM_STATE_WAITFOR_CC_ASSOC_RSP;
3027   7                              }
3028   6                              else
3029   6                              {
3030   7                                  //retry exhausted
3031   7                                  snam->txRetryCnt = 0; //reset
3032   7                                  //newEvent = EVENT_Alloc(sizeof(sNetAccRspEvent), 0);
3033   7                                 // if(newEvent == NULL)
3034   7                                 // {
3035   7                                 //     FM_Printf(FM_ERROR, "EAllocErr\n");
3036   7                                 //     break;
3037   7                                 // }
3038   7                                  if(!snam->teiRenew) 
3039   7                                  {
3040   8                                      //build Event_Net_ACC_RSP (failure)
3041   8                                      eventType = EVENT_TYPE_NET_ACC_RSP;
3042   8                                      eventBody.netAccRsp.result = 1;
3043   8                      
3044   8                      //SNSM_blackListCCo(staInfo->snid);
3045   8                                  }
3046   7                                  else
3047   7                                  {
3048   8                                      snam->teiRenew = 0;
3049   8                      
3050   8                      //SNSM_blackListCCo(staInfo->snid);
3051   8      
3052   8                                      SNSM_Stop(&linkl->staNsm);
3053   8      
3054   8                                      LINKL_StopSta(linkl);
3055   8                                      STM_StopTimer(snam->teiTimer);
3056   8                                      snam->state = SNAM_STATE_INIT;
3057   8      
3058   8                                      //remove the TEI MAP
3059   8                                      CRM_Init(crm);
3060   8                                      staInfo->staScb = NULL;
3061   8                                      staInfo->ccoScb = NULL;
3062   8                              
3063   8                                      //build Event_Net_LEAVE_IND
3064   8                                      eventType = EVENT_TYPE_NET_LEAVE_IND;
3065   8                                      eventBody.netLeaveInd.reason = 1;
3066   8                                  }
3067   7                                  //deliver the event to the upper layer
3068   7                                  SNAM_DeliverEvent(snam, eventType,
3069   7                                                    &eventBody);
3070   7      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 51  

3071   7                                  //change the state    
3072   7                                  snam->state = SNAM_STATE_READY;
3073   7                              }
3074   6                              break;
3075   6                          }
3076   5                          default:
3077   5                          {
3078   6                          }
3079   5                      }
3080   4                  }
3081   3                  break;
3082   3              }
3083   2              case SNAM_STATE_WAITFOR_CC_LEAVE_RSP:
3084   2              {
3085   3                  if( event->eventHdr.eventClass == EVENT_CLASS_MSG) 
3086   3                  {
3087   4                      switch(event->eventHdr.type)
3088   4                      {
3089   5                          case EVENT_TYPE_CC_LEAVE_CNF:
3090   5                          {
3091   6      #ifdef P8051
3092   6                      FM_Printf(FM_MMSG, "SNAM:<<CC_LEAVE.CNF(tei:%bu)\n", 
3093   6                                                  hpgpHdr->tei);
3094   6      #else
                              FM_Printf(FM_MMSG, "SNAM:<<CC_LEAVE.CNF(tei:%d)\n", 
                                                          hpgpHdr->tei);
              #endif
3098   6      #ifdef LOG_FLASH
                                      logEvent(MGMT_MSG, 0, EVENT_TYPE_CC_LEAVE_CNF, &hpgpHdr->tei, 1);
              #endif
3101   6                              //message payload for CC_LEAVE.CNF is null
3102   6      
3103   6                              STM_StopTimer(snam->accTimer);
3104   6                              //see below for other operatins taken 
3105   6                              //when the STA leaves the network
3106   6                              snam->stopDataPath = 1;
3107   6      
3108   6                              //STM_StopTimer(snam->teiTimer);
3109   6                              //CRM_FreeScb(crm, staInfo->staScb);
3110   6                              //staInfo->staScb = NULL;
3111   6                              //SNSM_Stop(&linkl->staNsm);
3112   6                           
3113   6      
3114   6                              //change the state    
3115   6                              snam->state = SNAM_STATE_READY;
3116   6      
3117   6                          //    SNAM_DeliverEvent(snam, EVENT_TYPE_NET_LEAVE_RSP,
3118   6                            //                    NULL);
3119   6                                                    
3120   6                              break;
3121   6                          }
3122   5                          default:
3123   5                          {
3124   6                          }
3125   5                      }
3126   4                  }
3127   3                  else  //control event
3128   3                  {
3129   4                      switch(event->eventHdr.type)
3130   4                      {
3131   5                          case EVENT_TYPE_TIMER_ACC_IND:
3132   5                          {
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 52  

3133   6                              if( snam->txRetryCnt <= HPGP_TX_RETRY_MAX)
3134   6                              { 
3135   7                                  //resend the message
3136   7                                  SNAM_SendMgmtMsg(snam, EVENT_TYPE_CC_LEAVE_REQ);
3137   7                                  STM_StartTimer(snam->accTimer, HPGP_TIME_ASSOC);
3138   7                                  snam->txRetryCnt++; 
3139   7                                  //stay in the same state
3140   7                                  //snam->state = SNAM_STATE_WAITFOR_CC_LEAVE_RSP;
3141   7                              }
3142   6                              else
3143   6                              {
3144   7                                  //leave request retry exhausted, leave anyway
3145   7                                  snam->stopDataPath = 1;
3146   7      
3147   7                                  //STM_StopTimer(snam->teiTimer);
3148   7                              
3149   7                                  //change the state    
3150   7                                  snam->state = SNAM_STATE_READY;
3151   7                              }
3152   6                              break;
3153   6                          }
3154   5                          default:
3155   5                          {
3156   6                          }
3157   5                      }
3158   4                  }
3159   3      
3160   3                  if(snam->stopDataPath)
3161   3                  {
3162   4      
3163   4                      STM_StopTimer(snam->teiTimer);
3164   4      
3165   4      //                SNSM_Stop(&linkl->staNsm);
3166   4      #ifdef HOM
              
                              //stop the SHOM
                              SHOM_Stop(&linkl->staHom);
              #endif
3171   4              //set the MAC routing table to stop the data path
3172   4      
3173   4      //        FM_Printf(FM_ERROR,"nam lrsp\n");
3174   4      
3175   4                      SNAM_DeliverEvent(snam, EVENT_TYPE_NET_LEAVE_RSP, NULL);
3176   4                              
3177   4                      snam->stopDataPath = 0;
3178   4                  }
3179   3                  //process events
3180   3                  break;
3181   3              }
3182   2      /*
3183   2              case SNAM_STATE_WAITFOR_AUTH_RSP:
3184   2              {
3185   2                  //process events
3186   2                  if( event->eventHdr.eventClass == EVENT_CLASS_CTRL) 
3187   2                  {
3188   2                      switch(event->eventHdr.type)
3189   2                      {
3190   2                          case EVENT_TYPE_AUTH_RSP:
3191   2                          {
3192   2                               result = *(newEvent->buffDesc.dataptr); 
3193   2                          }
3194   2                          default:
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 53  

3195   2                          {
3196   2                          }
3197   2                        
3198   2                      }
3199   2                  }
3200   2                  break;
3201   2              }
3202   2      */
3203   2              default:
3204   2              {
3205   3                  //perform no operation
3206   3              }
3207   2          }
3208   1      }
3209          
3210          
3211          
3212          /*
3213          void  SNAM_PerformHoSwitch(sSnam *snam)
3214          {
3215              //stop the SNAM Tei lease timer
3216              STM_StopTimer(snam->teiTimer);
3217          }
3218          */
3219          
3220          eStatus SNAM_Stop(sSnam *snam)
3221          {
3222   1          sEvent *newEvent = NULL;
3223   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3224   1          sLinkLayer    *linkl = snam->linkl;
3225   1      #if 0
                  newEvent = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
                  if(newEvent == NULL)
                  {
                      FM_Printf(FM_ERROR, "SNSM: Cannot allocate an event.\n");
                      return STATUS_FAILURE;
                  }
              
                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                  newEvent->eventHdr.type = EVENT_TYPE_SNAM_STOP;
                  //LINKL_SendEvent(linkl, newEvent);
                  SLIST_Put(&linkl->EventQueue, &newEvent->link);
              #else
3238   1      
3239   1          STM_StopTimer(snam->teiTimer);
3240   1        STM_StopTimer(snam->accTimer);
3241   1      
3242   1      
3243   1      #ifdef ROUTE
                  ROUTE_stopUpdateTimer();
              #endif
3246   1      #ifdef KEEP_ALIVE     
3247   1        STM_StopTimer(snam->keepAlive);
3248   1      #endif
3249   1      
3250   1          snam->state = SNAM_STATE_INIT;
3251   1        snam->txRetryCnt = 0;
3252   1        snam->teiRenew = 0;
3253   1      
3254   1      #endif
3255   1          return STATUS_SUCCESS;
3256   1      
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 54  

3257   1      }
3258          
3259          eStatus SNAM_Start(sSnam *snam, u8 staType)
3260          {
3261   1          sEvent *newEvent = NULL;
3262   1          sLinkLayer    *linkl = snam->linkl;
3263   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3264   1      
3265   1          newEvent = EVENT_Alloc(sizeof(sSnamStartEvent), EVENT_HPGP_CTRL_HEADROOM);
3266   1          if(newEvent == NULL)
3267   1          {
3268   2              FM_Printf(FM_ERROR, "SNSM: EAllocErr\n");
3269   2              return STATUS_FAILURE;
3270   2          }
3271   1      
3272   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
3273   1          newEvent->eventHdr.type = EVENT_TYPE_SNAM_START;
3274   1          *(newEvent->buffDesc.dataptr) = staType;
3275   1          newEvent->buffDesc.datalen += sizeof(sSnamStartEvent); 
3276   1          LINKL_SendEvent(linkl, newEvent);
3277   1          return STATUS_SUCCESS;
3278   1      }
3279          
3280          
3281          
3282          
3283          eStatus SNAM_Init(sSnam *snam, sLinkLayer *linkl)
3284          {
3285   1          snam->linkl = linkl;
3286   1          snam->staInfo = LINKL_GetStaInfo(linkl);
3287   1      
3288   1          snam->state = SNAM_STATE_INIT;
3289   1      
3290   1      #ifdef CALLBACK
                  snam->accTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                       EVENT_TYPE_TIMER_ACC_IND, linkl);
              #else
3294   1          snam->accTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
3295   1                               EVENT_TYPE_TIMER_ACC_IND, linkl);
3296   1      #endif
3297   1          if(snam->accTimer == STM_TIMER_INVALID_ID)
3298   1          {
3299   2              return STATUS_FAILURE;
3300   2          }
3301   1      #ifdef NAM_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:acc timer id:%bu\n", snam->accTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:acc timer id:%d\n", snam->accTimer);
              #endif
              #endif
3308   1      #ifdef CALLBACK
                  snam->teiTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                       EVENT_TYPE_TIMER_TEI_IND, NULL);
              #else
3312   1          snam->teiTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
3313   1                               EVENT_TYPE_TIMER_TEI_IND, NULL);
3314   1      #endif
3315   1      
3316   1          if(snam->teiTimer == STM_TIMER_INVALID_ID)
3317   1          {
3318   2              return STATUS_FAILURE;
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 55  

3319   2          }
3320   1      #ifdef NAM_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:tei lease timer id:%bu\n", snam->teiTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:tei lease timer id:%d\n", snam->teiTimer);
              #endif
              #endif
3327   1      
3328   1          snam->apptTimer = STM_TIMER_INVALID_ID;
3329   1      
3330   1          snam->txRetryCnt = 0;
3331   1          snam->teiRenew = 0;
3332   1          snam->stopDataPath = 0;
3333   1      
3334   1      //    snam->ccoInfo = LINKL_GetCcoInfo(linkLayer);
3335   1      
3336   1      
3337   1      //    snam->state = SNAM_STATE_READY;
3338   1      
3339   1      #ifdef STA_ID    
                  snam->identifyCapTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
                                             EVENT_TYPE_IDENTIFY_CAP_TIMEOUT, linkl);
                  if(snam->identifyCapTimer == STM_TIMER_INVALID_ID)
                  {
                      return STATUS_FAILURE;
                  }
              #endif  
3347   1      #ifdef KEEP_ALIVE
3348   1        snam->keepAlive = STM_AllocTimer(HP_LAYER_TYPE_LINK,EVENT_TYPE_TIMER_KEEP_LIVE_IND,linkl);
3349   1        if(snam->keepAlive == STM_TIMER_INVALID_ID)
3350   1          {
3351   2              return STATUS_FAILURE;
3352   2          }
3353   1      #endif
3354   1      
3355   1          return STATUS_SUCCESS;
3356   1      }
3357          
3358          
3359          #endif /* STA_FUNC */
3360          
3361          #ifdef STA_ID
              
              eStatus IDENTIFY_sendFrm(u16 mmType, sEvent *reqEvent, sScb *scb)
              {
                  sStaIdentifyCaps *idCaps;
                  eStatus     status = STATUS_FAILURE;
                  sEvent    xdata  *event = NULL;      
                  sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
                  u16         eventSize = (sizeof(sStaIdentifyCaps)); 
                sCrm    *crm = LINKL_GetCrm(linkl);
                  sHpgpHdr    *reqHpgpHdr;
                sHpgpHdr    *hpgpHdr;
                  u8 addIdentify = 0;
                  sScb *lscb = NULL;
                  
                  event = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM );
                  if(event == NULL)
                  {
                      FM_Printf(FM_ERROR, "EAllocErr\n");
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 56  

                      return STATUS_FAILURE;
                  }
              
                  
                  // prepare event    
                  event->eventHdr.eventClass = EVENT_CLASS_MSG;
              
                  
                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                  hpgpHdr->snid = staInfo->snid;
                  hpgpHdr->eks = staInfo->nekEks;
                  
                  switch(mmType)
                  {
                      case EVENT_TYPE_CM_STA_IDENTIFY_IND:
                          event->eventHdr.type = EVENT_TYPE_CM_STA_IDENTIFY_IND;
                          hpgpHdr->tei = scb->tei;
                          hpgpHdr->macAddr = scb->macAddr;
                          addIdentify = 1;
                          FM_Printf(FM_MMSG, "IDENTIFY:>>STA_IDENTIFY.IND(tei:%bu)\n",
                                             hpgpHdr->tei);
                          break;
                      case EVENT_TYPE_CM_STA_IDENTIFY_RSP:
                          reqHpgpHdr = (sHpgpHdr *)reqEvent->buffDesc.buff;
                          event->eventHdr.type = EVENT_TYPE_CM_STA_IDENTIFY_RSP;
                          hpgpHdr->tei = reqHpgpHdr->tei;
                          // find mac addr
                          scb = CRM_GetScb(crm, reqHpgpHdr->tei);
                          if(scb)
                          {
                              hpgpHdr->macAddr = scb->macAddr;
                          }
                          else
                          {
                              EVENT_Free(event);
                              return status;
                          }
              //            FM_Printf(FM_MMSG, "IDENTIFY:>>IDENTIFY.RSP(tei:%bu)\n//",
                //                                     hpgpHdr->tei);
                          break;
                      case EVENT_TYPE_CM_STA_IDENTIFY_REQ:
                          event->eventHdr.type = EVENT_TYPE_CM_STA_IDENTIFY_REQ;
                          if(scb == staInfo->ccoScb) 
                          {
                              hpgpHdr->tei = scb->tei;
                              hpgpHdr->macAddr = scb->macAddr;
                          }
              #ifdef ROUTE
                          else if(scb->tei != scb->lrtEntry.nTei)
                          {
              
                              lscb = CRM_GetScb(crm, scb->lrtEntry.nTei);
                              if(lscb)
                              {                
                                  hpgpHdr->tei = lscb->tei;
                                  hpgpHdr->macAddr = scb->macAddr;
                              }
                              else
                              {
                                  EVENT_Free(event);
                                  return status;
                              }
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 57  

                          }
              #else
                          else 
                          {
                              hpgpHdr->tei = scb->tei;
                              hpgpHdr->macAddr = scb->macAddr;
                          }
              #endif
                          
                         // FM_Printf(FM_MMSG, "IDENTIFY:>>STA_IDENTIFY.REQ(tei:%bu)\n",
                           //                  hpgpHdr->tei);
                          break;
                      case EVENT_TYPE_CM_STA_IDENTIFY_CNF:  
                          reqHpgpHdr = (sHpgpHdr *)reqEvent->buffDesc.buff;
                          event->eventHdr.type = EVENT_TYPE_CM_STA_IDENTIFY_CNF;
                          scb = CRM_GetScb(crm, reqHpgpHdr->tei);
                          // find mac addr
                          if(scb)
                          {                
                              hpgpHdr->tei = scb->tei;
                              hpgpHdr->macAddr = reqHpgpHdr->macAddr;
                          }
                          else
                          {
                              EVENT_Free(event);
                              return status;
                          }
                          addIdentify = 1;
                          FM_Printf(FM_MMSG, "IDENTIFY:>>STA_IDENTIFY.CNF(tei:%bu)\n",
                                                     hpgpHdr->tei);
                          break;
                      default:
                          FM_Printf(FM_MMSG, "IDENTIFY:>>Invalid Msg\n");
              
              
                  }
                  if(addIdentify)
                  {
                      idCaps = (sStaIdentifyCaps*)event->buffDesc.dataptr;
              
                      idCaps->efl = staInfo->identifyCaps.efl;
                      idCaps->HPAVVer = staInfo->identifyCaps.HPAVVer;
                      idCaps->routingCap = staInfo->identifyCaps.routingCap;
                      idCaps->powerSaveCap = staInfo->identifyCaps.powerSaveCap;
                      idCaps->greenPHYCap = staInfo->identifyCaps.greenPHYCap;
              
                      event->buffDesc.datalen = (sizeof(sStaIdentifyCaps));
                  }
                  else
                  {
                      
                      event->buffDesc.datalen = 0;
                  }
                  status = MUXL_TransmitMgmtMsg(event);
                  //the event is freed by MUXL if the TX is successful
                  if(status == STATUS_FAILURE)
                  {
                      EVENT_Free(event);
                  }
              
                  return status;
              
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 58  

              
              }
              
              eStatus IDENTIFY_procFrm(u16 mmType, sEvent *reqEvent)
              {
                  sStaIdentifyCaps *idCaps;
                  sHpgpHdr    *hpgpHdr;
                  sScb *scb = NULL;
                  sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
                sCrm    *crm = LINKL_GetCrm(linkl);
                  eStatus     status = STATUS_FAILURE;
              
                  hpgpHdr = (sHpgpHdr *)reqEvent->buffDesc.buff;
                  switch(mmType)
                  {
                          break;
                      case EVENT_TYPE_CM_STA_IDENTIFY_RSP:
                          FM_Printf(FM_MMSG, "IDENTIFY:<<STA_IDENTIFY.RSP(tei:%bu)\n",
                                                     hpgpHdr->tei);
                          break;
                      case EVENT_TYPE_CM_STA_IDENTIFY_REQ:
                          
                          FM_Printf(FM_MMSG, "IDENTIFY:<<STA_IDENTIFY.REQ(tei:%bu)\n",
                                             hpgpHdr->tei);
                          IDENTIFY_sendFrm(EVENT_TYPE_CM_STA_IDENTIFY_CNF, reqEvent, NULL);           
                          break;
                          
                      case EVENT_TYPE_CM_STA_IDENTIFY_IND:            
                      case EVENT_TYPE_CM_STA_IDENTIFY_CNF:  
                          hpgpHdr = (sHpgpHdr *)reqEvent->buffDesc.buff;
                          idCaps = (sStaIdentifyCaps*)reqEvent->buffDesc.dataptr;
                          // find mac addr
                          scb = CRM_FindScbMacAddr(hpgpHdr->macAddr);
                          if(scb)
                          {
                              scb->idCaps.efl = idCaps->efl;
                              scb->idCaps.HPAVVer = idCaps->HPAVVer;
                              scb->idCaps.routingCap = idCaps->routingCap;
                              scb->idCaps.powerSaveCap = idCaps->powerSaveCap;
                              scb->idCaps.greenPHYCap = idCaps->greenPHYCap;
                              scb->identityCapUpdated = TRUE;
                          }
                          else
                          {
                              return status;
                          }
                          if(mmType == EVENT_TYPE_CM_STA_IDENTIFY_CNF)
                          {
                              
                              FM_Printf(FM_MMSG, "IDENTIFY:<<STA_IDENTIFY.CNF(tei:%bu)\n",
                                                 hpgpHdr->tei);
              #ifdef ROUTE
                              if(scb->idCaps.routingCap == TRUE)
                              {
                                  ROUTE_sendRouteInfoReq(scb);
                              }
              #endif
                          }
                          else
                          {
                              
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 59  

                              FM_Printf(FM_MMSG, "IDENTIFY:<<STA_IDENTIFY.IND(tei:%bu)\n",
                                         hpgpHdr->tei);
                              IDENTIFY_sendFrm(EVENT_TYPE_CM_STA_IDENTIFY_RSP, reqEvent, scb);
                          }
                          break;
                      default:
                          FM_Printf(FM_MMSG, "IDENTIFY:>>Invalid Msg\n");
                  }
                  return STATUS_SUCCESS;
              
              }
              
              #endif
3580          
3581          /** =========================================================
3582           *
3583           * Edit History
3584           *
3585           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/link/nam.c,v $
3586           *
3587           * $Log: nam.c,v $
3588           * Revision 1.31  2015/01/02 14:55:36  kiran
3589           * 1) Timer Leak fixed while freeing SCB fixed
3590           * 2) Software broadcast supported for LG
3591           * 3) UART Loopback supported for LG
3592           * 4) Keep Alive feature to ageout defunctional STA
3593           * 5) Improved flash API's for NO Host Solution
3594           * 6) Imporved PLC Hang recovery mechanism
3595           * 7) Reduced nested call tree of common path functions
3596           * 8) Code optimization and cleanup (unused arguments, unused local variables)
3597           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
3598           * 10) Use of memory specific pointers instead of generic pointers
3599           *
3600           * Revision 1.30  2014/12/09 07:09:08  ranjan
3601           * - multicco feature under MCCO flag
3602           *
3603           * Revision 1.29  2014/11/11 14:52:58  ranjan
3604           * 1.New Folder Architecture espically in /components
3605           * 2.Modular arrangment of functionality in new files
3606           *    anticipating the need for exposing them as FW App
3607           *    development modules
3608           * 3.Other improvisation in code and .h files
3609           *
3610           * Revision 1.28  2014/10/28 16:27:43  kiran
3611           * 1) Software recovery using Watchdog Timer
3612           * 2) Hardware recovery monitor and policies
3613           * 3) Timer Polling in Control Task and Frame task for better accuracy
3614           * 4) Common memory optimized by reducing prints
3615           * 5) Discovered netlist corruption fixed
3616           * 6) VCO fix in HHAL_AFEInit()
3617           * 7) Idata optimized by removing floating point operation
3618           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
3619           * 9) Beacon processing protected from interrupts
3620           * 10) Corrupted Beacons are dropped
3621           * 11) Some unused arguments removed to improve code size
3622           *
3623           * Revision 1.27  2014/10/15 10:42:51  ranjan
3624           * small fixes in um
3625           *
3626           * Revision 1.26  2014/09/05 09:28:18  ranjan
3627           * 1. uppermac cco-sta switching feature fix
3628           * 2. general stability fixes for many station associtions
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 60  

3629           * 3. changed mgmt memory pool for many STA support
3630           *
3631           * Revision 1.25  2014/08/25 07:37:34  kiran
3632           * 1) RSSI & LQI support
3633           * 2) Fixed Sync related issues
3634           * 3) Fixed timer 0 timing drift for SDK
3635           * 4) MMSG & Error Logging in Flash
3636           *
3637           * Revision 1.24  2014/08/12 08:45:43  kiran
3638           * 1) Event fixes
3639           * 2) API to change UART line control parameters
3640           *
3641           * Revision 1.23  2014/07/30 12:26:26  kiran
3642           * 1) Software Recovery for CCo
3643           * 2) User appointed CCo support in SDK
3644           * 3) Association process performance fixes
3645           * 4) SSN related fixes
3646           *
3647           * Revision 1.22  2014/07/22 10:03:52  kiran
3648           * 1) SDK Supports Power Save
3649           * 2) Uart_Driver.c cleanup
3650           * 3) SDK app memory pool optimization
3651           * 4) Prints from STM.c are commented
3652           * 5) Print messages are trimmed as common no memory left in common
3653           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
3654           *
3655           * Revision 1.21  2014/07/05 09:16:27  prashant
3656           * 100 Devices support- only association tested, memory adjustments
3657           *
3658           * Revision 1.20  2014/06/26 17:59:42  ranjan
3659           * -fixes to make uppermac more robust for n/w change
3660           *
3661           * Revision 1.19  2014/06/24 16:26:45  ranjan
3662           * -zigbee frame_handledata fix.
3663           * -added reason code for uppermac host events
3664           * -small cleanups
3665           *
3666           * Revision 1.18  2014/06/23 06:56:44  prashant
3667           * Ssn reset fix upon device reset, Duplicate SNID fix
3668           *
3669           * Revision 1.17  2014/06/19 17:13:19  ranjan
3670           * -uppermac fixes for lvnet and reset command for cco and sta mode
3671           * -backup cco working
3672           *
3673           * Revision 1.16  2014/06/12 13:15:43  ranjan
3674           * -separated bcn,mgmt,um event pools
3675           * -fixed datapath issue due to previous checkin
3676           * -work in progress. neighbour cco detection
3677           *
3678           * Revision 1.15  2014/06/11 13:17:47  kiran
3679           * UART as host interface and peripheral interface supported.
3680           *
3681           * Revision 1.14  2014/05/28 10:58:59  prashant
3682           * SDK folder structure changes, Uart changes, removed htm (UI) task
3683           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
3684           *
3685           * Revision 1.13  2014/05/12 08:09:57  prashant
3686           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
3687           *
3688           * Revision 1.12  2014/04/30 22:29:37  tri
3689           * more PS
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 61  

3690           *
3691           * Revision 1.11  2014/04/09 21:08:52  tri
3692           * more PS
3693           *
3694           * Revision 1.10  2014/04/09 08:18:10  ranjan
3695           * 1. Added host events for homeplug uppermac indication (Host_SendIndication)
3696           * 2. timer workaround  + other fixes
3697           *
3698           * Revision 1.9  2014/03/25 23:09:15  tri
3699           * PS
3700           *
3701           * Revision 1.8  2014/03/20 23:20:29  tri
3702           * more PS
3703           *
3704           * Revision 1.7  2014/03/12 09:41:22  ranjan
3705           * 1. added ageout event to cco cnam,backupcco ageout handling
3706           * 2.  fix linking issue in zb_lx51_asic due to backup cco checkin
3707           *
3708           * Revision 1.6  2014/03/10 05:58:10  ranjan
3709           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
3710           *
3711           * Revision 1.5  2014/02/27 10:42:47  prashant
3712           * Routing code added
3713           *
3714           * Revision 1.4  2014/02/26 23:12:54  tri
3715           * more PS code
3716           *
3717           * Revision 1.3  2014/01/28 17:47:02  tri
3718           * Added Power Save code
3719           *
3720           * Revision 1.2  2014/01/10 17:17:53  yiming
3721           * check in Rajan 1/8/2014 code release
3722           *
3723           * Revision 1.5  2014/01/08 10:53:54  ranjan
3724           * Changes for LM OS support.
3725           * New Datapath FrameTask
3726           * LM and UM  datapath, feature verified.
3727           *
3728           * known issues : performance numbers needs revisit
3729           *
3730           * review : pending.
3731           *
3732           * Revision 1.4  2013/09/04 14:51:01  yiming
3733           * New changes for Hybrii_A code merge
3734           *
3735           * Revision 1.31  2013/07/12 08:56:36  ranjan
3736           * -UKE Push Button Security Feature.
3737           * Verified : DirectEntry Security Works.Datapath Works.
3738           *                 command SetSecMode for UKE works.
3739           * Added against bug-160
3740           *
3741           * Revision 1.30  2013/03/22 12:21:49  prashant
3742           * default FM_MASK and FM_Printf modified for USER INFO
3743           *
3744           * Revision 1.29  2013/03/21 07:43:26  ranjan
3745           * Starting NDC on "p reset" command
3746           *
3747           * Revision 1.28  2013/03/18 13:25:59  prashant
3748           * Changed release TEI timeout 48 hr and data path fix
3749           *
3750           * Revision 1.27  2013/03/14 11:49:18  ranjan
3751           * 1.handled cases  for CCo toSTA switch and  viceversa
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 62  

3752           * 2.UM uses bcntemplate
3753           *
3754           * Revision 1.26  2013/02/15 12:53:57  prashant
3755           * ASSOC.REQ changes for DEVELO
3756           *
3757           * Revision 1.25  2012/12/18 12:17:46  prashant
3758           * Stability checkin
3759           *
3760           * Revision 1.24  2012/11/22 09:44:02  prashant
3761           * Code change for auto ping test, sending tei map ind out, random mac addrr generation.
3762           *
3763           * Revision 1.23  2012/11/19 07:55:56  prashant
3764           * Compilation fix for last checkin
3765           *
3766           * Revision 1.22  2012/11/19 07:46:23  ranjan
3767           * Changes for Network discovery modes
3768           *
3769           * Revision 1.21  2012/09/24 06:01:38  yuanhua
3770           * (1) Integrate the NMA and HAL in Rx path (2) add a Tx queue in HAL to have less stack size needed in tx
             - path, and Tx in HAL is performed by polling now.
3771           *
3772           * Revision 1.20  2012/07/15 17:31:07  yuanhua
3773           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
3774           *
3775           * Revision 1.19  2012/07/08 18:42:20  yuanhua
3776           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
3777           *
3778           * Revision 1.18  2012/07/03 05:18:37  yuanhua
3779           * fixed an issue in HAL_XmitMacFrame(), which returns the status according to the status from HHAL_PlcTxQ
             -Write() now.
3780           *
3781           * Revision 1.17  2012/06/30 23:36:26  yuanhua
3782           * return the success status for LINKL_SendEvent() when RTX51 OS is used.
3783           *
3784           * Revision 1.16  2012/06/20 21:44:42  kripa
3785           * Assoc.Cnf dtei set to bcst tei.
3786           * Committed on the Free edition of March Hare Software CVSNT Client.
3787           * Upgrade to CVS Suite for more features and support:
3788           * http://march-hare.com/cvsnt/
3789           *
3790           * Revision 1.15  2012/06/20 17:56:31  kripa
3791           *
3792           * Committed on the Free edition of March Hare Software CVSNT Client.
3793           * Upgrade to CVS Suite for more features and support:
3794           * http://march-hare.com/cvsnt/
3795           *
3796           * Revision 1.14  2012/06/08 23:23:48  son
3797           * Fixed tei display
3798           *
3799           * Revision 1.13  2012/06/05 07:25:59  yuanhua
3800           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
3801           *
3802           * Revision 1.12  2012/06/04 23:34:02  son
3803           * Added RTX51 OS support
3804           *
3805           * Revision 1.11  2012/05/19 20:32:17  yuanhua
3806           * added non-callback option for the protocol stack.
3807           *
3808           * Revision 1.10  2012/05/19 05:05:15  yuanhua
3809           * optimized the timer handlers in CTRL and LINK layers.
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 63  

3810           *
3811           * Revision 1.9  2012/05/17 05:05:58  yuanhua
3812           * (1) added the option for timer w/o callback (2) added task id and name.
3813           *
3814           * Revision 1.8  2012/05/12 04:11:46  yuanhua
3815           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
3816           *
3817           * Revision 1.7  2012/05/01 04:51:09  yuanhua
3818           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
3819           *
3820           * Revision 1.6  2012/04/30 04:05:57  yuanhua
3821           * (1) integrated the HAL mgmt Tx. (2) various updates
3822           *
3823           * Revision 1.5  2012/04/20 01:39:33  yuanhua
3824           * integrated uart module and added compiler flag NMA.
3825           *
3826           * Revision 1.4  2012/04/13 06:15:11  yuanhua
3827           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
3828           *
3829           * Revision 1.3  2012/03/11 17:02:25  yuanhua
3830           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
3831           *
3832           * Revision 1.2  2011/09/09 07:02:31  yuanhua
3833           * migrate the firmware code from the greenchip to the hybrii.
3834           *
3835           * Revision 1.13  2011/09/06 05:01:46  yuanhua
3836           * Made a fix such that the STA continues periodic TEI renew after CCo handover.
3837           *
3838           * Revision 1.12  2011/08/12 23:13:22  yuanhua
3839           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
3840           *
3841           * Revision 1.11  2011/08/09 22:45:44  yuanhua
3842           * changed to event structure, seperating HPGP-related events from the general event defination so that th
             -e general event could be used for other purposes than the HPGP.
3843           *
3844           * Revision 1.10  2011/08/08 22:05:41  yuanhua
3845           * user-selected CCo handover fix
3846           *
3847           * Revision 1.9  2011/08/05 17:06:29  yuanhua
3848           * (1) added an internal queue in Link Layer for communication btw modules within Link Layer (2) Fixed bug
             -s in CCo Handover. Now, CCo handover could be triggered by auto CCo selection, CCo handover messages work fine (3) Made 
             -some modifications in SHAL.
3849           *
3850           * Revision 1.8  2011/08/02 16:06:00  yuanhua
3851           * (1) Fixed a bug in STM (2) Made STA discovery work according to the standard, including aging timer. (3
             -) release the resource after the STA leave (4) STA will switch to the backup CCo if the CCo failure occurs (5) At this p
             -oint, the CCo could work with multiple STAs correctly, including CCo association/leave, TEI renew, TEI map updating, dis
             -covery beacon scheduling, discovery STA list updating ang aging, CCo failure, etc.
3852           *
3853           * Revision 1.7  2011/07/30 02:43:35  yuanhua
3854           * (1) Split the beacon process into two parts: one requiring an immdiate response, the other tolerating t
             -he delay (2) Changed the API btw the MUX and SHAL for packet reception (3) Fixed bugs in various modules. Now, multiple 
             -STAs could successfully associate/leave the CCo
3855           *
3856           * Revision 1.6  2011/07/22 18:51:05  yuanhua
3857           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
3858           *
C51 COMPILER V9.53.0.0   NAM                                                               11/04/2015 20:09:44 PAGE 64  

3859           * Revision 1.5  2011/07/16 17:11:23  yuanhua
3860           * (1)Implemented SHOM and CHOM modules, including handover procedure, SCB resource updating for HO (2) Up
             -date SNAM and CNAM modules to support uer-appointed CCo handover (3) Made the SCB resources to support the TEI MAP for t
             -he STA mode and management of associated STA resources (e.g. TEI) (4) Modified SNSM and CNSM to perform all types of han
             -dover switch (CCo handover to the new STA, STA taking over the CCo, STA switching to the new CCo)
3861           *
3862           * Revision 1.4  2011/07/08 22:23:48  yuanhua
3863           * (1) Implemented CNSM, including its state machine, beacon transmission and process, discover beacon sch
             -eduling, auto CCo selection, discover list, handover countdown, etc. (2) Updated SNSM, including discover list processin
             -g, triggering a switch to the new CCo, etc. (3) Updated CNAM and SNAM, adding the connection state in the SNAM, switch t
             -o the new CCo, etc. (4) Other updates
3864           *
3865           * Revision 1.3  2011/07/02 22:09:01  yuanhua
3866           * Implemented both SNAM and CNAM modules, including network join and leave procedures, systemm resource (
             -such as TEI) allocation and release, TEI renew/release timers, and TEI reuse timer, etc.
3867           *
3868           * Revision 1.2  2011/06/24 14:33:18  yuanhua
3869           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
3870           *
3871           * Revision 1.1  2011/05/28 06:31:19  kripa
3872           * Combining corresponding STA and CCo modules.
3873           *
3874           * Revision 1.1  2011/05/06 19:10:12  kripa
3875           * Adding link layer files to new source tree.
3876           *
3877           * Revision 1.3  2011/04/23 19:48:45  kripa
3878           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
3879           *
3880           * Revision 1.2  2011/04/23 17:34:07  kripa
3881           * Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
3882           *
3883           * Revision 1.1  2011/04/08 21:42:45  yuanhua
3884           * Framework
3885           *
3886           *
3887           * =========================================================*/
3888          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  18149    ----
   CONSTANT SIZE    =    796    ----
   XDATA SIZE       =      1     425
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
