C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE NSM_STA
OBJECT MODULE PLACED IN .\obj\nsm_sta.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\src\link\nsm_sta.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X210
                    -0) INCDIR(..\..\..\common\datapath;..\..\..\common\include;..\..\..\hal;..\..\src\crypto;..\..\src\ctrl;..\..\src\hal;..
                    -\..\src\link;..\..\src\mux;..\..\src\nma;..\..\src\route;..\..\src\sap;..\..\src\test;..\..\..\project\hal\src;..\..\..\
                    -zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\eve
                    -nt\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\sampleapp\sr
                    -c;..\..\..\..\sampleapp\inc;..\..\..\common;..\..\..\hpgp;..\..\src;..\..\..\..\components\hpgp\inc;..\..\..\app_support
                    -;..\..\..\HybriiB_configuration_rw\src) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FU
                    -NC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HYBRII_ETH,HPGP_MAC_SAP,NMA,HYBRII_SPI,NEW_SYNC,UM,HYBRII_
                    -B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,AUTH_AES,PLC_TEST,B_ASICPLC,UART_HOST_INTF_,UART_RAW,MPER_,FREQ_DETECT,SW_RECOVER
                    -Y,PROD_TEST) DEBUG PRINT(.\lst\nsm_sta.lst) TABS(2) OBJECT(.\obj\nsm_sta.obj)

line level    source

   1          /** ========================================================
   2           *
   3           * @file nsm_sta.c
   4           * 
   5           *  @brief Network System Manager:
   6           *         CNSM: CCO Network System Manager
   7           *         SNSM: STA Network System Manager
   8           *
   9           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
  10           *  All Rights Reserved
  11           *  
  12           * =========================================================*/
  13          
  14          
  15          #include <string.h>
  16          #include <stdio.h>
  17          #include "papdef.h"
  18          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  21          #include "linkl.h"
  22          #include "nsm.h"
  23          #include "nam.h"
  24          #include "muxl.h"
  25          #include "hpgpapi.h"
  26          #include "hpgpconf.h"
  27          #include "fm.h"
  28          #include "ism.h"
  29          #include "hpgpevt.h"
  30          #include "mmsg.h"
  31          #include "timer.h"
  32          #include "stm.h"
  33          #include "hal.h"
  34          #ifdef HPGP_HAL
  35          #include "hal_hpgp.h"
  36          #else
              #include "sdrv.h"
              #endif
  39          
  40          #include "frametask.h"
  41          #ifndef CALLBACK
  42          #include "hpgpapi.h"
  43          #endif
  44          #ifdef UM
  45          #include "mac_intf_common.h"
  46          #endif
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 2   

  47          #include "hybrii_tasks.h"
  48          
  49          #include "sys_common.h"
  50          
  51          #ifndef UART_HOST_INTF
  52          #define DISC_BCN
  53          #endif
  54          
  55          
  56          #define HPGP_TIME_BBT                  1000   //2 seconds
  57          
  58          #define HPGP_TIME_USAI                  1000   //1 seconds
  59          //#define HPGP_TIME_DISC_AGING            120000 // 2 minutes
  60          #define HPGP_TIME_BEACON_LOSS           200 // test 
  61          
  62          #define HPGP_TIME_DISC_AGING            15000 // test 
  63          #define HPGP_TIME_DISC_AGING_UNASSOC    15000 // test
  64          
  65          #define HPGP_TIME_BEACON_LOSS            200 // test 
  66          
  67          
  68          #define HPGP_TIME_DISC_PERIOD_MAX       5000   //10 seconds - MaxDiscoverPeriod
  69          //#define HPGP_TIME_STA_AGING_CNT       5  //5* 10 seconds - MaxDiscoverPeriod
  70          #define HPGP_IDENTIFY_CAP_TIME               500
  71          #define HPGP_HO_COUNTDOWN_MAX           5   //5 beacon periods
  72          #define HPGP_HO_SWITCH_NONE             0   //no handover switch
  73          #define HPGP_HO_SWITCH_STA              1   //switch to the STA mdoe/role
  74          #define HPGP_HO_SWITCH_CCO              2   //switch to the CCO mdoe/role
  75          
  76          /* default regions (in unit of ALU) */
  77          #define HPGP_REGION_MIN_SHARED_CSMA    0x5DC  /* minimum shared CSMA */
  78                                                        /* 1500 usec */        
  79          #define HPGP_REGION_MIN_LOCAL_CSMA     0x5DC  /* minimum local CSMA  */
  80                                                        /* 1500 usec */             
  81          #define HPGP_REGION_MAX_BEACON         (8*HPGP_BEACON_SLOT_ATU)  
  82                                                        /* maximum beacon region */
  83                                                        /* 8 slots */             
  84          #define HPGP_GLID_LOCAL_CSMA           0xFF
  85          #define HPGP_GLID_SHARED_CSMA          0xFE
  86          #define HPGP_GLID_DISC_BEACON          0xFD
  87          #define HPGP_GLID_GPP                  0xFB
  88          
  89          #ifdef SIMU
              #define HPGP_TIME_BCN_INTERVAL    4 //4 ms
              #endif
  92          
  93          extern u8 psDebug;
  94          extern u8 syncThres;
  95          
  96          //beacon source
  97          enum
  98          {
  99              BCN_SRC_CCO,  // central beacon from the CCo/proxy CCo in the same network
 100              BCN_SRC_DISC, // discovery beacon from the STA in the same network 
 101              BCN_SRC_OTHER_CCO, //CCo or proxy CCo in other networks
 102              BCN_SRC_OTHER_DISC, //discovery beacon from other networks
 103              BCN_SRC_UNKNOWN,     //unknown
 104          };
 105          
 106          extern void LINKL_TimerHandler(u16 type, void *cookie);
 107          void CNSM_Stop(sCnsm *cnsm);
 108          void SCB_UpdateDiscNetList(sScb *scb, sDiscNetInfoRef *discNetInfoRef);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 3   

 109          void SCB_UpdateDiscStaList(sScb *scb, sDiscStaInfoRef *discStaInfoRef);
 110          void SCB_AgeDiscLists(sScb *scb);
 111          extern void setCSMA_onCCO1();
 112          #ifdef ROUTE
              extern void ROUTE_prepareHoldList(sCrm *crm, sScb *scb);
              eStatus ROUTE_sendRouteInfoReq(sScb *scb);
              extern eStatus ROUTE_sendRouteInfo(u16 mmType, sEvent *reqEvent);
              #endif
 117          
 118          #if 1
 119          //beacon entry header type
 120          u8 BeHdrType[] =
 121          {
 122              BEHDR_NON_PERSISTENT_SCHED,    //0x00   //Non-Persistent Schedule
 123              BEHDR_PERSISTENT_SCHED,        //0x01   //Current Persistent Schedule
 124              BEHDR_PERSISTENT_SCHED,        //0x01   //Preview Persistent Schedule
 125              BEHDR_REGIONS,                 //0x02   //region Schedule
 126              BEHDR_MAC_ADDR,                //0x03   //MAC Address
 127              BEHDR_DISCOVER,                //0x04   //Discover
 128              BEHDR_DISC_INFO,               //0x05   //Discovered Info
 129              BEHDR_BPSTO,                   //0x06   //Beacon Period Start Time Offset
 130              BEHDR_ENCRYP_KEY_CHANGE,       //0x07   //Encryption Key Change
 131              BEHDR_CCO_HANDOVER,            //0x08   //CCo Handover
 132              BEHDR_BCN_RELOC,               //0x09   //Beacon Relocation
 133              BEHDR_ACL_SYNC_CNTDOWN,        //0x0A   //AC Line Sync Countdown
 134              BEHDR_CHANGE_NUM_SLOTS,        //0x0B   //Change NumSlots
 135              BEHDR_CHANGE_HM,               //0x0C   //Change Hybrid Mode
 136              BEHDR_CHANGE_SNID,             //0x0D   //Change SNID
 137              BEHDR_RSN_INFO,                //0x0E   //RSN Info Element
 138              BEHDR_ISP,                     //0x0F   //ISP BENTRY
 139              BEHDR_EXT_BAND_STAY_OUT,       //0x10   //Extended Band Stay Out
 140              BEHDR_AG_ASSIGN,               //0x11   //AG Assignment
 141              BEHDR_EXT_CARR_SUPPORT,        //0x12   //Extended Carriers Support
 142              BEHDR_PWR_SAVE,                //0x13   //Power Save BENTRY
 143              BEHDR_VENDOR_SPEC,             //0xFF   //Vendor Specific
 144          };
 145          
 146          //Maximum size allowed for each entry corresponding to BeHdrType[]
 147          u8 BeLenMax[] =
 148          {
 149              sizeof(sBcnHdr) + 2 + 16,     //non-persistent: 4 SAIs (4 octets per SAI)
 150              sizeof(sBcnHdr) + 2 + 16,     //current persistent: 4 SAIs (4 octets per SAI)
 151              sizeof(sBcnHdr) + 2 + 16,     //preview persistent: 4 SAIs (4 octets per SAI)
 152              sizeof(sBcnHdr) + 1 + 8,      //region: 4 regions
 153              sizeof(sBcnHdr) + MAC_ADDR_LEN,  //MAC Address
 154              sizeof(sBcnHdr) + 1,             //Discover
 155              sizeof(sBcnHdr) + sizeof(sDiscInfoEntry),   //Discovered Info
 156              sizeof(sBcnHdr) + 3,            //Beacon Period Start Time Offset
 157              sizeof(sBcnHdr) + sizeof(sEncrypKeyChangeEntry),  //Encryption Key Change
 158              sizeof(sBcnHdr) + sizeof(sCcoHoEntry),      //CCo Handover
 159              sizeof(sBcnHdr) + sizeof(sBcnRelocEntry),   //Beacon Relocation
 160              sizeof(sBcnHdr) + sizeof(sAclSyncCntDownEntry),  //AC Line Sync Countdown
 161              sizeof(sBcnHdr) + sizeof(sChangeNumSlotsEntry),  //Change NumSlots
 162              sizeof(sBcnHdr) + sizeof(sChangeHmEntry),        //Change Hybrid Mode
 163              sizeof(sBcnHdr) + sizeof(sChangeSnidEntry),      //Change SNID
 164              0,                             //RSN Info Element
 165              0,                             //ISP BENTRY
 166              0,                             //Extended Band Stay Out
 167              0,                             //AG Assignment
 168              0,                             //Extended Carriers Support
 169              sizeof(sBcnHdr) + 12,          //Power Save BENTRY: 8 stations
 170              0,                             //Vendor Specific
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 4   

 171          };
 172          #else
              extern u8 BeHdrType[];
              extern u8 BeLenMax[];
              
              #endif
 177          
 178          #ifdef STA_FUNC
 179          /* ========================== 
 180           * STA  network system manager
 181           * ========================== */
 182          void SNSM_UpdateUaStaList(sSnsm *snsm, sCmUaStaInd *uaStaInfo, u8 *macAddr)
 183          {
 184   1          u8 i;
 185   1          u8 k = UA_STA_LIST_MAX;
 186   1          for(i = 0; i < UA_STA_LIST_MAX; i++)
 187   1          {
 188   2              if(snsm->uaStaInfo[i].valid == TRUE)
 189   2              {
 190   3                  if( (memcmp(snsm->uaStaInfo[i].nid, uaStaInfo->nid, NID_LEN) == 0)&&
 191   3                      (memcmp(snsm->uaStaInfo[i].macAddr, macAddr, MAC_ADDR_LEN) == 0))
 192   3                  {
 193   4                      snsm->uaStaInfo[i].hit = 1;
 194   4                      return;
 195   4                  }
 196   3              }
 197   2              else
 198   2              {
 199   3                  k = i;
 200   3              }
 201   2          }
 202   1      
 203   1          if(k < UA_STA_LIST_MAX)
 204   1          {
 205   2              snsm->uaStaInfo[k].valid = 1;
 206   2              snsm->uaStaInfo[k].hit = 1;
 207   2              memcpy(snsm->uaStaInfo[k].nid, uaStaInfo->nid, NID_LEN);
 208   2              memcpy(snsm->uaStaInfo[k].macAddr, macAddr, MAC_ADDR_LEN);
 209   2              snsm->uaStaInfo[k].ccoCap = uaStaInfo->ccoCap;
 210   2          }
 211   1      }
 212                      
 213          
 214          void SNSM_UpdateAvlnList(sSnsm *snsm, sAvlnInfoRef *avlnInfo)
 215          {
 216   1          u8 i;
 217   1          u8 k;
 218   1          //search through the AVLN list 
 219   1          k = AVLN_LIST_MAX;
 220   1          for(i = 0; i < AVLN_LIST_MAX; i++)
 221   1          {
 222   2              if(snsm->avlnInfo[i].valid == TRUE)
 223   2              {
 224   3                  if((memcmp(snsm->avlnInfo[i].nid, avlnInfo->nid, NID_LEN-1) == 0) &&
 225   3                     ((snsm->avlnInfo[i].nid[NID_LEN-1]&NID_EXTRA_BIT_MASK) == (avlnInfo->nid[NID_LEN-1]&NID_EXT
             -RA_BIT_MASK)))
 226   3                  {
 227   4                      //found the existing AVLN
 228   4                      snsm->avlnInfo[i].hit = 1;
 229   4                      return;
 230   4                  }            
 231   3              }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 5   

 232   2              else
 233   2              {
 234   3                  k = i;  
 235   3              }
 236   2          }
 237   1          
 238   1          if(k < AVLN_LIST_MAX)
 239   1          {
 240   2              //found a new AVLN
 241   2              snsm->avlnInfo[k].valid = TRUE;
 242   2              memcpy(snsm->avlnInfo[k].nid, avlnInfo->nid, NID_LEN-1);
 243   2              snsm->avlnInfo[k].nid[NID_LEN-1] = avlnInfo->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK;
 244   2              snsm->avlnInfo[k].hit = 1;
 245   2              snsm->avlnInfo[k].snid = avlnInfo->snid;
 246   2              snsm->numAvln++;
 247   2      
 248   2          }
 249   1          else
 250   1          {
 251   2              FM_Printf(FM_WARN, "SNSM:AVLN List full\n");
 252   2          }
 253   1      }
 254          
 255          
 256          
 257          //aging the discovered STA and network lists
 258          void SNSM_PerformAging(sSnsm *snsm)
 259          {
 260   1          u8 i;
 261   1      //    sLinkLayer *linkl = NULL;
 262   1      //    sEvent *event = NULL;
 263   1      //    sScb   *scb = NULL;
 264   1      
 265   1          if(snsm->state ==  SNSM_STATE_NET_DISC)
 266   1          {
 267   2              for(i = 0; i < UA_STA_LIST_MAX; i++)
 268   2              {
 269   3                  if(snsm->uaStaInfo[i].valid == TRUE)
 270   3                  {
 271   4                      if(snsm->uaStaInfo[i].hit == 1)
 272   4                      {
 273   5                          snsm->uaStaInfo[i].hit = 0;
 274   5                      }
 275   4                      else
 276   4                      {
 277   5                         //remove the entry from the list
 278   5                         memset(&snsm->uaStaInfo[i], 0, sizeof(sUaStaInfo));
 279   5                         // reduce uasta count
 280   5                         snsm->numUaSta--; 
 281   5                      }
 282   4                  }
 283   3              }
 284   2              
 285   2              for(i = 0; i < AVLN_LIST_MAX; i++)
 286   2              {
 287   3                  if(snsm->avlnInfo[i].valid == TRUE)
 288   3                  {
 289   4                      if(snsm->avlnInfo[i].hit == 1)
 290   4                      {
 291   5                          snsm->avlnInfo[i].hit = 0;
 292   5                      }
 293   4                      else
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 6   

 294   4                      {
 295   5                         //remove the entry from the list
 296   5                         memset(&snsm->avlnInfo[i], 0, sizeof(sAvlnInfo));
 297   5                         // reduce avln count
 298   5                         snsm->numAvln--;
 299   5                      }
 300   4                  }
 301   3              }
 302   2              
 303   2              
 304   2          }
 305   1      
 306   1      /*
 307   1          if(snsm->state ==  SNSM_STATE_CONN)
 308   1          {
 309   1              scb = snsm->staInfo->staScb;
 310   1              SCB_AgeDiscLists(scb);
 311   1              for(i = 0; i < DISC_STA_LIST_MAX; i++)
 312   1              {
 313   1                  if(scb->discStaInfo[i].valid == TRUE)
 314   1                  {
 315   1                      if(scb->discStaInfo[i].hit == 1)
 316   1                      {
 317   1                          scb->discStaInfo[i].hit = 0;
 318   1                      }
 319   1                      else
 320   1                      {
 321   1      FM_Printf(FM_ERROR, "SNSM: age out a discovery entry (tei: %d).\n",
 322   1                          scb->discStaInfo[i].tei);
 323   1                         //remove the entry from the list
 324   1                         memset(&scb->discStaInfo[i], 0, sizeof(sDiscStaInfo));
 325   1                         scb->discUpdate = 1;
 326   1                         scb->numDiscSta--;
 327   1                      }
 328   1                  }
 329   1              }
 330   1      
 331   1              for(i = 0; i < DISC_NET_LIST_MAX; i++)
 332   1              {
 333   1                  if(scb->discNetInfo[i].valid == TRUE)
 334   1                  {
 335   1                      if(scb->discNetInfo[i].hit == 1)
 336   1                      {
 337   1                          scb->discNetInfo[i].hit = 0;
 338   1                      }
 339   1                      else
 340   1                      {
 341   1                         //remove the entry from the list
 342   1                         memset(&scb->discNetInfo[i], 0, sizeof(sDiscNetInfo));
 343   1                         scb->discUpdate = 1;
 344   1                         scb->numDiscNet--;
 345   1                      }
 346   1                  }
 347   1              }
 348   1      
 349   1              //NOTE: noBcn is reset after the central beacon is received
 350   1              snsm->noBcn++; 
 351   1      
 352   1              if(snsm->noBcn > NO_BCN_MAX)
 353   1              {
 354   1                  //send event CCO_SEL_IND to the ctrl        
 355   1                  event = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 7   

 356   1                  if(event == NULL)
 357   1                  {
 358   1                      FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
 359   1                  }
 360   1                  else
 361   1                  {
 362   1                      //free all SCBs in the TEI map
 363   1                      CRM_Init(snsm->crm);
 364   1      
 365   1                      //TODO: search for the backup CCO through the TEI MAP list
 366   1      
 367   1                      event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 368   1                      //deliver the event to the upper layer
 369   1                      linkl = (sLinkLayer *)HOMEPLUG_GetLayer(HP_LAYER_TYPE_LINK);
 370   1                      linkl->deliverEvent(linkl->eventcookie, event);
 371   1                  }
 372   1                                       
 373   1              } 
 374   1          }
 375   1      */
 376   1      }
 377          
 378          
 379          u8 SNSM_SelectCco(sSnsm *snsm,  sEvent *event)
 380          {
 381   1          u8          *myMacAddr = NULL;
 382   1          u8          *staMacAddr = NULL;
 383   1          u8           beCco = FALSE;
 384   1          u8           ccoCap;
 385   1          sCmUaStaInd *uaStaInfo;
 386   1      #ifdef UKE  
                  sCmJoinReq  *joinReq;
              #endif
 389   1      
 390   1          sHpgpHdr    *hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
 391   1      #ifdef LG_WAR
                  if(snsm->staInfo->lastUserAppCCOState != 0)
                  {
                      return FALSE;
                  }
              #endif
 397   1      
 398   1          if(event->eventHdr.type == EVENT_TYPE_CM_UNASSOC_STA_IND)
 399   1          {
 400   2               uaStaInfo = (sCmUaStaInd *) event->buffDesc.dataptr;
 401   2      
 402   2          //chceck if the NID is matched
 403   2              if(memcmp(snsm->staInfo->nid, uaStaInfo->nid, NID_LEN) != 0)
 404   2                  return beCco;
 405   2              
 406   2              ccoCap  = uaStaInfo->ccoCap;
 407   2      
 408   2          }
 409   1      #ifdef UKE  
                  else
                  if(event->eventHdr.type == EVENT_TYPE_CM_SC_JOIN_REQ)
                  {
                      if((snsm->staInfo->secMode != SEC_MODE_SC_ADD &&
                          snsm->staInfo->secMode != SEC_MODE_SC_JOIN))
                      {
                          return beCco;
                      }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 8   

              
                      joinReq = (sCmJoinReq *) event->buffDesc.dataptr;
                      
                      ccoCap = joinReq->ccoCapability;
                  }
              #endif
 424   1      
 425   1          if(snsm->staInfo->staCap.fields.ccoCap > ccoCap)
 426   1          {
 427   2              beCco = TRUE;
 428   2          }
 429   1          else if (snsm->staInfo->staCap.fields.ccoCap == ccoCap)
 430   1          {
 431   2              //compare MAC address
 432   2              myMacAddr = snsm->staInfo->macAddr;
 433   2              staMacAddr = hpgpHdr->macAddr;      
 434   2      #ifdef NSM_STA_PRINT                              
              FM_Printf(FM_MINFO,"my MAC Address:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
                                  myMacAddr[0], myMacAddr[1],
                                  myMacAddr[2], myMacAddr[3],
                                  myMacAddr[4], myMacAddr[5]);
              FM_Printf(FM_MINFO,"peer MAC Address:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
                                  staMacAddr[0], staMacAddr[1],
                                  staMacAddr[2], staMacAddr[3],
                                  staMacAddr[4], staMacAddr[5]);
              #endif
 444   2                  if((memcmp(myMacAddr, staMacAddr, MAC_ADDR_LEN) > 0))
 445   2                  {
 446   3                      beCco = TRUE;
 447   3                  }
 448   2          
 449   2          } 
 450   1          return beCco;
 451   1      }
 452          
 453          //this function is called by the upper layer (e.g. when BBT timer expires) 
 454          //to determine the role of STA during network discovery
 455          u8 SNSM_DetermineStaRole(sSnsm *snsm)
 456          {
 457   1          u8 i;
 458   1          u8  staRole = STA_ROLE_USTA;
 459   1          for(i = 0; i < UA_STA_LIST_MAX; i++)
 460   1          {
 461   2              if(snsm->uaStaInfo[i].valid == TRUE)
 462   2              {
 463   3                  if( memcmp(snsm->uaStaInfo[i].nid, snsm->staInfo->nid, NID_LEN) == 0)
 464   3                  {
 465   4                      //matched NID is found
 466   4                      if(snsm->staInfo->staCap.fields.ccoCap > snsm->uaStaInfo[i].ccoCap)
 467   4                      {
 468   5                          staRole = STA_ROLE_ACCO;
 469   5                      }
 470   4                      else if(snsm->staInfo->staCap.fields.ccoCap == snsm->uaStaInfo[i].ccoCap)
 471   4                      {
 472   5                          if((memcmp(snsm->staInfo->macAddr, 
 473   5                                     snsm->uaStaInfo[i].macAddr, MAC_ADDR_LEN) > 0))
 474   5                          {
 475   6                              staRole = STA_ROLE_ACCO;
 476   6                          }
 477   5                          else
 478   5                          {
 479   6                              staRole = STA_ROLE_USTA;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 9   

 480   6                          }
 481   5                      } 
 482   4                      else
 483   4                      {
 484   5                          staRole = STA_ROLE_USTA;
 485   5                      }
 486   4                      break;
 487   4                  }
 488   3              }
 489   2          }         
 490   1      
 491   1          if (i == UA_STA_LIST_MAX)
 492   1          {
 493   2              if(snsm->numAvln)
 494   2              {
 495   3                  staRole = STA_ROLE_USTA;
 496   3              } 
 497   2              else
 498   2              {
 499   3                  staRole = STA_ROLE_UCCO;
 500   3              }
 501   2          }
 502   1      
 503   1          return staRole;
 504   1      }
 505          
 506          
 507          eStatus SNSM_BuildDiscBcn(sSnsm *snsm, sBeHdr *beHdrRef[])
 508          {
 509   1          u8              i, done;
 510   1          u8              offset = 0;
 511   1          u8              beLen = 0;
 512   1          u8              bcnLen = 0;
 513   1          sBcnHdr        *bcnHdr = NULL;
 514   1          sBeHdr         *centralBeHdr = NULL;
 515   1          sBeHdr         *beHdr = NULL;
 516   1          sDiscInfoEntry *discInfoEntry = NULL;
 517   1          sStaInfo       *staInfo = NULL;
 518   1          u8             *dataptr = NULL;
 519   1      
 520   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
 523   1          offset = sizeof(sFrmCtrlBlk);
 524   1      #endif
 525   1      
 526   1      
 527   1          staInfo = snsm->staInfo;
 528   1      
 529   1          memset(snsm->discBcnBuff, 0, BEACON_BUFF_LEN );
 530   1          bcnHdr = (sBcnHdr *)(snsm->discBcnBuff + offset);
 531   1          //(1)prepare the Beacon first 12 fixed portion
 532   1          memcpy(bcnHdr->nid, staInfo->nid, NID_LEN);
 533   1          bcnHdr->nid[NID_LEN-1] = (bcnHdr->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)|(staInfo->hm<<6);
 534   1          bcnHdr->stei = staInfo->staScb->tei;
 535   1      
 536   1          bcnHdr->bt = BEACON_TYPE_DISCOVER;
 537   1          bcnLen = sizeof(sBcnHdr);       //13 bytes, including nbe
 538   1      
 539   1          //(2)prepare the Beacon entries  
 540   1          dataptr = (u8 *)bcnHdr + sizeof(sBcnHdr);
 541   1      
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 10  

 542   1          i = 0;
 543   1          done = 0;
 544   1          beHdr = (sBeHdr *)dataptr;
 545   1          bcnHdr->nbe = 0;
 546   1          //TODO: may verify if there is enough room to transmit
 547   1          //the schedule entries.
 548   1          while((!done) && ((offset + bcnLen + BeLenMax[i]) <= BEACON_PAYLOAD_SIZE))
 549   1          {
 550   2              beLen = 0;
 551   2              switch(BeHdrType[i])
 552   2              {
 553   3                  case BEHDR_NON_PERSISTENT_SCHED:
 554   3                  case BEHDR_PERSISTENT_SCHED:
 555   3                  case BEHDR_REGIONS:
 556   3                  case BEHDR_CCO_HANDOVER:
 557   3                  case BEHDR_BCN_RELOC:
 558   3                  case BEHDR_CHANGE_NUM_SLOTS:
 559   3                  case BEHDR_CHANGE_SNID:
 560   3                  {
 561   4                     //copy those beacon entries
 562   4                     //from the central beacon to discover beacon
 563   4                     centralBeHdr = beHdrRef[BeHdrType[i]];
 564   4                     if(centralBeHdr)
 565   4                     {
 566   5                         memcpy(dataptr, centralBeHdr, 
 567   5                                centralBeHdr->beLen+sizeof(sBeHdr));  
 568   5                         dataptr +=sizeof(sBeHdr);
 569   5                         beLen = centralBeHdr->beLen;
 570   5                     }
 571   4                     break;
 572   4                  }
 573   3                  case BEHDR_MAC_ADDR: 
 574   3                  {
 575   4                      //always include mac addre entry
 576   4                      beHdr->beType = BEHDR_MAC_ADDR; 
 577   4                      dataptr +=sizeof(sBeHdr);
 578   4                      memcpy(dataptr, staInfo->macAddr, MAC_ADDR_LEN);
 579   4      
 580   4                      beLen = MAC_ADDR_LEN;
 581   4      
 582   4                      break;
 583   4                  } 
 584   3                  case BEHDR_DISC_INFO:
 585   3                  {
 586   4                      //always include discovered info entry
 587   4                      beHdr->beType = BEHDR_DISC_INFO;
 588   4                      dataptr +=sizeof(sBeHdr);
 589   4                      discInfoEntry = (sDiscInfoEntry *)dataptr;
 590   4                      discInfoEntry->staCap.byte = staInfo->staCap.byte;
 591   4      
 592   4              
 593   4                      discInfoEntry->staCap.fields.update = 
 594   4                          staInfo->staScb->discUpdate;          
 595   4      FM_Printf(FM_ERROR, "SNSM:disc bcn update:%d, %d\n", discInfoEntry->staCap.fields.update, staInfo->staScb-
             ->discUpdate);
 596   4      
 597   4                      discInfoEntry->numDiscSta = staInfo->staScb->numDiscSta; 
 598   4                      discInfoEntry->numDiscNet = staInfo->staScb->numDiscNet; 
 599   4                      discInfoEntry->staStatus.byte = staInfo->staStatus.byte;
 600   4      
 601   4                      beLen = sizeof(sDiscInfoEntry);
 602   4                      break;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 11  

 603   4                  }
 604   3                  case BEHDR_BPSTO:
 605   3                  {
 606   4                      //always include beacon period start time offset
 607   4                      beHdr->beType = BEHDR_BPSTO;
 608   4                      dataptr += sizeof(sBeHdr);
 609   4                      beLen = 3;
 610   4                      //snsm->bpstoOffset = bcnLen + sizeof(sBeHdr);
 611   4                      snsm->bpstoOffset = ((u8 *)beHdr  + sizeof(sBeHdr)) -  ((u8 *)snsm->discBcnBuff );
 612   4                      break;
 613   4                  }
 614   3      #ifdef POWERSAVE
                          case BEHDR_PWR_SAVE:
                          {
                              if(staInfo->staScb->psState == PSM_PS_STATE_ON)
                      {
                        // in DISC beacon's PS bentry, the only pertinent field is STA's PSS
                        sPowerSaveEntry *pPsBentry ;
              
                                beHdr->beType = BEHDR_PWR_SAVE;
                        beLen = sizeof(sPowerSaveEntry);
                                dataptr += sizeof(sBeHdr);
                        pPsBentry = (sPowerSaveEntry *) dataptr;
                        memcpy(pPsBentry, 0, sizeof(sPowerSaveEntry));
                          pPsBentry->tpss = staInfo->staScb->pss;
                                break;
                      }
                          }
              #endif
 632   3            case BEHDR_VENDOR_SPEC:  
 633   3                  {
 634   4                      done = 1;
 635   4                      break;
 636   4                  }
 637   3                  default:
 638   3                  {
 639   4                  }
 640   3              }
 641   2              if( beLen != 0)
 642   2              { 
 643   3                  beHdr->beLen = beLen; 
 644   3                  bcnLen += sizeof(sBeHdr) + beHdr->beLen;
 645   3                  dataptr += beLen;
 646   3                  beHdr = (sBeHdr *)dataptr;
 647   3                  beLen = 0;
 648   3                  bcnHdr->nbe++;
 649   3              }
 650   2              i++;
 651   2          }
 652   1      
 653   1      
 654   1          if((offset + bcnLen) > BEACON_PAYLOAD_SIZE)
 655   1          {
 656   2      #ifdef NSM_STA_PRINT  
                      FM_Printf(FM_ERROR, "SNSM:disc bcn is too big\n");
              #endif    
 659   2              return STATUS_FAILURE;
 660   2          }
 661   1      
 662   1          return STATUS_SUCCESS;
 663   1      
 664   1      }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 12  

 665          
 666          void SNSM_TransmitDiscBcn(sSnsm *snsm) 
 667          {
 668   1          sTxDesc         txinfo;
 669   1          sBuffDesc       buffDesc;
 670   1          u8              offset = 0; 
 671   1      
 672   1          FM_Printf(FM_HINFO, "SNSM:>>>DISC BCN\n");
 673   1      
 674   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
 677   1          offset = sizeof(sFrmCtrlBlk);
 678   1      #endif
 679   1      
 680   1          //transmit the beacon 
 681   1          txinfo.dtei = 0xFF;
 682   1          txinfo.stei = snsm->staInfo->staScb->tei;
 683   1          txinfo.frameType = BEACON_TYPE_DISCOVER;
 684   1          txinfo.snid = snsm->staInfo->snid;
 685   1        
 686   1          //prepare tx control information
 687   1          buffDesc.buff = snsm->discBcnBuff;
 688   1          buffDesc.bufflen = BEACON_BUFF_LEN;
 689   1          buffDesc.dataptr = snsm->discBcnBuff + offset;
 690   1          buffDesc.datalen = BEACON_PAYLOAD_SIZE;
 691   1      
 692   1          //FM_HexDump(FM_DATA|FM_MINFO, "SNSM: discovery beacon:", 
 693   1          //                             buffDesc.dataptr,
 694   1          //                             buffDesc.datalen);
 695   1      
 696   1          HAL_TransmitBeacon(HOMEPLUG_GetHal(), &txinfo, &buffDesc, snsm->bpstoOffset);
 697   1      }
 698          
 699          
 700          u8 SNSM_DetectCco(sSnsm *snsm, sBcnHdr *bcnHdr) 
 701          {
 702   1          sLinkLayer     *linkl = NULL;
 703   1          sStaInfo       *staInfo = NULL;
 704   1          sCrm           *crm = NULL;
 705   1          u8              bcnsrc = BCN_SRC_UNKNOWN;
 706   1      
 707   1      //    linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 708   1          linkl = snsm->linkl;
 709   1          staInfo = LINKL_GetStaInfo(linkl);
 710   1          crm = LINKL_GetCrm(linkl);
 711   1      
 712   1      
 713   1      
 714   1          bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
 715   1      /*
 716   1         FM_Printf(FM_MINFO,"my NID: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 717   1                              snsm->staInfo->nid[0], snsm->staInfo->nid[1],
 718   1                              snsm->staInfo->nid[2], snsm->staInfo->nid[3],
 719   1                              snsm->staInfo->nid[4], snsm->staInfo->nid[5],
 720   1                              snsm->staInfo->nid[6]);
 721   1         FM_Printf(FM_MINFO,"beacon NID: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 722   1                              bcnHdr->nid[0], bcnHdr->nid[1],
 723   1                              bcnHdr->nid[2], bcnHdr->nid[3],
 724   1                              bcnHdr->nid[4], bcnHdr->nid[5],
 725   1                              bcnHdr->nid[6]);
 726   1      */
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 13  

 727   1      
 728   1          if((memcmp(staInfo->nid, bcnHdr->nid, NID_LEN) == 0))
 729   1          {
 730   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 731   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 732   2              {
 733   3                  bcnsrc = BCN_SRC_CCO;
 734   3                  if(staInfo->ccoScb == NULL)
 735   3                  {
 736   4      #ifdef NSM_STA_PRINT      
                              FM_Printf(FM_MINFO, "SNSM:Add a scb for CCo.\n");
              #endif        
 739   4                      staInfo->ccoScb = CRM_AddScb(crm, bcnHdr->stei);
 740   4                      //NOTE: Beacon event does not contain CCo's MAC adddr
 741   4                      //The STA does not know CCo's MAC address until it associates
 742   4                      //with the CCo or it sends a query or receives discovery beacon
 743   4                      if(!staInfo->ccoScb) 
 744   4                      {
 745   5                          FM_Printf(FM_WARN, "SNSM:can't get a scb for CCo.\n");
 746   5                      }
 747   4                      memcpy(staInfo->ccoScb->macAddr, bcAddr, MAC_ADDR_LEN);
 748   4                  }
 749   3              }
 750   2              else
 751   2              {
 752   3                  bcnsrc = BCN_SRC_DISC;
 753   3              }
 754   2          }
 755   1          else
 756   1          {
 757   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 758   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 759   2              {
 760   3                  bcnsrc = BCN_SRC_OTHER_CCO;
 761   3              }
 762   2              else
 763   2              {
 764   3                  bcnsrc = BCN_SRC_OTHER_DISC;
 765   3              }
 766   2          }
 767   1      //    FM_Printf(FM_MINFO, "SNSM: Detect CCo %d.\n", bcnsrc);
 768   1          return bcnsrc;
 769   1      }
 770          
 771          void SNSM_HandleBcnLoss(sSnsm *snsm, u8 type)
 772          {
 773   1      
 774   1        sBcnHdr    *bcnHdr = NULL;
 775   1        u8        becomeCco = FALSE;
 776   1        u8        *bcn = NULL;
 777   1        sEvent     *newEvent = NULL;
 778   1        sHpgpHdr   *hpgpHdr = NULL;
 779   1        sCmUaStaInd  *uaStaInfo = NULL;
 780   1        sScb     *scb = NULL;
 781   1        sStaInfo   *staInfo = NULL; 
 782   1        sCrm     *crm = NULL;
 783   1        sEvent *event;
 784   1        sSnam    *snam = NULL;
 785   1        
 786   1        //    sCnam      *cnam = NULL;
 787   1        sLinkLayer   *linkl  = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 788   1        
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 14  

 789   1      
 790   1        staInfo = LINKL_GetStaInfo(linkl); 
 791   1        crm = LINKL_GetCrm(linkl);
 792   1        snam = LINKL_GetSnam(linkl);
 793   1      
 794   1        if (!snsm->enableBcnLossDetection)
 795   1        {
 796   2          return;
 797   2      
 798   2        }
 799   1      
 800   1        //type = *(iEvent->buffDesc.dataptr);
 801   1        
 802   1        if((type == MAX_NO_BEACON_NW_DISCOVERY) ||
 803   1           (type == MAX_NO_BEACON_BACKUPCCO))
 804   1        {
 805   2          sCcoLostIndEvent *ccoLostInd;
 806   2      
 807   2          
 808   2      
 809   2          if (type ==  MAX_NO_BEACON_NW_DISCOVERY)
 810   2          {
 811   3      
 812   3                Host_SendIndication(HOST_EVENT_BCN_LOSS, NULL, 0);
 813   3            //send event CCO_SEL_IND to the ctrl    
 814   3            event = EVENT_Alloc(1, EVENT_HPGP_CTRL_HEADROOM);
 815   3      
 816   3            if(event == NULL)
 817   3            {
 818   4              FM_Printf(FM_ERROR, "EAllocErr\n");
 819   4                      return;
 820   4            }
 821   3      
 822   3      
 823   3            event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 824   3            event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 825   3      
 826   3          
 827   3            ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;   
 828   3            //free all SCBs in the TEI map
 829   3            CRM_Init(snsm->crm);
 830   3      
 831   3            
 832   3            SNSM_Stop(&linkl->staNsm);
 833   3            SNAM_Stop(&linkl->staNam);
 834   3            
 835   3      
 836   3            ccoLostInd->reason   =  0;
 837   3      
 838   3            snsm->state = SNSM_STATE_INIT;
 839   3      
 840   3            //deliver the event to the upper layer
 841   3      #ifdef CALLBACK
                    linkl->deliverEvent(linkl->eventcookie, event);
              #else
 844   3            CTRLL_ReceiveEvent(linkl->eventcookie, event);
 845   3      #endif
 846   3            snsm->enableBcnLossDetection = 0;
 847   3      
 848   3          }
 849   2          else
 850   2          {
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 15  

 851   3            if (snsm->enableBackupCcoDetection  == 0)
 852   3            {
 853   4          
 854   4            Host_SendIndication(HOST_EVENT_PRE_BCN_LOSS, NULL, 0);
 855   4            if(staInfo->staCap.fields.backupCcoStatus)
 856   4            {
 857   5      
 858   5              
 859   5                
 860   5                
 861   5              //send event CCO_SEL_IND to the ctrl    
 862   5              event = EVENT_Alloc(1, EVENT_HPGP_CTRL_HEADROOM);
 863   5      
 864   5              if(event == NULL)
 865   5              {
 866   6                FM_Printf(FM_ERROR, "EAllocErr\n");
 867   6                          return;
 868   6              }
 869   5      
 870   5              HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);
 871   5      
 872   5              event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 873   5              event->eventHdr.type = EVENT_TYPE_CCO_LOST_IND;
 874   5      
 875   5              ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;   
 876   5      
 877   5              //perform handover switch to the CCo role
 878   5              //CRM has all SCBs for each STA from the  
 879   5              //CC_HANDOVER_INFO.IND,
 880   5              
 881   5                SNSM_Stop(&linkl->staNsm);
 882   5                  SNAM_Stop(&linkl->staNam);
 883   5              
 884   5              if (!staInfo->staScb)
 885   5              {
 886   6                printf("sta scb NULL\n");
 887   6              }
 888   5              staInfo->ccoScb = staInfo->staScb; 
 889   5              staInfo->ccoScb->staCap.fields.ccoStatus = 1;
 890   5      
 891   5              staInfo->staCap.fields.backupCcoStatus = 0;
 892   5              staInfo->staCap.fields.pcoStatus = 0;
 893   5      
 894   5              //deliver the event to the upper layer
 895   5      
 896   5              
 897   5              ccoLostInd->reason  =  1;
 898   5      #ifdef CALLBACK
                      linkl->deliverEvent(linkl->eventcookie, event);
              #else
 901   5              CTRLL_ReceiveEvent(linkl->eventcookie, event);
 902   5      #endif
 903   5            }
 904   4            else
 905   4            {
 906   5              snsm->enableBackupCcoDetection = 1;
 907   5            }
 908   4            }
 909   3      
 910   3          }
 911   2      
 912   2      
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 16  

 913   2        } 
 914   1      
 915   1      }
 916          
 917          //This function is called only when the STA is associated with the CCo
 918          //void SNSM_ProcBcn(sSnsm *snsm, sEvent *event)
 919          //We split the beacon processing into two parts:
 920          //High priority: those requiring immdiate response
 921          //Low  priority: those tolerating the delay.
 922          void SNSM_ProcBcnLow(sSnsm *snsm, sRxDesc *rxdesc, u8* bcn )
 923          {
 924   1          sBcnHdr        *bcnHdr = NULL;
 925   1          sBeHdr         *beHdr = NULL;
 926   1          u8              bcnsrc;
 927   1          u8              nid7;
 928   1          u8              nbe = 0;
 929   1          u8             *dataptr = 0;
 930   1          u8             *macAddr = NULL;
 931   1          sDiscStaInfoRef discStaInfoRef;
 932   1          sDiscNetInfoRef discNetInfoRef;
 933   1      //    sBcnRef         bcnRef;
 934   1          sCcoHoEntry    *ccoHo = NULL;
 935   1          sStaInfo       *staInfo = NULL;
 936   1      #ifdef ROUTE
                  sScb           *scb = NULL;
              #endif
 939   1      
 940   1          staInfo = snsm->staInfo;
 941   1      
 942   1          //(1) process the beacon header
 943   1      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
 944   1          bcnHdr = (sBcnHdr *) bcn;
 945   1          //get the Hybrid Mode before calling SNSM_DetectCco(),
 946   1          //which will remove the HM in the beacon header
 947   1          nid7 = bcnHdr->nid[NID_LEN-1];
 948   1        
 949   1          //first, check if it is my CCo
 950   1          bcnsrc = SNSM_DetectCco(snsm, bcnHdr); 
 951   1          switch(bcnsrc)
 952   1          {
 953   2              case BCN_SRC_CCO:
 954   2              {
 955   3                  //now, it is my network CCo
 956   3                  snsm->noBcn = 0;
 957   3                  if(snsm->enableCcoDetection)
 958   3                  {
 959   4      #ifdef NSM_STA_PRINT      
                              FM_Printf(FM_HINFO, "SNSM:Detect the CCo\n");
              #endif        
 962   4                      snsm->enableCcoDetection = 0;
 963   4                      snsm->ccoDetected = 1;
 964   4                  }
 965   3                  break;
 966   3              }
 967   2              case BCN_SRC_DISC:
 968   2              {
 969   3      #ifdef P8051
 970   3                  FM_Printf(FM_HINFO, "SNSM:<<<DISC BCN(L)(tei: %bu)\n", bcnHdr->stei);
 971   3      #else
                          FM_Printf(FM_HINFO, "SNSM:<<<DISC BCN(L)(tei: %d)\n", bcnHdr->stei);
              #endif
 974   3                  
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 17  

 975   3      #ifdef LG_WAR
                          return;
              #endif
 978   3                  break;
 979   3              }
 980   2              case BCN_SRC_OTHER_CCO:
 981   2              {
 982   3                  //It is a CCo from other networks
 983   3                  //update the network list
 984   3                  discNetInfoRef.nid = bcnHdr->nid;
 985   3                  discNetInfoRef.hybridMode = nid7>>6;
 986   3                  discNetInfoRef.netMode = bcnHdr->nm;
 987   3                  discNetInfoRef.numBcnSlots = bcnHdr->numslots;
 988   3      //            discNetInfoRef.bpsto = snsm->bpsto; //TODO: how to get the bpsto 
 989   3                  SCB_UpdateDiscNetList(snsm->staInfo->staScb, &discNetInfoRef);
 990   3                  return;
 991   3              }
 992   2              case BCN_SRC_OTHER_DISC:
 993   2              {
 994   3                  //discovery sta list may include the STA not in the same network
 995   3                  //but do not support it at present, though it is easy.
 996   3                  //
 997   3                  return;
 998   3              }
 999   2              default:
1000   2              {
1001   3              }
1002   2          }
1003   1      
1004   1          //now, the beacon is either central/proxy/discovery beacon 
1005   1          //from the same network
1006   1      
1007   1          if(bcnHdr->hoip)
1008   1          {
1009   2              //Call the SNAM to suspend the association request and traffic
1010   2              snsm->stopSnam = 1;
1011   2          }
1012   1          else if(snsm->stopSnam) //may not be necessary
1013   1          {
1014   2              //Call the SNAM to resume the association request and traffic
1015   2              snsm->stopSnam = 0;
1016   2          }
1017   1      
1018   1      
1019   1      //    memset(&bcnRef, 0, sizeof(sBcnRef));
1020   1          nbe = bcnHdr->nbe;
1021   1          dataptr = bcn + sizeof(sBcnHdr);
1022   1          beHdr = (sBeHdr *) dataptr;
1023   1      
1024   1      //FM_Printf(FM_HINFO, "SNSM: Beacon entry number (%d).\n", nbe);
1025   1      
1026   1      
1027   1          //(2) Process Beacon Management Information (BMI)
1028   1          //Note: According to the standard, the BENTRYs within the MBI shall 
1029   1          //be arranged in increasing order of their BEHDR values.
1030   1          while(nbe)
1031   1          {
1032   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1033   2              switch (beHdr->beType)
1034   2              {
1035   3                  case BEHDR_MAC_ADDR:
1036   3                  {
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 18  

1037   4                      macAddr = dataptr;
1038   4                      if (bcnsrc == BCN_SRC_CCO)
1039   4              {
1040   5                if(memcmp(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN))
1041   5                      {
1042   6                          //the central beacon from the backup CCo
1043   6                          //perform the CCo switch 
1044   6                          //(let the previous CCo scb aging out)
1045   6      
1046   6                
1047   6                if (snsm->enableBackupCcoDetection)
1048   6                {
1049   7                  staInfo->ccoScb = CRM_AddScb(snsm->crm, bcnHdr->stei);
1050   7      
1051   7                  //send CCO_DISC.IND to the SNAM to renew TEI with the
1052   7                  //backup CCo
1053   7                  snsm->ccoDetected = 1;
1054   7      
1055   7                  gHpgpHalCB.syncComplete = 0; // forcing re-sync to new Backup CCo
1056   7      
1057   7                  snsm->netSync = 0;
1058   7                  
1059   7                  snsm->enableBackupCcoDetection = 0;
1060   7      
1061   7                  FM_Printf(FM_HINFO, "SNSM:switch to the backup CCo.\n");
1062   7      
1063   7                  }
1064   6                }
1065   5                else
1066   5                {
1067   6                  snsm->enableBackupCcoDetection = 0;
1068   6                }
1069   5                      }
1070   4                     
1071   4                      break;
1072   4                  }
1073   3                  case BEHDR_DISC_INFO:
1074   3                  {
1075   4                      discStaInfoRef.discInfo = (sDiscInfoEntry *)dataptr;
1076   4                      if (macAddr)
1077   4                      {
1078   5                          discStaInfoRef.macAddr = macAddr;
1079   5      //                    discStaInfoRef.nid = bcnHdr->nid;
1080   5      //                    discStaInfoRef.tei = rxdesc->stei;
1081   5                          discStaInfoRef.tei = bcnHdr->stei;
1082   5                          discStaInfoRef.snid = rxdesc->snid;
1083   5                          //NOTE: hm filed in the beacon is set to zero
1084   5                          //in SNSM_DetectCco()
1085   5                          if( memcmp(snsm->staInfo->nid, bcnHdr->nid, NID_LEN) == 0 ) 
1086   5                          {
1087   6                              discStaInfoRef.sameNet = 1;
1088   6                          }
1089   5                          else
1090   5                          {
1091   6                              discStaInfoRef.sameNet = 0;
1092   6                          }
1093   5                          //update the discovred STA list
1094   5                          SCB_UpdateDiscStaList(staInfo->staScb, &discStaInfoRef);
1095   5      #ifdef ROUTE
                                  ROUTE_update(bcnHdr->stei);                    
              #endif
1098   5                      }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 19  

1099   4                      else
1100   4                      {
1101   5                          FM_Printf(FM_WARN, "SNSM:Unknown disc STA in Bcn\n");
1102   5                      }
1103   4                      break;
1104   4                  }
1105   3                  case BEHDR_ENCRYP_KEY_CHANGE:
1106   3                  {
1107   4                      break;
1108   4                  }
1109   3                  case BEHDR_CCO_HANDOVER:
1110   3                  {
1111   4                      ccoHo = (sCcoHoEntry *)dataptr;
1112   4                      FM_Printf(FM_HINFO, "SNSM:HO cntdown(%d)\n", ccoHo->hcd);
1113   4                      if(ccoHo->hcd == 0)
1114   4                      {
1115   5                          //FM_Printf(FM_HINFO, "SNSM: HO switch.\n");
1116   5                          //HO countdown expires. perform handover
1117   5                          if(ccoHo->nctei == snsm->staInfo->tei)
1118   5                          {
1119   6                              //switch to the CCO mode/role
1120   6                              snsm->hoSwitch = HPGP_HO_SWITCH_CCO;
1121   6                          }
1122   5                          else
1123   5                          {
1124   6                              //still in the STA mode but associate to new CCO 
1125   6                              snsm->nctei = ccoHo->nctei;
1126   6                              snsm->hoSwitch = HPGP_HO_SWITCH_STA;
1127   6                          }
1128   5                      }
1129   4                      break;
1130   4                  }
1131   3                  case BEHDR_ACL_SYNC_CNTDOWN:
1132   3                  {
1133   4                      break;
1134   4                  }
1135   3                  case BEHDR_CHANGE_HM:
1136   3                  {
1137   4                      break;
1138   4                  }
1139   3                  default:
1140   3                  {
1141   4                  }
1142   3              }
1143   2              //move to the next BEHDR
1144   2              dataptr = dataptr +  beHdr->beLen; 
1145   2              beHdr = (sBeHdr *) dataptr;
1146   2              nbe--;
1147   2          }         
1148   1      
1149   1      }
1150          
1151          void SNSM_ProcBcnHigh(sSnsm *snsm, u8* bcn, u8 snid)
1152          {
1153   1          sBcnHdr        *bcnHdr = NULL;
1154   1          sBeHdr         *beHdr = NULL;
1155   1          sBeHdr         *beHdrRef[NELEMENTS(BeHdrType)];
1156   1          u8              nid7; 
1157   1          u8              bcnsrc = BCN_SRC_UNKNOWN; 
1158   1          u8              nbe = 0;
1159   1          u8             *dataptr = 0;
1160   1          u8              i = 0;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 20  

1161   1          u8              j = 0;
1162   1          sStaInfo       *staInfo = NULL;
1163   1          sCsmaRegion    *region = NULL;
1164   1          u8              regionNum = 0;
1165   1          u16             endTime = 0;
1166   1          sRegionEntry   *regionEntry = NULL;
1167   1      #ifdef POWERSAVE
                sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sPowerSaveEntry *pPsBentry ;
                  sHpgpHalCB *hhalCb = HOMEPLUG_GetHal()->hhalCb;
              #endif
1172   1      
1173   1          staInfo = snsm->staInfo;
1174   1      
1175   1      // FM_Printf(FM_HINFO, "SNSM: BeHdrType size = %d\n", NELEMENTS(BeHdrType));
1176   1          for(i = 0; i< NELEMENTS(BeHdrType); i++)
1177   1          {
1178   2              beHdrRef[i] = NULL;
1179   2          }
1180   1          //(1) process the beacon header
1181   1      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
1182   1          bcnHdr = (sBcnHdr *)bcn;
1183   1      
1184   1          nid7 = bcnHdr->nid[NID_LEN-1];
1185   1      
1186   1          bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
1187   1      
1188   1       //FM_Printf(FM_HINFO, "SNSM_ProcBcnHigh\n");
1189   1      
1190   1          if((memcmp(staInfo->nid, bcnHdr->nid, NID_LEN) == 0))
1191   1          {
1192   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1193   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
1194   2              {
1195   3                  //it should not occur
1196   3      #ifdef NSM_STA_PRINT      
                          FM_Printf(FM_MMSG|FM_LINFO, "SNSM:<<<CENTRAL/PROXY BCN(H)\n");
              #endif      
1199   3                  bcnsrc = BCN_SRC_CCO;
1200   3              }
1201   2              else
1202   2              {
1203   3      #ifdef P8051
1204   3                  FM_Printf(FM_HINFO, "SNSM:<<<DISC BCN(H)(tei: %bu)\n", bcnHdr->stei);
1205   3      #else
                          FM_Printf(FM_HINFO, "SNSM:<<<DISC BCN(H)(tei: %d)\n", bcnHdr->stei);
              #endif
1208   3                  bcnsrc = BCN_SRC_DISC;
1209   3      
1210   3      #ifdef LOG_FLASH
                    logEvent(DISC_BCN_LOG,0,0,&bcnHdr->stei,1);
              #endif
1213   3      
1214   3      #ifdef LG_WAR
                          return;
              #endif
1217   3      
1218   3              }
1219   2          }
1220   1          else
1221   1          {
1222   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 21  

1223   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
1224   2              {
1225   3                  bcnsrc = BCN_SRC_OTHER_CCO;
1226   3                  // Process other bcn for avln detection
1227   3                  if(snsm->state != SNSM_STATE_NET_DISC)
1228   3                  {
1229   4                      return; 
1230   4                  }
1231   3              }
1232   2              else
1233   2              {
1234   3                  bcnsrc = BCN_SRC_OTHER_DISC;
1235   3                  //not interested in other discover beacons at present
1236   3                  return; // TODO TBD
1237   3              }
1238   2          }
1239   1      
1240   1          bcnHdr->nid[NID_LEN-1] = nid7;
1241   1      
1242   1          /* see if the beacon region exists */
1243   1          region = snsm->region;
1244   1          j = 0;
1245   1          if (bcnHdr->numslots)
1246   1          {
1247   2              /* need to include beacon region */
1248   2              region[j].startTime = 0;
1249   2              region[j].endTime = region[j].startTime + (bcnHdr->numslots * HPGP_BEACON_SLOT_ATU);
1250   2              region[j].regionType = REGION_TYPE_BEACON;
1251   2              region[j].rxOnly = 1;
1252   2              j++;
1253   2          }
1254   1                              
1255   1          nbe = bcnHdr->nbe;
1256   1          dataptr = bcn + sizeof(sBcnHdr);
1257   1          beHdr = (sBeHdr *) dataptr;
1258   1          
1259   1          //(2) Process Beacon Management Information (BMI)
1260   1          //Note: According to the standard, the BENTRYs within the MBI shall 
1261   1          //be arranged in increasing order of their BEHDR values.
1262   1      
1263   1          //FM_HexDump(FM_DATA|FM_MINFO, "Rx Bcn:",
1264   1          //           bcn, PLC_BCNRX_LEN);
1265   1          while(nbe)
1266   1          { 
1267   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1268   2              switch (beHdr->beType)
1269   2              {
1270   3                  case BEHDR_NON_PERSISTENT_SCHED:
1271   3                  {
1272   4                      beHdrRef[BEHDR_NON_PERSISTENT_SCHED] = beHdr;
1273   4      //                bcnRef.nonPersSchedEntry = beHdr;
1274   4       
1275   4                      break;
1276   4                  }
1277   3                  case BEHDR_PERSISTENT_SCHED:
1278   3                  {
1279   4                      sSaiWithSt    *saiwst = NULL;
1280   4                      sSaiWithoutSt *saiwost = NULL;
1281   4                      u8            *ptr = NULL;
1282   4                      u8 ns = 0; 
1283   4                      u8 scd = 0;
1284   4                      u8 stpf = 0;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 22  

1285   4                      u16 et = 0;
1286   4                      u16 st = 0;
1287   4                      u8 cscd;
1288   4                      static u8 changeSch = 1;
1289   4                      
1290   4                      beHdrRef[BEHDR_PERSISTENT_SCHED] = beHdr;
1291   4      //                bcnRef.persSchedEntry = beHdr;
1292   4      
1293   4                      /* schedule count down */
1294   4                      scd = *dataptr;
1295   4                      /* At present, interested in the current schedule only, 
1296   4                       * and ignore the preview schedule */ 
1297   4                      if (scd & 0x7) 
1298   4                      {
1299   5                          /* it is a preview schedule */
1300   5                          break; 
1301   5                      }
1302   4                      cscd = ((scd >> 3) & 0x7);
1303   4                      
1304   4                      if(changeSch == 1)
1305   4                      {
1306   5                              
1307   5                          /* now it is a current schedule */
1308   5                          /* NS */
1309   5                          ns = *(dataptr + 1);
1310   5                          ptr = dataptr + 2;
1311   5                          endTime = 0;
1312   5                    i = 0;
1313   5                          while((j < HPGP_REGION_MAX) && (i < ns))
1314   5                          {
1315   6                              stpf = *ptr;
1316   6                              if (stpf & 0x1) 
1317   6                              {
1318   7                                  saiwst = (sSaiWithSt *)ptr;
1319   7                                  endTime =  (saiwst->etHi << 4) | saiwst->etLo; 
1320   7                                  if ( (saiwst->glid == (HPGP_GLID_GPP & 0x7F)) ||
1321   7                                       (saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1322   7                                       (saiwst->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
1323   7                                  {
1324   8                                      st = (saiwst->stHi << 8) | saiwst->stLo;
1325   8                                      if(et != st)
1326   8                                      {
1327   9                                          region[j].startTime =  0;//et;
1328   9                                          region[j].endTime = st;
1329   9                                          region[j].hybridMd  = 1;
1330   9                            region[j].rxOnly = 1;
1331   9                                          region[j].regionType = REGION_TYPE_STAYOUT;
1332   9      
1333   9                                      }
1334   8                                      et = endTime;
1335   8                                      j++;
1336   8                                      region[j].startTime =  0;//st;
1337   8                                      region[j].endTime = endTime;// - region[j].startTime;
1338   8                                      
1339   8                          if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) || 
1340   8                              (saiwst->glid == (HPGP_GLID_GPP & 0x7F))) 
1341   8                          {
1342   9                              region[j].hybridMd  = 1;
1343   9                            region[j].rxOnly = 0;
1344   9                            region[j].regionType = REGION_TYPE_SHARED_CSMA;
1345   9                          }
1346   8                          else
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 23  

1347   8                          {
1348   9                              region[j].regionType = REGION_TYPE_LOCAL_CSMA;
1349   9                                          region[j].hybridMd = 1;
1350   9                                          region[j].rxOnly = 0;
1351   9                          }                            
1352   8                                      j++;
1353   8                                  }
1354   7                                  ptr += sizeof(sSaiWithSt);
1355   7                              }
1356   6                              else 
1357   6                              {
1358   7                                  saiwost = (sSaiWithoutSt *)ptr;
1359   7                                  if ( (saiwost->glid == (HPGP_GLID_GPP & 0x7F)) ||
1360   7                                       (saiwost->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1361   7                                       (saiwost->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
1362   7                                  {
1363   8                                      region[j].startTime =  0;//endTime;
1364   8                                      endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
1365   8                                      region[j].endTime = endTime;// - region[j].startTime;
1366   8                          if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
1367   8                              (saiwost->glid == (HPGP_GLID_GPP & 0x7F))) 
1368   8                          {
1369   9                              region[j].hybridMd = 1;
1370   9                            region[j].rxOnly = 0;
1371   9                                  region[j].regionType = REGION_TYPE_SHARED_CSMA;
1372   9                          }
1373   8                          else
1374   8                          {
1375   9                              region[j].regionType = REGION_TYPE_LOCAL_CSMA;
1376   9                                          region[j].hybridMd = 1;
1377   9                                          region[j].rxOnly = 0;
1378   9                          }
1379   8                                      et = endTime;
1380   8                                      j++;
1381   8                                  }
1382   7                                  else
1383   7                                  {
1384   8                                      endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
1385   8                                      et = endTime;
1386   8                                  }
1387   7                                  ptr += sizeof(sSaiWithoutSt);
1388   7                              }
1389   6                              i++;
1390   6                          }
1391   5                    for (;j < HPGP_REGION_MAX;j++)
1392   5                    {
1393   6                              region[j].startTime  = 0;//endTime;
1394   6                              region[j].rxOnly  = 1;
1395   6                              region[j].endTime   = 0xFFF;
1396   6                              region[j].hybridMd   = 1;  
1397   6                        region[j].regionType = REGION_TYPE_STAYOUT;
1398   6                              snsm->regionNum = j + 1;
1399   6                          }
1400   5                    //else
1401   5                          {
1402   6                              snsm->regionNum = HPGP_REGION_MAX;
1403   6                          }
1404   5                          //snsm->regionNum = HPGP_REGION_MAX;
1405   5      //#ifdef HPGP_HAL
1406   5                          HHAL_SetCsmaRegions(snsm->region, snsm->regionNum);
1407   5                          changeSch = 0;
1408   5      
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 24  

1409   5      //#endif
1410   5                    //      for (j=0; j<snsm->regionNum; j++) {
1411   5                    //          FM_Printf(FM_USER, "SNSM: region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n",
             - 
1412   5                    //              j, snsm->region[j].startTime, snsm->region[j].endTime, snsm->region[j].rxOnl
             -y);
1413   5                    //      }
1414   5                      }
1415   4                //      printf("cscd : %bu \n", cscd);
1416   4      
1417   4                      if(cscd == 0 || cscd == 1) // if we loss bcn (cscd = 0) still it will modify sch
1418   4                      {
1419   5                          changeSch = 1;
1420   5                          
1421   5                      }
1422   4                      break;
1423   4                  }
1424   3                  case BEHDR_REGIONS:
1425   3                  {
1426   4                      beHdrRef[BEHDR_REGIONS] = beHdr;
1427   4                      //bcnRef.regionEntry = beHdr;
1428   4                     // setCSMA_onCCO1();
1429   4                      break;
1430   4                  }
1431   3                  case BEHDR_DISCOVER:
1432   3                  {
1433   4      #ifdef P8051
1434   4      FM_Printf(FM_HINFO, "SNSM:get discBcn sched(%bu)\n", *dataptr);
1435   4      #else
              FM_Printf(FM_HINFO, "SNSM:get discBcn sched(%d)\n", *dataptr);
              #endif
1438   4                      if( (staInfo->staScb)&&(staInfo->staScb->tei == *dataptr) )
1439   4                      {
1440   5                          //transmit the discover beacon
1441   5      #ifdef LG_WAR
                                  snsm->txDiscBcn = FALSE;
              #else
1444   5                          snsm->txDiscBcn = TRUE;
1445   5      #endif
1446   5                      }
1447   4                      break;
1448   4                  }
1449   3                  case BEHDR_BPSTO:
1450   3                  {
1451   4                      
1452   4      #ifdef HPGP_HAL
1453   4                      /* TODO: perform sync with the any net
1454   4                       * during the network discovery 
1455   4                       */
1456   4                      /* set it to MAC */
1457   4                  // Process other bcn also to sync network
1458   4                    //if((bcnsrc == BCN_SRC_CCO) || (bcnsrc == BCN_SRC_OTHER_CCO))
1459   4                    if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1460   4                          (bcnHdr->bt == BEACON_TYPE_PROXY))
1461   4                      {
1462   5                          sHpgpHalCB *hhalCb = HOMEPLUG_GetHal()->hhalCb;
1463   5                          memcpy(snsm->bpsto, dataptr, 3);
1464   5                          if ( HHAL_SyncNet(HOMEPLUG_GetHal(), snsm->bpsto) == STATUS_SUCCESS 
1465   5                            && !snsm->netSync )
1466   5                          {
1467   6                              /* stop scan if it is my network */
1468   6                              //HAL_ScanNet(FALSE);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 25  

1469   6      
1470   6                              
1471   6                              snsm->netSync = TRUE;                        
1472   6                              FM_HexDump(FM_MINFO, "SNSM:Setting netSync %bu\n", &snsm->bpsto, 1);                   
             -                                  
1473   6      
1474   6                              
1475   6      
1476   6                          }
1477   5                      
1478   5                          /*FIXME: Host App should select the network , during scanning.
1479   5                                           Selection could be based on Lqi/Rssi 
1480   5                                           Temporarily the selection is done here */        
1481   5                          if(snsm->netScan && !hhalCb->nwSelected)
1482   5                          {
1483   6                  // TODO FIX THIS
1484   6                  
1485   6                              if ((hhalCb->nwSelectedSnid == 0)  || 
1486   6                                  (hhalCb->nwSelectedSnid == snid))
1487   6                              {
1488   7                                  if(hhalCb->halStats.RxGoodBcnCnt >= syncThres ) 
1489   7                                  {                            
1490   8                                      HHAL_SetSnid(snid);
1491   8                                      FM_Printf(FM_MINFO, "SNSM:Setting STA Snid %bu\n", snid);                 
             -            
1492   8                                  }
1493   7                              }
1494   6                          }
1495   5                          
1496   5      
1497   5                      }
1498   4      #endif
1499   4                      
1500   4                      break;
1501   4                  }
1502   3                  case BEHDR_CCO_HANDOVER:
1503   3                  {
1504   4                      //FM_Printf(FM_HINFO, "SNSM: CCO HO (H).\n");
1505   4                      beHdrRef[BEHDR_CCO_HANDOVER] = beHdr;
1506   4                      break;
1507   4                  }
1508   3                  case BEHDR_BCN_RELOC:
1509   3                  {
1510   4                      beHdrRef[BEHDR_BCN_RELOC] = beHdr;
1511   4                      break;
1512   4                  }
1513   3                  case BEHDR_CHANGE_NUM_SLOTS:
1514   3                  {
1515   4                      beHdrRef[BEHDR_CHANGE_NUM_SLOTS] = beHdr;
1516   4                      break;
1517   4                  }
1518   3                  case BEHDR_CHANGE_SNID:
1519   3                  {
1520   4                      beHdrRef[BEHDR_CHANGE_SNID] = beHdr;
1521   4                      break;
1522   4                  }
1523   3                  case BEHDR_MAC_ADDR:
1524   3                  {
1525   4      #if 0       
                              u8 *macAddr;
                              macAddr = dataptr;
                              if( (bcnsrc == BCN_SRC_CCO)&& staInfo->ccoScb != NULL &&
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 26  

                                  (memcmp(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN)) )
                              {                    
                                  memcpy(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN);
                              }
              #endif               
1534   4                      break;
1535   4                  }
1536   3      #ifdef POWERSAVE
                          case BEHDR_PWR_SAVE:
                          {
                              if(staInfo->staScb)
                      {
                        pPsBentry = (sPowerSaveEntry *) dataptr;
                          if (pPsBentry->spsf == TRUE)
                        {
                          // CCO wants to disable PS in AVLN
                          hhalCb->psAvln = FALSE; // AVLN PS = OFF
              
              //                    FM_Printf(FM_MMSG, "CENTRAL BCN RX: staInfo=%p, staInfo->staScb=%p, staInfo->staScb->p
             -sState=%bu\n", 
              //              staInfo, staInfo->staScb, staInfo->staScb->psState);
                          if (staInfo->staScb->psState == PSM_PS_STATE_ON)
                          {
                            // if Stop SP Flag is set by CCO, STA is not required to send 
                            // a PS_EXIT.REQ.
                            // it just clears its PS mode
                            PSM_ForcePsOff(staInfo->staScb); 
              //              PSM_set_sta_PS(FALSE, 0xF);
                          }
                        }   
                        else
                        {         
                          hhalCb->psAvln = TRUE;  // AVLN PS = ON
                        }
                        staInfo->ccoScb->psState = ((pPsBentry->tpss & 0x0f) == 0x0f) ? PSM_PS_STATE_OFF:PSM_PS_STATE_ON;  
                        staInfo->ccoScb->pss = pPsBentry->tpss;
                        staInfo->staScb->bpCnt = pPsBentry->bpCnt_Lo + (pPsBentry->bpCnt_Hi << 8);
              /*
                        if (psDebug)
                          printf("SNSM_ProcBcnHigh: received bpCnt=%d, pssi=%bu\n", staInfo->staScb->bpCnt, staInfo->staScb->p
             -ssi);
              */
                        if (staInfo->staScb->pssi != pPsBentry->pssi)
                        {
                          // PS State of AVLN has changed
                          if (staInfo->staScb->psState != PSM_PS_STATE_WAITING_ON)
                          {
                            // if STA is waiting to enter PS mode, its AWD should be 0
                            staInfo->staScb->pssi = pPsBentry->pssi;
                            PSM_recalc_AW(DEV_MODE_STA);  // recalculate common Awake Window
                          }
                        }
              #ifdef DOTHIS
                        u8 numPsSta;
                        u8 *tmpDataPtr;
              
                        tmpDataPtr = dataptr + sizeof(sPowerSaveEntry);
                        numPsSta = (beHdr->beLen - sizeof(sPowerSaveEntry)) / 2;
                        for (i=0; i< numPsSta; i++)
                        {
              //            printf("numPsSta=%bu,beHdr->beLen=%bu, TEI=%bu, pss=0x%bx\n", numPsSta,  beHdr->beLen, tmpDataPtr[
             -i*2], tmpDataPtr[(i*2)+1]);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 27  

                        }
              #endif
              /*
                        if (psDebug)
                        {
                          u8 i;
                          u8 *tmpp = dataptr;
              
                          for (i=0;i<beHdr->beLen;i++)
                            printf("0x%bx ", tmpp[i]);
                          printf("\n"); 
                        }
              */
                      }
                      break;
                         }
              #endif
1605   3                  default:
1606   3                  {
1607   4                  }
1608   3              }
1609   2              //move to the next BEHDR
1610   2              dataptr = dataptr + beHdr->beLen; 
1611   2              beHdr = (sBeHdr *) dataptr;
1612   2              nbe--;
1613   2          }
1614   1      
1615   1          if(snsm->txDiscBcn)
1616   1          {
1617   2              if(SNSM_BuildDiscBcn(snsm, beHdrRef) != STATUS_SUCCESS)
1618   2              {
1619   3                  snsm->txDiscBcn = FALSE;
1620   3              }
1621   2          } 
1622   1      
1623   1      }
1624          
1625          void LINKL_StaProcBcnHandler(void *cookie, sEvent *event)
1626          {
1627   1          sLinkLayer     *linkl = (sLinkLayer *)cookie;
1628   1          sSnsm*         snsm = (sSnsm *)LINKL_GetSnsm(linkl);
1629   1          sHpgpHdr         *hpgpHdr = NULL;
1630   1      
1631   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1632   1      
1633   1          SNSM_ProcBcnHigh(snsm, event->buffDesc.dataptr, hpgpHdr->snid);
1634   1      
1635   1          if(snsm->txDiscBcn)
1636   1          {
1637   2              SNSM_TransmitDiscBcn(snsm);
1638   2              snsm->txDiscBcn = FALSE;
1639   2          }
1640   1      }
1641          
1642          
1643          eStatus SNSM_SendMgmtMsg(sSnsm *snsm, u16 mmType)
1644          {
1645   1          eStatus          status = STATUS_FAILURE;
1646   1          sEvent          *newEvent = NULL;
1647   1          sHpgpHdr        *hpgpHdr = NULL;
1648   1          sCmUaStaInd     *uaStaInfo = NULL;
1649   1          sCcDiscStaInfo  *ccDiscStaInfo = NULL;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 28  

1650   1          sCcDiscNetInfo  *ccDiscNetInfo = NULL;
1651   1          u8               numSta = 0;
1652   1          u8               numNet = 0;
1653   1          u8               i = 0;
1654   1          u16              eventSize = 0;
1655   1          u8              *dataptr = NULL;
1656   1          sScb            *staScb = NULL;
1657   1        sStaInfo        *staInfo = NULL;
1658   1      
1659   1        staInfo = snsm->staInfo;
1660   1        
1661   1          switch(mmType)
1662   1          {
1663   2              case EVENT_TYPE_CM_UNASSOC_STA_IND:
1664   2              {
1665   3                  //prepare CM_UNASSOCIATED_STA_IND
1666   3                  eventSize = MAX(sizeof(sCmUaStaInd), HPGP_DATA_PAYLOAD_MIN); 
1667   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
1668   3                  if(newEvent == NULL)
1669   3                  {
1670   4                      FM_Printf(FM_ERROR, "EAllocErr\n");
1671   4                      return STATUS_FAILURE;
1672   4                  }
1673   3                  FM_Printf(FM_MMSG, "SNSM:>>>CM_UNASSOC_STA.IND\n");
1674   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
1675   3                  newEvent->eventHdr.type = EVENT_TYPE_CM_UNASSOC_STA_IND;
1676   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff; 
1677   3                  hpgpHdr->tei = 0xFF;
1678   3                  hpgpHdr->mnbc = 1;
1679   3                  hpgpHdr->macAddr = bcAddr;
1680   3                  hpgpHdr->snid = snsm->staInfo->snid;
1681   3                  hpgpHdr->eks = HPGP_EKS_NONE;
1682   3      
1683   3                  uaStaInfo = (sCmUaStaInd *)newEvent->buffDesc.dataptr; 
1684   3                  memcpy(uaStaInfo->nid, snsm->staInfo->nid, NID_LEN);
1685   3                  uaStaInfo->ccoCap = snsm->staInfo->staCap.fields.ccoCap;
1686   3                  newEvent->buffDesc.datalen += eventSize;
1687   3      
1688   3                  break;
1689   3              }
1690   2              case EVENT_TYPE_CC_DISCOVER_LIST_CNF:
1691   2              {
1692   3                  staScb = snsm->staInfo->staScb;
1693   3                  numSta = staScb->numDiscSta;
1694   3                  numNet = staScb->numDiscNet;
1695   3                  eventSize = MAX(HPGP_DATA_PAYLOAD_MIN,
1697   3                                  2 + (u16)(numSta*sizeof(sCcDiscStaInfo)) + 
1697   3                                  (u16)(numNet*sizeof(sCcDiscNetInfo))); 
1698   3                  newEvent = EVENT_MgmtAlloc(eventSize, EVENT_HPGP_MSG_HEADROOM);
1699   3                  if(newEvent == NULL)
1700   3                  {
1701   4                      FM_Printf(FM_ERROR, "EAllocErr\n");
1702   4                      return STATUS_FAILURE;
1703   4                  }
1704   3                  FM_Printf(FM_MMSG, "SNSM:>>>CC_DISCOVER_LIST.CNF\n");
1705   3                  newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
1706   3                  newEvent->eventHdr.type = EVENT_TYPE_CC_DISCOVER_LIST_CNF;
1707   3      
1708   3                  hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff; 
1709   3                  hpgpHdr->tei = snsm->staInfo->ccoScb->tei;
1710   3                  hpgpHdr->macAddr = snsm->staInfo->ccoScb->macAddr; 
1711   3                  hpgpHdr->snid = snsm->staInfo->snid;      
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 29  

1712   3            hpgpHdr->eks = staInfo->nekEks;
1713   3            
1714   3                  dataptr = newEvent->buffDesc.dataptr; 
1715   3                  //station information
1716   3                  *dataptr = numSta;
1717   3                  dataptr++;
1718   3                  i = 0;
1719   3                  while(numSta && (i < DISC_STA_LIST_MAX))
1720   3                  {
1721   4                      if(staInfo->discStaInfo[i].valid)
1722   4                      { 
1723   5                          ccDiscStaInfo = (sCcDiscStaInfo *)dataptr;
1724   5                          memcpy(ccDiscStaInfo->macAddr, staInfo->discStaInfo[i].macAddr, 
1725   5                                 MAC_ADDR_LEN);
1726   5      
1727   5                          ccDiscStaInfo->tei = staInfo->discStaInfo[i].tei; 
1728   5                          ccDiscStaInfo->sameNet = staInfo->discStaInfo[i].sameNet; 
1729   5                          ccDiscStaInfo->snid = staInfo->discStaInfo[i].snid; 
1730   5                          ccDiscStaInfo->staCap.byte = staInfo->discStaInfo[i].staCap.byte; 
1731   5                          ccDiscStaInfo->sigLevel = 0;//staInfo->discStaInfo[i].sigLevel; 
1732   5                          ccDiscStaInfo->avgBle = 0;//staInfo->discStaInfo[i].avgBle; 
1733   5                          dataptr += sizeof(sCcDiscStaInfo);
1734   5                          newEvent->buffDesc.datalen +=sizeof(sCcDiscStaInfo); 
1735   5                          numSta--;
1736   5                      }
1737   4                      i++;
1738   4                  }
1739   3                  //network information
1740   3                  *dataptr = numNet;
1741   3                  dataptr++;
1742   3                  i = 0;
1743   3                  while(numNet && (i < DISC_NET_LIST_MAX))
1744   3                  {
1745   4                      if(staInfo->discNetInfo[i].valid)
1746   4                      { 
1747   5                          ccDiscNetInfo = (sCcDiscNetInfo *) dataptr;
1748   5                          memcpy(ccDiscNetInfo->nid, staInfo->discNetInfo[i].nid, 
1749   5                                 NID_LEN);
1750   5      
1751   5                          ccDiscNetInfo->snid = staInfo->discNetInfo[i].snid; 
1752   5                          ccDiscNetInfo->hybridMode = staInfo->discNetInfo[i].hybridMode; 
1753   5                          ccDiscNetInfo->numBcnSlots = staInfo->discNetInfo[i].numBcnSlots; 
1754   5                          ccDiscNetInfo->coordStatus = staInfo->discNetInfo[i].coordStatus; 
1755   5                          ccDiscNetInfo->offset = staInfo->discNetInfo[i].offset; 
1756   5                          dataptr += sizeof(sCcDiscNetInfo);
1757   5                          newEvent->buffDesc.datalen +=sizeof(sCcDiscNetInfo); 
1758   5                          numNet--;
1759   5                      }
1760   4                      i++;
1761   4                  }
1762   3      
1763   3                  newEvent->buffDesc.datalen = eventSize;
1764   3                                               
1765   3                  break;
1766   3              }
1767   2              default:
1768   2              {
1769   3                  return status;
1770   3              }
1771   2          }
1772   1          EVENT_Assert(newEvent);
1773   1          //transmit the mgmt msg
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 30  

1774   1          status =  MUXL_TransmitMgmtMsg(HPGPCTRL_GetLayer(HP_LAYER_TYPE_MUX), newEvent);
1775   1          //the event will be freed by MUXL if the TX is successful
1776   1          if(status == STATUS_FAILURE)
1777   1          {
1778   2              EVENT_Free(newEvent);
1779   2          }
1780   1          
1781   1          return status;
1782   1      }
1783          
1784          eStatus SNSM_DeliverEvent(sSnsm *snsm, u16 eventType)
1785          {
1786   1          sEvent       *newEvent = NULL;
1787   1          sLinkLayer   *linkl = snsm->linkl;
1788   1      
1789   1          newEvent = EVENT_Alloc(sizeof(snsm->staRole), 0);
1790   1          if(newEvent == NULL)
1791   1          {
1792   2              FM_Printf(FM_ERROR, "EAllocErr\n");
1793   2              return STATUS_FAILURE;
1794   2          }
1795   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
1796   1          newEvent->eventHdr.type = eventType;
1797   1      
1798   1          if(eventType == EVENT_TYPE_NET_DISC_IND)
1799   1          {
1800   2              *(newEvent->buffDesc.dataptr) = snsm->staRole;
1801   2              newEvent->buffDesc.datalen += sizeof(snsm->staRole);
1802   2          }
1803   1      
1804   1          //deliver the event to the upper layer
1805   1      #ifdef CALLBACK
                  linkl->deliverEvent(linkl->eventcookie, newEvent);
              #else
1808   1          CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
1809   1      #endif
1810   1      
1811   1          return STATUS_SUCCESS;
1812   1      }
1813          
1814          
1815          void SNSM_ProcEvent(sSnsm *snsm, sEvent *event)
1816          {
1817   1          sBcnHdr      *bcnHdr = NULL;
1818   1          u8            becomeCco = FALSE;
1819   1          u8            *bcn = NULL;
1820   1          u8            bcnsrc;
1821   1          u8            staType;
1822   1          sAvlnInfoRef  avlnInfoRef;
1823   1          sEvent       *newEvent = NULL;
1824   1          sHpgpHdr     *hpgpHdr = NULL;
1825   1          sCmUaStaInd  *uaStaInfo = NULL;
1826   1          sScb         *scb = NULL;
1827   1          sStaInfo     *staInfo = NULL; 
1828   1          sCrm         *crm = NULL;
1829   1          sSnam        *snam = NULL;
1830   1      //    sCnam        *cnam = NULL;
1831   1          sRxDesc      rxdesc;
1832   1      //    sLinkLayer   *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1833   1          sLinkLayer   *linkl = snsm->linkl;
1834   1          staInfo = LINKL_GetStaInfo(linkl); 
1835   1          crm = LINKL_GetCrm(linkl);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 31  

1836   1          snam = LINKL_GetSnam(linkl);
1837   1      
1838   1      
1839   1          switch(snsm->state)
1840   1          {
1841   2              
1842   2              case SNSM_STATE_INIT:
1843   2              {
1844   3                  
1845   3                  if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) &&
1846   3                      (event->eventHdr.type == EVENT_TYPE_SNSM_START) )
1847   3                  {
1848   4                  
1849   4                      staType = *(event->buffDesc.dataptr);           
1850   4                      switch(staType)
1851   4                      {
1852   5                          case LINKL_STA_TYPE_NETDISC:
1853   5                          {
1854   6                              
1855   6                              snsm->enableCcoSelection = 0;
1856   6                              snsm->enableCcoDetection = 1;
1857   6      #ifdef HPGP_HAL
1858   6                              /* set PhyClk */
1859   6                              //HHAL_SetDevMode(linkl->hal, DEV_MODE_CCO, LINE_MODE_DC);
1860   6                              
1861   6                              //Device should in STA mode during net discovery     
1862   6                              //HHAL_SetDevMode(linkl->hal, DEV_MODE_CCO,gHpgpHalCB.lineMode);
1863   6                              FM_Printf(FM_MINFO,"nsm :LINKL_STA_TYPE_NETDISC , Set sta\n");
1864   6      
1865   6                              /* start scan */
1866   6                              //HAL_ScanNet(TRUE);
1867   6      #endif
1868   6                              if(staInfo->lastUserAppCCOState != 2)
1869   6                              {
1870   7                                  STM_StartTimer(snsm->bbtTimer, HPGP_TIME_BBT);
1871   7                              }
1872   6                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
1873   6                              STM_StartTimer(snsm->discAgingTimer, 
1874   6                                             HPGP_TIME_DISC_AGING_UNASSOC);   
1875   6                              snsm->state = SNSM_STATE_NET_DISC;
1876   6                              break;
1877   6                          }
1878   5                          case LINKL_STA_TYPE_UNASSOC:
1879   5                          {
1880   6                              if(staInfo->lastUserAppCCOState == 0)
1881   6                              {
1882   7                                  snsm->enableCcoSelection = 1;
1883   7                              }
1884   6                              else
1885   6                              {
1886   7                                  snsm->enableCcoSelection = 0; // Joinnet - Only STA
1887   7                              }
1888   6                              snsm->enableCcoDetection = 1;
1889   6      #ifdef HPGP_HAL 
1890   6                              /* set PhyClk */
1891   6                              //HHAL_SetDevMode(linkl->hal, DEV_MODE_CCO, LINE_MODE_DC);                  
1892   6                              FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC\n");
1893   6      
1894   6                              /* start scan */
1895   6                             // HAL_ScanNet(TRUE);
1896   6      #endif
1897   6                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 32  

1898   6                              STM_StartTimer(snsm->discAgingTimer, 
1899   6                                           HPGP_TIME_DISC_AGING_UNASSOC);   
1900   6                              snsm->state = SNSM_STATE_NET_DISC;
1901   6                              break;
1902   6                          }
1903   5                          case LINKL_STA_TYPE_ASSOC:
1904   5                          {
1905   6                              FM_Printf(FM_MINFO, "SNSM:Start ASSOC STA\n");
1906   6                              snsm->enableCcoSelection = 0;
1907   6                              snsm->enableCcoDetection = 1;
1908   6                  
1909   6                  snsm->enableBcnLossDetection = 1;
1910   6                  STM_StopTimer(snsm->discAgingTimer);
1911   6                  
1912   6                              STM_StartTimer(snsm->discAgingTimer, 
1913   6                                             HPGP_TIME_DISC_AGING);  
1914   6      
1915   6                  STM_StartTimer(snsm->bcnLossTimer,
1916   6                                             HPGP_TIME_BEACON_LOSS);
1917   6                  
1918   6                              snsm->state = SNSM_STATE_CONN;
1919   6                              break;
1920   6                          }
1921   5      #ifdef UKE
                                  
                                  case LINKL_STA_TYPE_SC_JOIN:
                                  case LINKL_STA_TYPE_SC_ADD:
                                  {                      
                                       
                                      FM_Printf(FM_ERROR, "\n UKE:Push button\n   \
                                               in SNSM_STATE_INIT state\n");
                                          
                                  }
              #endif          
1932   5                          default:
1933   5                          {
1934   6                              FM_Printf(FM_WARN, "SNSM:unknown sta type(%d)\n", staType);
1935   6                          }
1936   5                      }
1937   4                  }
1938   3                  break;
1939   3              }
1940   2              case SNSM_STATE_NET_DISC:
1941   2              {
1942   3                  //perform network discovery procedure
1943   3                  if(event->eventHdr.eventClass == EVENT_CLASS_MSG)
1944   3                  {
1945   4                  u8 cco = 0;
1946   4                  switch(event->eventHdr.type)
1947   4                  {
1948   5      #ifdef UKE      
                              case EVENT_TYPE_CM_SC_JOIN_REQ: //UKE
                              {
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
                                      FM_Printf(FM_MMSG, "SNSM:<<<CM_SC_JOIN.REQ\n");
                                      // If associated
                                      if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                      {
                                          //  its assumed that is secMode == JOIN, then device is in sta mode
                                          // if(snsm->enableCcoSelection)
                                          {
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 33  

                                              //  perform CCO selection   
                                              becomeCco = SNSM_SelectCco(snsm,  event);
                                              // If CCO 
                                              if(becomeCco)
                                              {
              
                                                  SNSM_Stop(snsm);
                                                  
                                                  //(2) stop the SNAM
              
                                                  SNAM_Stop(snam);
                                                          
                                                  snsm->enableCcoSelection = 0;
                                                  snsm->enableCcoDetection = 0;
                                    snsm->netSync = FALSE;
                                    snsm->netScan  = FALSE;
              
                                                  
                                                  staInfo->secMode = SEC_MODE_SC_ADD;
                                                  //generateNmkAndNid(staInfo);
                                                  
                                                  
                                                  STM_StopTimer(snsm->usttTimer);
                                                  STM_StopTimer(snsm->discAgingTimer);
                                                  
                                              }
                                          }
                                      }else
                                          {
              
              
                                          }
                                     
                                      // If SC_ADD mode
                                      if(staInfo->secMode == SEC_MODE_SC_ADD)
                                      {
                                          //send SC_JOIN.CNF
                                          LINKL_SendMgmtMsg(snsm->staInfo, EVENT_TYPE_CM_SC_JOIN_CNF, 
                                                      ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                          
                                          // If CCO start beacon
                                          if(becomeCco)
                                          {
                                              //send event CCO_SEL_IND to the upper layer
              
                                              CNAM_EnableAssocNotification(&linkl->ccoNam,
                                                                  ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                              SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_SLCT_IND);
              
                                                  
                                          }
                                          
                                      }
                                      
                                  }
                                  break;
                              }
                              case EVENT_TYPE_CM_SC_JOIN_CNF: //UKE
                              {
                                  FM_Printf(FM_MMSG, "SNSM:<<<CM_SC_JOIN.CNF\n");
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 34  

                                      sCmJoinCnf *joinCnf;
              
                                      STM_StopTimer(snsm->bbtTimer);
              
                                      // Save NID
                                      joinCnf = (sCmJoinCnf *) event->buffDesc.dataptr;
                                      memcpy(staInfo->nid, joinCnf->nid, NID_LEN);
                                      
                                      FM_HexDump(FM_HINFO, "NID in JOIN CNF Frame", joinCnf->nid, NID_LEN);
              
                                      snsm->netSync = FALSE;
                                      
                                      gHpgpHalCB.halStats.RxGoodBcnCnt   = 0; // rajan  do we call scanNet here.
              
                                      snsm->netScan  = FALSE;
                                          
                                      snsm->enableCcoSelection = 1;
              
                                      snsm->enableCcoDetection = 1;                        
              
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                   
                                      // not needed as STA will look for nid match
                                      //memcpy(&linkl->akm.ukePeer,  hpgpHdr->macAddr, MAC_ADDR_LEN);
                                          
                                      STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
              
                                      STM_StartTimer(snsm->discAgingTimer, 
                                                       HPGP_TIME_DISC_AGING);
                                      // IMP NOTE: What abt staCap fields
                                  }
                                  break;
                              }
              #endif        
2056   5                          case EVENT_TYPE_CM_UNASSOC_STA_IND:
2057   5                          {   
2058   6                              FM_Printf(FM_MMSG, "SNSM:<<<CM_UNASSOC_STA.IND\n");
2059   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2060   6                              uaStaInfo = (sCmUaStaInd *) (event->buffDesc.dataptr);
2061   6                              SNSM_UpdateUaStaList(snsm, uaStaInfo, hpgpHdr->macAddr);
2062   6      
2063   6                              //CCo selection is performed 
2064   6                              //when the STA is unassociated STA
2065   6                  if(
2066   6      #ifdef UKE            
                                        (staInfo->secMode != SEC_MODE_SC_JOIN) &&
              #else
2069   6      
2070   6      #endif            
2071   6                                (snsm->enableCcoSelection))
2072   6                              {
2073   7                                  becomeCco = SNSM_SelectCco(snsm, event);
2074   7                                     
2075   7                                  if(becomeCco == TRUE)
2076   7                                  {
2077   8      #ifdef NSM_STA_PRINT              
                                              FM_Printf(FM_MINFO, "SNSM:Auto-selected CCo.Scan Off\n");
              #endif                
2080   8      #ifdef HPGP_HAL
2081   8                                      /* stop scan */
2082   8                                      HAL_ScanNet(FALSE);
2083   8      #endif
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 35  

2084   8                                      //(1) stop the SNSM
2085   8                                      STM_StopTimer(snsm->usttTimer);   
2086   8                                      STM_StopTimer(snsm->discAgingTimer);   
2087   8      
2088   8                                      snsm->enableCcoSelection = 0;
2089   8                                      snsm->enableCcoDetection = 0;
2090   8                      snsm->netSync = FALSE;
2091   8                      snsm->netScan  = FALSE;
2092   8                                      snsm->state = SNSM_STATE_INIT;
2093   8                                      //(2) stop the SNAM
2094   8                                      SNAM_Stop(snam);
2095   8                                      //send event CCO_SEL_IND to the upper layer
2096   8                                      SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_SLCT_IND);
2097   8                                       
2098   8                                  }
2099   7                              }
2100   6                              break;                    
2101   6                          }
2102   5                          default:
2103   5                          {
2104   6                          }
2105   5                      }
2106   4                  }
2107   3                  else //control event
2108   3                  {
2109   4                      switch(event->eventHdr.type)
2110   4                      {
2111   5                          case EVENT_TYPE_SNSM_START:
2112   5                          {
2113   6                              staType = *(event->buffDesc.dataptr);           
2114   6                              switch (staType)
2115   6                              {
2116   7                                  case LINKL_STA_TYPE_UNASSOC:
2117   7                                  {
2118   8                                      if(!snsm->netSync && !snsm->netScan)
2119   8                                      {
2120   9                                      //TODO:does it occur now?
2121   9                                      if(staInfo->lastUserAppCCOState == 0)
2122   9                                      {
2123  10                                          snsm->enableCcoSelection = 1;
2124  10                                      }
2125   9                                      else
2126   9                                      {
2127  10                                          snsm->enableCcoSelection = 0; //  Only STA
2128  10                                      }
2129   9                                      snsm->enableCcoDetection = 1;
2130   9      #ifdef HPGP_HAL
2131   9                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC 2\n");
2132   9                                      /* TODO: Set PhyClk in HW */
2133   9                                      //HHAL_SetDevMode(linkl->hal, 
2134   9                                      //    DEV_MODE_CCO, LINE_MODE_DC);
2135   9                                      //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, gHpgpHalCB.lineMode);
2136   9                                      /* start scan */
2137   9                                      //HAL_ScanNet(TRUE);
2138   9      #endif
2139   9                                      /* these timers have started in the init state
2140   9                       * thus not need to start the timers again here
2141   9                       */
2142   9                          //          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
2143   9                          //          STM_StartTimer(snsm->discAgingTimer, 
2144   9                          //                         HPGP_TIME_DISC_AGING);   
2145   9                          
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 36  

2146   9                                      //stay in the net disc state
2147   9                                        STM_StopTimer(snsm->discAgingTimer);
2148   9                  
2149   9                                    STM_StartTimer(snsm->discAgingTimer, 
2150   9                                                 HPGP_TIME_DISC_AGING_UNASSOC);
2151   9                  
2152   9                                      }
2153   8                                      break;
2154   8                                  }
2155   7                                  case LINKL_STA_TYPE_ASSOC:
2156   7                                  {
2157   8      #ifdef HPGP_HAL
2158   8                                      /* stop scan */
2159   8                                      HAL_ScanNet(FALSE);
2160   8                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_ASSOC\n");
2161   8      #endif
2162   8                                      //it occurs after the STA discover
2163   8                                      //the CCo during the network discovery
2164   8                                      //and unassoicated STA
2165   8                                      STM_StopTimer(snsm->usttTimer);   
2166   8                                      snsm->enableCcoSelection = 0;
2167   8                                      snsm->enableCcoDetection = 0;
2168   8                      
2169   8                      snsm->enableBcnLossDetection = 1;
2170   8                                      snsm->state = SNSM_STATE_CONN;
2171   8                      STM_StopTimer(snsm->discAgingTimer);
2172   8                    
2173   8                      STM_StopTimer(snsm->bcnLossTimer);
2174   8                      
2175   8                      STM_StartTimer(snsm->discAgingTimer, 
2176   8                              HPGP_TIME_DISC_AGING);  
2177   8      
2178   8      
2179   8                      STM_StartTimer(snsm->bcnLossTimer, 
2180   8                              HPGP_TIME_BEACON_LOSS);
2181   8                      
2182   8      
2183   8                                  break;
2184   8                              }
2185   7      #ifdef UKE            
                                      case LINKL_STA_TYPE_SC_JOIN:
                                      {
              
                                          FM_Printf(FM_ERROR , "LINKL_STA_TYPE_SC_JOIN\n");
                                          
                                          STM_StopTimer(snsm->discAgingTimer);   
                                          STM_StopTimer(snsm->bbtTimer);
                                          STM_StopTimer(snsm->usttTimer);
                                         if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                          {
                                              // If n/w discovery is on then Stop discovery
                                              // Is associated
                                              // if yes then leave n/w and wait for LEAVE RSP
                                              //  
                                              STM_StartTimer(snsm->bbtTimer, HPGP_TIME_BBT);
                                              STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
              
                                              snsm->enableCcoSelection = 0;
                                              snsm->enableCcoDetection = 0;
                                              
                                              FM_Printf(FM_ERROR, "SNSM:SEC_MODE_SC_JOIN\n");
                                          }                        
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 37  

                                          else
                                          {
                                              FM_Printf(FM_ERROR, "SNSM:SEC_MODE_SC or HS\n");
                                          }
                                              break;
                                          }
              #endif              
2215   7                                  default:
2216   7                                  {
2217   8                                  }
2218   7                              }
2219   6                              break;
2220   6                          }
2221   5      
2222   5                          case EVENT_TYPE_SNSM_STOP:
2223   5                          {
2224   6                              //it happens when the STA becomes the CCo after
2225   6                              //network discovery
2226   6                              STM_StopTimer(snsm->usttTimer);   
2227   6                              STM_StopTimer(snsm->bbtTimer);
2228   6                              STM_StopTimer(snsm->discAgingTimer);   
2229   6      
2230   6                              snsm->enableCcoSelection = 0;
2231   6                              snsm->enableCcoDetection = 0;
2232   6                  snsm->netSync = FALSE;
2233   6                  snsm->netScan = FALSE;
2234   6                              HAL_ScanNet(FALSE);
2235   6                              snsm->state = SNSM_STATE_INIT;
2236   6                              break;
2237   6                          }
2238   5      
2239   5                          case EVENT_TYPE_TIMER_BBT_IND:
2240   5                          
2241   5      #ifdef UKE          
                                  if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                  {
                                      FM_Printf(FM_ERROR, "nsm:BBT Exp\n");
                                      staInfo->secMode = SEC_MODE_SC;
              
                      //                                              SNSM_DeliverEvent(snsm, EVENT_TYPE_RESTART_IND);
              
                                      snsm->enableCcoSelection = 1;
                                      snsm->enableCcoDetection = 1;
                                                  
              #ifdef NSM_STA_PRINT
                                      FM_Printf(FM_MINFO,"nsm:LINKL_STA_TYPE_UNASSOC From JOIN State\n");
              #endif
                                      STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);
              
                                      STM_StartTimer(snsm->discAgingTimer, 
                                               HPGP_TIME_DISC_AGING_UNASSOC);
                                      
                                  }
                                  else
              #endif          
2263   5                          {
2264   6                              snsm->staRole = SNSM_DetermineStaRole(snsm);
2265   6                              if( (snsm->staRole == STA_ROLE_ACCO) ||
2266   6                                  (snsm->staRole == STA_ROLE_UCCO) )
2267   6                              {
2268   7                                  //the STA becomes the CCo after network discovery
2269   7      #ifdef HPGP_HAL
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 38  

2270   7                                  /* stop scan */
2271   7                                  //HAL_ScanNet(FALSE);
2272   7                                  FM_Printf(FM_MINFO, "nsm:BBT Exp\n");
2273   7      #endif
2274   7                                  //(1) stop the SNSM
2275   7                                  STM_StopTimer(snsm->usttTimer);
2276   7                                  STM_StopTimer(snsm->discAgingTimer);
2277   7      
2278   7                                  snsm->enableCcoSelection = 0;
2279   7                                  snsm->enableCcoDetection = 0;
2280   7                                  //(2) stop the SNAM
2281   7                                  snsm->netSync = FALSE;
2282   7                                  snsm->netScan = FALSE;
2283   7      
2284   7                                  LINKL_StopSta(linkl);
2285   7      
2286   7                                  snsm->state = SNSM_STATE_INIT;
2287   7                              }
2288   6                              SNSM_DeliverEvent(snsm, EVENT_TYPE_NET_DISC_IND);
2289   6                              break;
2290   6                          }
2291   5                          case EVENT_TYPE_CC_BCN_IND:
2292   5                          {
2293   6                             // FM_Printf(FM_MINFO, "BCN\n");
2294   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2295   6                              bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
2296   6                              //CCO detetection is performed when the STA is
2297   6                              //in network discovery or unassociated STA
2298   6                              bcnsrc = SNSM_DetectCco(snsm, bcnHdr); 
2299   6                              switch(bcnsrc)
2300   6                              {
2301   7                                  case BCN_SRC_CCO:
2302   7                                  {
2303   8                                      /* find my CCo */
2304   8                                      /* save the snid from CCO */
2305   8                                      staInfo->snid = hpgpHdr->snid;
2306   8                      /* stop the timer as no need to 
2307   8                       * transmit the UNASSOCIATED_STA.IND
2308   8                       */
2309   8                      STM_StopTimer(snsm->usttTimer);   
2310   8                                      STM_StopTimer(snsm->bbtTimer);
2311   8                                      
2312   8                                      if ((gHpgpHalCB.nwSelected) && 
2313   8                        (gHpgpHalCB.snid != staInfo->snid))
2314   8                      {
2315   9      
2316   9                        FM_Printf(FM_MINFO,"switch sync to snid %bu\n", staInfo->snid);
2317   9      
2318   9                        snsm->netSync = FALSE;
2319   9                        
2320   9                        gHpgpHalCB.nwSelected = 0;
2321   9       
2322   9                        gHpgpHalCB.nwSelectedSnid = staInfo->snid;
2323   9      
2324   9                        snsm->netScan = FALSE;
2325   9                        
2326   9                        
2327   9                      }
2328   8                                      if (snsm->netSync == TRUE)
2329   8                      {
2330   9                                      if((snsm->enableCcoDetection)
2331   9      #ifdef FREQ_DETECT
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 39  

2332   9                                         && (gHpgpHalCB.gFreqCB.freqDetected == TRUE)
2333   9      #endif
2334   9                                          )
2335   9                                      {
2336  10      #ifdef HPGP_HAL
2337  10                                          /* stop scan */
2338  10                                      //FM_Printf(FM_MINFO,"nsm : enableCcoDetection , Scan OFF\n");
2339  10                        
2340  10                                          //HAL_ScanNet(FALSE);
2341  10                                          //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, LINE_MODE_DC);
2342  10      #endif
2343  10                                          snsm->enableCcoDetection = 0;
2344  10                                          //send event CCO_DISC_IND to the ctrl
2345  10                                          SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_DISC_IND);
2346  10                                      }
2347   9                      }
2348   8                      else if(!snsm->netScan)
2349   8                      {
2350   9                          /* since the device has found the CCo, it does not need to
2351   9                         * send an UNASSOCIATED_STA.IND. Thus, 
2352   9                         * (1) change back to the STA
2353   9                         * (2) start scanning to sync with the CCo. 
2354   9                         * Note: when the device is set to scan, it performs Rx only 
2355   9                         *       cannot transmit a message.
2356   9                         */
2357   9                         
2358   9                                         FM_Printf(FM_MINFO,"nsm:BCN_SRC_CCO\n");
2359   9                         
2360   9                          //HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, LINE_MODE_DC);
2361   9                                          HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, 
2362   9                                                  gHpgpHalCB.lineMode);
2363   9                          /* start scan for sync */
2364   9                        HAL_ScanNet(TRUE);
2365   9                                          snsm->netScan = TRUE;
2366   9                      }
2367   8                                      break;
2368   8                                  }
2369   7                                  case BCN_SRC_OTHER_CCO:
2370   7                                  {
2371   8       
2372   8       //                               hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2373   8                                      avlnInfoRef.nid = bcnHdr->nid;
2374   8                                      avlnInfoRef.snid = hpgpHdr->snid;
2375   8                                      // If other beacon detected scan network. 
2376   8                                     if(!snsm->netScan)
2377   8                       {
2378   9                                          staInfo->snid = hpgpHdr->snid;
2379   9                          HHAL_SetDevMode(linkl->hal, DEV_MODE_STA, 
2380   9                                gHpgpHalCB.lineMode);
2381   9                                          HAL_ScanNet(TRUE);
2382   9                                          snsm->netScan = TRUE;
2383   9                                      }
2384   8                 
2385   8                                      //update the AVLN list
2386   8                                      SNSM_UpdateAvlnList(snsm, &avlnInfoRef); 
2387   8                                      //select PhyClk from AVLN list. 
2388   8                                      //todo: How to get the PhyClk?
2389   8                                      break;     
2390   8                                  }
2391   7                                  default:
2392   7                                  {
2393   8                                  }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 40  

2394   7                              }
2395   6                              break;                    
2396   6                          }
2397   5                          case EVENT_TYPE_TIMER_USTT_IND:
2398   5                          {
2399   6                              //check AVLN list
2400   6                              if((snsm->numAvln) && (snsm->netSync))
2401   6                            {
2402   7      #ifdef UKE          
                                        if(staInfo->secMode == SEC_MODE_SC_JOIN)
                                            
                                        {
                                            LINKL_SendMgmtMsg(snsm->staInfo,
                                         EVENT_TYPE_CM_SC_JOIN_REQ,
                                         NULL);
              
                                      }
                                      //check AVLN list
                                      else
              #endif            
2414   7                              {
2415   8                                  //select the phyclk from the AVLN list
2416   8                                  //set the phyclk in the MAC
2417   8      
2418   8                                    SNSM_SendMgmtMsg(snsm, 
2419   8                                             EVENT_TYPE_CM_UNASSOC_STA_IND);
2420   8                                }
2421   7      
2422   7                            }
2423   6                  else
2424   6                  {
2425   7                    if(snsm->enableCcoSelection == 1)
2426   7                    {          
2427   8                      if(snsm->numAvln == 0)
2428   8                      {
2429   9                      // No avln become unassociated CCO
2430   9                      snsm->staRole = STA_ROLE_UCCO;
2431   9                      // stop ustt timer
2432   9                      STM_StopTimer(snsm->usttTimer);
2433   9                    
2434   9                      snsm->enableCcoSelection = 0;
2435   9                      snsm->enableCcoDetection = 0;
2436   9                    
2437   9                      snsm->netSync = FALSE;
2438   9                      snsm->netScan = FALSE;
2439   9                      snsm->state = SNSM_STATE_INIT;
2440   9                    
2441   9                      HAL_ScanNet(FALSE);
2442   9                    
2443   9                      LINKL_StopSta(linkl);
2444   9                    
2445   9                      snsm->state = SNSM_STATE_INIT;
2446   9                    
2447   9                      SNSM_DeliverEvent(snsm, EVENT_TYPE_UCCO_IND);
2448   9                      break;                  
2449   9                    
2450   9                      }
2451   8                    }
2452   7      
2453   7                          }
2454   6                          //start the USTT timer again
2455   6                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 41  

2456   6                          break;
2457   6                      }
2458   5                      case EVENT_TYPE_TIMER_DISC_AGING_IND:
2459   5                      {
2460   6                          SNSM_PerformAging(snsm);
2461   6                    // If no avln then become unassoc CCO
2462   6                    //If device is in USTA state and no avln found then become UCCO
2463   6      
2464   6                              //Using enableCcoSelection to know that we are in USTA mode
2465   6                  if(snsm->enableCcoSelection == 1)
2466   6                              {                  
2467   7                                  if(snsm->numAvln == 0)
2468   7                                  {
2469   8                                      // No avln become unassociated CCO
2470   8                                      snsm->staRole = STA_ROLE_UCCO;
2471   8                                      // stop ustt timer
2472   8                                      STM_StopTimer(snsm->usttTimer);
2473   8                                      
2474   8                                      snsm->enableCcoSelection = 0;
2475   8                                      snsm->enableCcoDetection = 0;
2476   8      
2477   8                                      snsm->netSync = FALSE;
2478   8                                      snsm->netScan = FALSE;
2479   8                                      snsm->state = SNSM_STATE_INIT;
2480   8      
2481   8                          HAL_ScanNet(FALSE);
2482   8      
2483   8                          LINKL_StopSta(linkl);
2484   8      
2485   8                                      snsm->state = SNSM_STATE_INIT;
2486   8      
2487   8                                      SNSM_DeliverEvent(snsm, EVENT_TYPE_UCCO_IND);
2488   8                                      break;                                
2489   8      
2490   8                                  }
2491   7                              }
2492   6                              //restart the aging timer
2493   6                              STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING_UNASSOC);   
2494   6                      
2495   6                      
2496   6                              break;
2497   6                          }
2498   5                          default:
2499   5                          {
2500   6                          }
2501   5                      }
2502   4                  }
2503   3                  break;
2504   3              }
2505   2              case SNSM_STATE_CONN:
2506   2              {
2507   3                  if(event->eventHdr.eventClass == EVENT_CLASS_MSG)
2508   3                  {
2509   4                      switch(event->eventHdr.type)
2510   4                      {
2511   5                         case EVENT_TYPE_CM_UNASSOC_STA_IND:
2512   5                          {   
2513   6                              FM_Printf(FM_MMSG, "SNSM:<<<CM_UNASSOC_STA.IND\n");
2514   6      
2515   6                  break;
2516   6                         }
2517   5                          case EVENT_TYPE_CC_DISCOVER_LIST_REQ:
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 42  

2518   5                          {
2519   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2520   6      #ifdef P8051
2521   6                 FM_Printf(FM_MMSG, "SNSM:<<<CC_DISCOVER_LIST.REQ(tei: %bu)\n",
2522   6                                     hpgpHdr->tei);
2523   6      #else
                         FM_Printf(FM_MMSG, "SNSM:<<<CC_DISCOVER_LIST.REQ(tei: %d)\n",
                                             hpgpHdr->tei);
              #endif
2527   6                              staInfo->staScb->discUpdate = 0;
2528   6                              SNSM_SendMgmtMsg(snsm, EVENT_TYPE_CC_DISCOVER_LIST_CNF);
2529   6                              break;
2530   6                          }
2531   5      #ifdef UKE          
                              case EVENT_TYPE_CM_SC_JOIN_REQ:                    
                              {
                                  if(staInfo->secMode == SEC_MODE_SC_ADD)
                                  {
                                  
                                      FM_Printf(FM_MINFO, "SNSM:<<<CM_SC_JOIN.REQ\n");
              
                                      if ((!snam->ukePeerNotification) ||
                                          (!memcmp(&((sHpgpHdr*)(event->buffDesc.buff))->macAddr,
                                                     snam->ukePeer, MAC_ADDR_LEN)))
                                      {
                                         LINKL_SendMgmtMsg(snsm->staInfo, EVENT_TYPE_CM_SC_JOIN_CNF, 
                                                      ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                        
                                         SNAM_EnableAssocNtf(snam, 
                                                             ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                         
              
                                     }
                                 }
                                 break;
                              } 
              #endif
2555   5                          
2556   5      #ifdef ROUTE
                                  case EVENT_TYPE_CM_ROUTE_INFO_REQ:
                                  {
                                      ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_CNF, event);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_CNF:
                                  {
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_IND:
                                  {
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_UNREACHABLE_IND:
                                  {
                                      u32 *unreachableNtb = event->buffDesc.dataptr;
                                      hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 43  

                                      ROUTE_procUnreachableInd(&event->buffDesc.dataptr[5], 
                                          event->buffDesc.dataptr[4], hpgpHdr->tei, (u32)*event->buffDesc.dataptr);
                                      break;
                                  }
              #endif // ROUTE
2583   5                          default:
2584   5                          {
2585   6                          }
2586   5                      }
2587   4                  }
2588   3                  else //control event
2589   3                  {
2590   4                      switch(event->eventHdr.type)
2591   4                      {
2592   5      
2593   5                case EVENT_TYPE_BCN_MISS_IND:
2594   5                {
2595   6      
2596   6                  FM_Printf(FM_HINFO, "bcn miss\n");
2597   6      //            SNSM_HandleBcnLoss(snsm, event);
2598   6                  break;
2599   6                }
2600   5                          case EVENT_TYPE_CC_BCN_IND:
2601   5                          {
2602   6      //                        FM_Printf(FM_MINFO, "SNSM: <<< BEACON.\n");
2603   6                              //perform the STA discovery procedure
2604   6                              //perform network discovery procedure
2605   6      
2606   6                              hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2607   6                              rxdesc.snid = hpgpHdr->snid;  
2608   6                              bcn = event->buffDesc.dataptr;
2609   6                 
2610   6      //                        LINKL_BcnRxHandler(linkl, &rxdesc, bcnHdr);
2611   6      //FM_HexDump(FM_DATA, "SNSM Rx beacon:", bcn, event->buffDesc.datalen);
2612   6                              SNSM_ProcBcnLow(snsm, &rxdesc, bcn);
2613   6      //                        SNSM_ProcBcn(snsm, event);
2614   6      
2615   6                              switch(snsm->hoSwitch)
2616   6                              {
2617   7                                  case HPGP_HO_SWITCH_CCO:
2618   7                                  {
2619   8                                      FM_Printf(FM_HINFO, "SNSM:become CCo\n");
2620   8                                  
2621   8                                      staInfo->ccoScb->staStatus.fields.apptCcoStatus = 0;
2622   8      
2623   8                                      //perform handover switch to the CCo role
2624   8                                      //CRM has all SCBs for each STA from the  
2625   8                                      //CC_HANDOVER_INFO.IND,
2626   8      
2627   8                                      staInfo->ccoScb = staInfo->staScb; 
2628   8                                      staInfo->ccoScb->staCap.fields.ccoStatus = 1;
2629   8      
2630   8                                      //SNAM_PerformHoSwitch(snam);
2631   8                                      SNAM_Stop(snam);
2632   8      
2633   8                                      //the following function is moved 
2634   8                                      //to the CNAM_START when the CCo starts
2635   8                                      //start the tei timer for each STA
2636   8                                      //cnam = LINKL_GetCnam(linkl);
2637   8                                      //CNAM_PerformHoSwitch(cnam);
2638   8                                      
2639   8                                      //deliver the event to the upper layer
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 44  

2640   8                                      SNSM_DeliverEvent(snsm, EVENT_TYPE_CCO_HO_IND);
2641   8      
2642   8                                      //Stop SNSM
2643   8                                      STM_StopTimer(snsm->usttTimer);
2644   8                                      STM_StopTimer(snsm->discAgingTimer); 
2645   8                                      STM_StopTimer(snsm->bcnLossTimer);
2646   8                      
2647   8                                      snsm->enableCcoSelection = 0;
2648   8                                      snsm->enableCcoDetection = 0;
2649   8                                      snsm->state = SNSM_STATE_INIT;
2650   8                                      break;
2651   8                                  }
2652   7                                  case HPGP_HO_SWITCH_STA: //switch to the third STA
2653   7                                  {
2654   8      
2655   8                                      scb = CRM_AddScb(crm, snsm->nctei);
2656   8                                      //scb = CRM_GetScb(crm, snsm->nctei);
2657   8                                      if(scb == NULL)
2658   8                                      {
2659   9                                          FM_Printf(FM_ERROR, "SNSM:Can't alloc scb for CCo\n");
2660   9                                          break;
2661   9                                      }
2662   8                                      
2663   8                                      scb->staCap.fields.ccoStatus = 1;
2664   8                                      staInfo->ccoScb = scb; 
2665   8      #ifdef NSM_STA_PRINT                
              #ifdef P8051
                             FM_Printf(FM_HINFO, "SNSM:switch to the new CCo(tei: %bu)\n",
                                                 scb->tei);
              #else
                             FM_Printf(FM_HINFO, "SNSM:switch to the new CCo(tei: %d)\n",
                                                 scb->tei);
              #endif
              #endif
2674   8                                      //for the handover, new CCo MAC address may be 
2675   8                                      //known from the CCO_SET_TEI_MAP.IND
2676   8                                      //otherwise , we may have a trouble in
2677   8                                      //sending CC_ASSOC.REQ for TEI renew.
2678   8                                      //Thus, we set HW MAC route table here for CCo`
2679   8      #ifdef SIMU
                                              SHAL_AddMacAddrToPortMap(
                                                  HOMEPLUG_GetHal()->shal,
                                                  scb->macAddr, 
                                                  scb->tei);
              #else
2685   8                                      /* set the TEI in the data plane */
2686   8      
2687   8      #endif
2688   8                                      snsm->enableCcoDetection = 1;
2689   8      
2690   8      
2691   8                                      break;
2692   8                                  }
2693   7                                  default:
2694   7                                  {
2695   8                                  }
2696   7                              }
2697   6                              snsm->hoSwitch = HPGP_HO_SWITCH_NONE;
2698   6      
2699   6                              if(snsm->ccoDetected)
2700   6                              {
2701   7                                  //send the event to the SNAM to renew the TEI
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 45  

2702   7                                  newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 
2703   7                                                         EVENT_HPGP_CTRL_HEADROOM);
2704   7                                  if(newEvent == NULL)
2705   7                                  {
2706   8                                      FM_Printf(FM_ERROR, "EAllocErr\n");
2707   8                                      break;
2708   8                                  }
2709   7                                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
2710   7                                  newEvent->eventHdr.type = EVENT_TYPE_CCO_DISC_IND;
2711   7                                  //send the event to the SNAM
2712   7                                  //LINKL_SendEvent(linkl, newEvent);
2713   7                                  SLIST_Put(&linkl->intEventQueue, &newEvent->link);
2714   7                                  snsm->ccoDetected = 0;
2715   7                              }
2716   6                              break;
2717   6                          }
2718   5      
2719   5                case EVENT_TYPE_TIMER_BEACON_LOSS_IND:
2720   5                {
2721   6      
2722   6                    //NOTE: noBcn is reset 
2723   6                              //after the central beacon is received
2724   6                              snsm->noBcn++; 
2725   6      #ifdef UM
2726   6      
2727   6                  if (snsm->noBcn == MAX_NO_BEACON_NW_DISCOVERY)
2728   6                  {
2729   7      
2730   7                    
2731   7                      HHAL_SetSWStatReqScanFlag(REG_FLAG_CLR);
2732   7                    
2733   7                  // if(staInfo->lastUserAppCCOState == 0)
2734   7                    {
2735   8      
2736   8                    //printf("\n MAX_NO_BEACON\n");
2737   8                    //LINKL_SendBcnLossInd(MAX_NO_BEACON_NW_DISCOVERY);
2738   8                    //                FM_Printf(FM_ERROR,"n/w discloss");
2739   8                    snsm->noBcn= 0;
2740   8      #ifdef LOG_FLASH
                            logEvent(ISM_ERROR, BCN_LOSS, EVENT_TYPE_BCN_MISS_IND, NULL, 0);
              #endif
2743   8                    SNSM_HandleBcnLoss(snsm, MAX_NO_BEACON_NW_DISCOVERY);
2744   8      
2745   8                    }
2746   7                  //Host_SendIndication(HOST_EVENT_BCN_LOSS, NULL, 0);
2747   7                  }
2748   6                  else if(snsm->noBcn  == MAX_NO_BEACON_BACKUPCCO)
2749   6                  {
2750   7      
2751   7                    //if(staInfo->lastUserAppCCOState == 0)
2752   7                    {
2753   8                    //LINKL_SendBcnLossInd(MAX_NO_BEACON_BACKUPCCO);
2754   8                    SNSM_HandleBcnLoss(snsm, MAX_NO_BEACON_BACKUPCCO);
2755   8      
2756   8                    }
2757   7                    //Host_SendIndication(HOST_EVENT_PRE_BCN_LOSS, NULL, 0);
2758   7                  }
2759   6      
2760   6      #endif          
2761   6      
2762   6      
2763   6                              STM_StartTimer(snsm->bcnLossTimer, HPGP_TIME_BEACON_LOSS);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 46  

2764   6      
2765   6                  }
2766   5      
2767   5                  break;
2768   5                  
2769   5                          case EVENT_TYPE_TIMER_DISC_AGING_IND:
2770   5                          {
2771   6                              //SNSM_PerformAging(snsm);
2772   6                              scb = snsm->staInfo->staScb;
2773   6      #ifdef DISC_BCN           
2774   6                              SCB_AgeDiscLists(scb);
2775   6      #endif
2776   6                            
2777   6                              //restart the aging timer
2778   6                              STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
2779   6                              break;
2780   6                          }
2781   5                          case EVENT_TYPE_SNSM_STOP:
2782   5                          {
2783   6                              //this happens when the STA leaves the network
2784   6                              STM_StopTimer(snsm->usttTimer);   
2785   6                              STM_StopTimer(snsm->discAgingTimer);   
2786   6      
2787   6                              STM_StopTimer(snsm->bcnLossTimer);
2788   6      
2789   6                              snsm->enableCcoSelection = 0;
2790   6                              snsm->enableCcoDetection = 0;
2791   6                  snsm->netSync = FALSE;
2792   6                  snsm->netScan = FALSE;
2793   6                              snsm->state = SNSM_STATE_INIT;
2794   6                              break;
2795   6                          } 
2796   5                          
2797   5      #ifdef ROUTE
                                  case EVENT_TYPE_ROUTE_UPDATE_TIMEOUT:
                                  {
                                      ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_IND, NULL);
                                      ROUTE_startUpdateTimer();
                                      break;
                                  }
                                  case EVENT_TYPE_ROUTE_HD_DURATION_TIMEOUT:
                                  {
                                      ROUTE_procHdDurationTimeout();
                                      break;
                                  }
              #endif // ROUTE
2810   5                          default:
2811   5                          {
2812   6                              
2813   6                              FM_Printf(FM_HINFO, "SNSM state connect %bu\n",event->eventHdr.type);
2814   6                          }
2815   5                      }
2816   4                  }
2817   3                  break;
2818   3              }
2819   2              default: //SNSM_STATE_INIT
2820   2              {
2821   3                  FM_Printf(FM_HINFO, "SNSM state %bu\n",snsm->state);
2822   3                  //perform no operation
2823   3              }
2824   2          }
2825   1      }
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 47  

2826          
2827          
2828          
2829          eStatus SNSM_Init(sSnsm *snsm, sLinkLayer *linkl)
2830          {
2831   1          //sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2832   1          
2833   1          snsm->linkl = linkl;
2834   1          snsm->staInfo = LINKL_GetStaInfo(linkl);
2835   1          snsm->crm = LINKL_GetCrm(linkl);
2836   1      
2837   1          snsm->state = SNSM_STATE_INIT;
2838   1          snsm->staRole = STA_ROLE_UNKNOWN;
2839   1          snsm->nctei = 0;
2840   1          snsm->hoEnabled = 0;
2841   1          snsm->discUpdate = 0;
2842   1          snsm->txDiscBcn = FALSE;
2843   1        snsm->netSync = FALSE;
2844   1        snsm->netScan = FALSE;
2845   1      
2846   1          snsm->hoSwitch = HPGP_HO_SWITCH_NONE;
2847   1      
2848   1        snsm->bcnLossTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
2849   1                                  EVENT_TYPE_TIMER_BEACON_LOSS_IND, linkl);
2850   1      
2851   1      
2852   1      
2853   1      #ifdef CALLBACK
                  snsm->bbtTimer = STM_AllocTimer(LINKL_TimerHandler,
                                       EVENT_TYPE_TIMER_BBT_IND, linkl);
              #else
2857   1          snsm->bbtTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK, 
2858   1                               EVENT_TYPE_TIMER_BBT_IND, linkl);
2859   1      #endif
2860   1          if(snsm->bbtTimer == STM_TIMER_INVALID_ID)
2861   1          {
2862   2              return STATUS_FAILURE;
2863   2          }
2864   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:bbt timer id:%bu\n", snsm->bbtTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:bbt timer id:%d\n", snsm->bbtTimer);
              #endif
              #endif
2871   1      
2872   1      #ifdef CALLBACK
                  snsm->usttTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                        EVENT_TYPE_TIMER_USTT_IND, linkl);
              #else
2876   1          snsm->usttTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
2877   1                                EVENT_TYPE_TIMER_USTT_IND, linkl);
2878   1      #endif
2879   1          if(snsm->usttTimer == STM_TIMER_INVALID_ID)
2880   1          {
2881   2              return STATUS_FAILURE;
2882   2          }
2883   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:ustt timer id: %bu\n", snsm->usttTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:ustt timer id: %d\n", snsm->usttTimer);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 48  

              #endif
              #endif
2890   1      
2891   1      #ifdef CALLBACK
                  snsm->discAgingTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                             EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
              #else
2895   1          snsm->discAgingTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
2896   1                                     EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
2897   1      #endif
2898   1          if(snsm->discAgingTimer == STM_TIMER_INVALID_ID)
2899   1          {
2900   2              return STATUS_FAILURE;
2901   2          }
2902   1      #ifdef NSM_STA_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "SNSM:disc aging timer id: %bu\n", snsm->discAgingTimer);
              #else
              FM_Printf(FM_ERROR, "SNSM:disc aging timer id: %d\n", snsm->discAgingTimer);
              #endif
              #endif
2909   1      //    snsm->ccoInfo = LINKL_GetCcoInfo(linkLayer);
2910   1          return STATUS_SUCCESS;
2911   1      }
2912          
2913          void showStaType(u8 stamode, u8 staType)
2914          {
2915   1          if(stamode == LINKL_STA_MODE_STA)
2916   1          {
2917   2              switch(staType)
2918   2              {
2919   3                  case LINKL_STA_TYPE_SC_JOIN: 
2920   3                      FM_Printf(FM_USER, "STA TYPE JOIN\n");
2921   3                      break;
2922   3                  case LINKL_STA_TYPE_SC_ADD: 
2923   3                      FM_Printf(FM_USER, "STA TYPE ADD\n");
2924   3                      break;
2925   3                  case LINKL_STA_TYPE_NETDISC: 
2926   3                      FM_Printf(FM_USER, "STA NETWORK DISC\n");
2927   3                      break;
2928   3                  case LINKL_STA_TYPE_UNASSOC: 
2929   3                      FM_Printf(FM_USER, "STA UNASSOC\n");
2930   3                      break;
2931   3                  case LINKL_STA_TYPE_UNASSOC_PASSIVE:
2932   3                      FM_Printf(FM_USER, "STA TYPE UNASSOC PASSIVE\n");
2933   3                      break;
2934   3                  case LINKL_STA_TYPE_ASSOC:
2935   3                      FM_Printf(FM_USER, "STA ASSOC\n");
2936   3                      break;
2937   3                  default:                
2938   3                  {
2939   4      
2940   4                  }
2941   3      
2942   3              }
2943   2          }
2944   1          else if(stamode == LINKL_STA_MODE_CCO)
2945   1          {
2946   2              switch(staType)
2947   2              {
2948   3                  case LINKL_CCO_TYPE_UNASSOC: 
2949   3                      FM_Printf(FM_USER, "CCO UNASSOC\n");
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 49  

2950   3                      break;
2951   3                  case LINKL_CCO_TYPE_ASSOC: 
2952   3                      FM_Printf(FM_USER, "CCO ASSOC\n");
2953   3                      break;
2954   3                  case LINKL_CCO_TYPE_HO: 
2955   3                      FM_Printf(FM_USER, "CCO HANDOVER\n");
2956   3                      break;
2957   3                  default:
2958   3                  {
2959   4      
2960   4                  }
2961   3              }
2962   2      
2963   2          }
2964   1      
2965   1      }
2966          
2967          //Start STA Mode
2968          eStatus SNSM_Start(sSnsm *snsm, u8 staType)
2969          {
2970   1          sEvent *newEvent = NULL;
2971   1          //sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2972   1          newEvent = EVENT_Alloc(sizeof(sSnsmStartEvent), EVENT_HPGP_CTRL_HEADROOM);
2973   1          if(newEvent == NULL)
2974   1          {
2975   2              FM_Printf(FM_ERROR, "SNSM:EAllocErr\n");
2976   2              return STATUS_FAILURE;
2977   2          }
2978   1          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
2979   1          newEvent->eventHdr.type = EVENT_TYPE_SNSM_START;
2980   1          *(newEvent->buffDesc.dataptr) = staType;
2981   1      //   if(staType == LINKL_STA_TYPE_ASSOC)
2982   1      //    {
2983   1      //        SLIST_Put(&linkl->intEventQueue, &newEvent->link);
2984   1      //    }
2985   1      //    else
2986   1      //    {
2987   1              LINKL_SendEvent(snsm->linkl, newEvent);
2988   1      //        SLIST_Put(&snsm->linkl->intEventQueue, &newEvent->link);
2989   1      
2990   1      //    }
2991   1          return STATUS_SUCCESS;
2992   1      }
2993          
2994          eStatus SNSM_Stop(sSnsm *snsm)
2995          {
2996   1          sEvent *newEvent = NULL;
2997   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2998   1          sLinkLayer *linkl = snsm->linkl;
2999   1      #if 0
                  newEvent = EVENT_Alloc(0, EVENT_HPGP_CTRL_HEADROOM);
                  if(newEvent == NULL)
                  {
                      FM_Printf(FM_ERROR, "SNSM: Cannot allocate an event.\n");
                      return STATUS_FAILURE;
                  }
                  
                  newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                  newEvent->eventHdr.type = EVENT_TYPE_SNSM_STOP;
                // FIX: Need to process immediately
                  LINKL_SendEvent(snsm->linkl, newEvent);
              //    SLIST_Put(&linkl->intEventQueue, &newEvent->link);
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 50  

              #else
3013   1          //this happens when the STA leaves the network
3014   1               STM_StopTimer(snsm->usttTimer);   
3015   1               STM_StopTimer(snsm->discAgingTimer);  
3016   1           
3017   1               STM_StopTimer(snsm->bbtTimer); 
3018   1           STM_StopTimer(snsm->bcnLossTimer);
3019   1          
3020   1               snsm->enableCcoSelection = 0;
3021   1               snsm->enableCcoDetection = 0;
3022   1           snsm->enableBcnLossDetection = 0;
3023   1               snsm->netSync = FALSE;
3024   1               snsm->netScan = FALSE;
3025   1           snsm->enableBackupCcoDetection = 0;
3026   1      
3027   1           gHpgpHalCB.syncComplete   = 0;
3028   1           gHpgpHalCB.nwSelected     = 0;
3029   1      
3030   1               
3031   1           gHpgpHalCB.nwSelectedSnid = 0;
3032   1      
3033   1               snsm->state = SNSM_STATE_INIT;
3034   1          
3035   1      #endif
3036   1      
3037   1          return STATUS_SUCCESS;
3038   1      }
3039          #endif /* STA_FUNC */
3040          //
3041          #if 0
              void SNSM_Start(sSns
              {
                  switch(staType)
                  {
                      case LINKL_STA_TYPE_UNASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          snsm->enableCcoSelection = 1;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_NETDISC:
                      {
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_ASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 51  

                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
                          snsm->state = SNSM_STATE_CONN;
                          break;
                      }
                      case LINKL_STA_TYPE_CONN:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 0;
                          snsm->state = SNSM_STATE_CONN;
                      }
                      default:
                      {
                      }
                  }
              }
              #endif
3095          
3096          
3097          
3098          
3099          /*
3100          void SNSM_StartConn(sSnsm *snsm)
3101          {
3102              STM_StopTimer(snsm->usttTimer);   
3103              snsm->state = SNSM_STATE_CONN;
3104          }
3105          
3106          
3107          void SNSM_LeaveConn(sSnsm *snsm)
3108          {
3109              snsm->state = SNSM_STATE_INIT;
3110          }
3111          */
3112          
3113          
3114          void SNSM_EnableHO(sSnsm *snsm)
3115          {
3116   1          snsm->hoEnabled = 1;
3117   1      }
3118          
3119          
3120          void SNSM_EnableCcoDetection(sSnsm *snsm) //detect the central cco
3121          {
3122   1          snsm->enableCcoDetection = 1;
3123   1      }
3124          
3125          /** =========================================================
3126           *
3127           * Edit History
3128           *
3129           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/link/nsm_sta.c,v $
3130           *
3131           * $Log: nsm_sta.c,v $
3132           * Revision 1.34  2014/09/05 09:28:18  ranjan
3133           * 1. uppermac cco-sta switching feature fix
3134           * 2. general stability fixes for many station associtions
3135           * 3. changed mgmt memory pool for many STA support
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 52  

3136           *
3137           * Revision 1.33  2014/08/25 07:37:34  kiran
3138           * 1) RSSI & LQI support
3139           * 2) Fixed Sync related issues
3140           * 3) Fixed timer 0 timing drift for SDK
3141           * 4) MMSG & Error Logging in Flash
3142           *
3143           * Revision 1.32  2014/08/12 08:45:43  kiran
3144           * 1) Event fixes
3145           * 2) API to change UART line control parameters
3146           *
3147           * Revision 1.31  2014/07/30 12:26:26  kiran
3148           * 1) Software Recovery for CCo
3149           * 2) User appointed CCo support in SDK
3150           * 3) Association process performance fixes
3151           * 4) SSN related fixes
3152           *
3153           * Revision 1.30  2014/07/22 10:03:52  kiran
3154           * 1) SDK Supports Power Save
3155           * 2) Uart_Driver.c cleanup
3156           * 3) SDK app memory pool optimization
3157           * 4) Prints from STM.c are commented
3158           * 5) Print messages are trimmed as common no memory left in common
3159           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
3160           *
3161           * Revision 1.29  2014/07/16 10:47:40  kiran
3162           * 1) Updated SDK
3163           * 2) Fixed Diag test in SDK
3164           * 3) Ethernet and SPI interfaces removed from SDK as common memory is less
3165           * 4) GPIO access API's added in SDK
3166           * 5) GV701x chip reset command supported
3167           * 6) Start network and Join network supported in SDK (Forced CCo and STA)
3168           * 7) Some bug fixed in SDK (CP free, p app command issue etc.)
3169           *
3170           * Revision 1.28  2014/07/10 11:42:45  prashant
3171           * power save commands added
3172           *
3173           * Revision 1.27  2014/07/05 09:16:27  prashant
3174           * 100 Devices support- only association tested, memory adjustments
3175           *
3176           * Revision 1.26  2014/07/04 03:54:14  tri
3177           * Fixed bug in STA
3178           *
3179           * Revision 1.25  2014/06/24 16:26:45  ranjan
3180           * -zigbee frame_handledata fix.
3181           * -added reason code for uppermac host events
3182           * -small cleanups
3183           *
3184           * Revision 1.24  2014/06/23 06:56:44  prashant
3185           * Ssn reset fix upon device reset, Duplicate SNID fix
3186           *
3187           * Revision 1.23  2014/06/19 17:13:19  ranjan
3188           * -uppermac fixes for lvnet and reset command for cco and sta mode
3189           * -backup cco working
3190           *
3191           * Revision 1.22  2014/06/19 07:16:02  prashant
3192           * Region fix, frequency setting fix
3193           *
3194           * Revision 1.21  2014/06/12 13:15:44  ranjan
3195           * -separated bcn,mgmt,um event pools
3196           * -fixed datapath issue due to previous checkin
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 53  

3197           * -work in progress. neighbour cco detection
3198           *
3199           * Revision 1.20  2014/06/11 13:17:47  kiran
3200           * UART as host interface and peripheral interface supported.
3201           *
3202           * Revision 1.19  2014/06/05 10:26:07  prashant
3203           * Host Interface selection isue fix, Ac sync issue fix
3204           *
3205           * Revision 1.18  2014/06/05 08:38:41  ranjan
3206           * -flash function enabled for uppermac
3207           * - commit command after any change would flash systemprofiles
3208           * - verfied upper mac
3209           *
3210           * Revision 1.17  2014/05/28 10:58:59  prashant
3211           * SDK folder structure changes, Uart changes, removed htm (UI) task
3212           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
3213           *
3214           * Revision 1.16  2014/05/21 23:02:31  tri
3215           * more PS
3216           *
3217           * Revision 1.15  2014/05/20 05:57:45  prashant
3218           * persistent schedule code updated
3219           *
3220           * Revision 1.14  2014/05/12 08:09:57  prashant
3221           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
3222           *
3223           * Revision 1.13  2014/04/21 03:12:04  tri
3224           * more PS
3225           *
3226           * Revision 1.12  2014/04/20 19:51:28  tri
3227           * more PS
3228           *
3229           * Revision 1.11  2014/04/11 12:23:55  prashant
3230           * Under PLC_TEST macro Diagnostic Mode code added
3231           *
3232           * Revision 1.10  2014/04/09 21:10:20  tri
3233           * more PS
3234           *
3235           * Revision 1.9  2014/04/09 08:18:10  ranjan
3236           * 1. Added host events for homeplug uppermac indication (Host_SendIndication)
3237           * 2. timer workaround  + other fixes
3238           *
3239           * Revision 1.8  2014/03/27 23:52:06  tri
3240           * more PS
3241           *
3242           * Revision 1.7  2014/03/10 05:58:10  ranjan
3243           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
3244           *
3245           * Revision 1.6  2014/03/08 18:15:26  tri
3246           * added more PS code
3247           *
3248           * Revision 1.5  2014/02/27 10:42:47  prashant
3249           * Routing code added
3250           *
3251           * Revision 1.4  2014/02/26 23:15:14  tri
3252           * more PS code
3253           *
3254           * Revision 1.3  2014/01/28 17:47:21  tri
3255           * Added Power Save code
3256           *
3257           * Revision 1.2  2014/01/10 17:17:53  yiming
3258           * check in Rajan 1/8/2014 code release
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 54  

3259           *
3260           * Revision 1.6  2014/01/08 10:53:54  ranjan
3261           * Changes for LM OS support.
3262           * New Datapath FrameTask
3263           * LM and UM  datapath, feature verified.
3264           *
3265           * known issues : performance numbers needs revisit
3266           *
3267           * review : pending.
3268           *
3269           * Revision 1.5  2013/10/16 07:43:38  prashant
3270           * Hybrii B Upper Mac compiling issues and QCA fix, added default eks code
3271           *
3272           * Revision 1.4  2013/09/04 14:51:01  yiming
3273           * New changes for Hybrii_A code merge
3274           *
3275           * Revision 1.9  2013/07/12 08:56:37  ranjan
3276           * -UKE Push Button Security Feature.
3277           * Verified : DirectEntry Security Works.Datapath Works.
3278           *                 command SetSecMode for UKE works.
3279           * Added against bug-160
3280           *
3281           * Revision 1.8  2013/05/23 10:09:30  prashant
3282           * Version command added, SPI polling waittime increased, sys_common file added
3283           *
3284           * Revision 1.7  2013/03/22 12:21:49  prashant
3285           * default FM_MASK and FM_Printf modified for USER INFO
3286           *
3287           * Revision 1.6  2013/03/21 07:43:26  ranjan
3288           * Starting NDC on "p reset" command
3289           *
3290           * Revision 1.5  2013/03/14 11:49:18  ranjan
3291           * 1.handled cases  for CCo toSTA switch and  viceversa
3292           * 2.UM uses bcntemplate
3293           *
3294           * Revision 1.4  2013/02/15 12:53:57  prashant
3295           * ASSOC.REQ changes for DEVELO
3296           *
3297           * Revision 1.3  2012/12/14 11:06:58  ranjan
3298           * queue added for eth to plc datapath
3299           * removed mgmt tx polling
3300           *
3301           * Revision 1.2  2012/11/19 07:46:24  ranjan
3302           * Changes for Network discovery modes
3303           *
3304           * Revision 1.1  2012/09/05 00:13:08  mark
3305           * separate nsm.c into nsm_cco.c and nsm_sta.c,  reason is nsm.c can't be put into bank
3306           *
3307           * Revision 1.40  2012/08/25 15:12:01  yuanhua
3308           * correct the csma region setting in SNSM when a persistent schedule is received
3309           *
3310           * Revision 1.39  2012/08/25 05:49:15  yuanhua
3311           * fix a potential overwriting of region array in SNSM when receive a beacon.
3312           *
3313           * Revision 1.38  2012/08/24 04:40:12  yuanhua
3314           * set initial regions in CNSM for CCO
3315           *
3316           * Revision 1.37  2012/08/23 04:06:52  yuanhua
3317           * made a fix in SNSM for persistent schedule process
3318           *
3319           * Revision 1.36  2012/08/20 04:57:35  yuanhua
3320           * modify the region entry and add persistent schedule entry for beacon
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 55  

3321           *
3322           * Revision 1.35  2012/08/03 04:03:23  kripa
3323           * *** empty log message ***
3324           *
3325           * Revision 1.34  2012/08/01 04:56:02  kripa
3326           * Fixed the variable reuse within BuildBeacon regions Bentry, that was causing bcn corruption.
3327           * Committed on the Free edition of March Hare Software CVSNT Client.
3328           * Upgrade to CVS Suite for more features and support:
3329           * http://march-hare.com/cvsnt/
3330           *
3331           * Revision 1.33  2012/07/31 14:53:34  kripa
3332           * Initilalizing snsm->hoSwitch = HPGP_HO_SWITCH_NONE ; it fixes a bug that causes STA to begin a Handover
             - process, soon afer initial sync.
3333           *
3334           * Revision 1.32  2012/07/30 04:37:55  yuanhua
3335           * fixed an issue that an event memory could be overwritten in the HAL when the HAL receives a mgmt messag
             -e.
3336           *
3337           * Revision 1.31  2012/07/15 17:31:07  yuanhua
3338           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
3339           *
3340           * Revision 1.30  2012/07/12 05:47:34  kripa
3341           * Commenting out Disc Bcn dump, as this could interfere with sync.
3342           * Committed on the Free edition of March Hare Software CVSNT Client.
3343           * Upgrade to CVS Suite for more features and support:
3344           * http://march-hare.com/cvsnt/
3345           *
3346           * Revision 1.29  2012/07/08 18:42:20  yuanhua
3347           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
3348           *
3349           * Revision 1.28  2012/06/30 19:53:58  kripa
3350           * Commenting out Schedule Bentrys enoding & parsing temporarily.
3351           * Committed on the Free edition of March Hare Software CVSNT Client.
3352           * Upgrade to CVS Suite for more features and support:
3353           * http://march-hare.com/cvsnt/
3354           *
3355           * Revision 1.27  2012/06/30 19:47:39  kripa
3356           * Commenting out Schedule Bentry encoding+parsing temporarily.
3357           * Committed on the Free edition of March Hare Software CVSNT Client.
3358           * Upgrade to CVS Suite for more features and support:
3359           * http://march-hare.com/cvsnt/
3360           *
3361           * Revision 1.26  2012/06/29 03:05:31  kripa
3362           * Commenting out SetCsmaRegions() call temporarily until it has been tested.
3363           * Passing Linemode argument to setDevMode call.
3364           * Committed on the Free edition of March Hare Software CVSNT Client.
3365           * Upgrade to CVS Suite for more features and support:
3366           * http://march-hare.com/cvsnt/
3367           *
3368           * Revision 1.25  2012/06/27 04:28:18  yuanhua
3369           * added region entry in the beacon.
3370           *
3371           * Revision 1.24  2012/06/20 17:57:05  kripa
3372           * Multiple changes to fix bcn sync. May need review later.
3373           * Committed on the Free edition of March Hare Software CVSNT Client.
3374           * Upgrade to CVS Suite for more features and support:
3375           * http://march-hare.com/cvsnt/
3376           *
3377           * Revision 1.23  2012/06/15 04:35:21  yuanhua
3378           * add a STA type of passive unassoc STA. With this STA type, the device acts as a STA during the network 
             -discovery. It performs the network scan for beacons from the CCO, but does not transmit the UNASSOC_STA.IND and does not
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 56  

             - involve in the CCO selection process. Thus, it joins the existing network.
3379           *
3380           * Revision 1.22  2012/06/14 06:51:50  yuanhua
3381           * still keep discovery aging timer to run after the CCO is found.
3382           *
3383           * Revision 1.21  2012/06/14 06:45:06  yuanhua
3384           * stop the periodic timers after the STA finds the CCo during the network discovery, as no need to transm
             -it an unassociated_sta.ind if the CCO is detected.
3385           *
3386           * Revision 1.20  2012/06/14 06:14:47  yuanhua
3387           * (1) remove the net scan when the device is set to the CCO mode(2) start the net scan when the CCO is fo
             -und, but the STA is not sync with CCO yet.
3388           *
3389           * Revision 1.19  2012/06/13 16:10:06  son
3390           * Commenting out ScanNet() call in Network Discovery state - so that unassocSta.Ind messages can be sent.
3391           * Committed on the Free edition of March Hare Software CVSNT Client.
3392           * Upgrade to CVS Suite for more features and support:
3393           * http://march-hare.com/cvsnt/
3394           *
3395           * Revision 1.18  2012/06/13 06:24:31  yuanhua
3396           * add code for tx bcn interrupt handler integration and data structures for region entry schedule. But th
             -ey are not in execution yet.
3397           *
3398           * Revision 1.17  2012/06/11 14:49:59  yuanhua
3399           * changed the HAL back to the STA mode after finding the CCo during the network discovery so that the CTR
             -LL issues an association request in the HAL STA mode.
3400           *
3401           * Revision 1.16  2012/06/11 06:29:01  yuanhua
3402           * changed HAL_SetBpsto to HAL_SyncNet.
3403           *
3404           * Revision 1.15  2012/06/08 05:50:57  yuanhua
3405           * added snid function.
3406           *
3407           * Revision 1.14  2012/06/05 22:37:12  son
3408           * UART console does not get initialized due to task ID changed
3409           *
3410           * Revision 1.13  2012/06/05 07:25:59  yuanhua
3411           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
3412           *
3413           * Revision 1.12  2012/06/04 23:34:02  son
3414           * Added RTX51 OS support
3415           *
3416           * Revision 1.11  2012/05/19 20:32:17  yuanhua
3417           * added non-callback option for the protocol stack.
3418           *
3419           * Revision 1.10  2012/05/19 05:05:15  yuanhua
3420           * optimized the timer handlers in CTRL and LINK layers.
3421           *
3422           * Revision 1.9  2012/05/17 05:05:58  yuanhua
3423           * (1) added the option for timer w/o callback (2) added task id and name.
3424           *
3425           * Revision 1.8  2012/05/01 04:51:09  yuanhua
3426           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
3427           *
3428           * Revision 1.7  2012/05/01 00:18:47  son
3429           * Added _CCO_FUNC_ and _STA_FUNC_ compiler flags
3430           *
3431           * Revision 1.6  2012/04/30 04:05:57  yuanhua
3432           * (1) integrated the HAL mgmt Tx. (2) various updates
3433           *
3434           * Revision 1.5  2012/04/20 01:39:33  yuanhua
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 57  

3435           * integrated uart module and added compiler flag NMA.
3436           *
3437           * Revision 1.4  2012/04/13 06:15:11  yuanhua
3438           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
3439           *
3440           * Revision 1.3  2012/03/11 17:02:25  yuanhua
3441           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
3442           *
3443           * Revision 1.2  2011/09/09 07:02:31  yuanhua
3444           * migrate the firmware code from the greenchip to the hybrii.
3445           *
3446           * Revision 1.12  2011/09/06 05:01:46  yuanhua
3447           * Made a fix such that the STA continues periodic TEI renew after CCo handover.
3448           *
3449           * Revision 1.11  2011/08/12 23:13:22  yuanhua
3450           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
3451           *
3452           * Revision 1.10  2011/08/09 22:45:44  yuanhua
3453           * changed to event structure, seperating HPGP-related events from the general event defination so that th
             -e general event could be used for other purposes than the HPGP.
3454           *
3455           * Revision 1.9  2011/08/08 22:05:41  yuanhua
3456           * user-selected CCo handover fix
3457           *
3458           * Revision 1.8  2011/08/05 17:06:29  yuanhua
3459           * (1) added an internal queue in Link Layer for communication btw modules within Link Layer (2) Fixed bug
             -s in CCo Handover. Now, CCo handover could be triggered by auto CCo selection, CCo handover messages work fine (3) Made 
             -some modifications in SHAL.
3460           *
3461           * Revision 1.7  2011/08/02 16:06:00  yuanhua
3462           * (1) Fixed a bug in STM (2) Made STA discovery work according to the standard, including aging timer. (3
             -) release the resource after the STA leave (4) STA will switch to the backup CCo if the CCo failure occurs (5) At this p
             -oint, the CCo could work with multiple STAs correctly, including CCo association/leave, TEI renew, TEI map updating, dis
             -covery beacon scheduling, discovery STA list updating ang aging, CCo failure, etc.
3463           *
3464           * Revision 1.6  2011/07/30 02:43:35  yuanhua
3465           * (1) Split the beacon process into two parts: one requiring an immdiate response, the other tolerating t
             -he delay (2) Changed the API btw the MUX and SHAL for packet reception (3) Fixed bugs in various modules. Now, multiple 
             -STAs could successfully associate/leave the CCo
3466           *
3467           * Revision 1.5  2011/07/22 18:51:05  yuanhua
3468           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
3469           *
3470           * Revision 1.4  2011/07/16 17:11:23  yuanhua
3471           * (1)Implemented SHOM and CHOM modules, including handover procedure, SCB resource updating for HO (2) Up
             -date SNAM and CNAM modules to support uer-appointed CCo handover (3) Made the SCB resources to support the TEI MAP for t
             -he STA mode and management of associated STA resources (e.g. TEI) (4) Modified SNSM and CNSM to perform all types of han
             -dover switch (CCo handover to the new STA, STA taking over the CCo, STA switching to the new CCo)
3472           *
3473           * Revision 1.3  2011/07/08 22:23:48  yuanhua
3474           * (1) Implemented CNSM, including its state machine, beacon transmission and process, discover beacon sch
             -eduling, auto CCo selection, discover list, handover countdown, etc. (2) Updated SNSM, including discover list processin
             -g, triggering a switch to the new CCo, etc. (3) Updated CNAM and SNAM, adding the connection state in the SNAM, switch t
             -o the new CCo, etc. (4) Other updates
3475           *
3476           * Revision 1.2  2011/06/24 14:33:18  yuanhua
3477           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
C51 COMPILER V9.52.0.0   NSM_STA                                                           12/02/2014 14:35:39 PAGE 58  

             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
3478           *
3479           * Revision 1.1  2011/05/28 06:31:19  kripa
3480           * Combining corresponding STA and CCo modules.
3481           *
3482           * Revision 1.1  2011/05/06 19:10:12  kripa
3483           * Adding link layer files to new source tree.
3484           *
3485           * Revision 1.3  2011/04/23 19:48:45  kripa
3486           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
3487           *
3488           * Revision 1.2  2011/04/23 17:35:36  kripa
3489           * Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
3490           *
3491           * Revision 1.1  2011/04/08 21:42:45  yuanhua
3492           * Framework
3493           *
3494           *
3495           * =========================================================*/
3496          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10991    ----
   CONSTANT SIZE    =    952    ----
   XDATA SIZE       =     45     444
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
