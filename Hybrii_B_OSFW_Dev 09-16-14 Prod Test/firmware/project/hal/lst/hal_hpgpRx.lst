C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HAL_HPGPRX
OBJECT MODULE PLACED IN .\obj\hal_hpgpRx.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\hal\hal_hpgpRx.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCD
                    -IR(..\..\common;..\..\project\hal\src;..\..\hpgp\src\mux;..\..\hpgp\src\link;..\..\hpgp\src\ctrl;..\..\hpgp\src\nma;..\.
                    -.\hal;.\src;..\..\hpgp\src\hal;..\..\hpgp\src\sap;..\..\hpgp\src\test;..\..\hpgp\src\;..\..\common\datapath;..\..\hpgp\s
                    -rc\route;..\..\..\components\utilities\datatype\inc;..\..\..\components\utilities\event\inc;..\..\..\components\utilitie
                    -s\linklist\inc;..\..\..\components\utilities\timer\inc;..\..\app_support;..\..\..\sampleapp\src;..\..\..\sampleapp\inc;.
                    -.\..\..\components\hpgp\inc;..\..\..\components\aps\inc) DEFINE(P8051,HYBRII_8051,HYBRII_HPGP,HYBRII_ASIC,PLC_SW_SYNC=1,
                    -inline,HPGP_HAL_TEST,RTX51_TINY_OS,_TIMER_INTERRUPT_,SNIFFER,Hybrii_B,NEW_SYNC,_TIMER_INTERRUPT_,HYBRII_B,HW_SPI_TX_CRC,
                    -HW_SPI_RX_CRC,_CRC_VERIFY_,HYBRII_SPI,SNIFFER,HYBRII_ETH,B_ASICPLC,FREQ_DETECT,PROD_TEST) DEBUG OBJECTEXTEND PRINT(.\lst
                    -\hal_hpgpRx.lst) TABS(2) OBJECT(.\obj\hal_hpgpRx.obj)

line level    source

   1          /*
   2          * $Id: hal_hpgpRx.c,v 1.26 2014/09/05 09:28:18 ranjan Exp $
   3          *
   4          * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hal/hal_hpgpRx.c,v $
   5          *
   6          * Description : HPGP HAL Receive module.
   7          *
   8          * Copyright (c) 2010-2011 Greenvity Communications, Inc.
   9          * All rights reserved.
  10          *
  11          * Purpose :
  12          *     Defines beacon and data receive functions for HPGP, .
  13          *
  14          *
  15          */
  16          
  17          #include <stdio.h>
  18          #include <string.h>
  19          #include "papdef.h"
  20          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  23          #include "fm.h"
  24          
  25          #include "hal_common.h"
  26          #include "hal.h"
  27          #include "mac_intf_common.h"
  28          #include "hal_hpgp.h"
  29          #include "hal_eth.h"
  30          #include "hal_tst.h"
  31          #include "hpgpevt.h"
  32          #include "hpgpdef.h"
  33          
  34          #ifdef HPGP_HAL_TEST
  35          #include "hal_cfg.h"
  36          #include "mmsg.h"
  37          #else
              #ifndef CALLBACK
              #include "hpgpapi.h"
              #endif
              #endif
  42          #include "frametask.h"
  43          
  44          #include "datapath.h"
  45          #include "hybrii_tasks.h"
  46          #include "sys_common.h"
  47          
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 2   

  48          #ifdef DEBUG_DATAPATH
              
              extern u8 pktDbg;
              
              extern u8 sigDbg;
              #endif
  54          #ifdef PLC_TEST
              u16 oldssn = 0;
              #endif
  57          
  58          u8 gpbcscorrect, gvalid;
  59          u32 gsnid;
  60          u32 debugcnt = 0;
  61          extern u32 gBcnPer;
  62          u32 misscnt = 0;
  63          u8 gbcnstart, gflag;
  64          extern u32 gbpst1, gtimer2, gtimer1;
  65          extern u8 opMode;
  66          extern u8 gBcnMissingRescanCnt;
  67          extern u16  prevCsmaRgns[HYBRII_MAXSMAREGION_CNT];
  68          #ifdef ROUTE_TEST
              u8 dropTei[3] = {0,0,0};
              #endif
  71          
  72          #ifdef PLC_TEST
              extern void printmsg(u8* buff, u8 len);
              extern void HHT_ProcessPlcFrame(sSwFrmDesc* plcRxFrmSwDesc);
              #endif
  76          
  77            
  78          #ifdef ASSOC_TEST
              extern eStatus LM_RecvFrame(sSwFrmDesc *rxFrmSwDesc, 
                               uRxFrmHwDesc*  pRxPktQ1stDesc,
                               uRxCpDesc*   pRxPktQCPDesc);
                
              #endif
  84          #ifdef ROUTE
              extern sScb* ROUTE_lookUpLRT(u8 *mac);
              #endif
  87          
  88          extern void EHT_FromPlcBcnTx(u8* rxBcnByteArr, u16 frameSize);
  89          
  90          
  91          uCSMARegionReg   csmaRegArr[HYBRII_MAXSMAREGION_CNT]; 
  92          u32              u32CSMARegs[HYBRII_MAXSMAREGION_CNT];
  93          
  94          
  95          eStatus CHAL_ReadFrame(sHaLayer *hal,
  96                                 sSwFrmDesc *rxFrmSwDesc,
  97                                 sBuffDesc *buffDesc)
  98          {
  99   1          volatile u8 XDATA *cellAddr;
 100   1          u8        frmOffset = 0;
 101   1          u8        i;
 102   1          s16       frmLen = rxFrmSwDesc->frmLen;
 103   1          s16       cellLen;
 104   1          u8       *dataptr = NULL;
 105   1          sHpgpHdr *hpgpHdr = NULL;
 106   1          eStatus   ret = STATUS_SUCCESS;
 107   1      
 108   1      
 109   1          /* sanity test on frame length */
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 3   

 110   1      /*    if (frmLen != ((rxFrmSwDesc->cpCount -1)*HYBRII_CELLBUF_SIZE +
 111   1                        rxFrmSwDesc->lastDescLen))       
 112   1          {
 113   1              FM_Printf(FM_ERROR, "CHAL: Frame length error.\n");
 114   1              ret = STATUS_FAILURE;
 115   1              goto done;
 116   1          } */
 117   1      
 118   1          if (rxFrmSwDesc->rxPort == PORT_PLC)
 119   1          {
 120   2              /* the first cell of the mgmt frame contains 4-byte */
 121   2              frmOffset = ((rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT) ? 4 : 0);
 122   2          }
 123   1      
 124   1      
 125   1          frmLen -= frmOffset;
 126   1          buffDesc->datalen = frmLen;
 127   1        //cellLen = HYBRII_CELLBUF_SIZE - frmOffset;
 128   1        cellLen = MIN(HYBRII_CELLBUF_SIZE - frmOffset, frmLen);
 129   1      //FM_Printf(FM_MINFO,"rx data len: %d, cell len: %d, cp cnt %bu\n", buffDesc->datalen, cellLen, rxFrmSwDes
             -c->cpCount);
 130   1      //FM_HexDump(FM_DATA|FM_MINFO, "rx buff:", (u8 *)buffDesc->dataptr, 256 );  
 131   1           
 132   1          dataptr = buffDesc->dataptr; 
 133   1      
 134   1        i = 0;
 135   1      //    for (i = 0; i < rxFrmSwDesc->cpCount; i++)
 136   1          while((i < rxFrmSwDesc->cpCount) && cellLen > 0)
 137   1          {
 138   2              cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[i].cp);
 139   2              memcpy(dataptr, cellAddr+frmOffset, cellLen);
 140   2              dataptr += cellLen;
 141   2              frmLen -= cellLen;
 142   2              cellLen = MIN(HYBRII_CELLBUF_SIZE, frmLen);
 143   2              frmOffset = 0;
 144   2          i++;
 145   2          }
 146   1      //FM_Printf(FM_MINFO,"rx data len: %d, frm len: %d\n", buffDesc->datalen, frmLen);
 147   1      //FM_HexDump(FM_DATA|FM_MINFO, "rx data:", (u8 *)buffDesc->dataptr, 256 );  
 148   1      //done:
 149   1          /* free cp */
 150   1          CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount);
 151   1          return ret;
 152   1      }
*** WARNING C280 IN LINE 95 OF ..\..\hal\hal_hpgpRx.c: 'hal': unreferenced local variable
 153          
 154          #if !defined (HPGP_HAL_TEST) && !defined(UM)
              
              void HHAL_ProcRxFrameDesc(struct haLayer *hal, uRxFrmHwDesc *rxFrmHwDesc,
                                        sSwFrmDesc *plcRxFrmSwDesc)
              {
                  uPlcRssiLqiReg  rssiLqi;
                  uPlcStatusReg   plcStatus;
                  u16             frmLen;
                  u8              stei;
              
              #ifdef _AES_SW_    
                  // Reset AES Block
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 1;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 4   

                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 0;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              #endif
              
                  /* Retrieve LQI_RSSI */
                  rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
                  plcRxFrmSwDesc->frmInfo.plc.rssi = rssiLqi.s.rssi;
                  plcRxFrmSwDesc->frmInfo.plc.lqi  = rssiLqi.s.lqi;
              
                  /* Extract Frame Length */
                  frmLen = rxFrmHwDesc->sof.frmLenHi;
                  frmLen = frmLen<<PKTQDESC1_FRMLENHI_POS | rxFrmHwDesc->sof.frmLenLo;
                  plcRxFrmSwDesc->frmLen = frmLen;
              //  printf("\nfrmLen : %d \n", frmLen);
              
                  /* Extract PLC Frame Type */
                  plcRxFrmSwDesc->frmType = (eHpgpHwFrmType)rxFrmHwDesc->sof.frmType;
                  /* Extract source TEI */
                  stei   = rxFrmHwDesc->sof.steiHi2;
                  stei   = (stei << PKTQDESC1_STEIHI_POS ) | rxFrmHwDesc->sof.steiLo6;
                  plcRxFrmSwDesc->frmInfo.plc.stei    = stei; 
              
              
              //  printf("rx len %d\n", frmLen);
                  
              
                  if(plcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MSDU)
                  {
                      gHpgpHalCB.halStats.RxGoodDataCnt++;
                      /* Extract PLC Frame Mcst Mode */
                      if(rxFrmHwDesc->sof.bcst)
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
                      }
                      else if(rxFrmHwDesc->sof.mcst)
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                      }
                      else
                      {
                          plcRxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
                      }
                  }
                  else if(plcRxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_SOUND)
                  {
                      /*
                       * H/W does not provide STEI for Sound packet
                       */
                      plcRxFrmSwDesc->frmInfo.plc.stei = 0;
                      gHpgpHalCB.halStats.RxGoodSoundCnt++;
                  }
                  else 
                  {
                      gHpgpHalCB.halStats.RxGoodMgmtCnt++;
                  }          
              
                  plcRxFrmSwDesc->frmInfo.plc.clst    = rxFrmHwDesc->sof.clst;
              
              
                  /* Update HPGP statistics - may be needed only in diag mode */
                  gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 5   

                  gHpgpHalCB.halStats.TotalRxBytesCnt += plcRxFrmSwDesc->frmLen;
                  gHpgpHalCB.halStats.macRxStuckCnt = 0;
                  gHpgpHalCB.halStats.smRxStuckCnt = 0;
              }
              
              #endif
 238          
 239          #ifndef HPGP_HAL_TEST
              
              
              eStatus HAL_RecvFrame(sHaLayer *hal, sSwFrmDesc *rxFrmSwDesc, 
                                           uRxFrmHwDesc*  pRxPktQ1stDesc,
                                           uRxCpDesc*     pRxPktQCPDesc)
              {
                  sEvent      *event = NULL;
                  sBuffDesc   *buffDesc = NULL;
                  sEth2Hdr    *ethhdr = NULL;
                  sHpgpHdr    *hpgpHdr = NULL; 
                  eStatus      ret = STATUS_SUCCESS;
                  volatile u8 XDATA *cellAddr;
                sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);    
                  u16 frmlen;
                  u8 i;
                  u8 frmOffset;
                sScb *scb = CRM_GetScb(LINKL_GetCrm(linkl), rxFrmSwDesc->frmInfo.plc.stei);
                
              #ifdef ROUTE
                  sScb *rScb = NULL;    
                  sStaInfo *staInfo = LINKL_GetStaInfo(linkl);
              #endif
                  switch(rxFrmSwDesc->rxPort)
                  {
                      case PORT_PLC:
                      {
                          cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[0].cp);
                          frmOffset = ((rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT) ? 4 : 0);
                          
                        ethhdr = (sEth2Hdr *)&cellAddr[frmOffset];
                          
              #if 1
              
                              // Drop frm if dest MAC not match with device MAC address
                              if(IS_GROUP(ethhdr->dstaddr))
                              {
                              }
                              else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
                              {
                                  
                              }
              #ifdef ROUTE
                              else if((rScb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                              {
                                  
                                  //FM_Printf(FM_USER, "LH: %bu\n",scb->tei);
                                  if(rScb->lrtEntry.routeIsInvalid == TRUE || rScb->lrtEntry.routeOnHold == TRUE)
                                  {
                                      return STATUS_FAILURE;
                                  }
                                  rxFrmSwDesc->frmInfo.plc.dtei = rScb->lrtEntry.nTei;
                                  rxFrmSwDesc->frmInfo.plc.eks = staInfo->nekEks;
                                  if(linkl->mode == LINKL_STA_MODE_CCO)
                                  {
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 6   

              
                                      rxFrmSwDesc->frmInfo.plc.stei = staInfo->ccoScb->tei;
                                  }
                                  else
                                  {
                                      rxFrmSwDesc->frmInfo.plc.stei =  staInfo->tei;
                                  }
              
              
                                 {
              
              
                                      rxFrmSwDesc->frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                                      rxFrmSwDesc->frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
              
                                      rxFrmSwDesc->frmInfo.plc.plid = 0;   //[YM] This line of code has to be changed ba
             -se on differnet QoS priority
              
              
                                      if (rxFrmSwDesc->frmInfo.plc.plid == 0)
                                      rxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
                                      else
                                      rxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP123;
              
                                      rxFrmSwDesc->frmInfo.plc.mcstMode       = HPGP_UCST;  // Unicast
              
                                      rxFrmSwDesc->frmInfo.plc.stdModeSel     = STD_ROBO_TEST; // std robo
                                      rxFrmSwDesc->frmInfo.plc.dt_av = HPGP_DTAV_SOF;
                                      rxFrmSwDesc->frmInfo.plc.saf = 1;
              
              
                                  }
              
                                  
                                  frmlen = rxFrmSwDesc->frmLen;
                                  for(i = 0; i< rxFrmSwDesc->cpCount; i++)
                                  {
                                      if(( i == 0) && (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT))
                                      {
                                          rxFrmSwDesc->cpArr[i].offsetU32 = 1;                           
                                      }
                                      rxFrmSwDesc->cpArr[i].len = MIN(frmlen, HYBRII_CELLBUF_SIZE);
                                      frmlen = frmlen - HYBRII_CELLBUF_SIZE;
                                  }
                                  rxFrmSwDesc->txPort = PORT_PLC;
                                  fwdAgent_handleData(rxFrmSwDesc);
                                  return STATUS_SUCCESS;
                              }
              #endif 
                              else
                              {
                                  // Drop frm
              #ifdef DEBUG_DATAPATH
                                  if(pktDbg)
                                  {
                                      FM_Printf(FM_MINFO, "Drop\n");
                                  }
              #endif
                                  gHpgpHalCB.halStats.PtoHswDropCnt++;
                                  return STATUS_FAILURE;
                              }
              #endif
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 7   

              
                    if (!scb)
                    {
                      if (rxFrmSwDesc->frmType != HPGP_HW_FRMTYPE_MGMT)
                      {
                        gHpgpHalCB.halStats.PtoHswDropCnt++;            
                        return STATUS_FAILURE;
                      }
                    
                    }
                    else
                    {
                      scb->rssiLqi.s.rssi = rxFrmSwDesc->frmInfo.plc.rssi;
                      scb->rssiLqi.s.lqi = rxFrmSwDesc->frmInfo.plc.lqi;
                    }
              
                    
                    //printf("tei %bu rssi %bu\n", scb->tei, scb->rssiLqi.s.rssi);
                    
              
                          if ((rxFrmSwDesc->frmInfo.plc.stei == 0) || (IS_GROUP(ethhdr->dstaddr)))
                    {
                    
                    }
                          else if (scb)
                    {
                      
                              if(scb->uWrapAround)
                              {
                                  if(rxFrmSwDesc->frmInfo.plc.ssn < 1000)
                                  {                    
                                      scb->uWrapAround = 0;
                                      scb->uMinSSN = 0;
                                  }
                              }
                              
              
                      //printf("tei %bu rssi %bu\n", scb->tei, scb->rssiLqi.s.rssi);
                      
                      if ((rxFrmSwDesc->frmInfo.plc.ssn <= scb->uMinSSN) && (scb->uMinSSN != 0))
                              {
                          // Drop duplicate frm
                          gHpgpHalCB.halStats.DuplicateRxCnt++;                    
                                  //printf("Dup frm: %u, %u \n",rxFrmSwDesc->frmInfo.plc.ssn, scb->uMinSSN);
                        return STATUS_FAILURE;
                      }
                              
                              scb->uMinSSN = rxFrmSwDesc->frmInfo.plc.ssn;// + numPBs;
                              
                              if(scb->uMinSSN >= 1500)
                              {
                                  scb->uWrapAround = 1;
                              }
              
                    }
              
                          
                          if (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MGMT)
                          {
                              /* create an event for the mgmt message */
                              event = EVENT_MgmtAlloc(rxFrmSwDesc->frmLen, sizeof(sHpgpHdr));
                              if (event == NULL)
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 8   

                              {
                                  FM_Printf(FM_ERROR, "HAL: EAllocErr\n");
                                  return STATUS_FAILURE;
                              }
              
                              buffDesc = &event->buffDesc;
              
                              if (CHAL_ReadFrame(hal, rxFrmSwDesc, buffDesc) == STATUS_SUCCESS)
                              {
                                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                                  //hpgpHdr->snid = hal->hhalCb->snid;
                                  hpgpHdr->snid = rxFrmSwDesc->frmInfo.plc.snid;
                                  hpgpHdr->tei = rxFrmSwDesc->frmInfo.plc.stei;
                                  FM_Printf(FM_MINFO, "HAL: Rx Snid=%bu, Stei=%bu\n", hpgpHdr->snid, hpgpHdr->tei);
                                  event->eventHdr.eventClass = EVENT_CLASS_MSG;
                                  /* process the MAC header */
                                  ethhdr = (sEth2Hdr *)event->buffDesc.dataptr; 
              #ifdef LOG_FLASH
                                  logEvent(MGMT_MSG,0,event->eventHdr.type,&hpgpHdr->tei,1);
              #endif
              #if 1         
                                  // Drop frm if dest MAC not match with device MAC address
                                  if(IS_GROUP(ethhdr->dstaddr))
                                  {
                                  }
                                  else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
                                  {
                                  }
                                  
              #ifdef ROUTE
                                  else if((scb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                                  {
                                      if(scb->lrtEntry.routeIsInvalid == TRUE || scb->lrtEntry.routeOnHold == TRUE)
                                      {
                                          return STATUS_SUCCESS;
                                      }
                                      
                                      FM_Printf(FM_USER, "LRT hit: %bu\n",scb->tei);
                                      hpgpHdr->tei = scb->lrtEntry.nTei;
                                      hpgpHdr->eks = staInfo->nekEks;
                                      //rxFrmSwDesc->plc.stei =  // TBD
                                      fwdAgent_sendFrame(PORT_PLC ,event);
                                      return STATUS_SUCCESS;
                                  }
              #endif
                                  else
                                  {
                                      // Drop frm
              #ifdef DEBUG_DATAPATH
                                      if(pktDbg)
                                      {
                                          FM_Printf(FM_MINFO, "MGMT drop\n");
                                      }
              #endif
                                      EVENT_Free(event);
                                      return STATUS_SUCCESS; //STATUS_FAILURE;
                                  }
              #endif                    
                                  hpgpHdr->macAddr = ethhdr->srcaddr;
              //                    hpgpHdr->scb = CRM_FindScbMacAddr(hpgpHdr->macAddr);
              
                                                                          
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 9   

                                  /* chop off the ethernet header */
                                  event->buffDesc.dataptr += sizeof(sEth2Hdr); 
                                  event->buffDesc.datalen -= sizeof(sEth2Hdr); 
                                  /* deliver the mgmt message to the upper layer */
              #ifdef CALLBACK
                                  hal->deliverMgmtPacket(hal->mgmtCookie, event);
              #else
                                  MUXL_RecvMgmtPacket(hal->mgmtCookie, event);
              #endif
                               //   CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount);
                              }
                              else
                              {
                                  EVENT_Free(event);
                              }
                          }
                          else if (rxFrmSwDesc->frmType == HPGP_HW_FRMTYPE_MSDU)
                        {
                            /* deliver the data packet to the data plane */
              
                            
                        
                                  // FM_Printf(FM_USER,"DATA ssn: %u\n", rxFrmSwDesc->frmInfo.plc.ssn);
              
                            
              
              #ifdef ROUTE
              
                                  //  cellAddr = CHAL_GetAccessToCP(rxFrmSwDesc->cpArr[0].cp);
                                  //  ethhdr = (sEth2Hdr *)cellAddr;
                                    // Drop frm if dest MAC not match with device MAC address
                                    if(IS_GROUP(ethhdr->dstaddr))
                                    {
                                    }
                                    else if(memcmp(ethhdr->dstaddr, hal->macAddr, MAC_ADDR_LEN) == 0)
                                    {
                                        
                                    }
                                    else if((scb = ROUTE_lookUpLRT(ethhdr->dstaddr)) != NULL)
                                    {
                                        
                                          FM_Printf(FM_USER, "LH: %bu\n",scb->tei);
                                        if(scb->lrtEntry.routeIsInvalid == TRUE || scb->lrtEntry.routeOnHold == TRUE)
                                        {
                                            return STATUS_FAILURE;
                                        }
                                        rxFrmSwDesc->frmInfo.plc.dtei = scb->lrtEntry.nTei;
                                        rxFrmSwDesc->frmInfo.plc.eks = staInfo->nekEks;
                                          if(linkl->mode == LINKL_STA_MODE_CCO)
                                          {
              
                                              rxFrmSwDesc->frmInfo.plc.stei = staInfo->ccoScb->tei;
                                          }
                                          else
                                          {
                                              rxFrmSwDesc->frmInfo.plc.stei =  staInfo->tei;
                                          }
              
              
                                          {
              
              
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 10  

                                              rxFrmSwDesc->frmInfo.plc.bcnDetectFlag  = REG_FLAG_SET;// REG_FLAG_CLR;
                                              rxFrmSwDesc->frmInfo.plc.clst = HPGP_CONVLYRSAPTYPE_ETH;
              
                                              rxFrmSwDesc->frmInfo.plc.plid = 0;   //[YM] This line of code has to be ch
             -anged base on differnet QoS priority
              
              
                                              if (rxFrmSwDesc->frmInfo.plc.plid == 0)
                                              rxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP0;
                                              else
                                              rxFrmSwDesc->frmInfo.plc.phyPendBlks    = HPGP_PPB_CAP123;
              
                                              rxFrmSwDesc->frmInfo.plc.mcstMode       = HPGP_UCST;  // Unicast
              
                                              rxFrmSwDesc->frmInfo.plc.stdModeSel     = STD_ROBO_TEST; // std robo
                                              rxFrmSwDesc->frmInfo.plc.dt_av = HPGP_DTAV_SOF;
                                              rxFrmSwDesc->frmInfo.plc.saf = 1;
              
              
                                          }
                                          frmlen = rxFrmSwDesc->frmLen;
                                          for(i = 0; i< rxFrmSwDesc->cpCount; i++)
                                          {
                                              rxFrmSwDesc->cpArr[i].offsetU32 = 0;
                                              rxFrmSwDesc->cpArr[i].len = MIN(frmlen, HYBRII_CELLBUF_SIZE);
                                              frmlen = frmlen - HYBRII_CELLBUF_SIZE;
                                          }
                                        rxFrmSwDesc->txPort = PORT_PLC;
                            fwdAgent_handleData(rxFrmSwDesc);
                                        return STATUS_SUCCESS;
                                    }
                                    else
                                    {
                                        // Drop frm
              #ifdef DEBUG_DATAPATH
                                        if(pktDbg)
                                        {
                                            FM_Printf(FM_MINFO, "DATA drop\n");
                                        }
              #endif
                                        return STATUS_FAILURE;
                                    }
              #endif
              
              
                //            FM_Printf(FM_USER, "prx\n");
                          fwdAgent_handleData(rxFrmSwDesc);
                        }
                          else
                          {
                              /* unknown HPGP frame type */
                          }
                          break;
                      }
                      case PORT_ZIGBEE:
                          break;
                      case PORT_SPI:
                      {
                          /* TODO: need to differentiate the mgmt and data */             
                          /* create an event for the mgmt message */
                          event = EVENT_MgmtAlloc(rxFrmSwDesc->frmLen, 0);
                          if (event == NULL)
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 11  

                          {
                              FM_Printf(FM_ERROR, "HAL: EAllocErr\n");
                              return STATUS_FAILURE;
                          }
              
                          buffDesc = &event->buffDesc;
                          if (CHAL_ReadFrame(hal, rxFrmSwDesc, buffDesc) == STATUS_SUCCESS)
                          {
                              /* deliver the mgmt message to the upper layer */
              #ifdef NMA
              #ifdef CALLBACK
                              hal->deliverNetMgmtPacket(hal->netMgmtCookie, event);
              #else
                              NMA_RecvMgmtPacket(hal->netMgmtCookie, event);
              #endif
              #endif
                             // CHAL_FreeFrameCp(rxFrmSwDesc->cpArr, rxFrmSwDesc->cpCount); // [PRA] double free
                          }
                          else
                          {
                              EVENT_Free(event);
                          }
                          break;
                      }
                      default:
                      {
                          /* deliver the data packet to the data plane */
                          //hal->deliverDataPacket(hal->dataCookie, rxFrmSwDesc);
                      }
                  }
              
                  return ret;
              }
              
              
              
              #endif
 639          
 640          #ifdef Z_P_BRIDGE
              extern bool zb_plc_bridging;
              extern void mac_hal_zb_pkt_bridge(sCommonRxFrmSwDesc* rx_frame_info_p);
              #endif
 644          
 645          void HHAL_RxSoundIntHandler()
 646          {
 647   1          uPlcRssiLqiReg  rssiLqi;
 648   1          // Retrieve LQI_RSSI   
 649   1          rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
 650   1          //printf(" SOUND int: 0xE4C REG Value= %lx, \n", rssiLqi.reg);
 651   1        
 652   1        //rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
 653   1        //printf(" SOUND 2: 0xE48 REG Value= %lx, \n", ReadU32Reg(PLC_RSSILQI_REG));
 654   1        
 655   1      }
 656          
 657          
 658          #ifdef HPGP_HAL_TEST
 659          void HHAL_RxIntHandler(sCommonRxFrmSwDesc* pRxFrmDesc)
 660          #else
              void HHAL_RxIntHandler(sCommonRxFrmSwDesc* pRxFrmDesc, void *cookie)
              #endif
 663          {
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 12  

 664   1      
 665   1          // If SrcPort is PLC, Frametype Bcn,Mgmt
 666   1          // Write to PLCCmdQ
 667   1      //#ifdef PLC_TEST
 668   1          volatile u8 xdata * cellAddr;
 669   1      //#endif
 670   1          uRxFrmHwDesc*   pRxPktQ1stDesc;
 671   1          uRxCpDesc*      pRxPktQCPDesc;
 672   1          uPlcRssiLqiReg  rssiLqi;
 673   1          sSwFrmDesc      plcRxFrmSwDesc;
 674   1          u16             frmLen;
 675   1          u16             tmpfrmLen;
 676   1          u8              snid;
 677   1          u8              stei;
 678   1          u16             ssn;
 679   1          u8              i;
 680   1          eStatus         status = STATUS_SUCCESS;
 681   1          sEth2Hdr         *ethHdr;
 682   1      #ifdef UM
                  sScb *scb;
              #endif
 685   1      #ifdef _AES_SW_    
                  // Reset AES Block
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 1;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              
                  plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
                  plcStatus.s.aesReset = 0;
                  WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
              #endif
 695   1      
 696   1      #ifdef PLC_DELAY    
                  CHAL_DelayTicks(500);
              #endif
 699   1      
 700   1      
 701   1      
 702   1      
 703   1      
 704   1      #if 0
                  // Retrieve LQI_RSSI   -- [YM] May change to only do this on sound packet
                  //rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
                  rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
                  //plcRxFrmSwDesc.frmInfo.plc.rssi = rssiLqi.s.rssi;
                  //plcRxFrmSwDesc.frmInfo.plc.lqi  = rssiLqi.s.lqi;  
                printf(" E48 REG = %lx, \n", rssiLqi.reg);
                rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
                printf(" E4C REG = %lx, \n", rssiLqi.reg);
              
              #endif
 715   1      
 716   1          pRxPktQ1stDesc      = (uRxFrmHwDesc*)&pRxFrmDesc->hdrDesc;
 717   1          pRxPktQCPDesc       = (uRxCpDesc*)&pRxFrmDesc->firstCpDesc;
 718   1      
 719   1          plcRxFrmSwDesc.rxPort = pRxPktQ1stDesc->sof.srcPort;
 720   1        plcRxFrmSwDesc.txPort = pRxPktQ1stDesc->sof.dstPort;
 721   1          plcRxFrmSwDesc.frmInfo.plc.rssi = pRxFrmDesc->rssiLqi.s.rssi;
 722   1          plcRxFrmSwDesc.frmInfo.plc.lqi  = pRxFrmDesc->rssiLqi.s.lqi;
 723   1          // 1.1.1 Extract PLC Frame Length
 724   1          frmLen = pRxPktQ1stDesc->sof.frmLenHi;
 725   1          frmLen = frmLen<<PKTQDESC1_FRMLENHI_POS | pRxPktQ1stDesc->sof.frmLenLo;
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 13  

 726   1          plcRxFrmSwDesc.frmLen = frmLen;
 727   1      
 728   1          // 1.1.2 Extract PLC Frame Type
 729   1          plcRxFrmSwDesc.frmType = (eHpgpHwFrmType)pRxPktQ1stDesc->sof.frmType;
 730   1          stei   = pRxPktQ1stDesc->sof.steiHi2;
 731   1          stei   = (stei << PKTQDESC1_STEIHI_POS ) | pRxPktQ1stDesc->sof.steiLo6;
 732   1      
 733   1          snid   = pRxPktQCPDesc->plc.snidHi;
 734   1          snid   = (snid << PKTQDESC1_SNIDHI_POS ) | pRxPktQCPDesc->plc.snidLo;
 735   1          
 736   1          tmpfrmLen = frmLen;
 737   1          // Update HPGP statistics - may be needed only in diag mode
 738   1      
 739   1      
 740   1        /*{
 741   1      
 742   1          uPlcTxPktQDescVF0 *vf0 = (uPlcTxPktQDescVF0*)&pRxFrmDesc->fc[0];
 743   1      
 744   1      
 745   1            stei = vf0->s.stei;
 746   1      
 747   1            snid  = vf0->s.snid;
 748   1      
 749   1      
 750   1        }*/
 751   1      #ifdef UM
                  if (stei == 0)       
                  {
                    cellAddr = CHAL_GetAccessToCP(pRxPktQCPDesc->plc.cp);
                      //if(cellAddr != NULL)// cellAddress is never NULL. Kiran
                      //{
                           if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT)
                           {
                               ethHdr = (sEth2Hdr*)(&(cellAddr + 4));
                           }
                           else
                           {
                               ethHdr = (sEth2Hdr*)cellAddr;
                           }
                           scb = CRM_FindScbMacAddr(ethHdr->srcaddr);
                           if(scb != NULL)
                           {
                               stei = scb->tei;
                           }
                      //}
                  }
              #endif
 773   1          plcRxFrmSwDesc.frmInfo.plc.snid    = snid;
 774   1          plcRxFrmSwDesc.frmInfo.plc.stei    = stei; 
 775   1      
 776   1          ssn    = pRxPktQCPDesc->plc.ssnHi;
 777   1          ssn    = (ssn << PKTQDESC1_SSNHI_POS ) | pRxPktQCPDesc->plc.ssnLo;
 778   1      #ifdef PLC_TEST
                  if(opMode == LOWER_MAC)
                  {
                      if(pRxPktQ1stDesc->sof.bcst == 0 && pRxPktQ1stDesc->sof.mcst == 0)
                      {
                          if((ssn == oldssn) && (ssn != 0))
                          {
                              CHAL_DecrementReleaseCPCnt(pRxPktQCPDesc->plc.cp);
                              for (i = 1; i < pRxFrmDesc->cpCount; i++)
                              {
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 14  

                              CHAL_DecrementReleaseCPCnt(pRxFrmDesc->cpArr[i]);
                              }
                              //printf("Dup frm: %u, %u \n",ssn, oldssn);
                              return;
                          }
                          oldssn = ssn;
                          if(oldssn == 2047)
                          {
                              oldssn = 0;
                          }
                      }
                  }
              #endif    
 801   1          gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
 802   1          gHpgpHalCB.halStats.TotalRxBytesCnt += plcRxFrmSwDesc.frmLen;
 803   1          gHpgpHalCB.halStats.macRxStuckCnt = 0;
 804   1          gHpgpHalCB.halStats.smRxStuckCnt = 0;
 805   1      
 806   1          if(plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MSDU)
 807   1          {
 808   2              gHpgpHalCB.halStats.RxGoodDataCnt++;
 809   2              // 1.1.3 Extract PLC Frame Mcst Mode
 810   2              if(pRxPktQ1stDesc->sof.bcst)
 811   2              {
 812   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_MNBCST;
 813   3              }
 814   2              else if(pRxPktQ1stDesc->sof.mcst)
 815   2              {
 816   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_MCST;
 817   3              }
 818   2              else
 819   2              {
 820   3                  plcRxFrmSwDesc.frmInfo.plc.mcstMode = HPGP_UCST;
 821   3              }
 822   2          }
 823   1          else if(plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
 824   1          {
 825   2              /*
 826   2               * H/W does not provide STEI for Sound packet
 827   2               */
 828   2              plcRxFrmSwDesc.frmInfo.plc.stei = 0;
 829   2              gHpgpHalCB.halStats.RxGoodSoundCnt++;
 830   2          //rssiLqi.reg         = ReadU32Reg(PLC_RSSILQI_REG);
 831   2              //plcRxFrmSwDesc.frmInfo.plc.rssi = rssiLqi.s.rssi;
 832   2              //plcRxFrmSwDesc.frmInfo.plc.lqi  = rssiLqi.s.lqi;  
 833   2            //printf(" SOUND: E48 REG = %lx, \n", rssiLqi.reg);
 834   2            rssiLqi.reg         = ReadU32Reg(PLC_RSSI_REG);
 835   2            //printf(" SOUND: E4C REG = %lx, \n", rssiLqi.reg);   
 836   2          }
 837   1          else 
 838   1          {
 839   2              gHpgpHalCB.halStats.RxGoodMgmtCnt++;
 840   2          }
 841   1                     
 842   1      #ifdef Z_P_BRIDGE
                  if (zb_plc_bridging) {
                      mac_hal_zb_pkt_bridge(pRxFrmDesc);
                      return;
                  }
              #endif  //Z_P_BRIDGE
 848   1      
 849   1          plcRxFrmSwDesc.frmInfo.plc.clst    = pRxPktQ1stDesc->sof.clst;
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 15  

 850   1          
 851   1          plcRxFrmSwDesc.frmInfo.plc.ssn = ssn;
 852   1      
 853   1          plcRxFrmSwDesc.cpArr[0].cp = pRxPktQCPDesc->plc.cp;
 854   1          plcRxFrmSwDesc.cpArr[0].offsetU32 =0;
 855   1          plcRxFrmSwDesc.lastDescLen  = pRxFrmDesc->lastDescLen;
 856   1      
 857   1          // 1.1.4 Read second and subsequent CP descriptors
 858   1          plcRxFrmSwDesc.cpCount = pRxFrmDesc->cpCount;
 859   1      
 860   1          for( i=1 ; i< plcRxFrmSwDesc.cpCount ; i++ )
 861   1          {
 862   2              plcRxFrmSwDesc.cpArr[i].cp = pRxFrmDesc->cpArr[i];
 863   2              plcRxFrmSwDesc.cpArr[i].offsetU32 = 0;
 864   2          }
 865   1          // 1.1.6 Call PLC Rx Callback -- tbd
 866   1        
 867   1      #ifdef PLC_TEST
                      cellAddr = CHAL_GetAccessToCP(plcRxFrmSwDesc.cpArr[0].cp);
                      
                      if((cellAddr[0] == '/') && 
                          (cellAddr[1] == '?') &&
                          (cellAddr[2] == '!'))//chek /?! header bytes for propritary protocol
                      {
                              
                          //printf("\n cell add");
                          //printmsg(&cellAddr[0],6);
                         gHpgpHalCB.halStats.RxGoodDataCnt--;
                          HHT_ProcessPlcFrame(&plcRxFrmSwDesc);
                      }
                     else
              #endif
 882   1          
 883   1      #ifdef HPGP_HAL_TEST
 884   1          if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_SOUND)
 885   1        // Sound  pakcet process
 886   1        { 
 887   2             printf("free sound packet, dt_av=%X\n", plcRxFrmSwDesc.frmType);
 888   2           CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
 889   2        }
 890   1        else
 891   1        {
 892   2          if(1 == eth_plc_bridge)
 893   2          //if((1 == eth_plc_bridge) && (plcRxFrmSwDesc.frmType != HPGP_HW_FRMTYPE_SOUND))
 894   2          { 
 895   3      #ifdef ASSOC_TEST         
                      if (plcRxFrmSwDesc.frmType == HPGP_HW_FRMTYPE_MGMT)
                      {
                           LM_RecvFrame(&plcRxFrmSwDesc,pRxPktQ1stDesc,
                                          pRxPktQCPDesc);
                      }
                      else
              #endif
 903   3              {
 904   4      #ifdef HYBRII_ETH
 905   4      //      memcpy((u8*)plcRxFrmSwDesc.fc, (u8*)pRxFrmDesc->fc, VF_SIZE);
 906   4      
 907   4      
 908   4            fwdAgent_handleData(&plcRxFrmSwDesc);
 909   4      #endif  //HYBRII_ETH
 910   4      
 911   4              }
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 16  

 912   3          }
 913   2          else
 914   2          {
 915   3              HHT_ProcessPlcMacFrame(&plcRxFrmSwDesc);
 916   3          }
 917   2        }  //End of frame type = SOUND
 918   1      
 919   1      #else  //HPGP_HAL_TEST
                  if(1 == eth_plc_bridge)
                  {
              #ifdef HYBRII_ETH
              //        memcpy((u8*)plcRxFrmSwDesc.fc, (u8*)pRxFrmDesc->fc, VF_SIZE);
              
              
                   fwdAgent_handleData(&plcRxFrmSwDesc);
              #else
                         CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
              #endif  //HYBRII_ETH
                  }
                  else
                  {
                      status = HAL_RecvFrame((sHaLayer *)cookie, &plcRxFrmSwDesc,pRxPktQ1stDesc,
                                          pRxPktQCPDesc);
                  }
                  
              
              #endif  //HPGP_HAL_TEST
 939   1          if (status == STATUS_FAILURE)
 940   1          {
 941   2              CHAL_FreeFrameCp(plcRxFrmSwDesc.cpArr, plcRxFrmSwDesc.cpCount);
 942   2          }
 943   1      }
*** WARNING C280 IN LINE 668 OF ..\..\hal\hal_hpgpRx.c: 'cellAddr': unreferenced local variable
*** WARNING C280 IN LINE 681 OF ..\..\hal\hal_hpgpRx.c: 'ethHdr': unreferenced local variable
 944          
 945          
 946          #ifdef HPGP_HAL_TEST
 947          extern sHalCB gHalCB;
 948          void HHAL_BcnRxIntHandler()
 949           {
 950   1              u32 xdata        rxBcnWordArr[(PLC_BCNRX_LEN>>2) + 5];  // 5 DWORD of Ether II header
 951   1                                                                         // and hostHdr_t
 952   1              u32              *prxBcnWordArr = NULL;
 953   1              u8*              rxBcnByteArr;
 954   1              u8               i, u8val;
 955   1              u8               bcnDataOffset;
 956   1              uPlcStatusReg    plcStatus;
 957   1              sHybriiRxBcnHdr* pRxBcnHdr;
 958   1              
 959   1              if(1 == eth_plc_sniffer)
 960   1              {
 961   2                  bcnDataOffset = (sizeof(hostHdr_t) + sizeof(sEth2Hdr));
 962   2          }
 963   1          else
 964   1          {
 965   2              bcnDataOffset = 0;
 966   2          }
 967   1      
 968   1      
 969   1          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
 970   1          rxBcnByteArr  = (u8*)rxBcnWordArr;
 971   1      
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 17  

 972   1          prxBcnWordArr =  (u32*)(rxBcnByteArr + bcnDataOffset);
 973   1          gHpgpHalCB.halStats.BcnRxIntCnt++;
 974   1          gHpgpHalCB.halStats.smRxStuckCnt = 0;
 975   1          // Confirm that Bcn Rx Fifo is not emplty.  //[YM] We should check the BcnCnt to make sure there is a 
             -valid beacon in RxFifo
 976   1          do
 977   1          {
 978   2              // Read from fifo to local memory.
 979   2              for( i=0 ; i<(PLC_BCNRX_LEN>>2) ; i++)
 980   2              {
 981   3                  prxBcnWordArr[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
 982   3              }
 983   2          // use R/W byte operation so we don't set plcTxQRdy here
 984   2          u8val = ReadU8Reg(PLC_STATUS_REG+1);
 985   2          u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
 986   2            WriteU8Reg(PLC_STATUS_REG+1, u8val);
 987   2             
 988   2              pRxBcnHdr = (sHybriiRxBcnHdr*)(rxBcnByteArr + (bcnDataOffset*4));
 989   2              // Update statistics.  //[YM] why check rsv1,2,3,4 bit fields??
 990   2              //if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && !
             -pRxBcnHdr->rsv3 && !pRxBcnHdr->rsv4)  
 991   2              if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect)
 992   2              {             
 993   3                  gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
 994   3                  gHpgpHalCB.halStats.RxGoodBcnCnt++;
 995   3                  gHpgpHalCB.halStats.macRxStuckCnt = 0; 
 996   3      #ifdef FREQ_DETECT
 997   3                      if(gHpgpHalCB.gFreqCB.freqDetected == FALSE && (gHpgpHalCB.devMode == DEV_MODE_STA))
 998   3                      {
 999   4                          FREQDET_DetectFrequencyUsingBcn();
1000   4                      }
1001   3      #endif
1002   3              }
1003   2              else
1004   2              {
1005   3                 gHpgpHalCB.halStats.RxErrBcnCnt++;
1006   3                 gHpgpHalCB.halStats.macRxStuckCnt++;  //[YM] It is not a right way to add macRxStuck count here
             -. 
1007   3              }
1008   2              // Call BeaconProcess function
1009   2              if(pRxBcnHdr->fccsCorrect)
1010   2              {
1011   3                  if(0 == eth_plc_sniffer)
1012   3                  {
1013   4                      HHAL_ProcBcnLow(rxBcnByteArr + bcnDataOffset * 4);
1014   4                  }
1015   3              }
1016   2      #ifdef HYBRII_ETH
1017   2              if(1 == eth_plc_sniffer)
1018   2              {
1019   3                  EHT_FromPlcBcnTx((rxBcnByteArr + sizeof(sHybriiRxBcnHdr)), 
1020   3                                       (PLC_BCNRX_LEN-sizeof(sHybriiRxBcnHdr)));
1021   3              }
1022   2      #endif
1023   2              // Any more beacons ?
1024   2              plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1025   2          } while (plcStatus.s.plcBcnCnt);
1026   1      }
1027          
1028          void HAL_SetCsmaRegions(uCSMARegionReg* regionArr)
1029          {
1030   1          uCSMARegionReg   *pCSMARgn;
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 18  

1031   1          u8 i = 0;
1032   1      
1033   1          pCSMARgn = regionArr;
1034   1          
1035   1      
1036   1          while(i < HYBRII_MAXSMAREGION_CNT)
1037   1          {
1038   2              switch(i)
1039   2              {
1040   3                  case 0:
1041   3                      
1042   3                      WriteU32Reg(PLC_CSMAREGION0_REG, (pCSMARgn->reg));
1043   3                      
1044   3                  break;
1045   3              
1046   3                  case 1:
1047   3                   WriteU32Reg(PLC_CSMAREGION1_REG, (pCSMARgn->reg));
1048   3                       //printf("\n ET2_low = %bu",  pCSMARgn->s.csma_endtime_lo);
1049   3                       //printf("\n ET2_h = %bu",  pCSMARgn->s.csma_endtime_hi);
1050   3                  break;
1051   3      
1052   3                  case 2:
1053   3                       WriteU32Reg(PLC_CSMAREGION2_REG, (pCSMARgn->reg));
1054   3                  break;
1055   3      
1056   3                  case 3:
1057   3                       WriteU32Reg(PLC_CSMAREGION3_REG, (pCSMARgn->reg));
1058   3                  break;
1059   3      
1060   3                  case 4:
1061   3                       WriteU32Reg(PLC_CSMAREGION4_REG, (pCSMARgn->reg));
1062   3                  break;
1063   3      
1064   3                  case 5:
1065   3                   WriteU32Reg(PLC_CSMAREGION5_REG, (pCSMARgn->reg));
1066   3                  break;
1067   3              }
1068   2              i++;
1069   2              pCSMARgn++;
1070   2          }
1071   1      }
1072          
1073          void process_region(u8 *dataptr)
1074          {
1075   1      //  sBEntry     *   pEntry;
1076   1          sRegion  *pRgn;
1077   1          uCSMARegionReg   *pCSMARgn;
1078   1          u8      i, rgn_num;
1079   1      //    u32     new_csma;
1080   1          u16     start_time;
1081   1          u8      update = 0;
1082   1          sRegions    *pRgns;
1083   1      
1084   1      //  pEntry = (sBEntry  *)dataptr;
1085   1      //  rgn_num = pEntry->entry.region.nr;
1086   1      //  pRgn = pEntry->entry.region.regn;
1087   1          pRgns = (sRegions *)dataptr;
1088   1          rgn_num = pRgns->nr;
1089   1          pRgn = pRgns->regn;
1090   1      
1091   1      //printf("rgns : %bd\n", rgn_num);
1092   1          memset(&csmaRegArr[0], 0, sizeof(csmaRegArr));
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 19  

1093   1          pCSMARgn = &csmaRegArr[0];
1094   1      
1095   1          start_time = 0;
1096   1        if (rgn_num > HYBRII_MAXSMAREGION_CNT)
1097   1          rgn_num = HYBRII_MAXSMAREGION_CNT;
1098   1      
1099   1          for (i=0; i < rgn_num; i++, pRgn++, pCSMARgn++)
1100   1          {
1101   2          // only set CSMA regions if they're different than previous values
1102   2          if (pRgn->reg16 != prevCsmaRgns[i])
1103   2          {
1104   3                update = 1;
1105   3      //      printf("update CSMA regions: pRgn->reg16=0x%x, prevCsmaRgns[%bu]=0x%x, rgn_num=%bu\n",pRgn->reg16, i,
             - prevCsmaRgns[i],rgn_num);
1106   3            prevCsmaRgns[i] = pRgn->reg16;
1107   3      
1108   3              pRgn->reg16 = rtocs(pRgn->reg16);
1109   3      
1110   3                pCSMARgn->s.csma_start_time_lo = 0; //start_time;
1111   3                pCSMARgn->s.csma_start_time_hi = 0;
1112   3                if(pRgn->s.region_type == REGION_TYPE_STAYOUT)
1113   3                    pCSMARgn->s.csma_rxOnly = 1;    //stayout region is rx only region
1114   3                //pCSMARgn->s.bcnRegion = 0; //pRgn->s.region_type;
1115   3                pCSMARgn->s.csma_hybrid = 1;
1116   3                pCSMARgn->s.csma_endtime_lo = pRgn->s.region_end_time & 0x00FF;
1117   3                pCSMARgn->s.csma_endtime_hi = ((pRgn->s.region_end_time & 0xFF00) >> 8);
1118   3                //printf("type:%X\n", pRgn->s.region_type);
1119   3                // printf("endHi: %bx\n", pCSMARgn->s.csma_endtime_hi);
1120   3                // printf("endLo: %bx\n", pCSMARgn->s.csma_endtime_lo);
1121   3                start_time = pRgn->s.region_end_time;
1122   3          }
1123   2      //    else printf(" no update CSMA region %bu\n", i);
1124   2          }
1125   1      
1126   1          if (update != 0)
1127   1          {
1128   2              /*for (i=rgn_num; i < HYBRII_MAXSMAREGION_CNT; i++, pCSMARgn++)
1129   2              {
1130   2                  pCSMARgn->reg = 0;  
1131   2              } */
1132   2      
1133   2            //  printf(" \n ET0_low = %bu", csmaRegArr[0].s.csma_endtime_lo);
1134   2             //  printf(" \n ET0_hi = %bu", csmaRegArr[0].s.csma_endtime_hi);
1135   2             //   printf(" \n ET1_low = %bu", csmaRegArr[1].s.csma_endtime_lo);
1136   2              // printf(" \n ET1_hi = %bu", csmaRegArr[1].s.csma_endtime_hi);
1137   2              
1138   2      
1139   2              HAL_SetCsmaRegions(csmaRegArr);
1140   2          }
1141   1      }
1142          
1143          #ifdef ASSOC_TEST
              extern u8 gCCoMacAddr;
              #endif
1146          void HHAL_ProcBcnLow(u8* bcn)
1147          {
1148   1          sHybriiRxBcnHdr* pRxBcnHdr;
1149   1          sFrmCtrlBlk*     pFrmCtrlBlk;
1150   1          sHybriiRxBcn*    rxBcn;      
1151   1          sBcnHdr*         pBcnHdr = 0;
1152   1          sBeHdr*          pBeHdr = 0;
1153   1          u8               hm; 
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 20  

1154   1          u8               reqDiscList = 0;
1155   1          u8               nbe = 0;
1156   1          u8*              dataptr = 0;
1157   1          u8*              macAddr = 0;   
1158   1          u32              bts;
1159   1      
1160   1          rxBcn       = (sHybriiRxBcn*)bcn;
1161   1          pRxBcnHdr   = (sHybriiRxBcnHdr*)bcn; 
1162   1          pFrmCtrlBlk = (sFrmCtrlBlk*) (bcn + sizeof(sHybriiRxBcnHdr)) ;
1163   1          pBcnHdr     = (sBcnHdr*) ((u8*)pFrmCtrlBlk + sizeof(sFrmCtrlBlk)); 
1164   1          hm          = (pBcnHdr->nid[NID_LEN-1])&0xC0;
1165   1          //pBcnHdr->nid[NID_LEN-1] &= 0x3F;
1166   1          //pBcnHdr->nid[NID_LEN-1] &= 0xFC;                          
1167   1          nbe         = pBcnHdr->nbe;
1168   1          dataptr     = (u8*)pBcnHdr + sizeof(sBcnHdr);
1169   1          pBeHdr      = (sBeHdr*) dataptr;
1170   1      
1171   1          bts  =  ((u32)(pFrmCtrlBlk->bts[3])<<24) + ((u32)(pFrmCtrlBlk->bts[2])<<16) + ((u32)(pFrmCtrlBlk->bts[
             -1])<<8) + (u32)(pFrmCtrlBlk->bts[0]); 
1172   1          memcpy(gHpgpHalCB.nid, pBcnHdr->nid, NID_LEN);
1173   1      
1174   1          gHpgpHalCB.nid[NID_LEN-1]  &= NID_EXTRA_BIT_MASK;
1175   1          // Extract Bto, deduce AC mode Cco's Bcn Period Len and write SWBcnPeriodAvg register.
1176   1      
1177   1         // HHAL_AdjustNextBcnTime(&pFrmCtrlBlk->bto[0]);
1178   1         /* if (gHpgpHalCB.lineMode == LINE_MODE_AC)
1179   1          {   
1180   1             
1181   1              if(gHpgpHalCB.devMode == DEV_MODE_STA)
1182   1              {
1183   1                  WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(PLC_AC_BP_LEN));//33.31
1184   1                  //WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(0xCB5E8));
1185   1                  
1186   1              }
1187   1          }*/
1188   1         
1189   1      
1190   1          // Process Low MAC relevant BENTRYs
1191   1          if(gHpgpHalCB.devMode == DEV_MODE_STA &&  pRxBcnHdr->pbcsCorrect  && pRxBcnHdr->valid)
1192   1          {
1193   2              while(nbe)
1194   2              { 
1195   3                  dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1196   3                  switch (pBeHdr->beType)
1197   3                  {
1198   4                      case BEHDR_MAC_ADDR:
1199   4                      {
1200   5                          macAddr = dataptr;
1201   5      #ifdef ASSOC_TEST
                                  memcpy ((u8*)&gCCoMacAddr, macAddr, 6);
              #endif
1204   5                          break;
1205   5                      }
1206   4                      case BEHDR_BPSTO:
1207   4                      {        
1208   5                          
1209   5                           gsnid = pFrmCtrlBlk->snid;
1210   5                            
1211   5                          if( ((pBcnHdr->bt == BEACON_TYPE_CENTRAL) || (pBcnHdr->bt == BEACON_TYPE_PROXY))   &&
1212   5                                (pFrmCtrlBlk->snid == gHpgpHalCB.snid) && gHpgpHalCB.nwSelected )              
1213   5                           {
1214   6                              gHpgpHalCB.snapShot = pRxBcnHdr->snapShot;
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 21  

1215   6                              gHpgpHalCB.bcnDetectFlag = 1;
1216   6                              HHAL_SyncNet(dataptr);
1217   6                           }
1218   5                          break;
1219   5                      }
1220   4                      case BEHDR_REGIONS:
1221   4                          process_region(dataptr); // WAR: Need to revisit code, deactivated to reduce loss in l
             -ower mac
1222   4                          break;
1223   4      
1224   4                      default:
1225   4                      {
1226   5                          break;
1227   5                      }
1228   4                  }
1229   3                  //move to the next BEHDR
1230   3                  dataptr = dataptr + pBeHdr->beLen; 
1231   3                  pBeHdr = (sBeHdr*) dataptr;
1232   3                  nbe--;
1233   3              }
1234   2              HHT_ProcessBcnHle(bcn);
1235   2          }
1236   1       
1237   1      }
1238          
1239          
1240          void HHAL_BcnRxTimeoutIntHandler()
1241          {
1242   1      //     uPlcLineControlReg plcLineCtrl;
1243   1      
1244   1      
1245   1        
1246   1      
1247   1         
1248   1         /* if(gtimer2 > gsyncTimeout)  //if time is greate then 40 ms
1249   1          {
1250   1              
1251   1              //gflag = 0;
1252   1             // printf("\n miss");
1253   1              misscnt++;
1254   1           
1255   1              gbpst1 += gBcnPer; 
1256   1              gtimer2 = 1;
1257   1              WriteU32Reg(PLC_BPST_REG,ctorl(gbpst1)); 
1258   1           }*/
1259   1          /* misscnt++;
1260   1      
1261   1           if(misscnt > 6)   //go for rescan
1262   1           {
1263   1              
1264   1              if(gHpgpHalCB.lineMode == LINE_MODE_DC )
1265   1                  WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8F430000));
1266   1              else 
1267   1                  WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8CB60000));
1268   1              
1269   1              gHpgpHalCB.scanEnb           = 0;
1270   1              HHAL_SetSWStatReqScanFlag(REG_FLAG_SET); //afetr this when we receive next bcn snid will be set an
             -d nw sel will be set
1271   1              gtimer2 = 0;
1272   1              misscnt =0;
1273   1              gHpgpHalCB.devMode = DEV_MODE_STA;
1274   1              HHAL_SetDevMode(gHpgpHalCB.devMode, gHpgpHalCB.lineMode); 
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 22  

1275   1              HHAL_SetDefAddrConfig();
1276   1              printf("\n Rescan");
1277   1           }   */
1278   1           /*if(gtimer1 > gBcnMissingRescanCnt)
1279   1           {
1280   1              if(gHpgpHalCB.lineMode == LINE_MODE_DC )
1281   1                  WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8F430000));
1282   1              else 
1283   1                  WriteU32Reg(PLC_CSMAREGION0_REG, ctorl(0x8CB60000));
1284   1              
1285   1              gHpgpHalCB.scanEnb           = 0;
1286   1              HHAL_SetSWStatReqScanFlag(REG_FLAG_SET); //afetr this when we receive next bcn snid will be set an
             -d nw sel will be set
1287   1              gtimer2 = 0;
1288   1              gtimer1 = 0;
1289   1              gHpgpHalCB.devMode = DEV_MODE_STA;
1290   1              HHAL_SetDevMode(gHpgpHalCB.devMode, gHpgpHalCB.lineMode); 
1291   1              HHAL_SetDefAddrConfig();
1292   1              printf("\n rescan");
1293   1              
1294   1           }*/ 
1295   1      
1296   1          //if((gHalCB.timerIntCnt >= gHpgpHalCB.lastBcnRxTime + 13) && (gflag ==1)) //13 *4 = 52ms
1297   1         /* if((gHalCB.timerIntCnt >= gHpgpHalCB.lastBcnRxTime + 12) && (gflag ==1)) //13 *4 = 52ms
1298   1          {
1299   1             
1300   1              gflag = 0;
1301   1              //if(gtimer2 > 10)   //we miss bcn
1302   1              if(gtimer2 > 9)   //we miss bcn
1303   1              {
1304   1                 gHpgpHalCB.lastBcnRxTime = (gHalCB.timerIntCnt - 4); 
1305   1                 gflag = 1; 
1306   1                 //gtimer2 = 0;
1307   1                  printf("\n miss");
1308   1                   if(gHpgpHalCB.lineMode == LINE_MODE_DC)
1309   1               gbpst1 += PLC_DC_BP_LEN;
1310   1               else
1311   1                gbpst1 += PLC_AC_BP_LEN;
1312   1      
1313   1             WriteU32Reg(PLC_BPST_REG,ctorl(gbpst1)); 
1314   1              }
1315   1             
1316   1          } */
1317   1      
1318   1      }    
1319          
1320          /*
1321          void HHAL_BPIntHandler()
1322          {
1323              uPlcMedStatReg  plcMedStat;   
1324              uPlcStatusReg   plcStatus;
1325              static u32 prevBPInt_TimerCnt;
1326              static u32 curBPInt_TimerCnt;
1327              static u8  bpInit;
1328          
1329              // Determine time gap between 2  consecutive HPGP BP interrupts.
1330              if( gHpgpHalCB.halStats.bpIntCnt )
1331              {
1332                    bpInit = 1;
1333              } 
1334              if( bpInit )
1335              {
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 23  

1336                  prevBPInt_TimerCnt = curBPInt_TimerCnt;
1337              }
1338              curBPInt_TimerCnt   = gHalCB.timerIntCnt;
1339              gHpgpHalCB.bpIntGap = curBPInt_TimerCnt - prevBPInt_TimerCnt;
1340              gHpgpHalCB.halStats.bpIntCnt++;
1341          
1342              // Compute running average of prev 64 ZeroCrossing periods
1343              // and write to Bcn Period Average register.
1344              if( gHpgpHalCB.devMode == DEV_MODE_CCO && gHpgpHalCB.lineMode == LINE_MODE_AC )
1345              {
1346                  //printf("HW Bcn PER = %lx\n",rtocl(ReadU32Reg(PLC_HWBCNPERLEN_REG)));
1347                  gHpgpHalCB.curBcnPer = rtocl(ReadU32Reg(PLC_HWBCNPERCUR_REG));
1348                  if( gHpgpHalCB.curBcnPer < PLC_MIN_AC_BPLEN )
1349                  {
1350                      gHpgpHalCB.curBcnPer = PLC_MIN_AC_BPLEN;
1351                  }
1352                  else if( gHpgpHalCB.curBcnPer > PLC_MAX_AC_BPLEN )
1353                  {
1354                      gHpgpHalCB.curBcnPer = PLC_MAX_AC_BPLEN;
1355                  }
1356          
1357                  gHpgpHalCB.bcnPerSum += gHpgpHalCB.curBcnPer;
1358                  gHpgpHalCB.perSumCnt ++;
1359          
1360                  if( gHpgpHalCB.perSumCnt >= PLC_BCNPERAVG_CNT )
1361                  {
1362                      gHpgpHalCB.bPerAvgInitDone = 1;
1363                  }
1364                  if( gHpgpHalCB.bPerAvgInitDone )
1365                  {
1366                      gHpgpHalCB.curBcnPer       = gHpgpHalCB.bcnPerSum >> PLC_BCNPERAVG_DIVCNT;
1367                      gHpgpHalCB.bcnPerSum      -= gHpgpHalCB.curBcnPer;
1368                  }
1369                  WriteU32Reg(PLC_SWBCNPERAVG_REG, ctorl(gHpgpHalCB.curBcnPer));
1370                  //WriteU32Reg( PLC_SWBCNPERAVG_REG, ctorl(0xCB735));
1371                  //printf("SW Bcn PER = %lx\n",gHpgpHalCB.curBcnPer);
1372              }
1373          
1374              // Prepare and send beacon here for now.
1375              // This will eventually be done by hpgp nsm module.
1376              HHT_BPIntHandler();
1377          
1378              // PHY Active Hang workaround
1379              plcStatus.reg  = ReadU32Reg(PLC_STATUS_REG);
1380              plcMedStat.reg = ReadU32Reg(PLC_MEDIUMSTATUS_REG); 
1381              if( plcMedStat.s.phyActive && plcMedStat.s.mpiRxEn )
1382              {
1383                  if(gHpgpHalCB.halStats.paRxEnHiCnt > PLC_RXPHYACT_HANG_THRES )
1384                  {
1385          #ifdef _RX_RECOVERY_                        
1386                      plcStatus.s.nRxEn = 1;
1387                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1388                      CHAL_DelayTicks(5);
1389                      
1390                      plcStatus.s.plcRxEnSwCtrl  = 0;
1391                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg);
1392          
1393                      plcStatus.s.plcRxEnSwCtrl  = 1;
1394                      WriteU32Reg(PLC_STATUS_REG, plcStatus.reg); 
1395          #endif             
1396                      gHpgpHalCB.halStats.paRxEnHiCnt = 0;   
1397                      gHpgpHalCB.halStats.phyActHangRstCnt++;                    
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 24  

1398                  }
1399                  else if( gHpgpHalCB.halStats.prevBPTotalRxCnt == gHpgpHalCB.halStats.TotalRxGoodFrmCnt )
1400                  {
1401                      gHpgpHalCB.halStats.paRxEnHiCnt ++;
1402                  } 
1403                  else
1404                  {
1405                      gHpgpHalCB.halStats.paRxEnHiCnt = 0;  
1406                  }                
1407              }
1408              gHpgpHalCB.halStats.prevBPTotalRxCnt = gHpgpHalCB.halStats.TotalRxGoodFrmCnt;  
1409          }
1410          */
1411          #else  /* HPGP_HAL_TEST */
              
              u8 HHAL_IsSnidMatched (sHaLayer *hal, uRxCpDesc *rxCpDesc)
              {
                  u8  snid;
                  snid = rxCpDesc->plc.snidHi;
                  snid = (snid << PKTQDESC1_SNIDHI_POS) | rxCpDesc->plc.snidLo;
                  return (snid == hal->hhalCb->snid);
              }
              
              #if 0
              eStatus HHAL_ProcRxFrameDesc(sHaLayer *hal, 
                                         uRxFrmHwDesc *rxFrmHwDesc, 
                                         sRxFrmSwDesc *rxFrmSwDesc)
              {
                  uPlcRssiLqiReg   rssiLqi;
                  u8               stei;
              
                  /*  LQI and RSSI */
                  rssiLqi.reg = ReadU32Reg(PLC_RSSILQI_REG);
                  rxFrmSwDesc->frmInfo.plc.rssi = rssiLqi.s.rssi;
                  rxFrmSwDesc->frmInfo.plc.lqi = rssiLqi.s.lqi;
              
                  /*  multicast and unicast */
                  if(rxFrmHwDesc->plc.bcst)
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MNBCST;
                  }
                  else if(rxFrmHwDesc->plc.mcst)
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_MCST;
                  }
                  else
                  {
                      rxFrmSwDesc->frmInfo.plc.mcstMode = HPGP_UCST;
                  }
              
                  /* source TEI */
                  stei = rxFrmHwDesc->plc.steiHi2;
                  stei = (stei << PKTQDESC1_STEIHI_POS ) | rxFrmHwDesc->plc.steiLo6;
                  rxFrmSwDesc->frmInfo.plc.stei = stei;
              
                  /* CLST */
                  rxFrmSwDesc->frmInfo.plc.clst = rxFrmHwDesc->plc.clst;
                  return STATUS_SUCCESS;
              
              }
              
              #endif
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 25  

              
              
              
              #endif /* HPGP_HAL_TEST */
1464          
1465          
1466          
1467          void HAL_beaconRxHandler(void *cookie)
1468           {
1469   1       
1470   1      #ifndef HPGP_HAL_TEST
                sHaLayer         *hal = (sHaLayer *)cookie;
                sHpgpHalCB       *hhalCb = hal->hhalCb;
                  sEvent           *event = NULL;
                  sHpgpHdr         *hpgpHdr = NULL;
              #else //#ifndef HPGP_HAL_TEST
1476   1          // 5 DWORD of Ether II header
1477   1        sHpgpHalCB       *hhalCb = &gHpgpHalCB;                              // and hostHdr_t
1478   1      #endif // #ifndef HPGP_HAL_TEST
1479   1          sBcnHdr        *bcnHdr = NULL;
1480   1        u32 xdata    rxBcnWordArr[(PLC_BCNRX_LEN>>2) + 5];
1481   1        sFrmCtrlBlk      *pFrmCtrlBlk = NULL;
1482   1      
1483   1        u32              *prxBcnWordArr = NULL;
1484   1        u8*              rxBcnByteArr;
1485   1        u8               i, u8val;
1486   1        u32        bts;
1487   1        u8               bcnDataOffset;
1488   1        sHybriiRxBcnHdr* pRxBcnHdr;
1489   1          
1490   1          uPlcStatusReg    plcStatus;
1491   1        
1492   1        if(1 == eth_plc_sniffer)
1493   1        {
1494   2          bcnDataOffset = (sizeof(hostHdr_t) + sizeof(sEth2Hdr));
1495   2        }
1496   1        else
1497   1        {
1498   2          bcnDataOffset = 0;
1499   2        }
1500   1      
1501   1          // Confirm that Bcn Rx Fifo is not emplty.  //[YM] We should check the BcnCnt to make sure there is a 
             -valid beacon in RxFifo
1502   1          do
1503   1        {
1504   2            
1505   2              if(eth_plc_sniffer == 1)
1506   2              {
1507   3                  // Size for (Ethernet header  + Hybri header) added
1508   3                  //event = EVENT_Alloc(BEACON_LEN + (sizeof(sEth2Hdr) + sizeof(hostHdr_t)+4), sizeof(sHpgpHdr))
             -;
1509   3                  rxBcnByteArr  = (u8*)(rxBcnWordArr);
1510   3              }
1511   2              else
1512   2              {
1513   3              
1514   3      #ifndef HPGP_HAL_TEST
                  
                          event = EVENT_BcnAlloc(BEACON_LEN, sizeof(sHpgpHdr));
                    if (event == NULL)
                          {
                              FM_Printf(FM_ERROR, "Bcn.AllocErr\n");
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 26  

                              return;
                          }
                    
                  
                          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
                          event->eventHdr.type = EVENT_TYPE_CC_BCN_IND;
                          
                          rxBcnByteArr = event->buffDesc.dataptr;
                          
                          event->buffDesc.datalen = BEACON_LEN;
              #else
1531   3                  rxBcnByteArr  = (u8*)(rxBcnWordArr);
1532   3          
1533   3      #endif
1534   3          
1535   3              }
1536   2              
1537   2              prxBcnWordArr =  (u32*)((u8*)rxBcnByteArr + bcnDataOffset);
1538   2              
1539   2              hhalCb->halStats.smRxStuckCnt = 0;
1540   2          // Read from fifo to local memory.
1541   2          for( i=0 ; i<(PLC_BCNRX_LEN>>2) ; i++)
1542   2          {
1543   3            prxBcnWordArr[i] = ReadU32Reg(PLC_BCNRXFIFO_REG);
1544   3          }
1545   2              
1546   2              bcnHdr = (sBcnHdr *) (rxBcnByteArr + (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr)));
1547   2          hhalCb->halStats.BcnRxIntCnt++;            
1548   2      
1549   2          pRxBcnHdr = (sHybriiRxBcnHdr*)&prxBcnWordArr[0];
1550   2      
1551   2          hhalCb->snapShot = pRxBcnHdr->snapShot;
1552   2          
1553   2          // use R/W byte operation so we don't set plcTxQRdy here
1554   2          plcStatus.reg = ReadU32Reg(PLC_STATUS_REG);
1555   2          u8val = ReadU8Reg(PLC_STATUS_REG+1);
1556   2          u8val |= 0x80;    // plcBcnCntDecr (bit 15 of PLC_STATUS_REG)
1557   2          WriteU8Reg(PLC_STATUS_REG+1, u8val);
1558   2      
1559   2              
1560   2              
1561   2      
1562   2          if(1 == eth_plc_sniffer)
1563   2          {
1564   3          
1565   3          
1566   3      #ifdef HYBRII_ETH        
1567   3            EHT_FromPlcBcnTx((rxBcnByteArr + sizeof(sHybriiRxBcnHdr)), 
1568   3                     (PLC_BCNRX_LEN-sizeof(sHybriiRxBcnHdr)));
1569   3      #endif
1570   3            return;
1571   3      
1572   3          }
1573   2      
1574   2          // Update statistics.  //[YM] why check rsv1,2,3,4 bit fields??
1575   2          //if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect && !pRxBcnHdr->rsv1 && !pRxBcnHdr->rsv2 && !pRxBcn
             -Hdr->rsv3 && !pRxBcnHdr->rsv4)  
1576   2          if(pRxBcnHdr->fccsCorrect && pRxBcnHdr->pbcsCorrect)
1577   2          {             
1578   3            gHpgpHalCB.halStats.TotalRxGoodFrmCnt++;
1579   3            gHpgpHalCB.halStats.RxGoodBcnCnt++;
1580   3            gHpgpHalCB.halStats.macRxStuckCnt = 0; 
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 27  

1581   3       #ifdef FREQ_DETECT
1582   3                      if((gHpgpHalCB.gFreqCB.freqDetected == FALSE) &&  (gHpgpHalCB.devMode == DEV_MODE_STA))
1583   3                      {
1584   4                          FREQDET_DetectFrequencyUsingBcn();
1585   4      //                    printf("\n using bcn \n");
1586   4                      }
1587   3      #endif
1588   3      
1589   3          }
1590   2          else
1591   2          {
1592   3            gHpgpHalCB.halStats.RxErrBcnCnt++;
1593   3            gHpgpHalCB.halStats.macRxStuckCnt++;  //[YM] It is not a right way to add macRxStuck count here. 
1594   3      
1595   3      #ifndef HPGP_HAL_TEST
              
                    EVENT_Free(event);
                    
              #endif
1600   3            return;
1601   3          }
1602   2      
1603   2          
1604   2      
1605   2          pFrmCtrlBlk = (sFrmCtrlBlk*) (rxBcnByteArr + sizeof(sHybriiRxBcnHdr)) ;
1606   2          
1607   2          bts  =  ((u32)(pFrmCtrlBlk->bts[3])<<24) +
1608   2              ((u32)(pFrmCtrlBlk->bts[2])<<16) + 
1609   2              ((u32)(pFrmCtrlBlk->bts[1])<<8) + 
1610   2               (u32)(pFrmCtrlBlk->bts[0]); 
1611   2          if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1612   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
1613   2                  {     
1614   3                      
1615   3                      hhalCb->bcnmisscnt = 0;
1616   3                  gCCO_BTS = bts;
1617   3                  hhalCb->bts = bts;
1618   3                      hhalCb->bcnDetectFlag = 1;
1619   3                  }
1620   2      #ifdef ROUTE_TEST
              
                      for(i=0; i < 3; i++)
                      {
                          if(bcnHdr->stei == dropTei[i])
                          {
              
                              
              #ifndef HPGP_HAL_TEST
                              
                                          EVENT_Free(event);
                                          
              #endif
                                          return;
                          }
                      }
                  
              #endif
1638   2      
1639   2      #ifdef HPGP_HAL_TEST
1640   2          
1641   2              HHAL_ProcBcnLow(rxBcnByteArr);
1642   2      #else
C51 COMPILER V9.52.0.0   HAL_HPGPRX                                                        01/10/2015 21:25:25 PAGE 28  

              
                  hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
                  hpgpHdr->snid = pFrmCtrlBlk->snid;
              
                  event->buffDesc.dataptr += (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr));
                  event->buffDesc.datalen -= (sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr)); 
                  
                  if (hhalCb->devMode == DEV_MODE_CCO)
                  {
              #ifdef CCO_FUNC
                    LINKL_CcoProcBcnHandler(hal->bcnCookie, event);
              #endif
                  }
                  else 
                  {
              #ifdef STA_FUNC
                    LINKL_StaProcBcnHandler(hal->bcnCookie, event);
              #endif
                  }
              
                  MUXL_RecvMgmtPacket(hal->mgmtCookie, event);
              
              
              #endif
1667   2      
1668   2      
1669   2      
1670   2        }while(plcStatus.s.plcBcnCnt);
1671   1      
1672   1      }
*** WARNING C280 IN LINE 1467 OF ..\..\hal\hal_hpgpRx.c: 'cookie': unreferenced local variable
1673          
1674          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2981    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =     64     553
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
