C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE APP_SUP_LAYER
OBJECT MODULE PLACED IN .\obj\app_sup_layer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\app_support\app_sup_layer.c LARGE OBJECTADVANCED OP
                    -TIMIZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;
                    -..\..\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hp
                    -gp\src\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\
                    -..\..\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmwa
                    -re\zigbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\
                    -event\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\component
                    -s\hpgp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_
                    -support;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components
                    -\drivers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\compo
                    -nents;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\.
                    -.\..\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components
                    -\drivers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\
                    -utilities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\d
                    -rivers\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;
                    -..\..\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HA
                    -L,HYBRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,
                    -NEW_SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,
                    -FREQ_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_
                    -INTERRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO
                    -_APP,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\app_sup_layer
                    -.lst) TABS(2) OBJECT(.\obj\app_sup_layer.obj)

line level    source

   1          #ifdef NO_HOST
   2          #include <stdio.h>
   3          #include <string.h>
   4          #include "papdef.h"
   5          #include "list.h"
   6          #include "event.h"
   7          #include "hal_common.h"
   8          #include "dmm.h"
   9          #include "nma.h"
  10          #include "gv701x_osal.h"
  11          #include "app_sup_layer.h"
  12          #include "dmm.h"
  13          #include "hpgpevt.h"
  14          #include "hal_hpgp.h"
  15          #include "hpgpdef.h"
  16          #include "linkl.h"
  17          #include "nma.h"
  18          #include "nma_fw.h"
  19          #include "green.h"
  20          #include "fm.h"
  21          #include "frametask.h"
  22          #ifdef RTX51_TINY_OS
  23          #include <rtx51tny.h>
  24          #endif
  25          #include "hybrii_tasks.h"
  26          #ifdef HYBRII_SPI
              #include "hal_spi.h"
              #endif
  29          #ifdef UART_HOST_INTF
  30          #include "gv701x_uartdriver_fw.h"
  31          #endif
  32          #ifdef HYBRII_ETH
              #include "hal_eth.h"
              #endif
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 2   

  35          
  36          #define APP_MEM_POOL_SIZE         4048 //5632//5000 //
  37          #define APP_MEM_SLAB_SEG_SIZE_0   32
  38          #define APP_MEM_SLAB_SEG_SIZE_1   64
  39          #define APP_MEM_SLAB_SEG_SIZE_2   150
  40          #define APP_MEM_SLAB_SEG_SIZE_3   196 
  41          #define APP_MEM_SLAB_SEG_SIZE_4   256 
  42          #define APP_MEM_SLAB_SEG_SIZE_5   560
  43          #define APP_MEM_SLAB_SEG_SIZE_6   1024
  44          
  45          extern sNma *HOMEPLUG_GetNma() ;
  46          
  47          #ifdef SW_BCST
              #define SW_SSN_SIZE 1
              #define BCST_RETRY  3
              extern volatile u8 gSoftBCST;
              #endif
  52          
  53          gv701x_aps_queue_t appSupLayer;
  54          u8 gapp_id = 0;
  55          
  56          u8 XDATA AppMemPool[APP_MEM_POOL_SIZE];
  57          sSlist peripheralTxQ;
  58          //sSlist peripheralRxQ;
  59          #if 0
              
              static sSlabDesc AppSlabDesc[] =
              {
                  {4, APP_MEM_SLAB_SEG_SIZE_0},
                  {5, APP_MEM_SLAB_SEG_SIZE_1},
                  {6, APP_MEM_SLAB_SEG_SIZE_2},
                  {6, APP_MEM_SLAB_SEG_SIZE_3},
                  {6, APP_MEM_SLAB_SEG_SIZE_4},
                  {0, APP_MEM_SLAB_SEG_SIZE_5},    
                  {0, APP_MEM_SLAB_SEG_SIZE_6},
              };
              #else
  72          static sSlabDesc AppSlabDesc[] =
  73          {
  74              {4, APP_MEM_SLAB_SEG_SIZE_0},
  75              {2, APP_MEM_SLAB_SEG_SIZE_1},
  76              {6, APP_MEM_SLAB_SEG_SIZE_2},
  77              {6, APP_MEM_SLAB_SEG_SIZE_3},
  78              {5, APP_MEM_SLAB_SEG_SIZE_4},
  79              {0, APP_MEM_SLAB_SEG_SIZE_5},    
  80              {0, APP_MEM_SLAB_SEG_SIZE_6},
  81          };
  82          #endif
  83          extern sDmm AppDmm;
  84          extern u8 opMode;
  85          #ifdef UART_HOST_INTF
  86          extern bool hal_uart_tx (sEvent * event);
  87          #endif
  88          extern sHomePlugCb HomePlug;
  89          
  90          extern void Host_RxHandler(sHaLayer *pHal, sCommonRxFrmSwDesc* pRxFrmDesc);
  91          
  92          gv701x_aps_queue_t* Aps_init(void)
  93          { 
  94   1        sNma * nma = HOMEPLUG_GetNma();
  95   1        /*Create transmit queue for application data tx*/
  96   1        SLIST_Init(&appSupLayer.txQueue);
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 3   

  97   1      
  98   1        /*Create recieve queue for sending data to application*/
  99   1        SLIST_Init(&appSupLayer.rxQueue);
 100   1      
 101   1        /*Create recieve queue for sending response/event to application*/
 102   1        SLIST_Init(&appSupLayer.rspEvntRxQueue);
 103   1      
 104   1        appSupLayer.reqTxQueue = &nma->eventQueue;
 105   1        
 106   1          SLIST_Init(&peripheralTxQ);    
 107   1        //  SLIST_Init(&peripheralRxQ);
 108   1      
 109   1        DMM_Init(APP_POOL_ID);
 110   1        DMM_InitMemPool(APP_POOL_ID, AppMemPool, sizeof(AppMemPool), AppSlabDesc, 
 111   1                sizeof(AppSlabDesc)/sizeof(AppSlabDesc[0]));
 112   1      
 113   1        if(opMode == UPPER_MAC)
 114   1        {
 115   2          GV701x_TaskInit(&appSupLayer);
 116   2            os_create_task(HYBRII_TASK_ID_APP);
 117   2          os_switch_task(); 
 118   2        }
 119   1        return &appSupLayer;
 120   1      }
 121          
 122          eStatus Aps_PostDataToQueue(u8 src_port, sSwFrmDesc* plcRxFrmSwDesc)
 123          { 
 124   1        sEvent* event = NULL; 
 125   1        u16 payloadlen, frmLen; 
 126   1        volatile u8 xdata * cellAddr1stCP;
 127   1          u8 i;
 128   1          u16 len = 0;
 129   1        
 130   1        if((src_port != PORT_PLC) && (src_port != PORT_PERIPHERAL) &&
 131   1          (src_port != PORT_ZIGBEE))
 132   1        {
 133   2          CHAL_FreeFrameCp(plcRxFrmSwDesc->cpArr, plcRxFrmSwDesc->cpCount);     
 134   2          return STATUS_FAILURE;
 135   2        }
 136   1      
 137   1        event = GV701x_EVENT_Alloc(plcRxFrmSwDesc->frmLen, 0);
 138   1      
 139   1        if(event == NULL)
 140   1        {
 141   2              CHAL_FreeFrameCp(plcRxFrmSwDesc->cpArr, plcRxFrmSwDesc->cpCount);
 142   2          gHpgpHalCB.halStats.HtoPswDropCnt++;
 143   2          return STATUS_FAILURE;
 144   2        }
 145   1          event->eventHdr.eventClass = EVENT_CLASS_DATA;
 146   1          event->eventHdr.type = 0;
 147   1        if(src_port == PORT_PLC)
 148   1            event->eventHdr.trans = APP_PORT_PLC;
 149   1        else if(src_port == PORT_PERIPHERAL)
 150   1            event->eventHdr.trans = APP_PORT_PERIPHERAL;
 151   1        else if(src_port == PORT_ZIGBEE)
 152   1            event->eventHdr.trans = APP_PORT_ZIGBEE;
 153   1        
 154   1          event->buffDesc.datalen = plcRxFrmSwDesc->frmLen;
 155   1          frmLen = plcRxFrmSwDesc->frmLen;
 156   1          for(i=0; i<plcRxFrmSwDesc->cpCount; i++)
 157   1          {
 158   2            cellAddr1stCP  = CHAL_GetAccessToCP(plcRxFrmSwDesc->cpArr[i].cp);
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 4   

 159   2              if(frmLen < HYBRII_CELLBUF_SIZE)
 160   2              {
 161   3                  payloadlen = frmLen;
 162   3              }
 163   2              else
 164   2            {
 165   3                  payloadlen = HYBRII_CELLBUF_SIZE;
 166   3              }
 167   2              if(cellAddr1stCP)
 168   2              {
 169   3                  memcpy((u8*)(&(event->buffDesc.dataptr[len])), cellAddr1stCP, payloadlen);              
 170   3              }
 171   2              len += payloadlen;
 172   2              frmLen -= payloadlen;
 173   2          }
 174   1      
 175   1          /* enqueue the event to the transmit queue */
 176   1      __CRIT_SECTION_BEGIN__
 177   1        SLIST_Put(&(appSupLayer.rxQueue), &event->link);  
 178   1      __CRIT_SECTION_END__
 179   1      
 180   1          CHAL_FreeFrameCp(plcRxFrmSwDesc->cpArr, plcRxFrmSwDesc->cpCount);
 181   1      #ifdef RTX51_TINY_OS  
 182   1        os_set_ready(HYBRII_TASK_ID_APP);
 183   1      #endif  
 184   1      
 185   1        //Should there be a os_set_ready() call here ?
 186   1          return STATUS_SUCCESS;       
 187   1      }
 188          
 189          eStatus Aps_PostRspEventToQueue(sEvent* event)
 190          { 
 191   1        SLINK_Init(&event->link);
 192   1      
 193   1          /* enqueue the event to the response transmit queue */
 194   1        SLIST_Put(&(appSupLayer.rspEvntRxQueue), &event->link);   
 195   1      
 196   1      #ifdef RTX51_TINY_OS  
 197   1        os_set_ready(HYBRII_TASK_ID_APP);
 198   1      #endif  
 199   1      
 200   1        //Should there be a os_set_ready() call here ?
 201   1          return STATUS_SUCCESS;       
 202   1      }
 203          
 204          #if 0
              void Aps_TxData(u8 dstn_port, u8* buff, u16 len)
              {
                if((dstn_port != APP_PORT_PLC) &&
                  (dstn_port != APP_PORT_PERIPHERAL) &&
                  (dstn_port != APP_PORT_ZIGBEE))
                  return;
                
                if(len > HYBRII_CELLBUF_SIZE)
                  return;
                
                if(dstn_port == APP_PORT_PLC)
                {
                  eStatus status;
                  u8 eth_hdr_cp = 0;
                  u8 xdata* cellAddr;
                  sCommonRxFrmSwDesc RxFrmDesc;
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 5   

                  uRxPktQDesc1* pRxPktQ1stDesc;
                  uRxPktQCPDesc* pRxPktQCPDesc;
                  sHaLayer *pHal = &(HomePlug.haLayer); //HOMEPLUG_GetHal();
                  memset((u8*)&RxFrmDesc, 0x00, sizeof(RxFrmDesc));     
                  status = CHAL_RequestCP(&eth_hdr_cp);
              
                  if (status != STATUS_SUCCESS)
                  {
                    FM_Printf(FM_ERROR, "\nCP alloc fail");
                    return;
                  }
                  
                  cellAddr = CHAL_GetAccessToCP(eth_hdr_cp);
                  memset(cellAddr, 0x00, HYBRII_CELLBUF_SIZE);      
                  RxFrmDesc.cpArr[0] = eth_hdr_cp;
                  RxFrmDesc.cpCount = 1;
                  memcpy((u8*)cellAddr, buff, (u8)len);
                  pRxPktQ1stDesc = (uRxPktQDesc1*)&RxFrmDesc.hdrDesc;
                  pRxPktQCPDesc  = (uRxPktQCPDesc*)&RxFrmDesc.firstCpDesc;  
                  pRxPktQ1stDesc->s.frmLenLo = (u8)len;
                  pRxPktQ1stDesc->s.frmLenHi = 0;
                  pRxPktQCPDesc->s.cp = eth_hdr_cp;
                  RxFrmDesc.hdrDesc.s.rsv4 = 0;   
                  RxFrmDesc.hdrDesc.s.srcPort = PORT_APP;       
                  RxFrmDesc.hdrDesc.s.dstPort = PORT_PLC;           
                  Host_RxHandler(pHal, &RxFrmDesc);
                }
                else if((dstn_port == APP_PORT_PERIPHERAL) || 
                  (dstn_port == APP_PORT_ZIGBEE))
                {
                  sSwFrmDesc plcTxFrmSwDesc; 
                  u8 eth_hdr_cp = 0;
                  u8 xdata* cellAddr;
                  eStatus status;       
              
                  memset(&plcTxFrmSwDesc, 0x00, sizeof(plcTxFrmSwDesc));
                  plcTxFrmSwDesc.frmType = HPGP_HW_FRMTYPE_MSDU;
                  plcTxFrmSwDesc.rxPort = PORT_APP;
                  if(dstn_port == APP_PORT_PERIPHERAL)        
                    plcTxFrmSwDesc.txPort = PORT_PERIPHERAL;    
                  else if (dstn_port == APP_PORT_ZIGBEE)
                    plcTxFrmSwDesc.txPort = PORT_ZIGBEE;    
              
                  plcTxFrmSwDesc.frmLen = len;  
                  status = CHAL_RequestCP(&eth_hdr_cp);   
                  if (status != STATUS_SUCCESS)
                  {
                    FM_Printf(FM_ERROR, "\nCP alloc fail");
                    return;
                  }       
                  cellAddr = CHAL_GetAccessToCP(eth_hdr_cp);
                  memset(cellAddr, 0x00, HYBRII_CELLBUF_SIZE);      
                  plcTxFrmSwDesc.cpArr[0].cp = eth_hdr_cp;
                  plcTxFrmSwDesc.cpArr[0].len = (u8)len;    
                  plcTxFrmSwDesc.cpCount = 1;
                  memcpy((u8*)cellAddr, buff, (u8)len);
              
                  //fwdAgent_handleData(&plcTxFrmSwDesc);
                  queueToPeripheral(event);
                }
              }
              #endif
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 6   

 283          
 284          bool APS_IsPeripheralIdle()
 285          {
 286   1      #ifdef HYBRII_ETH
                if(hostIntf == HOST_INTF_ETH)
                {
                  return (EHAL_IsTxReady());
                }
              #endif
 292   1      #ifdef HYBRII_SPI
                if(hostIntf == HOST_INTF_SPI)
                {
                  return (hal_spi_isTxReady());
                }
              #endif   //HYBRII_SPI
 298   1      #ifdef UART_HOST_INTF //UART_16550
 299   1        if(hostIntf == HOST_INTF_UART)
 300   1        {
 301   2          return (hal_uart_isTxReady());
 302   2        }
 303   1      #endif  
 304   1        return FALSE;
 305   1      }
 306          void APS_ProcPeripheral()
 307          {
 308   1          sEvent *event = NULL;
 309   1          sSlink *slink = NULL;
 310   1      
 311   1          /* check peripheral status */
 312   1          if(APS_IsPeripheralIdle() == FALSE)
 313   1          {
 314   2              return;
 315   2          }
 316   1        /*Read peripheral tx  Queue*/
 317   1        if(!SLIST_IsEmpty(&peripheralTxQ))
 318   1        {
 319   2      __CRIT_SECTION_BEGIN__
 320   2          slink = SLIST_Pop(&peripheralTxQ);
 321   2      __CRIT_SECTION_END__  
 322   2          event = SLIST_GetEntry(slink, sEvent, link);
 323   2      
 324   2          if(event == NULL)   
 325   2            return;
 326   2      
 327   2      #ifdef UART_HOST_INTF   
 328   2          if(hostIntf == HOST_INTF_UART)
 329   2              {
 330   3                  hal_uart_tx(event);        
 331   3              }
 332   2      #endif        
 333   2              EVENT_Free(event);
 334   2        }       
 335   1      
 336   1          
 337   1      }
 338          
 339          extern u32 gApsRxFwd;
 340          extern u32 gApsRxApp;
 341            
 342          
 343          void APS_QueueToPeripheral(sEvent *event)
 344          {
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 7   

 345   1      __CRIT_SECTION_BEGIN__
 346   1      
 347   1          SLIST_Put(&peripheralTxQ, &event->link);
 348   1          // pop here 
 349   1          APS_ProcPeripheral();
 350   1      __CRIT_SECTION_END__
 351   1      }
 352          
 353          void Aps_ProcEvent(void *cookie, sEvent *event)
 354          {
 355   1        /*Compiler warning suppression*/
 356   1        cookie = cookie;
 357   1        
 358   1        if((event->buffDesc.dataptr == NULL) || 
 359   1          (event->buffDesc.datalen == 0) )
 360   1          {   
 361   2              EVENT_Free(event);
 362   2          return; 
 363   2          }
 364   1        if(event->eventHdr.eventClass != EVENT_CLASS_DATA)
 365   1        {   
 366   2              EVENT_Free(event);
 367   2          return; 
 368   2          } 
 369   1        gApsRxApp++;
 370   1          if((event->eventHdr.trans == APP_PORT_PLC) ||
 371   1           (event->eventHdr.trans == APP_PORT_ZIGBEE))
 372   1          {
 373   2              eStatus status;
 374   2              u8 xdata* cellAddr;
 375   2              sCommonRxFrmSwDesc RxFrmDesc;
 376   2              uRxPktQDesc1* pRxPktQ1stDesc;
 377   2              uRxPktQCPDesc* pRxPktQCPDesc;
 378   2              sHaLayer *pHal = &(HomePlug.haLayer); //HOMEPLUG_GetHal();
 379   2              u16 len;
 380   2              u8 payloadlen;
 381   2              u8 i=0;
 382   2              u16 frmLen = 0;
 383   2      #ifdef SW_BCST    
                  static u8 swSsn = 255;
                  u8 lastDescLen = 0;
                  sEth2Hdr   *pktEthHdr;
                  sCommonRxFrmSwDesc RxFrmDescArr[BCST_RETRY];
                  u8 bcstFrame;
              #endif    
 390   2            memset((u8*)&RxFrmDesc, 0x00, sizeof(RxFrmDesc));           
 391   2      
 392   2              RxFrmDesc.cpCount = 0;
 393   2      #ifdef SW_BCST    
                  if(event->eventHdr.status & APP_DATA_TX_SWBCST_OPT)
                  {
                    gSoftBCST = 1;
                    // do mac lookup to identify broadcast frame
                    pktEthHdr = ((sEth2Hdr*)(event->buffDesc.dataptr));
                    if((pktEthHdr->dstaddr[0] & 0x01))
                    {
                      len = event->buffDesc.datalen + SW_SSN_SIZE; // Add Software SSN size so that FW can 
                      event->buffDesc.datalen = len;
                      lastDescLen = len % HYBRII_CELLBUF_SIZE;
                      bcstFrame = 1;
                    }
                    else
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 8   

                    {
                      len = event->buffDesc.datalen;
                      bcstFrame = 0;
                    }
                  }
                  else
                  {
                    gSoftBCST = 0;
                    bcstFrame = 0;
              #endif    
 417   2                len = event->buffDesc.datalen;
 418   2      #ifdef SW_BCST  
                  }
              #endif    
 421   2              while(len > 0)
 422   2              {
 423   3                  if(len < HYBRII_CELLBUF_SIZE)
 424   3                  {
 425   4                      payloadlen = len;
 426   4                      RxFrmDesc.lastDescLen = len;
 427   4                  }
 428   3                  else
 429   3                  {
 430   4                      payloadlen = HYBRII_CELLBUF_SIZE;
 431   4              RxFrmDesc.lastDescLen = HYBRII_CELLBUF_SIZE;
 432   4                  }
 433   3                  status = CHAL_RequestCP(&RxFrmDesc.cpArr[i]);
 434   3      
 435   3                  if (status != STATUS_SUCCESS)
 436   3                  {
 437   4                      FM_Printf(FM_ERROR, "\nCP alloc fail");
 438   4              EVENT_Free(event);
 439   4                      return;
 440   4                  }
 441   3                cellAddr  = CHAL_GetAccessToCP(RxFrmDesc.cpArr[i]);
 442   3                
 443   3                  if(cellAddr)
 444   3                  {
 445   4      #ifdef SW_BCST            
                            if(bcstFrame == 1)
                          {
                        if(len <= lastDescLen)
                        {
                          if(len > SW_SSN_SIZE)
                          {
                            memcpy(cellAddr,(u8*)(&(event->buffDesc.dataptr[frmLen])), payloadlen-SW_SSN_SIZE);           
                          }
                          cellAddr[payloadlen-SW_SSN_SIZE] =  swSsn;  
                        }
                        else
                        {
                          memcpy(cellAddr,(u8*)(&(event->buffDesc.dataptr[frmLen])), payloadlen); 
                        }
                            }
                      else
                      {
              #endif        
 464   4                memcpy(cellAddr,(u8*)(&(event->buffDesc.dataptr[frmLen])), payloadlen); 
 465   4      #ifdef SW_BCST
                      }
              #endif        
 468   4            }
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 9   

 469   3                  len -= payloadlen;
 470   3                  frmLen += payloadlen;
 471   3                  RxFrmDesc.cpCount++;
 472   3                  i++;
 473   3              }
 474   2            
 475   2              pRxPktQ1stDesc = (uRxPktQDesc1*)&RxFrmDesc.hdrDesc;
 476   2              pRxPktQCPDesc  = (uRxPktQCPDesc*)&RxFrmDesc.firstCpDesc;    
 477   2              pRxPktQ1stDesc->s.frmLenLo = (u8)event->buffDesc.datalen;
 478   2              pRxPktQ1stDesc->s.frmLenHi =  (event->buffDesc.datalen >> PKTQDESC1_FRMLENHI_POS);
 479   2              pRxPktQCPDesc->s.cp = RxFrmDesc.cpArr[0];
 480   2              RxFrmDesc.hdrDesc.s.rsv4 = 0;       
 481   2              RxFrmDesc.hdrDesc.s.srcPort = PORT_APP;      
 482   2          if(event->eventHdr.trans == APP_PORT_ZIGBEE)    
 483   2          {
 484   3            RxFrmDesc.hdrDesc.s.dstPort = PORT_ZIGBEE;  
 485   3          }
 486   2          else if (event->eventHdr.trans == APP_PORT_PLC)
 487   2          {
 488   3            RxFrmDesc.hdrDesc.s.dstPort = PORT_PLC;   
 489   3          }
 490   2              
 491   2          gApsRxFwd++;
 492   2      #ifdef SW_BCST
                    if(bcstFrame == 1)
                        { //printf("tx SSN %bu\n",swSsn);
                      swSsn++; 
                      for(i=0;i<RxFrmDesc.cpCount;i++)
                      { u8 usage;
              EA = 0;     
                        usage = 0;
                        while(usage != (BCST_RETRY +1))
                        {
                          CHAL_IncrementCPUsageCnt(RxFrmDesc.cpArr[i],1);
                          usage = CHAL_GetCPUsageCnt(RxFrmDesc.cpArr[i]);
                        }
              EA = 1; 
              #if 0         
                        if(CHAL_GetCPUsageCnt(RxFrmDesc.cpArr[i])!= (BCST_RETRY+1))
                        {
                          printf("CP Usage issue %bu\n",CHAL_GetCPUsageCnt(RxFrmDesc.cpArr[i]));
                        }
              #endif          
                      }
                      for(i=0;i<BCST_RETRY;i++)
                      {
                        memcpy((u8*)&RxFrmDescArr[i],(u8*)&RxFrmDesc,sizeof(sCommonRxFrmSwDesc));
                        Host_RxHandler(pHal, &RxFrmDescArr[i]);
                      }     
                    }
              #endif    
 520   2              Host_RxHandler(pHal, &RxFrmDesc);
 521   2              EVENT_Free(event);
 522   2          }
 523   1          else if(event->eventHdr.trans == APP_PORT_PERIPHERAL)
 524   1          {
 525   2              APS_QueueToPeripheral(event);
 526   2          }
 527   1          else
 528   1          {
 529   2              EVENT_Free(event);
 530   2          }
C51 COMPILER V9.53.0.0   APP_SUP_LAYER                                                     11/04/2015 20:09:48 PAGE 10  

 531   1      }
 532          
 533          
 534          u8 Aps_Proc(void *cookie)
 535          {
 536   1          sEvent *event = NULL;
 537   1          sSlink *slink = NULL;
 538   1          u8      ret = 0;
 539   1          gv701x_aps_queue_t *pappSupLayer = (gv701x_aps_queue_t *)(&appSupLayer);
 540   1      
 541   1          /*Compiler warning suppression*/
 542   1          cookie = cookie;
 543   1        
 544   1        /*Read PLC Rx Queue*/
 545   1        while(!SLIST_IsEmpty(&(pappSupLayer->txQueue)))
 546   1        {
 547   2      __CRIT_SECTION_BEGIN__
 548   2          slink = SLIST_Pop(&(pappSupLayer->txQueue));
 549   2      __CRIT_SECTION_END__  
 550   2          event = SLIST_GetEntry(slink, sEvent, link);
 551   2      
 552   2          if(event == NULL)   
 553   2            break;
 554   2          
 555   2          Aps_ProcEvent(pappSupLayer, event);     
 556   2        }       
 557   1      
 558   1          return ret;
 559   1      }
 560          
 561          #endif // NO_HOST
 562          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1874    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   4100     109
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
