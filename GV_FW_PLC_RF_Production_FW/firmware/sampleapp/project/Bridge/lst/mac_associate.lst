C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAC_ASSOCIATE
OBJECT MODULE PLACED IN .\obj\mac_associate.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\zigbee\mac_associate.c LARGE OBJECTADVANCED OPTIMIZ
                    -E(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..
                    -\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\sr
                    -c\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..
                    -\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zi
                    -gbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event
                    -\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpg
                    -p\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_suppo
                    -rt;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\driv
                    -ers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components
                    -;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\
                    -..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\driv
                    -ers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utili
                    -ties;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\driver
                    -s\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..
                    -\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYB
                    -RII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_S
                    -YNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_
                    -DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTER
                    -RUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,
                    -REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\mac_associate.lst)
                    - TABS(2) OBJECT(.\obj\mac_associate.obj)

line level    source

   1          /**
   2           * @file mac_associate.c
   3           *
   4           * Implements the functionality required for Association.
   5           *
   6           * $Id: mac_associate.c,v 1.6 2014/11/26 13:19:41 ranjan Exp $
   7           *
   8           * Copyright (c) 2011, Greenvity Communication All rights reserved.
   9           *
  10           */
  11          
  12          #ifdef HYBRII_802154
  13          
  14          /* === Includes ============================================================= */
  15          
  16          #include <string.h>
  17          #include "papdef.h"
  18          #include "timer.h"
  19          #include "return_val.h"
  20          #include "bmm.h"
  21          #include "qmm.h"
  22          #include "mac_msgs.h"
  23          #include "mac_hal.h"
  24          #include "mac_const.h"
  25          #include "mac_api.h"
  26          #include "mac_data_structures.h"
  27          #include "mac_internal.h"
  28          #include "mac.h"
  29          #include "mac_security.h"
  30          #include "utils_fw.h"
  31          #include "timer.h"
  32          #include "list.h"
  33          #include "stm.h"
  34          
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 2   

  35          /* === Macros =============================================================== */
  36          
  37          /* Payload length of association request frame. */
  38          #define ASSOC_REQ_PAYLOAD_LEN           (2)
  39          
  40          /* Payload length of association response frame. */
  41          #define ASSOC_RESP_PAYLOAD_LEN          (4)
  42          
  43          /* === Globals ============================================================== */
  44          
  45          /* === Prototypes =========================================================== */
  46          
  47          
  48          /* === Implementation ======================================================= */
  49          
  50          /*
  51           *
  52           * This function creates and appends a MLME associate confirm message
  53           * into the  internal event queue.
  54           *
  55           * buf_ptr          - Buffer for sending MLME associate confirm message to NHLE
  56           * status           - Status of association
  57           * assoc_short_addr - Allocated short address
  58           */
  59          void mac_gen_mlme_associate_conf (buffer_t *buf_p,
  60                                            uint8_t  status,
  61                                            uint16_t assoc_short_addr)
  62          {
  63   1          /* Reuse the associate request buffer for associate confirm. */
  64   1          mlme_associate_conf_t *assoc_conf_p = (mlme_associate_conf_t *)
  65   1                                                BMM_BUFFER_POINTER(buf_p);
  66   1      
  67   1          assoc_conf_p->cmdcode = MLME_ASSOCIATE_CONFIRM;
  68   1          assoc_conf_p->status = status;
  69   1          assoc_conf_p->AssocShortAddress = assoc_short_addr;
  70   1      
  71   1      #if (defined UM) && (!defined ZBMAC_DIAG)
  72   1        mlme_send_to_host(buf_p);
  73   1      #else
                mlme_associate_conf(buf_p);
              #endif
  76   1      }
  77          
  78          /*
  79           * Handle Poll Waiting timer while waiting for the association reponse frame
  80           *
  81           * callback_parameter Callback parameter
  82           */
  83          void mac_assocresponsetime_cb (void *callback_parameter)
  84          {
  85   1          uint16_t panid;
  86   1          /*
  87   1           * Association response is not received within time, hence generate
  88   1           * mlme association confirm with MAC_NO_DATA using the buffer stored in
  89   1           * mac_conf_buf_ptr.
  90   1           */
  91   1          mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
  92   1                                      MAC_NO_DATA,
  93   1                                      BROADCAST);
  94   1      
  95   1          /* Restore the mac poll state in case of association failure. */
  96   1          mac_poll_state = MAC_POLL_IDLE;
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 3   

  97   1      
  98   1          /* Set the default parameters. */
  99   1          panid = macPANId_def;
 100   1          set_hal_pib_internal(macPANId, (void *)&panid);
 101   1      
 102   1          mac_pib_macCoordShortAddress = macCoordShortAddress_def;
 103   1          mac_pib_macCoordExtendedAddress.lo_u32 = 0;
 104   1          mac_pib_macCoordExtendedAddress.hi_u32 = 0;
 105   1      
 106   1          /* Set radio to sleep if allowed */
 107   1          mac_trx_sleep();
 108   1      
 109   1          callback_parameter = callback_parameter;
 110   1      }
 111          
 112          /**
 113           * The MLME associate request primitive is generated by the next higher layer
 114           * of an unassociated device and issued to its MAC to request an association
 115           * with a coordinator.
 116           *
 117           * buf_p Pointer to MLME association request parameters
 118           */
 119          void mlme_associate_request (buffer_t *buf_p)
 120          {
 121   1          mlme_associate_req_t mar;
 122   1          retval_t             status, status_2;
 123   1          uint8_t              frame_len = 0;
 124   1          uint8_t              *frame_ptr;
 125   1          uint8_t              *temp_frame_ptr;
 126   1          uint16_t             fcf = 0;
 127   1          uint16_t             bc_addr = BROADCAST;
 128   1          frame_info_t         *assoc_req_frame_p;
 129   1          bool                 encrypt = FALSE;
 130   1          wpan_addr_spec_t     dst_addr_spec;
 131   1      
 132   1          memcpy(&mar, BMM_BUFFER_POINTER(buf_p), sizeof(mlme_associate_req_t));
 133   1      
 134   1          /*
 135   1           * Store the buffer which was received from the NHLE as it will be reused
 136   1           * while sending MLME association confirmation to the NHLE.
 137   1           */
 138   1          mac_conf_buf_ptr = (uint8_t *)buf_p;
 139   1      
 140   1          if ((FCF_SHORT_ADDR != mar.CoordAddrMode) &&
 141   1              (FCF_LONG_ADDR != mar.CoordAddrMode)) {
 142   2              mac_gen_mlme_associate_conf(buf_p,
 143   2                                          MAC_INVALID_PARAMETER,
 144   2                                          INVALID_SHORT_ADDRESS);
 145   2      
 146   2              return;
 147   2          }
 148   1          
 149   1          dst_addr_spec.AddrMode = mar.CoordAddrMode;
 150   1                  
 151   1          if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
 152   2              ADDR_COPY_DST_SRC_16(mac_pib_macCoordShortAddress,
 153   2                                   mar.CoordAddress.short_address);
 154   2              dst_addr_spec.Addr.short_address = mar.CoordAddress.short_address;
 155   2          } else {
 156   2              dst_addr_spec.Addr.long_address =mar.CoordAddress.long_address;
 157   2              ADDR_COPY_DST_SRC_64(mac_pib_macCoordExtendedAddress,
 158   2                                   mar.CoordAddress.long_address);
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 4   

 159   2              /*
 160   2               * Since the coordinator used its extended address, we need to mark
 161   2               * this also in its short address.
 162   2               */
 163   2              mac_pib_macCoordShortAddress = MAC_NO_SHORT_ADDR_VALUE;
 164   2          }
 165   1      
 166   1          /* Set the PAN ID. */
 167   1          set_hal_pib_internal(macPANId, (void *)&mar.CoordPANId);
 168   1      
 169   1          mac_trx_wakeup();
 170   1      
 171   1          /* Build the Association Request command frame. */
 172   1      
 173   1          assoc_req_frame_p = (frame_info_t *)(BMM_BUFFER_POINTER(buf_p));
 174   1      
 175   1          assoc_req_frame_p->msg_type = ASSOCIATIONREQUEST;
 176   1          assoc_req_frame_p->buffer_header_p = buf_p;
 177   1      
 178   1      
 179   1          /* Get the payload pointer. */
 180   1          frame_ptr = temp_frame_ptr =
 181   1                      (uint8_t *)assoc_req_frame_p +
 182   1                      BUFFER_SIZE -
 183   1                      ASSOC_REQ_PAYLOAD_LEN;
 184   1      
 185   1          /* Update the payload field. */
 186   1          *frame_ptr++ = ASSOCIATIONREQUEST;
 187   1          /* Build the capability info. */
 188   1          *frame_ptr = mar.CapabilityInformation;
 189   1      
 190   1          /* Get the payload pointer again to add the MHR. */
 191   1          frame_ptr = temp_frame_ptr;
 192   1      
 193   1          if (mar.Security.SecurityLevel > 0) {
 194   2              if (mac_pib_macSecurityEnabled == TRUE) {
 195   3                  retval_t build_sec;
 196   3      
 197   3                  build_sec = mac_build_aux_sec_header(&frame_ptr, &mar.Security,
 198   3                                                       &frame_len);
 199   3                  if (MAC_SUCCESS != build_sec) {
 200   4                      mac_gen_mlme_associate_conf(buf_p,
 201   4                                                  MAC_SECURITY_ERROR,
 202   4                                                  INVALID_SHORT_ADDRESS);
 203   4                      /* Set radio to sleep if allowed */
 204   4                      mac_trx_sleep();
 205   4                      return; 
 206   4                  }
 207   3                  fcf = FCF_SECURITY_ENABLED | FCF_FRAME_VERSION_2006;
 208   3                  encrypt = TRUE;
 209   3              } else {
 210   3                  mac_gen_mlme_associate_conf(buf_p,
 211   3                                              MAC_UNSUPPORTED_SECURITY,
 212   3                                              INVALID_SHORT_ADDRESS);
 213   3                  /* Set radio to sleep if allowed */
 214   3                  mac_trx_sleep();
 215   3                  return; 
 216   3              }
 217   2          }
 218   1      
 219   1          /* Update the length. */
 220   1          frame_len += ASSOC_REQ_PAYLOAD_LEN +
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 5   

 221   1                       PAN_ID_LEN            +     // Destination PAN-Id
 222   1                       PAN_ID_LEN            +     // Source PAN-Id
 223   1                       EXT_ADDR_LEN          +     // long Source Address
 224   1                       SEQ_NUM_LEN           +     // Sequence number
 225   1                       FCF_LEN;             // FCF
 226   1      
 227   1          /* Source address */
 228   1          frame_ptr -= EXT_ADDR_LEN;
 229   1          mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 230   1      
 231   1          /* Source PAN-Id is broadcast PAN ID */
 232   1          frame_ptr -= PAN_ID_LEN;
 233   1          mac_utils_16_bit_to_byte_array(bc_addr, frame_ptr);
 234   1      
 235   1          /* Destination address */
 236   1          if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
 237   2              frame_ptr -= SHORT_ADDR_LEN;
 238   2              frame_len += SHORT_ADDR_LEN;
 239   2              mac_utils_16_bit_to_byte_array(mac_pib_macCoordShortAddress, frame_ptr);
 240   2      
 241   2              fcf |= FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD)                  |
 242   2                                       FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR)  |
 243   2                                       FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
 244   2                                       FCF_ACK_REQUEST;
 245   2          } else {
 246   2              frame_ptr -= EXT_ADDR_LEN;
 247   2              frame_len += EXT_ADDR_LEN;
 248   2              mac_utils_64_bit_to_byte_array(mac_pib_macCoordExtendedAddress,
 249   2                                             frame_ptr);
 250   2      
 251   2              fcf |= FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD)                  |
 252   2                                       FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR)   |
 253   2                                       FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
 254   2                                       FCF_ACK_REQUEST;
 255   2          }
 256   1      
 257   1          /* Destination PAN-Id */
 258   1          frame_ptr -= PAN_ID_LEN;
 259   1          mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 260   1          dst_addr_spec.PANId = hal_pib_PANId;
 261   1      
 262   1          /* Set DSN. */
 263   1          frame_ptr -= SEQ_NUM_LEN;
 264   1          *frame_ptr = mac_pib_macDSN++;
 265   1      
 266   1      
 267   1          /* Set the FCF. */
 268   1          frame_ptr -= FCF_LEN;
 269   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
 270   1      
 271   1      
 272   1          /* First element shall be length of PHY frame. */
 273   1          frame_ptr -= LENGTH_FIELD_LEN;
 274   1          *frame_ptr = frame_len;
 275   1      
 276   1          /* Finished building of frame. */
 277   1          assoc_req_frame_p->mpdu_p = frame_ptr;
 278   1      
 279   1          /* Set the channel page passed by the request. */
 280   1          status = set_hal_pib_internal(phyCurrentPage,
 281   1                                        (void *)&(mar.ChannelPage));
 282   1      
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 6   

 283   1          /* Set the channel passed by the request. */
 284   1          status_2 = set_hal_pib_internal(phyCurrentChannel,
 285   1                                          (void *)&(mar.LogicalChannel));
 286   1      
 287   1          if ((MAC_SUCCESS == status) && (MAC_SUCCESS == status_2)) {
 288   2              tx_mode_t tx_mode;
 289   2      
 290   2              if (TRUE == encrypt) {
 291   3                  status = mac_secure(&mar.Security, &dst_addr_spec);
 292   3                  if (MAC_SUCCESS != status) {
 293   4                      mac_gen_mlme_associate_conf(buf_p,
 294   4                                                  MAC_SECURITY_ERROR,
 295   4                                                  INVALID_SHORT_ADDRESS);
 296   4                      /* Set radio to sleep if allowed */
 297   4                      mac_trx_sleep();
 298   4                      return; 
 299   4                  }
 300   3              }
 301   2          /*
 302   2               * In Beacon network the association request frame is sent with
 303   2               * slotted CSMA-CA if the node is synced before assocaition.
 304   2               * In all other cases the frame is transmitted using unslotted
 305   2               * CSMA-CA.
 306   2               */
 307   2      
 308   2      
 309   2              if (MAC_SYNC_BEFORE_ASSOC == mac_sync_state) {
 310   3                  tx_mode = CSMA_SLOTTED;
 311   3              } else {
 312   3                  tx_mode = CSMA_UNSLOTTED;
 313   3              }
 314   2      
 315   2              status = mac_hal_tx_frame(assoc_req_frame_p, tx_mode, encrypt);
 316   2      
 317   2              if (MAC_SUCCESS == status) {
 318   3                  MAC_BUSY();
 319   3              } else {
 320   3                  mac_gen_mlme_associate_conf(buf_p,
 321   3                                              MAC_CHANNEL_ACCESS_FAILURE,
 322   3                                              INVALID_SHORT_ADDRESS);
 323   3      
 324   3                  /* Set radio to sleep if allowed */
 325   3                  mac_trx_sleep();
 326   3              }
 327   2          } else {
 328   2              mac_gen_mlme_associate_conf(buf_p,
 329   2                                          MAC_CHANNEL_ACCESS_FAILURE,
 330   2                                          INVALID_SHORT_ADDRESS);
 331   2      
 332   2              /* Set radio to sleep if allowed */
 333   2              mac_trx_sleep();
 334   2          }
 335   1      }
 336          
 337          /**
 338           *
 339           * This function will process a received association request command frame and
 340           * generates a MLME associate indication to the NHLE.
 341           *
 342           * assoc_req_p - pointer to the received association request frame
 343           */
 344          void mac_process_associate_request (buffer_t *assoc_req_p)
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 7   

 345          {
 346   1          /* Use the frame reception buffer for association indication. */
 347   1          mlme_associate_ind_t *mai_p = (mlme_associate_ind_t *)
 348   1                                        BMM_BUFFER_POINTER(assoc_req_p);
 349   1      
 350   1          /*
 351   1           * If the coordinator has macAssociationPermit set to false, and receives an
 352   1           * association request command from a device, the command shall be ignored.
 353   1           */
 354   1          if (FALSE == mac_pib_macAssociationPermit) {
 355   2              bmm_buffer_free(assoc_req_p);
 356   2              return;
 357   2          }
 358   1      
 359   1          /* Build the MLME association indication parameters. */
 360   1          ADDR_COPY_DST_SRC_64(mai_p->DeviceAddress,
 361   1                               mac_parse_data.src_addr.long_address);
 362   1          mai_p->CapabilityInformation = 
 363   1                      mac_parse_data.mac_payload_data.assoc_req_data.capability_info;
 364   1          mai_p->cmdcode = MLME_ASSOCIATE_INDICATION;
 365   1      
 366   1      #if (defined UM) && (!defined ZBMAC_DIAG)    
 367   1        mlme_send_to_host(assoc_req_p);
 368   1      #else
                mlme_associate_ind(assoc_req_p);
              #endif
 371   1      }
 372          
 373          /**
 374           * Entry point from the stack for MLME associate response
 375           *
 376           * The MLME associate response primitive is used to initiate a response to a
 377           * MLME association indication primitive.
 378           *
 379           * buf_p - Pointer to association response parameters
 380           */
 381          void mlme_associate_response (buffer_t *buf_p)
 382          {
 383   1          uint8_t frame_len;
 384   1          uint8_t *frame_ptr;
 385   1          uint8_t *temp_frame_ptr;
 386   1          uint16_t fcf;
 387   1          frame_info_t *assoc_resp_frame_p;
 388   1      
 389   1          mlme_associate_resp_t mar;
 390   1          memcpy(&mar, BMM_BUFFER_POINTER(buf_p), sizeof(mlme_associate_resp_t));
 391   1      
 392   1          assoc_resp_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);
 393   1        
 394   1           /*
 395   1           * A MLME associate response can only be processed
 396   1           * in the MAC_PAN_COORD_STARTED or MAC_COORDINATOR state.
 397   1           */
 398   1          if ((MAC_PAN_COORD_STARTED != mac_state) &&
 399   1              (MAC_COORDINATOR != mac_state)) {
 400   2              bmm_buffer_free(buf_p);
 401   2              return;
 402   2          }
 403   1      
 404   1          /* Build the Association Response frame. */
 405   1          assoc_resp_frame_p->msg_type = ASSOCIATIONRESPONSE;
 406   1      
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 8   

 407   1      
 408   1          /* Get the payload pointer. */
 409   1          frame_ptr = temp_frame_ptr =
 410   1                      (uint8_t *)assoc_resp_frame_p +
 411   1                      BUFFER_SIZE -
 412   1                      ASSOC_RESP_PAYLOAD_LEN;
 413   1      
 414   1          /* Update the payload field. */
 415   1          *frame_ptr++ = ASSOCIATIONRESPONSE;
 416   1      
 417   1          /* Add the short address allocated for the device. */
 418   1          mac_utils_16_bit_to_byte_array(mar.AssocShortAddress, frame_ptr);
 419   1          frame_ptr += SHORT_ADDR_LEN;
 420   1      
 421   1          /* Build the association status. */
 422   1          *frame_ptr = mar.status;
 423   1      
 424   1          /* Get the payload pointer again to add the MHR. */
 425   1          frame_ptr = temp_frame_ptr;
 426   1      
 427   1      
 428   1          /* Update the length. */
 429   1          frame_len = ASSOC_RESP_PAYLOAD_LEN +
 430   1                      PAN_ID_LEN             + // Destination PAN-Id
 431   1                      EXT_ADDR_LEN           + // long Destination Address
 432   1                      EXT_ADDR_LEN           + // long Source Address
 433   1                      SEQ_NUM_LEN            +
 434   1                      FCF_LEN;
 435   1      
 436   1          /* Source address */
 437   1          frame_ptr -= EXT_ADDR_LEN;
 438   1          mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);
 439   1      
 440   1      
 441   1          /* Build the Destination address. */
 442   1          frame_ptr -= EXT_ADDR_LEN;
 443   1          mac_utils_64_bit_to_byte_array(mar.DeviceAddress, frame_ptr);
 444   1      
 445   1      
 446   1          /* Build the Destination PAN ID. */
 447   1          frame_ptr -= PAN_ID_LEN;
 448   1          mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
 449   1      
 450   1      
 451   1          /* Set DSN. */
 452   1          frame_ptr -= SEQ_NUM_LEN;
 453   1          *frame_ptr = mac_pib_macDSN++;
 454   1      
 455   1      
 456   1          /* Set the FCF. */
 457   1          /* Create the frame control field. */
 458   1          fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
 459   1                FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR)    |
 460   1                FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
 461   1                FCF_PAN_ID_COMPRESSION                   |
 462   1                FCF_ACK_REQUEST;
 463   1          frame_ptr -= FCF_LEN;
 464   1          mac_utils_16_bit_to_byte_array(fcf, frame_ptr);
 465   1      
 466   1      
 467   1          /* First element shall be length of PHY frame. */
 468   1          frame_ptr -= LENGTH_FIELD_LEN;
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 9   

 469   1          *frame_ptr = frame_len;
 470   1      
 471   1          /* Finished building of frame. */
 472   1          assoc_resp_frame_p->mpdu_p = frame_ptr;
 473   1      
 474   1          /* Indirect transmission not ongoing yet. */
 475   1          assoc_resp_frame_p->indirect_in_transit = false;
 476   1      
 477   1           /* Append the association response into indirect queue. */
 478   1          if (FALSE == qmm_queue_append(&indirect_data_q, buf_p)) {
 479   2              /*
 480   2               * Indirect queue reached the maximum size allowed.
 481   2               * Send the comm status indication with MAC transaction overflow.
 482   2               */
 483   2              mac_mlme_comm_status(MAC_TRANSACTION_OVERFLOW, buf_p);
 484   2      
 485   2              return;
 486   2          }
 487   1          /*
 488   1           * If an FFD does have pending data,
 489   1           * the MAC persistence timer needs to be started.
 490   1           */
 491   1          assoc_resp_frame_p->persistence_time = 
 492   1                                             mac_pib_macTransactionPersistenceTime;
 493   1          mac_start_persistence_timer();
 494   1      }
 495          
 496          /**
 497           *
 498           * This function processes the received association response
 499           * command frame.
 500           *
 501           * assoc_resp_p - Pointer to  Association response
 502           */
 503          void mac_process_associate_response (buffer_t *assoc_resp_p)
 504          {
 505   1          uint16_t panid;
 506   1          uint16_t short_addr;
 507   1          uint8_t  status;
 508   1      
 509   1          status = mac_parse_data.mac_payload_data.assoc_response_data.assoc_status;
 510   1      
 511   1          /* Free the buffer received for association response frame. */
 512   1          bmm_buffer_free(assoc_resp_p);
 513   1      
 514   1          if (ASSOCIATION_SUCCESSFUL == status) {
 515   2              /* Set the short address received in association response frame. */
 516   2              set_hal_pib_internal(macShortAddress,
 517   2                                   (void *)&(mac_parse_data.\
 518   2                                   mac_payload_data.assoc_response_data.short_addr));
 519   2      
 520   2              short_addr = mac_parse_data.\
 521   2                           mac_payload_data.assoc_response_data.short_addr;
 522   2      
 523   2              ADDR_COPY_DST_SRC_64(mac_pib_macCoordExtendedAddress,
 524   2                                   mac_parse_data.src_addr.long_address);
 525   2      
 526   2              /* Node is properly associated now */
 527   2              mac_state = MAC_ASSOCIATED;
 528   2              mac_poll_state = MAC_POLL_IDLE;
 529   2      
 530   2              if (MAC_SYNC_BEFORE_ASSOC == mac_sync_state) {
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 10  

 531   3                  mac_sync_state = MAC_SYNC_TRACKING_BEACON;
 532   3              }
 533   2          } else {
 534   2              /* Restore the default values. */
 535   2              mac_poll_state = MAC_POLL_IDLE;
 536   2      
 537   2              panid = macPANId_def;
 538   2      
 539   2              set_hal_pib_internal(macPANId, (void *)&panid);
 540   2      
 541   2              mac_pib_macCoordShortAddress = macCoordShortAddress_def;
 542   2              mac_pib_macCoordExtendedAddress.hi_u32 = 0;
 543   2              mac_pib_macCoordExtendedAddress.lo_u32 = 0;
 544   2      
 545   2              short_addr = INVALID_SHORT_ADDRESS;
 546   2          }
 547   1      
 548   1          /*
 549   1           * The MLME association request buffer is stored in mac_conf_buf_ptr,
 550   1           * which is reused to generate MLME association confirmation.
 551   1           */
 552   1          mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
 553   1                                      status,
 554   1                                      short_addr);
 555   1      
 556   1          /* Set radio to sleep if allowed */
 557   1          mac_trx_sleep();
 558   1      }
 559          
 560          /**
 561           * Handle T_Poll_Wait_Time timer after successful transmission of an
 562           * association request frame and before sending out the subsequent
 563           * data request frame.
 564           *
 565           * callback_parameter Callback parameter.
 566           */
 567          void mac_response_wait_cb (void *callback_parameter)
 568          {
 569   1          uint32_t response_time;
 570   1          bool     status;
 571   1      
 572   1          /*
 573   1           * IEEE 802.15.4-2006 page 154:
 574   1           *
 575   1           * If the data request command is being sent following the acknowledgment
 576   1           * to an association request command frame, the Destination Addressing Mode
 577   1           * subfield of the Frame Control field shall be set according to the
 578   1           * coordinator to which the data request command is directed.
 579   1           * If macCoordShortAddress is equal to 0xfffe, extended addressing
 580   1           * shall be used. Short addressing shall be used otherwise.
 581   1           * The Source Addressing Mode subfield shall be set to use
 582   1           * extended addressing.
 583   1           */
 584   1          /*
 585   1           * No explicit destination address attached, so use current values of
 586   1           * PIB attributes macCoordShortAddress or macCoordExtendedAddress.
 587   1           */
 588   1          status = mac_data_build_and_tx_data_req(false, true, 0, NULL, 0);
 589   1      
 590   1          if (!status) {
 591   2              /*
 592   2               * Data request could not be transmitted, hence association confirmation
C51 COMPILER V9.53.0.0   MAC_ASSOCIATE                                                     11/04/2015 20:09:51 PAGE 11  

 593   2               * is generated using the buffer stored in mac_conf_buf_ptr.
 594   2               */
 595   2              mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
 596   2                                          MAC_CHANNEL_ACCESS_FAILURE,
 597   2                                          INVALID_SHORT_ADDRESS);
 598   2              return;
 599   2          }
 600   1      
 601   1          response_time = 
 602   1              HAL_CONVERT_SYMBOLS_TO_US(mac_pib_macResponseWaitTime) / 1000;
 603   1      
 604   1          if (STATUS_SUCCESS != 
 605   1              STM_StartTimer(mac_asso_rsp_wait_timer, response_time)) {
 606   2              /* Timer could not be started. */
 607   2              mac_assocresponsetime_cb(NULL);
 608   2          }
 609   1      
 610   1          callback_parameter = callback_parameter;
 611   1      }
 612          #endif // HYBRII_802154
 613          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1991    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     122
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
