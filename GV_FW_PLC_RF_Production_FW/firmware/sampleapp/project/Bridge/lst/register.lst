C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE REGISTER
OBJECT MODULE PLACED IN .\obj\register.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\sampleapp\src\register.c LARGE OBJECTADVANCED OPTIMIZE(9,SPEED)
                    - BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\fi
                    -rmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\
                    -..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware
                    -\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\.
                    -.\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\.
                    -.\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\
                    -..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\
                    -..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\
                    -inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..
                    -\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compon
                    -ents\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash
                    -\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\.
                    -.\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc
                    -;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\co
                    -mponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,
                    -HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HY
                    -BRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HY
                    -BRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO
                    -,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_
                    -APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\register.lst) TABS(2) OBJEC
                    -T(.\obj\register.obj)

line level    source

   1          /* ========================================================
   2           *
   3           * @file:  register.c
   4           * 
   5           * @brief: This file handles the registration process of the 
   6           *       node with the Host
   7           *      
   8           *  Copyright (C) 2010-2015, Greenvity Communications, Inc.
   9           *  All Rights Reserved
  10           *  
  11           * =========================================================*/
  12          
  13          #ifdef REGISTER_APP
  14          /****************************************************************************** 
  15            * Includes
  16            ******************************************************************************/
  17          
  18          #include <REG51.H>
  19          #include <string.h>
  20          #include <stdio.h>
  21          #include <stdlib.h>
  22          #include "gv701x_includes.h"
  23          #include "register.h"
  24          #include "register_fw.h"
  25          #ifdef ROUTE_APP
  26          #include "route.h"
  27          #include "route_fw.h"
  28          #endif
  29          #ifdef LLP_APP
  30          #include "llpapp.h"
  31          #include "llpapp_fw.h"
  32          #endif
  33          #ifdef HPGP_DRIVER_APP
  34          #include "gv701x_hpgpdriver.h"
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 2   

  35          #endif
  36          #ifdef LRWPAN_DRIVER_APP
  37          #include "gv701x_lrwpandriver.h"
  38          #endif
  39          #ifdef NWKSTARTUP_APP
  40          #include "gv701x_nwkstartup.h"
  41          #endif
  42          
  43          /****************************************************************************** 
  44            * Global Data
  45            ******************************************************************************/
  46          u8 register_app_id;
  47          gv701x_app_queue_t register_queues; 
  48          
  49          register_data_t register_data;     
  50          gv701x_state_t register_state;   
  51          
  52          /****************************************************************************** 
  53            * External Data
  54            ******************************************************************************/
  55            
  56          /******************************************************************************
  57            * Funtion prototypes
  58            ******************************************************************************/
  59          
  60          void register_send_req(u16* cnt);
  61          void register_send_confirm(void);
  62          void register_handle_timeout(void);
  63          u8 register_tx(u8* buf, u8 payloadLen, u8 frametype);
  64          
  65          /******************************************************************************
  66           * @fn      RegisterApp_Init
  67           *
  68           * @brief   Initializes the Registration Layer
  69           *
  70           * @param   app_id - application identification number
  71           *
  72           * @return  none
  73           */
  74          
  75          void RegisterApp_Init(u8 app_id) 
  76          { 
  77   1        u8* macaddr;
  78   1        memset(&register_state, 0x00, sizeof(gv701x_state_t));
  79   1        memset(&register_data, 0x00, sizeof(register_data_t));
  80   1      
  81   1        /*Record the applications id,will 
  82   1         be used while allocating timers*/
  83   1        register_app_id = app_id; 
  84   1        SLIST_Init(&register_queues.appRxQueue);
  85   1        
  86   1        FM_Printf(FM_USER, "\nInit RegisterApp (app id %bu)", app_id);
  87   1        
  88   1        memcpy((u8*)&register_data.macaddr, (u8*)macaddr, MAC_ADDR_LEN);
  89   1      #if 0 
                FM_HexDump(FM_APP, "MAC: ", (u8*)&register_data.macaddr, MAC_ADDR_LEN);     
              #endif
  92   1      
  93   1      #if 0
                /*Fetches previously accquired short address if any*/
                if(STATUS_SUCCESS == GV701x_FlashRead(register_app_id, (u8*)&register_data.nwk_addr, 
                          sizeof(register_data.nwk_addr)))
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 3   

                {   
                  if((register_data.nwk_addr.addr_16bit == 0xFFFF) || 
                    (register_data.nwk_addr.addr_16bit == 0))
                    register_state.state = REGISTER_IDLE_STATE;   
                  else
                    register_state.state = REGISTER_REGISTERED_STATE;
                }
              
                if(STATUS_SUCCESS == GV701x_FlashRead(route_app_id, (u8*)(&(route_info.root_ieee_addr[0])), 
                          IEEE_MAC_ADDRESS_LEN - 2))
                {   
                }
              #else
 110   1        register_state.state = REGISTER_IDLE_STATE; 
 111   1      #endif
 112   1      
 113   1        /*Initialize State machine*/
 114   1        register_state.event = REGISTER_IDLE_EVNT;  
 115   1        register_state.statedata = NULL;
 116   1        register_state.statedatalen = 0;
 117   1        register_data.reg_req_retry_cnt = 0;
 118   1      
 119   1        /*Allocated Registration timer*/
 120   1        register_data.register_timer = STM_AllocTimer(SW_LAYER_TYPE_APP, 
 121   1                  REGISTRATION_TIMER_EVNT,&register_app_id);
 122   1      }
 123          
 124          
 125          /******************************************************************************
 126           * @fn      register_send_req
 127           *
 128           * @brief   Sends Registration request to the Host
 129           *
 130           * @param   cnt - pointer to the re-transmit counter
 131           *               (re-transmissions occur at an exponential index)
 132           *
 133           * @return  none
 134           */
 135          
 136          void register_send_req(u16* cnt) 
 137          {
 138   1        u8 buf[REGISTER_MAX_PKT_BUFFSIZE];
 139   1        route_hdr_t* rhdr = &buf[(sizeof(sEth2Hdr))];
 140   1        register_req_t* req = (register_req_t*)(rhdr + 1);
 141   1      
 142   1        if(register_state.state != REGISTER_UNREGISTERED_STATE)
 143   1          return;
 144   1      
 145   1        memset(buf, 0x00, REGISTER_MAX_PKT_BUFFSIZE); 
 146   1      
 147   1        /*Fill message header*/ 
 148   1        req->fc.control_bits = 0;
 149   1        req->flags |= REG_REQ_BOTH_PRESENT;   
 150   1        req->tei = register_data.tei;
 151   1      #ifdef HPGP_DRIVER_APP
 152   1        memcpy(req->nid, hpgp_nwk_data.params.nwk.key.nid, NID_LEN);
 153   1      #if 0
                FM_HexDump(FM_APP, "\nReg Nid:", req->nid, NID_LEN);
              #endif
 156   1      #endif
 157   1        memcpy_cpu_to_le(&(req->mac_addr), 
 158   1            &(register_data.macaddr), MAC_ADDR_LEN);
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 4   

 159   1      
 160   1        /*Start Registration timer*/ 
 161   1        if(STATUS_SUCCESS == STM_StartTimer(register_data.register_timer, 
 162   1                    register_data.registration_time)) 
 163   1        {           
 164   2          if(STATUS_SUCCESS == register_tx(buf, 
 165   2            (sizeof (route_hdr_t) + sizeof(register_req_t) + (sizeof(sEth2Hdr))), REGISTRATION_REQ))
 166   2          {     
 167   3            register_data.stats.regreq++;
 168   3            if((*cnt) < REGISTER_TIMEOUT_MAX_EXPONENT)
 169   3            {
 170   4              register_data.registration_time = ( (register_data.registration_time)*
 171   4                                (REGISTER_TIMEOUT_EXPONENT) );
 172   4            }       
 173   3            *cnt = *cnt + 1;      
 174   3          }
 175   2        }
 176   1      }
 177          
 178          /******************************************************************************
 179           * @fn      register_send_confirm
 180           *
 181           * @brief   Sends Registration confirm to the Host
 182           *
 183           * @param   cnt - pointer to the re-transmit counter
 184           *               (re-transmissions occur at an exponential index)
 185           *
 186           * @return  none
 187           */
 188          
 189          void register_send_confirm(void) 
 190          {
 191   1        u8 buf[REGISTER_MAX_PKT_BUFFSIZE];  
 192   1        register_up_ind_msg_t register_up;  
 193   1        route_updt_addr_evnt_msg_t route_update;
 194   1        route_hdr_t* rhdr = &buf[(sizeof(sEth2Hdr))];
 195   1        register_cnf_t* cnf = (register_cnf_t*)(rhdr + 1);  
 196   1      
 197   1        memset(buf, 0x00, REGISTER_MAX_PKT_BUFFSIZE);
 198   1      
 199   1        /*Fill message header*/ 
 200   1        cnf->fc.control_bits = 0;
 201   1        cnf->status = TRUE; 
 202   1      #ifdef LLP_APP
 203   1        cnf->dev_type = (u8)(*node_data.dev_type);  
 204   1        cnf->sub_type = (u8)(*node_data.dev_subtype);
 205   1      #endif
 206   1        cnf->nwkaddr = cpu_to_le16(register_data.nwk_addr.addr_16bit);
 207   1        
 208   1        memcpy_cpu_to_le(&(cnf->mac_addr), 
 209   1            &(register_data.macaddr), MAC_ADDR_LEN); 
 210   1      
 211   1      #if 1
 212   1        FM_Printf(FM_APP, "\nRCnf Tx  (s - 0x%02x, d - 0x%02x, l - %bu", 
 213   1              le16_to_cpu(rhdr->target), 
 214   1              le16_to_cpu(rhdr->parent), 
 215   1              (route_info.parent != NULL)? route_info.parent->link:0);
 216   1      #endif
 217   1        register_data.stats.regcnf++;
 218   1        if(FALSE == register_tx(buf, (sizeof (route_hdr_t) + sizeof(register_cnf_t) +  (sizeof(sEth2Hdr))), 
 219   1                REGISTRATION_CNF))
 220   1        {
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 5   

 221   2        }
 222   1      
 223   1        register_state.state = REGISTER_REGISTERED_STATE;
 224   1      
 225   1      #ifdef ROUTE_APP
 226   1        route_info.unreachable = TRUE;
 227   1      #endif
 228   1        /*Trigger Route Acquired event to the Routing layer*/
 229   1        register_up.event = REGISTER_UP_IND;
 230   1        register_up.nwk_addr = register_data.nwk_addr.addr_16bit;
 231   1        GV701x_SendAppEvent(register_app_id, APP_BRDCST_MSG_APPID, APP_MSG_TYPE_APPIND,
 232   1          APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,
 233   1                &register_up, sizeof(register_up_ind_msg_t), 0);  
 234   1        
 235   1        route_update.event = ROUTE_UPDATE_ADDR_EVNT;
 236   1        route_update.addr = register_data.nwk_addr.addr_16bit;
 237   1        GV701x_SendAppEvent(register_app_id, route_app_id, APP_MSG_TYPE_APPEVENT,
 238   1          APP_MAC_ID, EVENT_CLASS_CTRL, MGMT_FRM_ID,
 239   1                &route_update, sizeof(route_updt_addr_evnt_msg_t), 0);  
 240   1      }
 241          
 242          /******************************************************************************
 243           * @fn      register_rx_rsp
 244           *
 245           * @brief   Handles Registration response received from the Host
 246           *
 247           * @param   frm - the response frame
 248           *      len - length in bytes
 249           *
 250           * @return  none
 251           */
 252          
 253          void register_rx_rsp(u8* frm, u8 len) 
 254          {
 255   1        route_hdr_t* rhdr = (route_hdr_t*)&frm[(sizeof(sEth2Hdr))];
 256   1        register_rsp_t* rsp = (register_rsp_t*)(rhdr + 1);
 257   1        len = len;  
 258   1        
 259   1        if(memcmp_cpu_to_le((u8*)&(rsp->mac_addr), (u8*)&(register_data.macaddr), MAC_ADDR_LEN))
 260   1          return;
 261   1      
 262   1        STM_StopTimer(register_data.register_timer);  
 263   1      #ifdef ROUTE_APP
 264   1        {
 265   2          sEth2Hdr* petherhdr = (sEth2Hdr*)frm;
 266   2          memcpy(&(route_info.root_ieee_addr[0]), &(petherhdr->srcaddr), IEEE_MAC_ADDRESS_LEN-2);   
 267   2        }
 268   1      #endif  
 269   1      
 270   1        register_data.stats.regrsp++;
 271   1        register_data.nwk_addr.addr_16bit = cpu_to_le16(rsp->nwkaddr);
 272   1        nwkstartup_data.link.power_line.addr = register_data.nwk_addr.addr_16bit;
 273   1        nwkstartup_data.link.wireless.addr = register_data.nwk_addr.addr_16bit;
 274   1      #ifdef LRWPAN_DRIVER_APP  
 275   1        lrwpan_set_shortaddr(register_data.nwk_addr.addr_16bit);
 276   1      #endif      
 277   1      #if 1 
 278   1        FM_Printf(FM_APP, "\nRRsp Rx  (s - 0x%02x, d - 0x%02x, l - %bu", 
 279   1              le16_to_cpu(rhdr->parent), 
 280   1              le16_to_cpu(rhdr->target), 
 281   1              (route_info.parent != NULL)? route_info.parent->link:0);
 282   1      #endif
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 6   

 283   1      
 284   1        register_send_confirm();
 285   1      
 286   1      #if 0
                /*Write the newly acquired short address in flash*/
                if(STATUS_FAILURE == GV701x_FlashWrite(register_app_id, (u8*)&register_data.nwk_addr, 
                                    sizeof(register_data.nwk_addr)))
                {
                }
              
              #ifdef ROUTE_APP
                if(STATUS_FAILURE == GV701x_FlashWrite(route_app_id, (u8*)&(route_info.root_ieee_addr[0]), 
                                    IEEE_MAC_ADDRESS_LEN-2))
                {
                }
                else
                {
                } 
              #endif
              #endif
 303   1      }
 304          
 305          /******************************************************************************
 306           * @fn      register_rx_rereq
 307           *
 308           * @brief   Handles Re-Registration request received from the Host
 309           *
 310           * @param   frm - the response frame
 311           *      len - length in bytes
 312           *
 313           * @return  none
 314           */
 315          
 316          void register_rx_rereq(u8* frm, u8 len) 
 317          {
 318   1        u8 brdcst_macaddr[MAC_ADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 319   1        route_hdr_t* rhdr = (route_hdr_t*)&frm[(sizeof(sEth2Hdr))];
 320   1        reregister_req_t* rereg = (reregister_req_t*)(rhdr + 1);
 321   1        len = len;
 322   1      
 323   1        if(register_state.state == REGISTER_IDLE_STATE)
 324   1          return;
 325   1      
 326   1        if((!memcmp_cpu_to_le(&(rereg->mac_addr), 
 327   1              &(register_data.macaddr), MAC_ADDR_LEN)) ||
 328   1          (!memcmp_cpu_to_le(&(rereg->mac_addr), 
 329   1              brdcst_macaddr, MAC_ADDR_LEN))) 
 330   1        {
 331   2      
 332   2          register_data.stats.reregreq++;   
 333   2      
 334   2          /*Trigger Re-registraion event*/
 335   2          register_state.state = REGISTER_IDLE_STATE;
 336   2          register_state.event = REGISTER_START_EVNT;   
 337   2        }
 338   1      }
 339          
 340          /******************************************************************************
 341           * @fn      RegisterApp_RxAppMsg
 342           *
 343           * @brief   Receives a message from another app/fw
 344           *
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 7   

 345           * @params  msg_buf - message buffer
 346           *
 347           * @return  none
 348           */
 349          
 350          void RegisterApp_RxAppMsg(sEvent* event)
 351          {
 352   1        gv701x_app_msg_hdr_t* msg_hdr = (gv701x_app_msg_hdr_t*)event->buffDesc.dataptr;
 353   1        hostHdr_t* hybrii_hdr;
 354   1        hostEventHdr_t* evnt_hdr;
 355   1        
 356   1        hybrii_hdr = (hostHdr_t*)(msg_hdr + 1);
 357   1      
 358   1        if(msg_hdr->dst_app_id == register_app_id)
 359   1        {
 360   2          memcpy(&register_state.msg_hdr, msg_hdr, sizeof(gv701x_app_msg_hdr_t));
 361   2          register_state.eventproto = hybrii_hdr->protocol;
 362   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 363   2            (hybrii_hdr->type == EVENT_FRM_ID))
 364   2          {
 365   3            evnt_hdr = (hostEventHdr_t*)(hybrii_hdr + 1);
 366   3            register_state.event = evnt_hdr->type;  
 367   3            register_state.statedata = (u8*)(evnt_hdr + 1);
 368   3            register_state.statedatalen = (u16)(hybrii_hdr->length - sizeof(hostEventHdr_t));   
 369   3          }
 370   2          else
 371   2          {
 372   3            register_state.event = (u8)(*((u8*)(hybrii_hdr + 1)));
 373   3            register_state.statedata = (u8*)(hybrii_hdr + 1);
 374   3            register_state.statedatalen = (u16)hybrii_hdr->length;
 375   3          }   
 376   2          register_state.eventtype = hybrii_hdr->type;
 377   2          register_state.eventclass = event->eventHdr.eventClass;
 378   2      
 379   2          if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 380   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 381   2            (register_state.event == HOST_EVENT_APP_TIMER))
 382   2          {     
 383   3            RegisterApp_TimerHandler((u8*)(evnt_hdr + 1)); 
 384   3            return;
 385   3          }     
 386   2          else if((msg_hdr->src_app_id == APP_FW_MSG_APPID) && 
 387   2            (hybrii_hdr->type == EVENT_FRM_ID) &&
 388   2            (register_state.event == HOST_EVENT_APP_CMD))
 389   2          {     
 390   3            RegisterApp_CmdProcess((char*)(evnt_hdr + 1)); 
 391   3            return;
 392   3          }   
 393   2        }
 394   1        else if(msg_hdr->dst_app_id == APP_BRDCST_MSG_APPID)
 395   1        {
 396   2          u8 *event = (u8*)(hybrii_hdr + 1);
 397   2      #ifdef NWKSTARTUP_APP     
 398   2          if(msg_hdr->src_app_id == nwkstartup_data.app_id)
 399   2          {
 400   3            if(msg_hdr->type == APP_MSG_TYPE_APPIND)
 401   3            {   
 402   4              switch((u8)*event)
 403   4              {
 404   5                case NWK_LINKUP_IND:          
 405   5                {
 406   6                  register_start_evnt_msg_t register_start;
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 8   

 407   6                  register_start.event = REGISTER_START_EVNT;
 408   6                  GV701x_SendAppEvent(register_app_id, register_app_id, APP_MSG_TYPE_APPEVENT, APP_MAC_ID, EVENT_CLASS
             -_CTRL,
 409   6                            MGMT_FRM_ID, &register_start, sizeof(register_start_evnt_msg_t), 0);            
 410   6                }
 411   5                break;
 412   5                
 413   5                case NWK_LINKDWN_IND:
 414   5                {
 415   6                  nwk_dwn_ind_msg_t* nwk_dwn = (nwk_dwn_ind_msg_t*)event;         
 416   6                  if((nwk_dwn->link & PLC_NIC) || (nwk_dwn->link & RF_NIC))   
 417   6                  {         
 418   7                    if(route_info.parent == NULL)
 419   7                    {
 420   8                      register_stop_evnt_msg_t register_stop;
 421   8                      register_start_evnt_msg_t register_start;               
 422   8                      
 423   8                      register_stop.event = REGISTER_STOP_EVNT;           
 424   8                      GV701x_SendAppEvent(register_app_id, register_app_id, APP_MSG_TYPE_APPEVENT, APP_MAC_ID, EVENT_CLA
             -SS_CTRL,
 425   8                                MGMT_FRM_ID, &register_stop, sizeof(register_stop_evnt_msg_t), 0);            
 426   8      
 427   8                      register_start.event = REGISTER_START_EVNT;
 428   8                      GV701x_SendAppEvent(register_app_id, register_app_id, APP_MSG_TYPE_APPEVENT, APP_MAC_ID, EVENT_CLA
             -SS_CTRL,
 429   8                                MGMT_FRM_ID, &register_start, sizeof(register_start_evnt_msg_t), 0);            
 430   8                      
 431   8                    }
 432   7                  }
 433   6                }
 434   5                break;
 435   5      
 436   5                default:
 437   5                break;
 438   5              } 
 439   4            }
 440   3          }
 441   2      #endif    
 442   2          return;
 443   2        } 
 444   1        RegisterApp_StateMachine(&register_state);  
 445   1      }
 446          
 447          /******************************************************************************
 448           * @fn      RegisterApp_Start
 449           *
 450           * @brief   Register the node
 451           *
 452           * @params  none
 453           *
 454           * @return  none
 455           */
 456          
 457          void RegisterApp_Start(void)
 458          {
 459   1      #if 0   
                register_data.nwk_addr.addr_16bit = 0xFFFF;
                if(STATUS_SUCCESS == GV701x_FlashWrite(register_app_id, (u8*)&register_data.nwk_addr, 
                          sizeof(register_data.nwk_addr)))
              #else
 464   1        
 465   1      #endif
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 9   

 466   1        {
 467   2      #ifdef HPGP_DRIVER_APP          
 468   2          register_data.tei = hpgp_nwk_data.params.nwk.tei;
 469   2      #endif
 470   2      #ifdef NWKSTARTUP_APP         
 471   2          memcpy(&(register_data.macaddr), (u8*)nwkstartup_data.link.long_addr.mac_addr, 
 472   2                MAC_ADDR_LEN);
 473   2      #endif
 474   2          register_state.state = REGISTER_UNREGISTERED_STATE;
 475   2          register_data.registration_cnt = 0;
 476   2          register_data.registration_time = REGISTER_BASE_TIMEOUT;
 477   2          register_send_req(&register_data.registration_cnt);
 478   2        }
 479   1      }
 480          
 481          /******************************************************************************
 482           * @fn      RegisterApp_TimerHandler
 483           *
 484           * @brief   Timer handler for Registration timer events
 485           *
 486           * @param   event - event from firmware
 487           *
 488           * @return  none
 489           *
 490           */
 491          
 492          void RegisterApp_TimerHandler(u8* buf)
 493          { 
 494   1        hostTimerEvnt_t* timerevt = 
 495   1            (hostTimerEvnt_t*)buf;  
 496   1        
 497   1        if(buf == NULL)
 498   1          return;
 499   1      
 500   1        /*Demultiplexing the specific timer event*/           
 501   1        switch((u8)timerevt->type)
 502   1        {               
 503   2          case REGISTRATION_TIMER_EVNT: 
 504   2            register_handle_timeout();
 505   2          break;            
 506   2          
 507   2          default:
 508   2          break;
 509   2        }     
 510   1      }
 511          
 512          /******************************************************************************
 513           * @fn      RegisterApp_StateMachine
 514           *
 515           * @brief   The Registration State Machine, it executes all internal/external 
 516           *      events triggered
 517           *
 518           * @param   state - state machine object of the driver
 519           *          (passed as a reference incase there are more than one object)
 520           *
 521           * @return  none
 522           *
 523           */
 524          
 525          void RegisterApp_StateMachine(gv701x_state_t* state) 
 526          {
 527   1        if(state == NULL)
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 10  

 528   1          return;
 529   1      #if 1
 530   1        if(state->event != REGISTER_IDLE_EVNT)
 531   1          FM_Printf(FM_APP, "\nRegister S %bu E %bu P %bu C %bu E %bu Da %bu Sa %bu T %bu", 
 532   1              state->state, state->event,
 533   1              state->eventproto, state->eventclass, state->eventtype, 
 534   1              state->msg_hdr.dst_app_id, state->msg_hdr.src_app_id, state->msg_hdr.type);
 535   1      #endif
 536   1      
 537   1        switch(state->state) 
 538   1        { 
 539   2          case REGISTER_IDLE_STATE:
 540   2            if(state->eventproto == APP_MAC_ID)
 541   2            {
 542   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
 543   3              {               
 544   4                switch(state->event) 
 545   4                {   
 546   5                  case REGISTER_IDLE_EVNT:                  
 547   5                  break;
 548   5      
 549   5                  case REGISTER_START_EVNT:
 550   5                    RegisterApp_Start();
 551   5                  break;    
 552   5      
 553   5                  default:
 554   5                  break;        
 555   5                }
 556   4              }
 557   3            }
 558   2          break;
 559   2              
 560   2          case REGISTER_UNREGISTERED_STATE:
 561   2            if(state->eventproto == APP_MAC_ID)
 562   2            {
 563   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
 564   3              {                     
 565   4                switch(state->event) 
 566   4                {         
 567   5                  case REGISTER_STOP_EVNT:
 568   5                    register_data.registration_cnt = 0;
 569   5                    register_data.registration_time = REGISTER_BASE_TIMEOUT;              
 570   5                    STM_StopTimer(register_data.register_timer);
 571   5                    state->state = REGISTER_IDLE_STATE;
 572   5                  break;
 573   5      
 574   5      
 575   5                  case REGISTER_START_EVNT:
 576   5                    RegisterApp_Start();
 577   5                  break;  
 578   5      
 579   5                  default:
 580   5                  break;          
 581   5                }
 582   4              }
 583   3            }
 584   2          break;
 585   2                
 586   2          case REGISTER_REGISTERED_STATE: 
 587   2            if(state->eventproto == APP_MAC_ID)
 588   2            {
 589   3              if(state->msg_hdr.type == APP_MSG_TYPE_APPEVENT)
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 11  

 590   3              {                     
 591   4                switch(state->event) 
 592   4                {
 593   5                  case REGISTER_STOP_EVNT:
 594   5                    register_data.registration_cnt = 0;
 595   5                    register_data.registration_time = REGISTER_BASE_TIMEOUT;              
 596   5                    STM_StopTimer(register_data.register_timer);
 597   5                    state->state = REGISTER_IDLE_STATE;
 598   5                  break;
 599   5      
 600   5                  case REGISTER_START_EVNT:
 601   5                    nwkstartup_data.link.power_line.addr = 
 602   5                              register_data.nwk_addr.addr_16bit;
 603   5                    nwkstartup_data.link.wireless.addr =    
 604   5                            register_data.nwk_addr.addr_16bit;
 605   5      #ifdef LRWPAN_DRIVER_APP  
 606   5                    lrwpan_set_shortaddr(register_data.nwk_addr.addr_16bit);
 607   5      #endif              
 608   5      
 609   5                  break;
 610   5      
 611   5                  default:
 612   5                  break;
 613   5                } 
 614   4              }
 615   3            }
 616   2          break;
 617   2      
 618   2          default:
 619   2          break;
 620   2        }
 621   1      
 622   1        
 623   1        state->event = REGISTER_IDLE_EVNT;
 624   1        state->eventtype = 0;
 625   1        state->eventclass = 0;
 626   1        state->eventproto = 0;
 627   1        state->statedata = NULL;  
 628   1        state->statedatalen = 0;  
 629   1        memset((u8*)&state->msg_hdr, 0x00, sizeof(gv701x_app_msg_hdr_t));
 630   1      }
 631          
 632          /******************************************************************************
 633           * @fn      register_handle_timeout
 634           *
 635           * @brief   Handles registration timeout
 636           *
 637           * @param   none
 638           *
 639           * @return  none
 640           *
 641           */
 642          
 643          void register_handle_timeout(void)
 644          {
 645   1        if(register_data.registration_cnt >= MAX_REGISTER_RETRY_COUNT)
 646   1        { 
 647   2          route_stop_evnt_msg_t route_stop;   
 648   2      #ifdef NWKSTARTUP_APP   
 649   2          nwk_stop_evnt_msg_t nwk_stop;   
 650   2      #endif    
 651   2          register_data.registration_cnt = 0;
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 12  

 652   2          register_data.registration_time = REGISTER_BASE_TIMEOUT;  
 653   2          register_state.state = REGISTER_IDLE_STATE;
 654   2          register_state.event = REGISTER_IDLE_EVNT;
 655   2      
 656   2      #ifdef ROUTE_APP            
 657   2          route_stop.event = ROUTE_STOP_EVNT;
 658   2          route_stop.link = route_info.parent->link;
 659   2          GV701x_SendAppEvent(register_app_id, route_app_id, APP_MSG_TYPE_APPEVENT, APP_MAC_ID, EVENT_CLASS_CTRL,
 660   2                    MGMT_FRM_ID, &route_stop, sizeof(route_stop_evnt_msg_t), 0);              
 661   2      #endif
 662   2      #ifdef NWKSTARTUP_APP
 663   2          nwk_stop.event = NWK_STOP_EVENT;
 664   2          nwk_stop.link = route_info.parent->link;
 665   2          
 666   2          GV701x_SendAppEvent(register_app_id, nwkstartup_data.app_id, APP_MSG_TYPE_APPEVENT, APP_MAC_ID, EVENT_CL
             -ASS_CTRL,
 667   2                    MGMT_FRM_ID, &nwk_stop, sizeof(nwk_stop_evnt_msg_t), 0);              
 668   2      #endif    
 669   2        }
 670   1        else
 671   1        {
 672   2          /*Trigger Registration request message on registration timeout*/
 673   2          register_send_req(&register_data.registration_cnt);
 674   2        }
 675   1      }
 676          
 677          /******************************************************************************
 678           * @fn      register_tx
 679           *
 680           * @brief   Used to send an OTA frame to the Host
 681           *
 682           * @param   none
 683           *
 684           * @return  none
 685           *
 686           */
 687          
 688          u8 register_tx(u8* buf, u8 payloadLen, u8 frametype)
 689          {
 690   1        u8 ret = STATUS_FAILURE;
 691   1        u8 brdcstmac[MAC_ADDR_LEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 692   1      
 693   1      #ifdef ROUTE_APP    
 694   1        ret = route_send_to_ll((u8*)buf, payloadLen, frametype, FALSE);
 695   1      
 696   1        if(ret == FALSE)
 697   1          ret = STATUS_FAILURE;
 698   1        else
 699   1          ret = STATUS_SUCCESS;   
 700   1      #endif
 701   1        return ret;
 702   1      }
 703          
 704          /******************************************************************************
 705           * @fn      RegisterApp_CmdProcess
 706           *
 707           * @brief   It handles application command line requests
 708           *
 709           * @param   CmdBuf - command string
 710           *
 711           * @return  none
 712           *
C51 COMPILER V9.53.0.0   REGISTER                                                          11/04/2015 20:09:43 PAGE 13  

 713           */
 714          
 715          void RegisterApp_CmdProcess(char* CmdBuf) 
 716          {
 717   1        if(strcmp(CmdBuf, "state") == 0) 
 718   1        {
 719   2          printf("\nRegister S %bu E %bu", register_state.state, register_state.event);           
 720   2        }
 721   1        else if(strcmp(CmdBuf, "stats") == 0) 
 722   1        {
 723   2          printf("\nRegister addr %x \nregreq %u regrsp %u regcnf %u reregreq %u",
 724   2               register_data.nwk_addr.addr_16bit, register_data.stats.regreq,
 725   2               register_data.stats.regrsp, register_data.stats.regcnf,
 726   2               register_data.stats.reregreq);   
 727   2        }
 728   1        else if(strcmp(CmdBuf, "nvclear") == 0) 
 729   1        {
 730   2          GV701x_FlashErase(register_app_id);
 731   2        } 
 732   1      }
 733          
 734          #endif /*REGISTER_APP*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3383    ----
   CONSTANT SIZE    =    292    ----
   XDATA SIZE       =     48    1118
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
