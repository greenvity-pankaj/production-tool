C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE CTRLL
OBJECT MODULE PLACED IN .\obj\ctrll.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\ctrl\ctrll.c LARGE OBJECTADVANCED OPTIMIZE
                    -(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\
                    -..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src
                    -\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\
                    -firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zig
                    -bee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\
                    -inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp
                    -\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_suppor
                    -t;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drive
                    -rs\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;
                    -..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\.
                    -.\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drive
                    -rs\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilit
                    -ies;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers
                    -\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\
                    -..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBR
                    -II_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SY
                    -NC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_D
                    -ETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERR
                    -UPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,R
                    -EGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\ctrll.lst) TABS(2) 
                    -OBJECT(.\obj\ctrll.obj)

line level    source

   1          /** =========================================================
   2           *
   3           *  @file ctrll.c
   4           * 
   5           *  @brief Control Layer
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * ===========================================================*/
  11          #ifdef RTX51_TINY_OS
  12          #include <rtx51tny.h>
  13          #endif
  14          #include <string.h>
  15          #include "papdef.h"
  16          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  19          #include "list.h"
  20          #include "event.h"
  21          #include "nma.h"
  22          #include "nma_fw.h"
  23          #include "green.h"
  24          #include "fm.h"
  25          #include "timer.h"
  26          #include "stm.h"
  27          #include "hpgpdef.h"
  28          #include "hpgpevt.h"
  29          #include "hpgpapi.h"
  30          #include "ctrll.h"
  31          #include "frametask.h"
  32          #include "hybrii_tasks.h"
  33          #include "sys_common.h"
  34          #include "hpgp_msgs.h"
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 2   

  35          #include "event_fw.h"
  36          #ifdef UART_HOST_INTF 
  37          #include "gv701x_uartdriver_fw.h"
  38          #include "gv701x_uartdriver.h"
  39          #endif
  40          #ifdef HYBRII_802154
  41          #include "qmm.h"
  42          #include "return_val.h"
  43          #include "mac_const.h"
  44          #include "mac_msgs.h"
  45          #include "mac_data_structures.h"
  46          #include "mac_hal.h"
  47          #include "mac_internal.h"
  48          #endif
  49          
  50          #define HPGP_TIME_DISC                 1000   //2 seconds
  51          enum {
  52              CTRL_ACC_NEW,
  53              CTRL_ACC_HO,
  54          }; 
  55          
  56          #ifdef UART_HOST_INTF
  57          extern uartRxControl_t uartRxControl; 
  58          extern void timer0Poll();
  59          extern void STM_Proc(void);
  60          extern void uartRxProc();
  61          #endif
  62          void CTRLL_TimerHandler(u16 type, void *cookie);
  63          
  64          u8 hostLeaveReqRsp = 0;
  65          
  66          /* post an event into the internal event queue */
  67          eStatus CTRLL_PostEvent(sCtrlLayer *ctrlLayer, enum eventType evtType, 
  68                                  void *param)
  69          {
  70   1          sEvent xdata * event= EVENT_Alloc(0, 0);
  71   1        
  72   1          /*Compiler warning suppression*/
  73   1          param = param;
  74   1          ctrlLayer = ctrlLayer;
  75   1        
  76   1          if(event== NULL)
  77   1          {
  78   2              FM_Printf(FM_ERROR, "EAF\n");
  79   2              return STATUS_FAILURE;
  80   2          }
  81   1      
  82   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
  83   1          event->eventHdr.type = evtType;
  84   1      
  85   1          /* enqueue the event to the internal event queue */
  86   1          SLIST_Put(&ctrlLayer->intEventQueue, &event->link);
  87   1      
  88   1          return STATUS_SUCCESS;
  89   1      }
  90          
  91          
  92          
  93          eStatus CTRLL_SendEventToLinkLayer( sCtrlLayer *ctrlLayer, 
  94                      enum eventType evtType, 
  95                      void *param)
  96          {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 3   

  97   1          u16          size = 0;
  98   1          sEvent    xdata  *event = NULL;
  99   1          sAuthReq    *authreq = NULL;
 100   1          sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 101   1      
 102   1          /*Compiler warning suppression*/
 103   1          ctrlLayer = ctrlLayer;
 104   1          param = param;
 105   1        
 106   1          if (evtType == EVENT_TYPE_AUTH_REQ)
 107   1          {
 108   2              size = sizeof(sAuthReq);
 109   2              event = EVENT_Alloc(size, EVENT_HPGP_CTRL_HEADROOM);
 110   2          }
 111   1          else
 112   1          {
 113   2              event = EVENT_Alloc(size, 0);
 114   2          }
 115   1          if(event == NULL)
 116   1          {
 117   2              FM_Printf(FM_ERROR, "EAF\n");
 118   2              return STATUS_FAILURE;
 119   2          }
 120   1      
 121   1          if (evtType == EVENT_TYPE_AUTH_REQ)
 122   1          {
 123   2              authreq = (sAuthReq *)(event->buffDesc.dataptr);
 124   2              authreq->authType = AUTH_TYPE_NEK;
 125   2              event->buffDesc.datalen = sizeof(sAuthReq);
 126   2          }
 127   1          
 128   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
 129   1          event->eventHdr.type = evtType;
 130   1      
 131   1          return LINKL_SendEvent(linkl, event);
 132   1      }
 133          
 134          
 135          
 136          #ifdef STA_FUNC
 137          /* ==================================
 138           * Network Discovery Controller (NDC)
 139           * ================================== */
 140          
 141          eStatus NDC_Init(sNdc *ndc)
 142          {
 143   1      //    sCtrlLayer *ctrlLayer = (sCtrlLayer *)HOMEPLUG_GetLayer(HP_LAYER_TYPE_CTRL);
 144   1          memset(ndc, 0, sizeof(sNdc));
 145   1      //    ndc->bbtTimer = STM_AllocTimer(CTRLL_BbtTimerHandler, ctrlLayer);
 146   1      //    if(ndc->bbtTimer == STM_TIMER_INVALID_ID)
 147   1      //    {
 148   1      //        return STATUS_FAILURE;
 149   1      //    }
 150   1          ndc->state = NDC_STATE_INIT; 
 151   1          return STATUS_SUCCESS;
 152   1      
 153   1      }
 154          
 155          void NDC_Stop(sNdc *ndc)
 156          {
 157   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 158   1      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 4   

 159   1          //STM_StopTimer(usc->discTimer);
 160   1          LINKL_StopSta(linkLayer);
 161   1          ndc->state = NDC_STATE_INIT;
 162   1      }
 163          
 164          
 165          void NDC_Start(sNdc *ndc)
 166          {
 167   1          // If NDC restart then stop sta free cco scb
 168   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 169   1          
 170   1          LINKL_StopSta(linkLayer);    
 171   1          LINKL_SetStaMode(linkLayer);
 172   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_NETDISC);
 173   1          ndc->state = NDC_STATE_READY; 
 174   1      }
 175          
 176          
 177          
 178          
 179          
 180          eStatus NDC_SetStaRole(sCtrlLayer *ctrlLayer, u8 staRole)
 181          {
 182   1          u16 eventType;
 183   1          switch(staRole)
 184   1          {
 185   2              case STA_ROLE_USTA:
 186   2              {
 187   3                  eventType = EVENT_TYPE_USTA_IND;
 188   3                  break;
 189   3              }
 190   2              case STA_ROLE_UCCO:
 191   2              {            
 192   3                  eventType = EVENT_TYPE_UCCO_IND;
 193   3                  break;
 194   3              }
 195   2              case STA_ROLE_ACCO:
 196   2              {
 197   3                  eventType = EVENT_TYPE_ACCO_IND;
 198   3                  break;
 199   3              }
 200   2              default:
 201   2              {
 202   3                  //FM_Printf(FM_ERROR, "Unknown Sta Role.\n");
 203   3                  return STATUS_FAILURE;
 204   3              }
 205   2          }
 206   1      
 207   1          return CTRLL_PostEvent(ctrlLayer, eventType, NULL); 
 208   1      }
 209          
 210          
 211          
 212          
 213          void NDC_ProcEvent(sNdc *ndc, sEvent *event)
 214          {
 215   1          u8          staRole = STA_ROLE_UNKNOWN;
 216   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 217   1        
 218   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 219   1          sNma       *nma = HOMEPLUG_GetNma(); 
 220   1      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 5   

 221   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 222   1      
 223   1        //FM_HexDump(FM_USER,"ndcE", (u8*)&event->eventHdr.type, 2);
 224   1        
 225   1          switch(ndc->state)
 226   1          {
 227   2              case NDC_STATE_READY:
 228   2              {
 229   3                  //process events
 230   3                  if(event->eventHdr.type == EVENT_TYPE_CCO_DISC_IND)
 231   3                  {
 232   4                      CTRLL_SendEventToLinkLayer(ctrlLayer, 
 233   4                                                 EVENT_TYPE_NET_ACC_REQ,
 234   4                                                 NULL);
 235   4      //FM_Printf(FM_ERROR, "NDC: send NET_ACC_REQ.\n");
 236   4      
 237   4                      ndc->state = NDC_STATE_WAITFOR_NET_ACC_RSP;
 238   4      
 239   4                  }
 240   3                  else if(event->eventHdr.type == EVENT_TYPE_NET_DISC_IND)
 241   3                  {
 242   4                      staRole = *(event->buffDesc.dataptr);
 243   4      
 244   4                      FM_Printf(FM_CTRL|FM_MINFO, "CTRLL: Rx NET_DISC_IND.\n");
 245   4      #ifdef P8051
 246   4                      FM_Printf(FM_CTRL|FM_MINFO, "STA Role: %bu.\n", staRole);
 247   4      #else
                              FM_Printf(FM_CTRL|FM_MINFO, "STA Role: %d.\n", staRole);
              #endif
 250   4              mctrl->reason = HOST_EVENT_NW_IND_REASON_NWDISCOVERY;
 251   4                      
 252   4                      NDC_SetStaRole(ctrlLayer, staRole); 
 253   4                      ndc->state = NDC_STATE_INIT;
 254   4                  }
 255   3                  else if(event->eventHdr.type == EVENT_TYPE_CCO_SLCT_IND)
 256   3                  {
 257   4              /* 
 258   4              * receive a CCO_SLCT_IND event, which indicates 
 259   4              * that the device will become the CCO.
 260   4              */
 261   4                      LINKL_StopSta(linkl);
 262   4                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 263   4                      ndc->state = NDC_STATE_INIT;
 264   4                  }
 265   3                  
 266   3                  break;
 267   3              }
 268   2      
 269   2          case EVENT_TYPE_NET_EXIT_REQ:
 270   2            hostLeaveReqRsp = 0;
 271   2          case EVENT_TYPE_RESTART_REQ:
 272   2            
 273   2            NDC_Stop(ndc);
 274   2      
 275   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 276   2            {       
 277   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 278   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 279   3            }
 280   2            else
 281   2            {
 282   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 6   

 283   3              mctrl->nextState = MCTRL_STATE_INIT;      
 284   3            }
 285   2            
 286   2            /* send a NET EXIT IND to the MCTRL */
 287   2            CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 288   2            ndc->state = NDC_STATE_INIT;
 289   2      
 290   2            break;
 291   2      
 292   2              case NDC_STATE_WAITFOR_NET_ACC_RSP:
 293   2              {
 294   3                  /* process events (Note: BTT timer has been stopped) */
 295   3                  if(event->eventHdr.type == EVENT_TYPE_NET_ACC_RSP)
 296   3                  {
 297   4                      if(*(event->buffDesc.dataptr) == 0)
 298   4                      {
 299   5                          /* the assocation is successful */
 300   5                          CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL); 
 301   5                          ndc->state = NDC_STATE_INIT;
 302   5                      }
 303   4                      else 
 304   4                      {
 305   5      
 306   5                          /* start the network discovery */
 307   5                          NDC_Start(ndc);
 308   5                          ndc->restart += 1;
 309   5                          if(ndc->restart > 6)
 310   5                          {
 311   6                              //TODO: call the NMA to alert the user
 312   6                          }
 313   5                      }
 314   4                  }
 315   3                  break;
 316   3              }
 317   2              default:
 318   2              {
 319   3                  //perform no operation
 320   3              }
 321   2          }
 322   1      }
 323          
 324          
 325          
 326          /* ===================================
 327           *  Unassociated STA Controller (USC)    
 328           * =================================== */
 329          
 330          eStatus USC_Init(sUsc *usc)
 331          {
 332   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 333   1          memset(usc, 0, sizeof(sUsc));
 334   1      #ifdef CALLBACK
                  usc->discTimer = STM_AllocTimer(CTRLL_TimerHandler, 
                                       EVENT_TYPE_TIMER_DISC_IND, ctrlLayer);
              #else
 338   1          usc->discTimer = STM_AllocTimer(HP_LAYER_TYPE_CTRL, 
 339   1                               EVENT_TYPE_TIMER_DISC_IND, ctrlLayer);
 340   1          FM_Printf(FM_MINFO,"CTRL: Starting EVENT_TYPE_TIMER_DISC_IND\n");
 341   1      #endif
 342   1      
 343   1          if(usc->discTimer == STM_TIMER_INVALID_ID)
 344   1          {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 7   

 345   2              return STATUS_FAILURE;
 346   2          }
 347   1      
 348   1          usc->state = USC_STATE_INIT; 
 349   1          usc->maxDiscoverPeriod = HPGP_TIME_DISC;
 350   1          return STATUS_SUCCESS;
 351   1      }
 352          
 353          
 354          
 355          void USC_Start(sUsc *usc)
 356          {
 357   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);    
 358   1      
 359   1          LINKL_StopSta(linkLayer);    
 360   1          LINKL_SetStaMode(linkLayer);
 361   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_UNASSOC);
 362   1      
 363   1        if(linkLayer->staInfo.lastUserAppCCOState != 2)   
 364   1        {
 365   2            STM_StartTimer(usc->discTimer, usc->maxDiscoverPeriod);
 366   2        }
 367   1          usc->state = USC_STATE_READY; 
 368   1      }
 369          
 370          
 371          
 372          
 373          void USC_Stop(sUsc *usc)
 374          {
 375   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 376   1      
 377   1          STM_StopTimer(usc->discTimer);
 378   1          LINKL_StopSta(linkLayer);
 379   1          usc->state = USC_STATE_INIT;
 380   1      }
 381          
 382          void  USC_ProcReadyState(sUsc *usc, sEvent *event)
 383          {
 384   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 385   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 386   1          sNma       *nma = HOMEPLUG_GetNma(); 
 387   1      
 388   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 389   1          
 390   1          switch(event->eventHdr.type)
 391   1          {
 392   2              case EVENT_TYPE_CCO_DISC_IND:
 393   2                  /* 
 394   2                   * receive a CCO_DISC_IND event, which indicates 
 395   2                   * that the CCO is discovered. Thus, associate the network 
 396   2                   */
 397   2                  FM_Printf(FM_CTRL|FM_MINFO, "USC:CCO_DISC_IND event\n");
 398   2      
 399   2                  STM_StopTimer(usc->discTimer);
 400   2                  if (CTRLL_SendEventToLinkLayer(ctrlLayer,EVENT_TYPE_NET_ACC_REQ, 
 401   2                          NULL) ==  STATUS_SUCCESS)
 402   2                  {
 403   3                      /* stop the discover timer for simplicity */
 404   3                      FM_Printf(FM_CTRL|FM_MINFO, "USC:Wait for ACC Rsp\n");
 405   3                      usc->state = USC_STATE_WAITFOR_NET_ACC_RSP;
 406   3                  }
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 8   

 407   2                  else
 408   2                  {
 409   3                      /* restart for retrigger */
 410   3                      USC_Start(usc);
 411   3                      /* stay in the ready state */
 412   3                  }
 413   2                  break;
 414   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
                      {            
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_JOIN);
               
                          break;
                      }
              #endif
 422   2              case EVENT_TYPE_TIMER_DISC_IND:
 423   2      
 424   2            if(linkLayer->staInfo.lastUserAppCCOState != 2)
 425   2            {
 426   3              
 427   3                    if (LINKL_QueryAnyAlvn(linkLayer))
 428   3                    {
 429   4      #ifdef CCO_FUNC
 430   4                        /* There is an other AVLN */
 431   4                mctrl->reason = HOST_EVENT_NW_IND_REASON_AVLN_FOUND;
 432   4                        CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_UCCO_IND, NULL);
 433   4                        usc->state = USC_STATE_INIT;
 434   4      #endif
 435   4                    }
 436   3                    else
 437   3                    {
 438   4                        STM_StartTimer(usc->discTimer, usc->maxDiscoverPeriod);
 439   4                        /* stay in the ready state */
 440   4                    }
 441   3      
 442   3            }
 443   2                  break;
 444   2              case EVENT_TYPE_CCO_SLCT_IND:
 445   2                  /* 
 446   2                   * receive a CCO_SLCT_IND event, which indicates 
 447   2                   * that the device will become the CCO after net discovery
 448   2                   */
 449   2                  if(linkLayer->staInfo.lastUserAppCCOState != 2)
 450   2                  {
 451   3                      LINKL_StopSta(linkLayer);
 452   3                      STM_StopTimer(usc->discTimer);
 453   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_NWDISCOVERY;
 454   3                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 455   3                      usc->state = USC_STATE_INIT;
 456   3                  }
 457   2                  break;
 458   2            
 459   2          case EVENT_TYPE_JOINNET_TIMEOUT:
 460   2            {
 461   3      
 462   3              
 463   3                      LINKL_StopSta(linkLayer);
 464   3                      STM_StopTimer(usc->discTimer);
 465   3              usc->state = USC_STATE_INIT;
 466   3                        
 467   3      
 468   3              {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 9   

 469   4          //      hostEvent_NetworkId nwId;
 470   4              
 471   4              
 472   4        //        nwId.state = (nwIdState_e)MCTRL_STATE_UNASSOC_STA;
 473   4      //          nwId.reason = 0xFF;
 474   4                //Host_SendIndication(HOST_EVENT_NETWORK_IND,
 475   4                  //      HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
 476   4              
 477   4                mctrl->nextState = MCTRL_STATE_INIT;
 478   4              
 479   4                FM_Printf(FM_USER,"JOINNET\n");
 480   4      
 481   4                mctrl->reason = HOST_EVENT_NW_IND_REASON_ASSOC_FAIL;                  
 482   4                  /* send a NET EXIT IND to the MCTRL */
 483   4                CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 484   4      
 485   4                
 486   4                  
 487   4              }
 488   3      
 489   3      
 490   3              break;
 491   3            }
 492   2              case EVENT_TYPE_NET_EXIT_REQ:
 493   2             hostLeaveReqRsp = 0;
 494   2              
 495   2          case EVENT_TYPE_RESTART_REQ:
 496   2            mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 497   2                  USC_Stop(usc);
 498   2      
 499   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 500   2            {   
 501   3              mctrl->nextState = MCTRL_STATE_NET_DISC;  
 502   3              
 503   3            }
 504   2            else
 505   2            {
 506   3      
 507   3              mctrl->nextState = MCTRL_STATE_INIT;
 508   3                    mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;       
 509   3            }
 510   2            
 511   2            /* send a NET EXIT IND to the MCTRL */
 512   2            CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 513   2            usc->state = UCC_STATE_INIT;
 514   2      
 515   2                  break;
 516   2      
 517   2                  case EVENT_TYPE_AUTH_IND:
 518   2                  {
 519   3                      sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;               
 520   3                                                      
 521   3                      if(pAuthInd->keyType == KEY_TYPE_NEK)
 522   3                      {
 523   4                          //FM_Printf(FM_HINFO,"GOT NEK\n");
 524   4                      }
 525   3                      else
 526   3                      {
 527   4                          //FM_Printf(FM_HINFO,"GOT NMK\n");
 528   4                       
 529   4                      }
 530   3      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 10  

 531   3                      break;
 532   3      
 533   3                  }
 534   2      
 535   2              default:
 536   2              {
 537   3                  /* ignore all other events */
 538   3                  
 539   3            FM_HexDump(FM_ERROR,"usE Unexp", (u8*)&event->eventHdr.type, 2);
 540   3              }
 541   2          }
 542   1      }
 543          
 544          
 545          
 546          void USC_ProcEvent(sUsc *usc, sEvent *event)
 547          {
 548   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 549   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);  
 550   1        
 551   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 552   1        sNma       *nma = HOMEPLUG_GetNma(); 
 553   1          
 554   1      
 555   1        
 556   1        //FM_HexDump(FM_USER,"usE", (u8*)&event->eventHdr.type, 2);
 557   1        //FM_Printf(FM_USER, "usst %bu\n", usc->state);
 558   1      
 559   1          
 560   1          switch(usc->state)
 561   1          {
 562   2              case USC_STATE_READY:
 563   2              {
 564   3                  USC_ProcReadyState(usc, event);
 565   3                  break;
 566   3              }
 567   2              case USC_STATE_WAITFOR_NET_ACC_RSP:
 568   2              {
 569   3                  //process events
 570   3      #if 1
 571   3      
 572   3            switch(event->eventHdr.type)
 573   3                  {
 574   4                    case EVENT_TYPE_NET_ACC_RSP:
 575   4              {
 576   5                        if(*(event->buffDesc.dataptr) == 0)
 577   5                        {
 578   6                            //FM_Printf(FM_CTRL|FM_MINFO, "USC:rx NET_ACC_RSP\n");  
 579   6                           /* success */
 580   6                  mctrl->reason = HOST_EVENT_NW_IND_REASON_ASSOC_CMD;
 581   6                            CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL); 
 582   6                            usc->state = USC_STATE_INIT;
 583   6                        }
 584   5                        else
 585   5                        {
 586   6      #if 1
 587   6                  
 588   6                  
 589   6                  hostEvent_NetworkId nwId;
 590   6                  
 591   6                  /*Compiler warning suppression*/
 592   6                  nwId = nwId;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 11  

 593   6                          
 594   6                  mctrl->reason = HOST_EVENT_NW_IND_REASON_ASSOC_FAIL;
 595   6                  {
 596   7      
 597   7                    USC_Stop(usc);
 598   7      
 599   7                    mctrl->nextState = MCTRL_STATE_INIT;
 600   7                    
 601   7                    CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 602   7      
 603   7                    usc->state = USC_STATE_INIT;
 604   7      
 605   7      
 606   7                    //nwId.state = (nwIdState_e)MCTRL_STATE_UNASSOC_STA;
 607   7      //              nwId.reason = 0xFF;
 608   7        //            Host_SendIndication(HOST_EVENT_NETWORK_IND,
 609   7        ///                   HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));             
 610   7                  }
 611   6      #else
                                    /* restart for retrigger */
                                    USC_Start(usc);
              #endif
 615   6                        }
 616   5      
 617   5                break;
 618   5      
 619   5                    }
 620   4              case EVENT_TYPE_NET_EXIT_REQ:
 621   4                hostLeaveReqRsp = 0;
 622   4              case EVENT_TYPE_RESTART_REQ:
 623   4                {
 624   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 625   5      
 626   5                USC_Stop(usc);
 627   5          
 628   5                if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 629   5                {       
 630   6                  mctrl->nextState = MCTRL_STATE_NET_DISC;
 631   6                }               
 632   5                else
 633   5                {
 634   6      
 635   6                  mctrl->nextState = MCTRL_STATE_INIT;
 636   6                  mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;
 637   6                
 638   6                }
 639   5                
 640   5                /* send a NET EXIT IND to the MCTRL */
 641   5                CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);
 642   5                usc->state = USC_STATE_INIT;
 643   5          
 644   5                break;      
 645   5                }
 646   4            
 647   4                    default:
 648   4                    {
 649   5                        /* ignore all other events */
 650   5                        //FM_Printf(FM_ERROR, "USC:Unexpected event(%d)\n", event->eventHdr.type);
 651   5                FM_HexDump(FM_ERROR,"usE MUnexp", (u8*)&event->eventHdr.type, 2);
 652   5                
 653   5                    }
 654   4      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 12  

 655   4      
 656   4      
 657   4                }
 658   3      #endif
 659   3      
 660   3                  break;
 661   3              }
 662   2              default:
 663   2              {
 664   3                  //perform no operation
 665   3              }
 666   2          }
 667   1      }
 668          
 669          #endif /* STA_FUNC */
 670          
 671          
 672          #ifdef CCO_FUNC
 673          /* =================================
 674           * Unassociated CCO Controller (UCC)
 675           * ================================= */
 676          
 677          eStatus UCC_Init(sUcc *ucc)
 678          {
 679   1          memset(ucc, 0, sizeof(sUcc));
 680   1          ucc->state = UCC_STATE_INIT; 
 681   1          return STATUS_SUCCESS;
 682   1      }
 683          
 684          void UCC_Start(sUcc *ucc)
 685          {
 686   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 687   1      
 688   1      #ifndef MCCO  
                  LINKL_SetBcnInit();
              #endif
 691   1      
 692   1          LINKL_SetCcoMode(linkLayer);
 693   1          LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_UNASSOC);
 694   1          ucc->state = UCC_STATE_READY; 
 695   1      }
 696          
 697          void UCC_ProcEvent(sUcc *ucc, sEvent *event)
 698          {
 699   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 700   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 701   1          sNma       *nma = HOMEPLUG_GetNma(); 
 702   1      
 703   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 704   1          
 705   1      
 706   1      
 707   1          if(ucc->state != UCC_STATE_READY)
 708   1              return;
 709   1      
 710   1      
 711   1        
 712   1        //FM_HexDump(FM_USER,"ucE", (u8*)&event->eventHdr.type, 2);
 713   1      
 714   1      
 715   1          switch(event->eventHdr.type)
 716   1          {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 13  

 717   2      #if 1    
 718   2              case EVENT_TYPE_NET_DISC_IND:
 719   2              {
 720   3                  if(linkLayer->staInfo.lastUserAppCCOState != 1)
 721   3                  {
 722   4                      //other AVLN is found
 723   4                      mctrl->reason = HOST_EVENT_NW_IND_REASON_AVLN_FOUND;
 724   4                      LINKL_StopCco(linkLayer);
 725   4                mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
 726   4               
 727   4                      ucc->state = UCC_STATE_INIT;
 728   4                  }
 729   3                  break;
 730   3              }
 731   2      #endif    
 732   2              case EVENT_TYPE_NET_ACC_IND:
 733   2              {
 734   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
 735   3                  /* Some STA has associated with the CCo */
 736   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 737   3                  ucc->state = UCC_STATE_INIT;
 738   3                  break;
 739   3              }
 740   2          //case EVENT_TYPE_NET_DISC_IND:
 741   2          case EVENT_TYPE_NCO_IND:  //test
 742   2          {
 743   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_NWDISCOVERY;
 744   3            LINKL_StopCco(linkLayer);   
 745   3            ucc->state = UCC_STATE_INIT;      
 746   3      
 747   3          //  if (event->eventHdr.type == EVENT_TYPE_NCO_IND)
 748   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 749   3          //  else
 750   3          //    mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
 751   3              
 752   3              
 753   3              break;
 754   3          } 
 755   2              case EVENT_TYPE_AUTH_IND:
 756   2              {
 757   3      
 758   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
 759   3      
 760   3                 /*
 761   3      
 762   3                              Here, we notify Host of Authentication event
 763   3                 */
 764   3                          
 765   3                                                  
 766   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
 767   3                  {
 768   4                      //FM_Printf(FM_HINFO, "Sent NEK\n");
 769   4                  }
 770   3                  else
 771   3                  {
 772   4                      //FM_Printf(FM_HINFO, "Sent NMK\n");
 773   4                  }
 774   3      
 775   3              }
 776   2              break;
 777   2      #ifdef UKE    
                      case EVENT_TYPE_SET_SEC_MODE:
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 14  

                      {
              
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
              
                                      
                          break;
                      }
              #endif    
 787   2          case EVENT_TYPE_SET_NETWORK_REQ:
 788   2          {
 789   3      
 790   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 791   3            if(*(event->buffDesc.dataptr) == NETWORK_START)
 792   3            {
 793   4          
 794   4              //Generate a time event
 795   4          
 796   4              CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_RESTART_IND,
 797   4                      event->buffDesc.dataptr, 1);
 798   4          
 799   4              /* place the event into the external queue */
 800   4          
 801   4            }
 802   3            else if(*(event->buffDesc.dataptr) == NETWORK_JOIN)
 803   3            {
 804   4              FM_Printf(FM_ERROR,"join \n");
 805   4                
 806   4              LINKL_StopCco(linkLayer);       
 807   4              
 808   4              mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
 809   4              
 810   4              ucc->state = UCC_STATE_INIT;
 811   4          
 812   4            }
 813   3            
 814   3            
 815   3          }
 816   2          
 817   2            
 818   2            break;
 819   2              case EVENT_TYPE_NET_EXIT_REQ:
 820   2              hostLeaveReqRsp = 0;
 821   2              case EVENT_TYPE_RESTART_REQ:    
 822   2            
 823   2          case EVENT_TYPE_RESTART_IND:
 824   2            
 825   2            LINKL_StopCco(linkLayer);
 826   2            
 827   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 828   2            {       
 829   3      
 830   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 831   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 832   3            }
 833   2            else if (event->eventHdr.type == EVENT_TYPE_RESTART_IND)        
 834   2            { 
 835   3               mctrl->nextState = MCTRL_STATE_UNASSOC_CCO;    
 836   3               mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
 837   3            }     
 838   2            else
 839   2            {
 840   3              mctrl->nextState = MCTRL_STATE_INIT;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 15  

 841   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;   
 842   3            }
 843   2            
 844   2                ucc->state = UCC_STATE_INIT;
 845   2                break;
 846   2          
 847   2              default:
 848   2              {
 849   3              }
 850   2          }
 851   1      }
 852          
 853          #endif /* CCO_FUNC */
 854          
 855          
 856          #ifdef STA_FUNC
 857          /* ================================
 858           * Associated STA Controller (ASC)
 859           * ================================ */
 860          
 861          eStatus ASC_Init(sAsc *asc)
 862          {
 863   1          memset(asc, 0, sizeof(sAsc));
 864   1          asc->state = ASC_STATE_INIT; 
 865   1          return STATUS_SUCCESS;
 866   1      }
 867          
 868          
 869          
 870          
 871          void ASC_Start(sAsc *asc, u8 auth)
 872          {
 873   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 874   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 875   1          
 876   1          LINKL_SetStaMode(linkLayer);
 877   1          LINKL_StartSta(linkLayer, LINKL_STA_TYPE_ASSOC);
 878   1          asc->state = ASC_STATE_READY; 
 879   1      
 880   1          if(auth == 1)
 881   1          {
 882   2              CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, NULL);
 883   2          }
 884   1      #ifndef AKM 
 885   1        LINKL_SetHpgpNetworkKey(linkLayer);
 886   1        LINKL_SetKeyDone(linkLayer);
 887   1      
 888   1      #endif
 889   1      
 890   1      #ifdef P8051
 891   1          FM_Printf(FM_CTRL|FM_MINFO, "ASC:start(%bu)\n", auth);
 892   1      #else
                  FM_Printf(FM_CTRL|FM_MINFO, "ASC:start(%d)\n", auth);
              #endif
 895   1      }
 896          
 897          
 898          u8 mctrlJoinnetProc = 0;
 899          
 900          void ASC_ProcEvent(sAsc *asc, sEvent *event)
 901          {
 902   1          sNetLeaveIndEvent  *netLeaveInd = NULL;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 16  

 903   1          sCcoLostIndEvent   *ccoLostInd =  NULL;
 904   1          sNma       *nma = HOMEPLUG_GetNma(); 
 905   1      
 906   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 907   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
 908   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
 909   1        
 910   1      
 911   1          if(asc->state != ASC_STATE_READY)
 912   1              return;
 913   1      
 914   1        //FM_HexDump(FM_USER,"asE", (u8*)&event->eventHdr.type, 2);
 915   1          
 916   1          switch(event->eventHdr.type)
 917   1          {
 918   2              case EVENT_TYPE_CCO_HO_IND:
 919   2              {
 920   3                  // become the CCo. Send EVENT_TYPE_ACCO_IND to Main Controller
 921   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_CCOHANDOVER;
 922   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL); 
 923   3                  asc->state = ASC_STATE_INIT;
 924   3                  break;
 925   3              }
 926   2              case EVENT_TYPE_NET_LEAVE_IND:
 927   2              {
 928   3                  netLeaveInd = (sNetLeaveIndEvent *)event->buffDesc.dataptr;       
 929   3                  //TODO: call the NMA API to notify the user
 930   3                  mctrl->reason = HOST_EVENT_NW_IND_REASON_CCO_LEAVE_IND;
 931   3                  // Send EVENT_TYPE_USTA_IND to Main Controller
 932   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL); 
 933   3                  mctrl->state = MCTRL_STATE_INIT;
 934   3                  asc->state = ASC_STATE_INIT;
 935   3                  break;
 936   3              }
 937   2              case EVENT_TYPE_CCO_LOST_IND:
 938   2              {
 939   3                  ccoLostInd = (sCcoLostIndEvent *)event->buffDesc.dataptr;
 940   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_BCNLOSS;
 941   3            asc->state = ASC_STATE_INIT;
 942   3            LINKL_StopSta(linkLayer);
 943   3                  if(linkLayer->staInfo.lastUserAppCCOState == 2)
 944   3                  {
 945   4              mctrl->state = MCTRL_STATE_INIT;
 946   4                      CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL); 
 947   4         
 948   4                  }
 949   3                  else
 950   3                  {
 951   4                      if(ccoLostInd->reason == 0) //really lost
 952   4                      {
 953   5                          //restart the network discovery
 954   5                          CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_RESTART_IND, NULL); 
 955   5                      }
 956   4                      else //become the CCo due to backup
 957   4                      {
 958   5                          
 959   5                          // Send EVENT_TYPE_ACCO_IND to Main Controller
 960   5                          CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ACCO_IND, NULL);
 961   5                      }
 962   4                  }
 963   3                  break;
 964   3              }
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 17  

 965   2      #if 0   
                      case EVENT_TYPE_SET_NETWORK_REQ:
                      {
                          if(*(event->buffDesc.dataptr) != NETWORK_LEAVE)
                          {
                              break;
                          }
                      }
              #endif
 974   2      
 975   2              case EVENT_TYPE_NET_EXIT_REQ:
 976   2            hostLeaveReqRsp = 0;
 977   2          case EVENT_TYPE_RESTART_REQ:
 978   2      
 979   2                  CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_LEAVE_REQ, 
 980   2                                             NULL);
 981   2            
 982   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
 983   2            {       
 984   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
 985   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
 986   3            }
 987   2            else
 988   2            {
 989   3              mctrl->nextState = MCTRL_STATE_INIT;
 990   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;
 991   3      
 992   3            }
 993   2            
 994   2            
 995   2                  /* stay in the same state to wait for a response */
 996   2                  break;
 997   2              case EVENT_TYPE_NET_LEAVE_RSP:
 998   2                  LINKL_StopSta(linkLayer);
 999   2      
1000   2            //FM_Printf(FM_ERROR,"lrsp %u \n",mctrl->nextState);
1001   2      
1002   2      ///     if (mctrl->nextState == MCTRL_STATE_INIT)
1003   2            
1004   2      
1005   2                 /* send a NET EXIT IND to the MCTRL */
1006   2                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_NET_EXIT_IND, NULL);   
1007   2                  asc->state = ASC_STATE_INIT;
1008   2                  break;
1009   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
                      {
                         
                           LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
                          
                          break;
                      }
              #endif
1018   2              case EVENT_TYPE_AUTH_IND:
1019   2              {
1020   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
1021   3      
1022   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
1023   3                  {
1024   4              if(pAuthInd->result == STATUS_SUCCESS)
1025   4              {
1026   5      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 18  

1027   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_ASSOC_CMD;
1028   5              
1029   5      
1030   5                #if 0
                        FM_Printf(FM_ERROR,"F NEK Failed");
                          if(linkLayer->staInfo.lastUserAppCCOState == 2)
                                  {
                            mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
                                  }
                                  else
                                  {
                                      mctrl->nextState = MCTRL_STATE_NET_DISC;
                                  }
                                
                        CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_LEAVE_REQ, 
                                           NULL);                   
              
                        
              
                        #endif
1047   5                
1048   5                mctrlJoinnetProc = 0;
1049   5                
1050   5                Host_SendIndication(HOST_EVENT_AUTH_COMPLETE, HPGP_MAC_ID, NULL, 0);
1051   5              }
1052   4              else
1053   4              {
1054   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_AUTH_FAIL;
1055   5                  if(linkLayer->staInfo.lastUserAppCCOState == 2)
1056   5                          {
1057   6      #if 1
1058   6      
1059   6      
1060   6      #if 0
                          hostEvent_NetworkId nwId;
                            mctrl->nextState = MCTRL_STATE_INIT;            
              
                          nwId.state = (nwIdState_e)MCTRL_STATE_UNASSOC_STA;
                          nwId.reason = 0xFF;
                          Host_SendIndication(HOST_EVENT_NETWORK_IND,
                                  HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
              #endif            
1069   6                  
1070   6      
1071   6                  mctrl->nextState = MCTRL_STATE_INIT;
1072   6      #else
                            mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
              #endif
1075   6                          }
1076   5                          else
1077   5                          {
1078   6                              mctrl->nextState = MCTRL_STATE_NET_DISC;
1079   6                          }
1080   5      
1081   5                FM_Printf(FM_ERROR,"NEK Failed");
1082   5              
1083   5                CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_LEAVE_REQ, 
1084   5                                   NULL);                   
1085   5              }
1086   4              
1087   4                  }
1088   3                  else
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 19  

1089   3                  {
1090   4      #ifdef UKE                
              
                              u8 secMode = pAuthInd->secMode;
              
                              if (secMode == SEC_MODE_SC_JOIN)
                              {                   
                                  
                                  //FM_Printf(FM_HINFO,"GOT NMK\n");
              
              //                    CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, 
                //                                                 linkLayer->staInfo.ccoScb);             
                                  CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_AUTH_REQ, 
                                                                 NULL);
                              }
                              else
                              {
                                  //FM_Printf(FM_HINFO,"SENT NMK\n");
                              }
              #endif
1109   4      
1110   4                  }
1111   3              
1112   3      
1113   3                  
1114   3                  break;
1115   3      
1116   3              }
1117   2              
1118   2              default:
1119   2              {
1120   3            FM_HexDump(FM_ERROR,"aSE MUnexp", (u8*)&event->eventHdr.type, 2);
1121   3              }
1122   2          }
1123   1      }
1124          
1125          #endif /* STA_FUNC */
1126          
1127          
1128          #ifdef CCO_FUNC
1129          /* ===============================
1130           * Associated CCO Controller (ACC)
1131           * =============================== */
1132          
1133          eStatus ACC_Init(sAcc *acc)
1134          {
1135   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1136   1          memset(acc, 0, sizeof(sAcc));
1137   1      #ifdef CALLBACK
                  acc->joinTimer = STM_AllocTimer(CTRLL_TimerHandler, 
                                       EVENT_TYPE_TIMER_JOIN_IND, ctrlLayer);
              #else
1141   1          acc->joinTimer = STM_AllocTimer(HP_LAYER_TYPE_CTRL,
1142   1                               EVENT_TYPE_TIMER_JOIN_IND, ctrlLayer);
1143   1      #endif
1144   1          if(acc->joinTimer == STM_TIMER_INVALID_ID)
1145   1          {
1146   2              return STATUS_FAILURE;
1147   2          }
1148   1          acc->state = ACC_STATE_INIT; 
1149   1          acc->maxDiscoverPeriod = HPGP_TIME_DISC;
1150   1          return STATUS_SUCCESS;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 20  

1151   1      }
1152          
1153          void ACC_Start(sAcc *acc, u8 reason)
1154          {
1155   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1156   1        
1157   1      #ifndef MCCO  
                LINKL_SetBcnInit();
              #endif
1160   1      
1161   1          LINKL_SetCcoMode(linkLayer);
1162   1          if (reason == CTRL_ACC_NEW)
1163   1             LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_ASSOC);
1164   1          else
1165   1             LINKL_StartCco(linkLayer, LINKL_CCO_TYPE_HO);
1166   1          STM_StartTimer(acc->joinTimer, acc->maxDiscoverPeriod);
1167   1          acc->state = ACC_STATE_READY;
1168   1      #ifdef P8051
1169   1          FM_Printf(FM_CTRL|FM_MINFO, "ACC:start(%bu)\n", reason);
1170   1      #else
                  FM_Printf(FM_CTRL|FM_MINFO, "ACC:start(%d)\n", reason);
              #endif 
1173   1      }
1174          
1175          
1176          
1177          void ACC_BecomeUnassociated(sCtrlLayer *ctrlLayer)
1178          {
1179   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1180   1          
1181   1          if (LINKL_QueryAnyAlvn(linkLayer) && (linkLayer->staInfo.lastUserAppCCOState != 1))
1182   1          {
1183   2              
1184   2              CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL);
1185   2          }
1186   1          else
1187   1          {
1188   2              CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_UCCO_IND, NULL);
1189   2          }
1190   1      }
1191          
1192          
1193          
1194          void ACC_ProcEvent(sAcc *acc, sEvent *event)
1195          {
1196   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1197   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1198   1          sNma       *nma = HOMEPLUG_GetNma(); 
1199   1      
1200   1        sMctrl *mctrl =  &ctrlLayer->mainCtrl;
1201   1          
1202   1      
1203   1          if(acc->state != ACC_STATE_READY)
1204   1              return;
1205   1      
1206   1        //FM_HexDump(FM_USER,"acE", (u8*)&event->eventHdr.type, 2);
1207   1        
1208   1      
1209   1          switch(event->eventHdr.type)
1210   1          {
1211   2              case EVENT_TYPE_TIMER_ACC_IND:
1212   2              {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 21  

1213   3                  if (LINKL_QueryAnySta(linkLayer))
1214   3                  {
1215   4                      // stay here
1216   4                      acc->state = ACC_STATE_READY;
1217   4                  }
1218   3                  else
1219   3                  {
1220   4                      ACC_BecomeUnassociated(ctrlLayer);
1221   4                      acc->state = ACC_STATE_INIT;
1222   4                  }
1223   3                  break;
1224   3              }
1225   2              case EVENT_TYPE_NO_STA_IND:
1226   2              {
1227   3      #if 0     
                    mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
                          LINKL_StopCco(linkLayer);
                          acc->state = ACC_STATE_INIT;
                    mctrl->nextState = MCTRL_STATE_UNASSOC_CCO;
              
              #else
1234   3      
1235   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
1236   3            acc->state = ACC_STATE_INIT;
1237   3            mctrl->nextState = MCTRL_STATE_UNASSOC_CCO;
1238   3            ACC_BecomeUnassociated(ctrlLayer);
1239   3      
1240   3      #endif
1241   3      
1242   3                  break;
1243   3              }
1244   2              case EVENT_TYPE_AUTH_IND:
1245   2              {
1246   3      
1247   3                  sAuthInd *pAuthInd = (sAuthInd*)event->buffDesc.dataptr;
1248   3      
1249   3                  /*
1250   3      
1251   3                              Here, we notify Host of Authentication event
1252   3                          */
1253   3                                                  
1254   3                  if(pAuthInd->keyType == KEY_TYPE_NEK)
1255   3                  {
1256   4                      //FM_Printf(FM_ERROR,"SENT NEK\n");
1257   4                  }
1258   3                  else
1259   3                  {
1260   4                     
1261   4                      //FM_Printf(FM_ERROR,"SENT NMK\n");
1262   4                  }
1263   3      
1264   3              }
1265   2              break;
1266   2      #ifdef UKE
                      case EVENT_TYPE_SET_SEC_MODE:
                      {
                          LINKL_SetSecurityMode(linkLayer, SEC_MODE_SC_ADD);
                                  
                          break;
                      }
              #endif    
1274   2              case EVENT_TYPE_CCO_HO_IND:
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 22  

1275   2              {
1276   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
1277   3                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_ASTA_IND, NULL);
1278   3                  acc->state = ACC_STATE_INIT;
1279   3                  break;
1280   3              }
1281   2          case EVENT_TYPE_NCO_IND:
1282   2          {
1283   3            mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
1284   3            LINKL_StopCco(linkLayer);
1285   3            acc->state = ACC_STATE_INIT;      
1286   3            mctrl->nextState = MCTRL_STATE_NET_DISC;            
1287   3              
1288   3              break;
1289   3          }     
1290   2      
1291   2           case EVENT_TYPE_SET_NETWORK_REQ:
1292   2             {
1293   3      
1294   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
1295   3            
1296   3          
1297   3               if(*(event->buffDesc.dataptr) == NETWORK_START)
1298   3               {
1299   4          
1300   4                 sEvent xdata *event = NULL;
1301   4                 u8   *dataptr = NULL;
1302   4                 //Generate a time event
1303   4                 event = EVENT_Alloc(1, 0);
1304   4                 if(event == NULL)
1305   4                 {
1306   5                   FM_Printf(FM_ERROR, "EAF\n");
1307   5                   break;
1308   5                 }
1309   4                 event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1310   4                 event->eventHdr.type = EVENT_TYPE_RESTART_IND;
1311   4                 dataptr = event->buffDesc.dataptr;
1312   4          
1313   4                 /* place the event into the external queue */
1314   4                 CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_RESTART_IND,
1315   4                         NULL, 0);
1316   4          
1317   4               }
1318   3               else if(*(event->buffDesc.dataptr) == NETWORK_JOIN)
1319   3               {
1320   4               FM_Printf(FM_ERROR,"join \n");
1321   4          
1322   4               LINKL_StopCco(linkLayer);         
1323   4          
1324   4               mctrl->nextState = MCTRL_STATE_UNASSOC_STA;
1325   4          
1326   4               acc->state = UCC_STATE_INIT;
1327   4          
1328   4               }
1329   3          
1330   3          
1331   3             }
1332   2          
1333   2                 
1334   2          break;     
1335   2              case EVENT_TYPE_NET_EXIT_REQ:
1336   2            hostLeaveReqRsp = 0;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 23  

1337   2              case EVENT_TYPE_RESTART_REQ:
1338   2      
1339   2              case EVENT_TYPE_RESTART_IND:
1340   2      
1341   2                  LINKL_StopCco(linkLayer);     
1342   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_REQ)
1343   2            {       
1344   3              mctrl->nextState = MCTRL_STATE_NET_DISC;
1345   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
1346   3            }
1347   2            else
1348   2            if (event->eventHdr.type == EVENT_TYPE_RESTART_IND)       
1349   2            { 
1350   3               mctrl->nextState = MCTRL_STATE_UNASSOC_CCO;
1351   3                 mctrl->reason = HOST_EVENT_NW_IND_REASON_RESERVED;
1352   3          
1353   3            }else
1354   2            {
1355   3      
1356   3              mctrl->nextState = MCTRL_STATE_INIT;
1357   3      
1358   3              mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;
1359   3            }
1360   2                  acc->state = ACC_STATE_INIT;
1361   2                  break;
1362   2              default:
1363   2              {
1364   3              }
1365   2          }
1366   1      }
1367          
1368          #endif /* CCO_FUNC */
1369          
1370          /* =========================
1371           * Main Controller (MCTRL)
1372           * ========================= */
1373          
1374          eStatus MCTRL_Init(sMctrl *mctrl)
1375          {
1376   1        sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1377   1      
1378   1          memset(mctrl, 0, sizeof(sMctrl));
1379   1          mctrl->state = MCTRL_STATE_INIT;
1380   1        mctrl->wdtTimer = STM_AllocTimer(HP_LAYER_TYPE_CTRL,EVENT_TYPE_TIMER_WDT_SET_IND, ctrlLayer);
1381   1        if(mctrl->wdtTimer == STM_TIMER_ID_NULL)
1382   1        {
1383   2          return STATUS_FAILURE;
1384   2        }
1385   1        configWDT(1,0xffff, SYSTEM_CLOCK_1024_PRESCALE);
1386   1        STM_StartTimer(mctrl->wdtTimer,WDT_SET_IND_TIME);
1387   1         return STATUS_SUCCESS;
1388   1      }
1389          
1390          void MCTRL_PreProcEvent(sMctrl *mctrl, sEvent *event)
1391          {
1392   1          /*Compiler warning suppression*/
1393   1          mctrl = mctrl;
1394   1        
1395   1          //set event destination transaction to MCTRL
1396   1          event->eventHdr.trans = CTRLL_TRANS_MCTRL;
1397   1      }
1398          
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 24  

1399          bool MCTRL_IsAssociated()
1400          {
1401   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1402   1          if(ctrlLayer->mainCtrl.state == MCTRL_STATE_ASSOC_STA || ctrlLayer->mainCtrl.state == MCTRL_STATE_ASSO
             -C_CCO)
1403   1          {
1404   2              return TRUE;
1405   2          }
1406   1          return FALSE;
1407   1      }
1408          
1409          void MCTRL_ProcEvent(sMctrl *mctrl, sEvent *event)
1410          {
1411   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
1412   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1413   1          sHaLayer *hal = HOMEPLUG_GetHal();
1414   1        u8 stateOld = mctrl->state;
1415   1        
1416   1        sNma* nma = (sNma*)HOMEPLUG_GetNma();
1417   1      
1418   1      
1419   1        //FM_HexDump(FM_USER,"mE", (u8*)&event->eventHdr.type, 2);
1420   1        
1421   1      
1422   1        if(event->eventHdr.type == EVENT_TYPE_TIMER_WDT_SET_IND)
1423   1        {
1424   2          configWDT(1,0xffff, SYSTEM_CLOCK_1024_PRESCALE);
1425   2          STM_StartTimer(mctrl->wdtTimer,WDT_SET_IND_TIME);
1426   2          return;
1427   2        }
1428   1          switch(mctrl->state)
1429   1          {
1430   2              case MCTRL_STATE_INIT:
1431   2              {
1432   3                  switch(event->eventHdr.type)
1433   3                  {
1434   4      #ifdef STA_FUNC
1435   4                      case EVENT_TYPE_RESTART_REQ:
1436   4                      {
1437   5                          /* start the network discovery */
1438   5                          NDC_Start(&ctrlLayer->netDiscCtrl);
1439   5                FM_Printf(FM_CTRL|FM_MINFO, "MCTRL: transit to NET_DISC state\n");
1440   5                          mctrl->state = MCTRL_STATE_NET_DISC;
1441   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
1442   5                          break;
1443   5                      }
1444   4      #endif
1445   4                      case EVENT_TYPE_SET_NETWORK_REQ:
1446   4                      {
1447   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_USERCMD;
1448   5                                      
1449   5                          if(*(event->buffDesc.dataptr) == NETWORK_START)
1450   5                          {
1451   6      #ifdef CCO_FUNC
1452   6                              /* start the unassociated CCo */
1453   6                              UCC_Start(&ctrlLayer->uCcoCtrl);
1454   6                              mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1455   6      #endif
1456   6                          }
1457   5                          else if(*(event->buffDesc.dataptr) == NETWORK_JOIN)
1458   5                          {
1459   6      
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 25  

1460   6                  mctrl->reason = HOST_EVENT_NW_IND_REASON_ASSOC_CMD;
1461   6                //  FM_Printf(FM_USER,"HOST_EVENT_NW_IND_REASON_ASSOC_CMD\n");
1462   6        
1463   6      #ifdef STA_FUNC
1464   6                              /* start the unassociated STA */
1465   6                              USC_Start(&ctrlLayer->uStaCtrl);
1466   6                  mctrlJoinnetProc = 1;
1467   6                              mctrl->state = MCTRL_STATE_UNASSOC_STA;
1468   6      #endif
1469   6                          }
1470   5                          else
1471   5                          {
1472   6                          }
1473   5                          break;
1474   5                      }
1475   4      
1476   4              case EVENT_TYPE_NET_EXIT_REQ:
1477   4              {
1478   5                hostEvent_NetworkId nwId;
1479   5                
1480   5      
1481   5                sNma* nma = (sNma*)HOMEPLUG_GetNma();
1482   5                mctrl->reason = HOST_EVENT_NW_IND_REASON_NETEXIT_CMD;
1483   5                
1484   5                  /* respond to the NMA */
1485   5                //NMA_SendNetExitCnf(nma, 0);   /* success result */
1486   5                nwId.state = (nwIdState_e)mctrl->state;
1487   5                nwId.reason = mctrl->reason;
1488   5      #if 0         
                        FM_Printf(FM_USER, "oldstate : %bu  ", stateOld);
                        FM_Printf(FM_USER, "state : %bu  ", nwId.state);
                        FM_Printf(FM_USER, "reason : %bu ", nwId.reason);
              #endif          
1493   5                Host_SendIndication(HOST_EVENT_NETWORK_IND, HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
1494   5                
1495   5                
1496   5                break;      
1497   5                }
1498   4                    
1499   4                      default:
1500   4                          FM_HexDump(FM_CTRL|FM_MINFO, "MCTRL:rx unexp evt(%d)at INIT state\n", (u8*)&event->eve
             -ntHdr.type,2);
1501   4                  }
1502   3                  break;
1503   3              }
1504   2      #ifdef STA_FUNC
1505   2              case MCTRL_STATE_NET_DISC:
1506   2              {
1507   3            FM_HexDump(FM_CTRL|FM_MINFO, "MCTRL: Get an event \n", (u8*)&event->eventHdr.type, 2);
1508   3                  switch(event->eventHdr.type)
1509   3                  {
1510   4                      case EVENT_TYPE_USTA_IND:
1511   4                      {
1512   5                          USC_Start(&ctrlLayer->uStaCtrl );
1513   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1514   5                          break;
1515   5                      }
1516   4                      case EVENT_TYPE_ASTA_IND:
1517   4                      {
1518   5      
1519   5      #ifdef UKE                    
                                  u8 secMode;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 26  

              
                                  LINKL_GetSecurityMode(linkl, &secMode);
              
                                  if(secMode  == SEC_MODE_SC_JOIN)
                                  {
                                      ASC_Start(&ctrlLayer->aStaCtrl, 0);
                                  }
                                  else                        
              #endif          
1530   5                          {
1531   6      #ifdef AKM                   
                                      ASC_Start(&ctrlLayer->aStaCtrl, 1);
              #else
1534   6                  ASC_Start(&ctrlLayer->aStaCtrl, 0);
1535   6      
1536   6      #endif
1537   6                          }
1538   5                          mctrl->state = MCTRL_STATE_ASSOC_STA;
1539   5                          break;
1540   5                      }
1541   4      #ifdef CCO_FUNC
1542   4                      case EVENT_TYPE_UCCO_IND:
1543   4                      {
1544   5                          UCC_Start(&ctrlLayer->uCcoCtrl );
1545   5                          mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1546   5                          break;
1547   5                      }
1548   4                      case EVENT_TYPE_ACCO_IND:
1549   4                      {
1550   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1551   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1552   5                          break;
1553   5                      }
1554   4      #endif /* CCO_FUNC */
1555   4              
1556   4              case EVENT_TYPE_NET_EXIT_IND:
1557   4              if (mctrl->nextState == MCTRL_STATE_INIT)
1558   4              {
1559   5      
1560   5                mctrl->state = MCTRL_STATE_INIT;
1561   5      #ifdef NMA
1562   5                /* respond to the NMA */
1563   5                //if (hostLeaveReqRsp)
1564   5                //NMA_SendNetExitCnf(nma, 0);   /* success result */
1565   5      #endif
1566   5                hostLeaveReqRsp = 0;
1567   5      
1568   5              }
1569   4              else
1570   4              {
1571   5                mctrl->state = MCTRL_STATE_NET_DISC;
1572   5      
1573   5                /* start the network discovery */
1574   5      #ifdef STA_FUNC           
1575   5                NDC_Start(&ctrlLayer->netDiscCtrl);
1576   5      #endif
1577   5      
1578   5              }
1579   4              break;
1580   4              
1581   4              
1582   4              
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 27  

1583   4                      default:
1584   4                      {
1585   5                          //stay in the same state
1586   5                          NDC_ProcEvent(&ctrlLayer->netDiscCtrl, event);
1587   5                      }
1588   4                  }
1589   3                  break;
1590   3              }
1591   2              case MCTRL_STATE_UNASSOC_STA:
1592   2              {
1593   3                  switch(event->eventHdr.type)
1594   3                  {
1595   4                      case EVENT_TYPE_ASTA_IND:
1596   4                      {
1597   5      #ifdef UKE
                          u8 secMode;
              
                                  LINKL_GetSecurityMode(linkl, &secMode);
              
                                  if(secMode == SEC_MODE_SC_JOIN)
                                  {
                                      ASC_Start(&ctrlLayer->aStaCtrl, 0);
                                  }
                                  else
              #endif          
1608   5                
1609   5                          {
1610   6      #ifdef AKM                    
                                      ASC_Start(&ctrlLayer->aStaCtrl, 1);
              #else
1613   6                  ASC_Start(&ctrlLayer->aStaCtrl, 0);
1614   6      
1615   6      #endif
1616   6                          }
1617   5                          mctrl->state = MCTRL_STATE_ASSOC_STA;
1618   5                          break;
1619   5                      }
1620   4      #ifdef CCO_FUNC
1621   4                      case EVENT_TYPE_UCCO_IND:
1622   4                      {
1623   5                          if(linkl->staInfo.lastUserAppCCOState != 2)
1624   5                          {
1625   6                              LINKL_StopSta(linkl);
1626   6                              UCC_Start(&ctrlLayer->uCcoCtrl);
1627   6                              mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1628   6                          }
1629   5                          break;
1630   5                      }
1631   4                      case EVENT_TYPE_ACCO_IND:
1632   4                      {
1633   5                          if(linkl->staInfo.lastUserAppCCOState != 2)
1634   5                          {
1635   6                              ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1636   6                              mctrl->state = MCTRL_STATE_ASSOC_CCO;
1637   6                          }
1638   5                          break;
1639   5                      }
1640   4      #endif /* CCO_FUNC */
1641   4      
1642   4              case EVENT_TYPE_NET_EXIT_IND:
1643   4              if (mctrl->nextState == MCTRL_STATE_INIT)
1644   4              {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 28  

1645   5                mctrl->state = MCTRL_STATE_INIT;
1646   5      #ifdef NMA
1647   5                /* respond to the NMA */
1648   5      
1649   5                if (hostLeaveReqRsp)
1650   5                {
1651   6                  //NMA_SendNetExitCnf(nma, 0);   /* success result */
1652   6      
1653   6                }
1654   5      #endif
1655   5                hostLeaveReqRsp = 0;
1656   5      
1657   5              }
1658   4              else
1659   4              {
1660   5                mctrl->state = MCTRL_STATE_NET_DISC;
1661   5      
1662   5                /* start the network discovery */
1663   5      #ifdef STA_FUNC           
1664   5                NDC_Start(&ctrlLayer->netDiscCtrl);
1665   5      #endif
1666   5      
1667   5              }
1668   4              break;
1669   4      
1670   4      
1671   4      
1672   4      
1673   4      
1674   4                      case EVENT_TYPE_SET_NETWORK_REQ:
1675   4                          if(linkl->staInfo.lastUserAppCCOState != 2)
1676   4                          {
1677   5                            mctrl->state = MCTRL_STATE_NET_DISC;
1678   5                            /* start the network discovery */
1679   5      #ifdef STA_FUNC         
1680   5                            NDC_Start(&ctrlLayer->netDiscCtrl);
1681   5      #endif
1682   5                }
1683   4                          break;
1684   4      
1685   4      
1686   4                      default:
1687   4                      {
1688   5                          //stay in the same state
1689   5                          USC_ProcEvent(&ctrlLayer->uStaCtrl, event);
1690   5                      }
1691   4                  }
1692   3                  break;
1693   3              }
1694   2              case MCTRL_STATE_ASSOC_STA:
1695   2              {
1696   3                  switch(event->eventHdr.type)
1697   3                  {
1698   4      #ifdef CCO_FUNC
1699   4                      case EVENT_TYPE_ACCO_IND:
1700   4                      {
1701   5                          if(linkl->staInfo.lastUserAppCCOState != 2)
1702   5                          {
1703   6                              ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_HO);
1704   6                              mctrl->state = MCTRL_STATE_ASSOC_CCO;
1705   6                          }
1706   5                          break;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 29  

1707   5                      }
1708   4      #endif /* CCO_FUNC */
1709   4                      case EVENT_TYPE_USTA_IND:
1710   4                      {
1711   5                          
1712   5                          USC_Start(&ctrlLayer->uStaCtrl );
1713   5                          mctrl->state = MCTRL_STATE_UNASSOC_STA;
1714   5                          break;
1715   5                      }
1716   4                      case EVENT_TYPE_RESTART_IND:
1717   4                      {
1718   5                if (linkl->staInfo.lastUserAppCCOState == 0)
1719   5                {
1720   6      #ifdef STA_FUNC
1721   6                            NDC_Start(&ctrlLayer->netDiscCtrl);
1722   6      #endif
1723   6                  mctrl->state = MCTRL_STATE_NET_DISC;
1724   6                }
1725   5                else
1726   5                {
1727   6      #ifdef STA_FUNC
1728   6                  USC_Start(&ctrlLayer->uStaCtrl);
1729   6      #endif
1730   6                  mctrl->state = MCTRL_STATE_UNASSOC_STA;
1731   6      
1732   6                }
1733   5                          
1734   5                          break;
1735   5                      }
1736   4                      case EVENT_TYPE_NET_EXIT_IND:
1737   4                {
1738   5                    FM_Printf(FM_ERROR, "nexit asc %bu \n", mctrl->nextState);
1739   5                if (mctrl->nextState == MCTRL_STATE_INIT)
1740   5                {
1741   6                  mctrl->state = MCTRL_STATE_INIT;
1742   6      #ifdef NMA
1743   6                
1744   6                  /* respond to the NMA */
1745   6                //  if (hostLeaveReqRsp)
1746   6                  //NMA_SendNetExitCnf(nma, STATUS_SUCCESS);   /* success result */
1747   6                
1748   6      #endif
1749   6                  hostLeaveReqRsp = 0;
1750   6      
1751   6                }
1752   5                else
1753   5                if (mctrl->nextState == MCTRL_STATE_UNASSOC_STA)
1754   5                {
1755   6                  mctrl->state = MCTRL_STATE_UNASSOC_STA;
1756   6      #ifdef STA_FUNC
1757   6                  USC_Start(&ctrlLayer->uStaCtrl);
1758   6      #endif
1759   6                }
1760   5                else
1761   5                {
1762   6                  mctrl->state = MCTRL_STATE_NET_DISC;
1763   6                  
1764   6                            /* start the network discovery */
1765   6      #ifdef STA_FUNC           
1766   6                            NDC_Start(&ctrlLayer->netDiscCtrl);
1767   6      #endif
1768   6                
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 30  

1769   6                }
1770   5                          break;
1771   5      
1772   5                        }
1773   4                      default:
1774   4                      {
1775   5                          
1776   5                          //stay in the same state
1777   5                          ASC_ProcEvent(&ctrlLayer->aStaCtrl, event);
1778   5                      }
1779   4                  } 
1780   3                  break;
1781   3              }
1782   2      #endif /* STA_FUNC */
1783   2      #ifdef CCO_FUNC
1784   2              case MCTRL_STATE_UNASSOC_CCO:
1785   2              {
1786   3                  switch(event->eventHdr.type)
1787   3                  {
1788   4      #ifdef STA_FUNC
1789   4                      case EVENT_TYPE_USTA_IND:
1790   4                      {
1791   5                          if(linkl->staInfo.lastUserAppCCOState != 1)
1792   5                          {
1793   6                              USC_Start(&ctrlLayer->uStaCtrl );
1794   6                              mctrl->state = MCTRL_STATE_UNASSOC_STA;
1795   6                          }
1796   5                          break;
1797   5                      }
1798   4      #endif
1799   4                      case EVENT_TYPE_ACCO_IND:
1800   4                      {
1801   5                          ACC_Start(&ctrlLayer->aCcoCtrl, CTRL_ACC_NEW);
1802   5                          mctrl->state = MCTRL_STATE_ASSOC_CCO;
1803   5                          break;
1804   5                      }
1805   4                      case EVENT_TYPE_NET_EXIT_IND:
1806   4                
1807   4          //        HHAL_SetDevMode(DEV_MODE_STA,gHpgpHalCB.lineMode);
1808   4              
1809   4        
1810   4                    LINKL_PostStopCCo(linkl);
1811   4      
1812   4                if (mctrl->nextState == MCTRL_STATE_UNASSOC_STA)
1813   4                {
1814   5                  CTRLL_PostEvent(ctrlLayer, EVENT_TYPE_USTA_IND, NULL);      
1815   5      
1816   5                }
1817   4                else if (mctrl->nextState == MCTRL_STATE_NET_DISC)
1818   4                {
1819   5                  mctrl->state = MCTRL_STATE_NET_DISC;
1820   5                  /* start the network discovery */
1821   5      #ifdef STA_FUNC           
1822   5                  NDC_Start(&ctrlLayer->netDiscCtrl);
1823   5      #endif
1824   5      
1825   5                }
1826   4                else if(mctrl->nextState == MCTRL_STATE_UNASSOC_CCO)
1827   4                {
1828   5      #ifdef CCO_FUNC
1829   5                  /* start the unassociated CCo */
1830   5                  UCC_Start(&ctrlLayer->uCcoCtrl );
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 31  

1831   5                  mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1832   5      #endif
1833   5                }
1834   4                else
1835   4                {
1836   5                  mctrl->state = MCTRL_STATE_INIT;
1837   5      #ifdef NMA
1838   5              
1839   5                  /* respond to the NMA */
1840   5                  if (hostLeaveReqRsp)
1841   5                  {
1842   6                    //NMA_SendNetExitCnf(nma, 0);   /* success result */
1843   6                  }
1844   5      #endif    
1845   5                  hostLeaveReqRsp = 0;            
1846   5                }
1847   4                
1848   4                          break;          
1849   4                        
1850   4          
1851   4      
1852   4                  //Generate a time event
1853   4      
1854   4      
1855   4                  /* place the event into the external queue */
1856   4      
1857   4                  //FM_Printf(FM_ERROR,"join \n");
1858   4                    
1859   4                  
1860   4                  
1861   4      
1862   4                
1863   4                
1864   4      
1865   4                
1866   4                      default:
1867   4                      {
1868   5                          //stay in the same state
1869   5                          UCC_ProcEvent(&ctrlLayer->uCcoCtrl, event);
1870   5                      }               
1871   4                  }
1872   3                  break;
1873   3              }
1874   2              case MCTRL_STATE_ASSOC_CCO:
1875   2              {
1876   3                  switch(event->eventHdr.type)
1877   3                  {
1878   4      #ifdef STA_FUNC
1879   4                      case EVENT_TYPE_USTA_IND:
1880   4                      {
1881   5                          if(linkl->staInfo.lastUserAppCCOState != 1)
1882   5                          {
1883   6                              USC_Start(&ctrlLayer->uStaCtrl );
1884   6                              mctrl->state = MCTRL_STATE_UNASSOC_STA;
1885   6                          }
1886   5                          break;
1887   5                      }
1888   4                      case EVENT_TYPE_ASTA_IND:
1889   4                      {
1890   5                          //from the Assoc CCo to Assoc STA due to handover
1891   5                          //ASC_Start(&ctrlLayer->aStaCtrl);
1892   5                          if(linkl->staInfo.lastUserAppCCOState != 1)
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 32  

1893   5                          {
1894   6                              ASC_Start(&ctrlLayer->aStaCtrl, 0);
1895   6                              mctrl->state = MCTRL_STATE_ASSOC_STA;
1896   6                          }
1897   5                          break;
1898   5                      }
1899   4      #endif
1900   4                      case EVENT_TYPE_UCCO_IND:
1901   4                      {
1902   5                          UCC_Start(&ctrlLayer->uCcoCtrl );
1903   5                          mctrl->state = MCTRL_STATE_UNASSOC_CCO;
1904   5                          break;
1905   5                      }
1906   4                      case EVENT_TYPE_NET_EXIT_IND:
1907   4                         
1908   4                          /* start the network discovery */
1909   4                LINKL_PostStopCCo(linkl);
1910   4                
1911   4                if (mctrl->nextState == MCTRL_STATE_NET_DISC)
1912   4                { 
1913   5                  mctrl->state = MCTRL_STATE_NET_DISC;
1914   5      #ifdef STA_FUNC           
1915   5                  NDC_Start(&ctrlLayer->netDiscCtrl);
1916   5      #endif
1917   5                }
1918   4                else
1919   4                if (mctrl->nextState == MCTRL_STATE_UNASSOC_CCO)
1920   4                {
1921   5                  ACC_BecomeUnassociated(ctrlLayer);
1922   5                }
1923   4                else
1924   4                {
1925   5                  mctrl->state = MCTRL_STATE_INIT;
1926   5      
1927   5      #ifdef NMA
1928   5              /* respond to the NMA */        
1929   5                  //if (hostLeaveReqRsp)
1930   5                  //NMA_SendNetExitCnf(nma, 0);   /* success result */
1931   5      #endif                
1932   5                  hostLeaveReqRsp = 0;
1933   5                }
1934   4      
1935   4          
1936   4                          break;
1937   4          
1938   4                      default:
1939   4                      {
1940   5                          //stay in the same state
1941   5                          ACC_ProcEvent(&ctrlLayer->aCcoCtrl, event);
1942   5                      }
1943   4                  }
1944   3                  break;
1945   3              }
1946   2      #endif /* CCO_FUNC */
1947   2              default:
1948   2              {
1949   3              }
1950   2          }
1951   1      
1952   1        if (mctrl->state != stateOld)       
1953   1        { 
1954   2          
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 33  

1955   2          hostEvent_NetworkId nwId;
1956   2      #if 0
              
              
                  if (mctrlJoinnetProc && 
                      ((stateOld == MCTRL_STATE_UNASSOC_STA) ||
                      (stateOld == MCTRL_STATE_ASSOC_STA))&&
                    (mctrl->state == MCTRL_STATE_INIT ))
                  {
              
                    mctrlJoinnetProc = 0;
                    
                    nwId.state = (nwIdState_e)MCTRL_STATE_UNASSOC_STA;
                    nwId.reason = 0xFF;
              #ifdef LOG_FLASH
                    logEvent(INDICATION, 0, HOST_EVENT_NETWORK_IND, &nwId, sizeof(nwId));
              #endif
                    Host_SendIndication(HOST_EVENT_NETWORK_IND, HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
              
                    
                  }
                  else
                  if ( ((mctrl->state == MCTRL_STATE_UNASSOC_STA) &&
                     (stateOld == MCTRL_STATE_INIT)) ||
                     (mctrl->state == MCTRL_STATE_INIT ))
                  {
                    return;
                  }
                  else
                  {
              
              
                  nwId.state = (nwIdState_e)mctrl->state;
                  nwId.reason = 0xFF;
              #ifdef LOG_FLASH
                      logEvent(INDICATION, 0, HOST_EVENT_NETWORK_IND, &nwId, sizeof(nwId));
              #endif
                    Host_SendIndication(HOST_EVENT_NETWORK_IND, HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
              
                  }
              #else
1996   2          
1997   2          nwId.state = (nwIdState_e)mctrl->state;
1998   2          nwId.reason = mctrl->reason;
1999   2      #if 0
                  FM_Printf(FM_USER, "oldstate : %bu  ", stateOld);
                  FM_Printf(FM_USER, "state : %bu  ", nwId.state);
                  FM_Printf(FM_USER, "reason : %bu ", nwId.reason);
              #endif
2004   2      
2005   2      #ifdef LOG_FLASH
                  logEvent(INDICATION, 0, HOST_EVENT_NETWORK_IND, &nwId, sizeof(nwId));
              #endif
2008   2          Host_SendIndication(HOST_EVENT_NETWORK_IND, HPGP_MAC_ID, (u8*)&nwId, sizeof(nwId));
2009   2      
2010   2      
2011   2      #endif
2012   2      
2013   2          
2014   2        }
2015   1      }
2016          
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 34  

2017          
2018          eStatus CTRLL_GetKey(sCtrlLayer *ctrlLayer, u8 *nmk, u8 *nid)
2019          {
2020   1         sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2021   1      
2022   1          /*Compiler warning suppression*/
2023   1          ctrlLayer = ctrlLayer;
2024   1        
2025   1         LINKL_GetKey(linkl, nmk, nid);
2026   1         return STATUS_SUCCESS;
2027   1      }
2028          
2029          eStatus CTRLL_SetKey(sCtrlLayer *ctrlLayer, u8 *nmk, u8 *nid)
2030          {
2031   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2032   1      
2033   1          /*Compiler warning suppression*/
2034   1          ctrlLayer = ctrlLayer;
2035   1        
2036   1          LINKL_SetKey(linkl, nmk, nid);
2037   1        
2038   1        //  CTRLL_NetExit(ctrlLayer);
2039   1      
2040   1         return STATUS_SUCCESS;
2041   1      }
2042          
2043          
2044          
2045          /* The function starts the network discovery */
2046          eStatus CTRLL_StartNetDisc(sCtrlLayer *ctrlLayer)
2047          {
2048   1          sEvent  xdata  *event = NULL;
2049   1          eStatus    ret = STATUS_FAILURE;
2050   1        sLinkLayer *linkl = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2051   1        sStaInfo *staInfo = LINKL_GetStaInfo(linkl); 
2052   1        
2053   1        ret = CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_RESTART_REQ,
2054   1                NULL, 0);
2055   1      
2056   1        if (ret == STATUS_SUCCESS)
2057   1          {
2058   2      
2059   2          staInfo->lastUserAppCCOState = 0;
2060   2          staInfo->staCap.fields.backupCcoCap = 0;
2061   2      
2062   2          }
2063   1      
2064   1          return ret;
2065   1      }
2066          
2067          /* The function starts either an unassociated Cco or  unassociated sta */
2068          eStatus CTRLL_StartNetwork(sCtrlLayer *ctrlLayer, u8 type, u8 *nid)
2069          {
2070   1          sEvent   xdata *event = NULL;
2071   1          eStatus    ret = STATUS_FAILURE;
2072   1          u8        *dataptr = NULL;
2073   1        sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2074   1          sStaInfo    *staInfo = LINKL_GetStaInfo(linkl);
2075   1      
2076   1          /*Compiler warning suppression*/
2077   1          nid = nid;
2078   1        
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 35  

2079   1          ret = CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_SET_NETWORK_REQ,
2080   1                (u8*)&type, 1);
2081   1      
2082   1         if (ret == STATUS_SUCCESS)
2083   1          {
2084   2             
2085   2              if(type == NETWORK_START)
2086   2              {
2087   3                  staInfo->lastUserAppCCOState = 1;
2088   3              }
2089   2              else
2090   2              {
2091   3      
2092   3            //FM_Printf(FM_USER,"join\n");              
2093   3                  staInfo->lastUserAppCCOState = 2;
2094   3              }
2095   2            
2096   2          }
2097   1      
2098   1          return ret;
2099   1      }
2100          
2101          eStatus CTRLL_NetExit(sCtrlLayer *ctrlLayer)
2102          {
2103   1          //Generate a time event
2104   1          eStatus    ret = STATUS_FAILURE;
2105   1      
2106   1        ret = CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_NET_EXIT_REQ,
2107   1                  NULL, 0);
2108   1      
2109   1        return ret;
2110   1      
2111   1      }
2112          #ifdef UKE
              eStatus CTRLL_setSecMode(sCtrlLayer *ctrlLayer, u8 secMode)
              {
                eStatus    ret = STATUS_FAILURE;
              
                  //Generate a time event
                  ret = CTRLL_SendEvent(ctrlLayer,EVENT_TYPE_SET_SEC_MODE,
                          &secMode, 1);
              
                return ret;
              
              }
              #endif
2125          
2126          #if 0
              eStatus CTRLL_SendAssocReq(sCtrlLayer *ctrlLayer)
              {                                                
                 CTRLL_SendEventToLinkLayer(ctrlLayer, EVENT_TYPE_NET_ACC_REQ, NULL); 
                 return STATUS_SUCCESS;
              }
              #endif
2133          
2134          
2135          #if 1
2136          
2137          
2138          u8 CTRLL_Proc(void *cookie)
2139          {
2140   1          sEvent *event = NULL;
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 36  

2141   1          sSlink *slink = NULL;
2142   1          u8      ret = 0;
2143   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
2144   1      
2145   1          while(!SLIST_IsEmpty(&ctrlLayer->eventQueue) )
2146   1          {
2147   2      #ifdef P8051
2148   2      __CRIT_SECTION_BEGIN__
2149   2      #else
                  SEM_WAIT(&ctrlLayer->ctrlSem);
              #endif
2152   2      
2153   2              slink = SLIST_Pop(&ctrlLayer->eventQueue);
2154   2      #ifdef P8051
2155   2      __CRIT_SECTION_END__
2156   2      #else
                  SEM_POST(&ctrlLayer->ctrlSem);
              #endif
2159   2              event = SLIST_GetEntry(slink, sEvent, link);
2160   2      
2161   2              if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
2162   2              {
2163   3                  //FM_Printf(FM_CTRL|FM_MINFO, "CTRLL: Get an event (%d)\n", event->eventHdr.type);
2164   3                  MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
2165   3                  MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
2166   3              }
2167   2           
2168   2              if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
2169   2              {
2170   3                  EVENT_Free(event);
2171   3              }
2172   2      
2173   2              while(!SLIST_IsEmpty(&ctrlLayer->intEventQueue))
2174   2              {
2175   3                  //no need for sync protection
2176   3                  slink = SLIST_Pop(&ctrlLayer->intEventQueue);
2177   3                  event = SLIST_GetEntry(slink, sEvent, link);
2178   3      
2179   3                  
2180   3      //            FM_HexDump(FM_ERROR, "C type", (u8*)&event->eventHdr.type, 2);
2181   3                  if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
2182   3                  {
2183   4                      MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
2184   4                      MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
2185   4                  }
2186   3           
2187   3                  if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
2188   3                  {
2189   4                      EVENT_Free(event);
2190   4                  }
2191   3              }
2192   2          }
2193   1          return ret;
2194   1      }
2195          
2196          
2197          #else
              
              extern u8 LINKL_Proc(void *cookie);
              u8 CTRLL_Proc(void *cookie)
              
              {
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 37  

                  sEvent *event = NULL;
                  sSlink *slink = NULL;
                  u8      ret = 0;  
                  sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
                sLinkLayer *linkLayer = (sLinkLayer*)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
              
                  while((!SLIST_IsEmpty(&ctrlLayer->eventQueue) 
              #ifndef RTX51_TINY_OS
                  && !(ret = SCHED_IsPreempted(&ctrlLayer->task))
              #endif
                  ) || ((!SLIST_IsEmpty(&linkLayer->eventQueue))))
                  { 
              #if 1
                  if((!SLIST_IsEmpty(&linkLayer->eventQueue)))
                  {
                    LINKL_Proc(HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK));
              
                    return ret;
                  }
              
                  
              
                  if (SLIST_IsEmpty(&ctrlLayer->eventQueue))
                    return ret;
              #endif
              
              #ifdef P8051
              __CRIT_SECTION_BEGIN__
              #else
                    SEM_WAIT(&ctrlLayer->ctrlSem);
              #endif
              
                      slink = SLIST_Pop(&ctrlLayer->eventQueue);
              #ifdef P8051
              __CRIT_SECTION_END__
              #else
                  SEM_POST(&ctrlLayer->ctrlSem);
              #endif
                  if (slink == NULL)
                    return ret;
                    
                      event = SLIST_GetEntry(slink, sEvent, link);
              
                      if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                      {
                     //     FM_HexDump(FM_CTRL|FM_MINFO, "CTRLL: \n", (u8*)&event->eventHdr.type,2);
                          MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
                          MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
                      }
                   
                      if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
                      {
                          EVENT_Free(event);
                      }
              
                      while(!SLIST_IsEmpty(&ctrlLayer->intEventQueue))
                      {
                          //no need for sync protection
                          slink = SLIST_Pop(&ctrlLayer->intEventQueue);
                          event = SLIST_GetEntry(slink, sEvent, link);
              
                          
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 38  

              //            FM_HexDump(FM_ERROR, "C type", (u8*)&event->eventHdr.type, 2);
                          if (event->eventHdr.eventClass == EVENT_CLASS_CTRL)
                          {
                              MCTRL_PreProcEvent(&ctrlLayer->mainCtrl, event);
                              MCTRL_ProcEvent(&ctrlLayer->mainCtrl, event);
                          }
                   
                          if(event->eventHdr.status == EVENT_STATUS_COMPLETE)
                          {
                              EVENT_Free(event);
                          }
                      }
              
                  return ret;
                  }
                  return ret;
              }
              
              #endif
2284          
2285          
2286          void CTRLL_RegisterEventCallback(sCtrlLayer *ctrlLayer, 
2287              void (*callback)(void XDATA *cookie, sEvent XDATA *event),
2288              void *cookie)
2289          {
2290   1          /*Compiler warning suppression*/
2291   1          callback = callback;
2292   1        
2293   1      #ifdef CALLBACK
                  ctrlLayer->deliverEvent = callback;
              #endif
2296   1          ctrlLayer->eventcookie = cookie;
2297   1      
2298   1      }
2299          
2300          
2301          /* Post an event into the external event queue */
2302          eStatus CTRLL_SendEvent(sCtrlLayer *ctrll, u16 eventId, u8* dataptr,
2303                                  u8 datalen) __REENTRANT__
2304          {
2305   1        sEvent *event;
2306   1        event = EVENT_Alloc(datalen, 0);
2307   1          if(event == NULL)
2308   1          {
2309   2          FM_Printf(FM_ERROR, "Ctrl EAF\n");
2310   2              return STATUS_FAILURE;
2311   2          }
2312   1        event->eventHdr.eventClass = EVENT_CLASS_CTRL;
2313   1        event->eventHdr.type = eventId;
2314   1        if (dataptr && datalen)
2315   1        {
2316   2          memcpy(event->buffDesc.dataptr, dataptr, datalen);
2317   2          event->buffDesc.datalen = datalen;
2318   2        }
2319   1        else
2320   1        {
2321   2          event->buffDesc.datalen = 0;
2322   2          }
2323   1      
2324   1      #ifdef P8051
2325   1      __CRIT_SECTION_BEGIN__
2326   1      #else
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 39  

                  SEM_WAIT(&ctrll->ctrlSem);
              #endif
2329   1      
2330   1          SLIST_Put(&ctrll->eventQueue, &event->link);
2331   1      
2332   1      #ifdef P8051
2333   1      __CRIT_SECTION_END__
2334   1      #else
                  SEM_POST(&ctrll->ctrlSem);
              #endif
2337   1          /* schedule the task */
2338   1      #ifndef RTX51_TINY_OS
                  return SCHED_Sched(&ctrll->task);
              #else
2341   1          os_set_ready(HPGP_TASK_ID_CTRL);
2342   1        ctrll->pendingEvent = 1;
2343   1      
2344   1          return STATUS_SUCCESS;
2345   1      #endif
2346   1      
2347   1      }
2348          
2349          
2350          
2351          
2352          void CTRLL_ReceiveEvent(void* cookie, sEvent* event)
2353          {
2354   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
2355   1        
2356   1          /*Compiler warning suppression*/
2357   1          cookie = cookie;
2358   1        
2359   1          //place the event into the queue in the Control Layer
2360   1          //SLIST_Put(&ctrlLayer->eventQueue, &event->link);
2361   1          CTRLL_SendEvent(ctrlLayer, event->eventHdr.type, event->buffDesc.dataptr, 
2362   1                  event->buffDesc.datalen);
2363   1        EVENT_Free(event);
2364   1      }
2365          
2366          
2367          
2368          eStatus CTRLL_Init(sCtrlLayer *ctrlLayer)
2369          {
2370   1          eStatus     status = STATUS_SUCCESS;
2371   1          sLinkLayer *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2372   1      
2373   1      #ifndef P8051
              #if defined(WIN32) || defined(_WIN32)
                  ctrlLayer->ctrlSem = CreateSemaphore(
                      NULL,           // default security attributes
                      SEM_COUNT,      // initial count
                      SEM_COUNT,      // maximum count
                      NULL);          // unnamed semaphore
                  if(ctrlLayer->ctrlSem == NULL)
              #else
                  if(sem_init(&ctrlLayer->ctrlSem, 0, SEM_COUNT))
              #endif
                  {
                      status = STATUS_FAILURE;
                  }
              #endif
2388   1      #ifdef RTX51_TINY_OS
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 40  

2389   1         os_create_task(HPGP_TASK_ID_CTRL);
2390   1      #else
                  SCHED_InitTask(&ctrlLayer->task, HPGP_TASK_ID_CTRL, "CTRL", 
                                 HPGP_TASK_PRI_CTRL, CTRLL_Proc, ctrlLayer);
              #endif
2394   1          MCTRL_Init(&ctrlLayer->mainCtrl);
2395   1      #ifdef STA_FUNC
2396   1          NDC_Init(&ctrlLayer->netDiscCtrl);
2397   1          USC_Init(&ctrlLayer->uStaCtrl);
2398   1          ASC_Init(&ctrlLayer->aStaCtrl);
2399   1      #endif
2400   1      #ifdef CCO_FUNC
2401   1          UCC_Init(&ctrlLayer->uCcoCtrl);
2402   1          ACC_Init(&ctrlLayer->aCcoCtrl);
2403   1      #endif
2404   1          SLIST_Init(&ctrlLayer->eventQueue);
2405   1        SLIST_Init(&ctrlLayer->intEventQueue);
2406   1          LINKL_RegisterEventCallback(linkLayer, 
2407   1                                      CTRLL_ReceiveEvent, 
2408   1                                      (void *)ctrlLayer);
2409   1      
2410   1        ctrlLayer->pendingEvent = 0;
2411   1      
2412   1          FM_Printf(FM_MINFO, "Ctrl Layer:Init\n");
2413   1      
2414   1          return status;
2415   1      }
2416          
2417          
2418          void CTRLL_TimerHandler(u16 type, void *cookie)
2419          {
2420   1          sCtrlLayer *ctrlLayer = (sCtrlLayer *)cookie;
2421   1        eStatus    ret = STATUS_FAILURE;
2422   1      
2423   1        ret = CTRLL_SendEvent(ctrlLayer,type,
2424   1                   NULL, 0);
2425   1      }
2426          
2427          #ifdef RTX51_TINY_OS
2428          bool pending_802154_task = FALSE; 
2429          void CTRL_Task (void) _task_ HPGP_TASK_ID_CTRL
2430          {
2431   1        
2432   1      
2433   1        sNma* nma = (sNma*)HOMEPLUG_GetNma();
2434   1          sCtrlLayer *ctrll = (sCtrlLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_CTRL);
2435   1          while (1) { 
2436   2      #ifdef UART_HOST_INTF 
2437   2          timer0Poll();
2438   2          STM_Proc();
2439   2      
2440   2          if(uartRxControl.rxExpectedCount == 0)
2441   2          {
2442   3            uartRxProc();
2443   3          }
2444   2      #endif  
2445   2          if(pending_802154_task == FALSE) 
2446   2          {   
2447   3      #ifdef UART_HOST_INTF
2448   3            if (!ctrll->pendingEvent)
2449   3            {
2450   4              os_switch_task();
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 41  

2451   4            }
2452   3      #else
                    if (!ctrll->pendingEvent)
                    {
                      os_switch_task();
                    }
              #endif    
2458   3          }
2459   2          ctrll->pendingEvent = 0;
2460   2          CTRLL_Proc(ctrll);
2461   2          os_switch_task();
2462   2              LINKL_Proc(HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK));
2463   2              os_switch_task();
2464   2          CTRLL_Proc(ctrll);
2465   2          NMA_Proc(nma);      
2466   2      #ifdef HYBRII_802154
2467   2          pending_802154_task = FALSE;
2468   2          mac_task();
2469   2          mac_hal_sm_handler();   
2470   2          mac_hal_task();     
2471   2      #endif  /* HYBRII_802154 */         
2472   2          }
2473   1      }
2474          #endif
2475          
2476          
2477          /** =========================================================
2478           *
2479           * Edit History
2480           *
2481           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/ctrl/ctrll.c,v $
2482           *
2483           * $Log: ctrll.c,v $
2484           * Revision 1.19  2015/01/02 14:55:35  kiran
2485           * 1) Timer Leak fixed while freeing SCB fixed
2486           * 2) Software broadcast supported for LG
2487           * 3) UART Loopback supported for LG
2488           * 4) Keep Alive feature to ageout defunctional STA
2489           * 5) Improved flash API's for NO Host Solution
2490           * 6) Imporved PLC Hang recovery mechanism
2491           * 7) Reduced nested call tree of common path functions
2492           * 8) Code optimization and cleanup (unused arguments, unused local variables)
2493           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
2494           * 10) Use of memory specific pointers instead of generic pointers
2495           *
2496           * Revision 1.18  2014/12/09 07:09:08  ranjan
2497           * - multicco feature under MCCO flag
2498           *
2499           * Revision 1.17  2014/11/26 13:19:40  ranjan
2500           * *** empty log message ***
2501           *
2502           * Revision 1.16  2014/11/11 14:52:58  ranjan
2503           * 1.New Folder Architecture espically in /components
2504           * 2.Modular arrangment of functionality in new files
2505           *    anticipating the need for exposing them as FW App
2506           *    development modules
2507           * 3.Other improvisation in code and .h files
2508           *
2509           * Revision 1.15  2014/10/28 16:27:43  kiran
2510           * 1) Software recovery using Watchdog Timer
2511           * 2) Hardware recovery monitor and policies
2512           * 3) Timer Polling in Control Task and Frame task for better accuracy
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 42  

2513           * 4) Common memory optimized by reducing prints
2514           * 5) Discovered netlist corruption fixed
2515           * 6) VCO fix in HHAL_AFEInit()
2516           * 7) Idata optimized by removing floating point operation
2517           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
2518           * 9) Beacon processing protected from interrupts
2519           * 10) Corrupted Beacons are dropped
2520           * 11) Some unused arguments removed to improve code size
2521           *
2522           * Revision 1.14  2014/10/15 10:42:51  ranjan
2523           * small fixes in um
2524           *
2525           * Revision 1.13  2014/09/05 09:28:18  ranjan
2526           * 1. uppermac cco-sta switching feature fix
2527           * 2. general stability fixes for many station associtions
2528           * 3. changed mgmt memory pool for many STA support
2529           *
2530           * Revision 1.12  2014/08/25 07:37:34  kiran
2531           * 1) RSSI & LQI support
2532           * 2) Fixed Sync related issues
2533           * 3) Fixed timer 0 timing drift for SDK
2534           * 4) MMSG & Error Logging in Flash
2535           *
2536           * Revision 1.11  2014/06/26 17:59:42  ranjan
2537           * -fixes to make uppermac more robust for n/w change
2538           *
2539           * Revision 1.10  2014/06/19 17:13:19  ranjan
2540           * -uppermac fixes for lvnet and reset command for cco and sta mode
2541           * -backup cco working
2542           *
2543           * Revision 1.9  2014/06/12 13:15:43  ranjan
2544           * -separated bcn,mgmt,um event pools
2545           * -fixed datapath issue due to previous checkin
2546           * -work in progress. neighbour cco detection
2547           *
2548           * Revision 1.8  2014/06/11 13:17:47  kiran
2549           * UART as host interface and peripheral interface supported.
2550           *
2551           * Revision 1.7  2014/05/28 10:58:59  prashant
2552           * SDK folder structure changes, Uart changes, removed htm (UI) task
2553           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
2554           *
2555           * Revision 1.6  2014/05/12 08:09:57  prashant
2556           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
2557           *
2558           * Revision 1.5  2014/04/09 08:18:10  ranjan
2559           * 1. Added host events for homeplug uppermac indication (Host_SendIndication)
2560           * 2. timer workaround  + other fixes
2561           *
2562           * Revision 1.4  2014/02/27 10:42:47  prashant
2563           * Routing code added
2564           *
2565           * Revision 1.3  2014/01/17 11:19:28  prashant
2566           * SPI fix, UM stablity fix
2567           *
2568           * Revision 1.2  2014/01/10 17:14:40  yiming
2569           * check in Rajan 1/8/2014 code release
2570           *
2571           * Revision 1.5  2014/01/08 10:53:54  ranjan
2572           * Changes for LM OS support.
2573           * New Datapath FrameTask
2574           * LM and UM  datapath, feature verified.
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 43  

2575           *
2576           * known issues : performance numbers needs revisit
2577           *
2578           * review : pending.
2579           *
2580           * Revision 1.4  2013/09/04 14:50:33  yiming
2581           * New changes for Hybrii_A code merge
2582           *
2583           * Revision 1.31  2013/07/12 08:56:36  ranjan
2584           * -UKE Push Button Security Feature.
2585           * Verified : DirectEntry Security Works.Datapath Works.
2586           *                 command SetSecMode for UKE works.
2587           * Added against bug-160
2588           *
2589           * Revision 1.30  2013/04/17 13:00:59  ranjan
2590           * Added FW ready event, Removed hybrii header from datapath, Modified hybrii header
2591           *  formate
2592           *
2593           * Revision 1.29  2013/04/04 12:21:54  prashant
2594           * Detecting PLC link failure for HMC. added project for HMC and Renesas
2595           *
2596           * Revision 1.28  2013/03/22 12:21:48  prashant
2597           * default FM_MASK and FM_Printf modified for USER INFO
2598           *
2599           * Revision 1.27  2013/03/21 07:43:26  ranjan
2600           * Starting NDC on "p reset" command
2601           *
2602           * Revision 1.26  2013/03/14 11:49:18  ranjan
2603           * 1.handled cases  for CCo toSTA switch and  viceversa
2604           * 2.UM uses bcntemplate
2605           *
2606           * Revision 1.25  2012/11/19 07:46:23  ranjan
2607           * Changes for Network discovery modes
2608           *
2609           * Revision 1.24  2012/10/11 06:21:00  ranjan
2610           * ChangeLog:
2611           * 1. Added HPGP_MAC_SAP to support linux host data and command path.
2612           *     define HPGP_MAC_SAP, NMA needs to be added in project.
2613           *
2614           * 2. Added 'p ping' command in htm.c . Feature is under AUTO_PING macro.
2615           *
2616           * 3. Extended  'p key' command to include PPEK support.
2617           *
2618           * verified :
2619           *   1. Datapath ping works overnite after association,auth
2620           *   2. HAL TEST project is intact
2621           *
2622           * Revision 1.23  2012/07/29 02:59:22  yuanhua
2623           * Initialize the internel queue of CTRL Layer to fix an issue of unexpected event free error message.
2624           *
2625           * Revision 1.22  2012/07/08 18:42:20  yuanhua
2626           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
2627           *
2628           * Revision 1.21  2012/06/30 23:36:26  yuanhua
2629           * return the success status for LINKL_SendEvent() when RTX51 OS is used.
2630           *
2631           * Revision 1.20  2012/06/20 17:47:52  kripa
2632           * Included the SendAssocReq() func.
2633           * Reverted the changes for passive network join.
2634           * Committed on the Free edition of March Hare Software CVSNT Client.
2635           * Upgrade to CVS Suite for more features and support:
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 44  

2636           * http://march-hare.com/cvsnt/
2637           *
2638           * Revision 1.19  2012/06/15 04:35:21  yuanhua
2639           * add a STA type of passive unassoc STA. With this STA type, the device acts as a STA during the network 
             -discovery. It performs the network scan for beacons from the CCO, but does not transmit the UNASSOC_STA.IND and does not
             - involve in the CCO selection process. Thus, it joins the existing network.
2640           *
2641           * Revision 1.18  2012/06/08 23:37:36  son
2642           * Remove networks scan from CTRLL as it is moved to NMS
2643           *
2644           * Revision 1.17  2012/06/08 00:21:47  son
2645           * Fixed beacon RX problem
2646           *
2647           * Revision 1.16  2012/06/05 22:37:11  son
2648           * UART console does not get initialized due to task ID changed
2649           *
2650           * Revision 1.15  2012/06/05 07:25:59  yuanhua
2651           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
2652           *
2653           * Revision 1.14  2012/06/04 23:30:17  son
2654           * Created Control Task for RTX51 Tiny OS
2655           *
2656           * Revision 1.13  2012/05/24 05:08:18  yuanhua
2657           * define sendEvent functions in CTRL/LINK layer as reentrant.
2658           *
2659           * Revision 1.12  2012/05/19 20:32:17  yuanhua
2660           * added non-callback option for the protocol stack.
2661           *
2662           * Revision 1.11  2012/05/19 05:05:15  yuanhua
2663           * optimized the timer handlers in CTRL and LINK layers.
2664           *
2665           * Revision 1.10  2012/05/17 05:05:58  yuanhua
2666           * (1) added the option for timer w/o callback (2) added task id and name.
2667           *
2668           * Revision 1.9  2012/05/14 05:22:29  yuanhua
2669           * support the SCHED without using callback functions.
2670           *
2671           * Revision 1.8  2012/05/12 04:11:46  yuanhua
2672           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
2673           *
2674           * Revision 1.7  2012/05/01 04:51:09  yuanhua
2675           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
2676           *
2677           * Revision 1.6  2012/04/20 01:39:33  yuanhua
2678           * integrated uart module and added compiler flag NMA.
2679           *
2680           * Revision 1.5  2012/04/17 23:09:50  yuanhua
2681           * fixed compiler errors for the hpgp hal test due to the integration changes.
2682           *
2683           * Revision 1.4  2012/04/13 06:15:11  yuanhua
2684           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
2685           *
2686           * Revision 1.3  2012/03/11 17:02:24  yuanhua
2687           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
2688           *
2689           * Revision 1.2  2011/09/09 07:02:31  yuanhua
2690           * migrate the firmware code from the greenchip to the hybrii.
2691           *
2692           * Revision 1.5  2011/08/12 23:13:21  yuanhua
2693           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
C51 COMPILER V9.53.0.0   CTRLL                                                             11/04/2015 20:09:47 PAGE 45  

             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
2694           *
2695           * Revision 1.2  2011/06/24 14:33:18  yuanhua
2696           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
2697           *
2698           * Revision 1.1  2011/05/06 19:07:48  kripa
2699           * Adding ctrl layer files to new source tree.
2700           *
2701           * Revision 1.3  2011/04/23 19:48:45  kripa
2702           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
2703           *
2704           * Revision 1.2  2011/04/23 18:31:12  kripa
2705           * 1.Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
2706           * 2.NDC_Init(), USC_Init(), USC_Start(), ACC_Init() ; placed memset after struct declaration.
2707           * 3.CTRLL_Proc(); changed event->class to event->eventClass.
2708           *
2709           * Revision 1.1  2011/04/08 21:43:29  yuanhua
2710           * Framework
2711           *
2712           *
2713           * =========================================================*/
2714          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8588    ----
   CONSTANT SIZE    =    361    ----
   XDATA SIZE       =      3     370
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
