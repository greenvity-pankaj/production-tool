C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE ISM
OBJECT MODULE PLACED IN .\obj\ism.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\common\ism.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) 
                    -BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\..\..\..\fir
                    -mware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\src\hal;..\.
                    -.\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\..\firmware\
                    -hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\zigbee;..\..
                    -\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\event\inc;..\..
                    -\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hpgp\inc;..\.
                    -.\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_support;..\..\.
                    -.\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\drivers\hpgp\i
                    -nc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components;..\..\..\
                    -..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..\..\compone
                    -nts\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\drivers\flash\
                    -inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\utilities;..\..
                    -\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drivers\nwk\inc;
                    -..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\..\..\..\com
                    -ponents\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HYBRII_8051,H
                    -YBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_SYNC,UM,HYB
                    -RII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ_DETECT,HYB
                    -RII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTERRUPT,MCCO,
                    -SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP,REGISTER_A
                    -PP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\ism.lst) TABS(2) OBJECT(.\ob
                    -j\ism.obj)

line level    source

   1          /** ========================================================
   2           *
   3           * @file ism.c
   4           * 
   5           *  @brief Interrupt Service Manager
   6           *
   7           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
   8           *  All Rights Reserved
   9           *  
  10           * =========================================================*/
  11          #ifdef RTX51_TINY_OS
  12          #include <rtx51tny.h>
  13          #include "hybrii_tasks.h"
  14          #endif  //RTX51_TINY_OS
  15          #include <stdio.h>
  16          #include <string.h>
  17          #include "papdef.h"
  18          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  21          #include "ism.h"
  22          #include "hal_common.h"
  23          #include "hal.h"
  24          #include "hal_reg.h"
  25          #include "hal_hpgp_reset.h"
  26          #include "nma.h"
  27          #include "nma_fw.h"
  28          #ifndef CALLBACK
  29          #include "hpgpapi.h"
  30          #include "hal_hpgp.h"
  31          #endif
  32          #ifdef HYBRII_ETH
              #include "hal_eth.h"
              #endif
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 2   

  35          #ifdef HYBRII_SPI
              #include "hal_spi.h"
              #endif
  38          #ifdef UM
  39          #include "frametask.h"
  40          #endif
  41          #ifdef CCO_FUNC
  42          #include "linkl.h"
  43          #endif
  44          #include "datapath.h"
  45          #ifdef UM
  46          #include "gv701x_osal.h"
  47          #endif
  48          #include "fm.h"
  49          #include "gv701x_gpiodriver.h"
  50          #include "sys_common.h"
  51          
  52          #ifndef CALLBACK
  53          extern void CHAL_FrameRxIntHandler(void *cookie);
  54          extern void hal_hpgp_mac_monitoring (void);
  55          extern void HHAL_BcnTxIntHandler(void *cookie);
  56          extern void LINKL_BcnTxHandler(void* cookie);
  57          extern void HHAL_Bcn3SentIntHandler();
  58          #endif
  59          #ifdef ETH_BRDG_DEBUG
              extern u32 oldNumEthTxDoneInts;
              #endif
  62          #define BPST_THRESHOLD 47000000
  63          u32 goldntb1;
  64          #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
              u8  EarlyWakeBpIntFlag = FALSE;
              extern u32 earlywakeBPintCnt;
              u32 EarlyWakeBcnCnt = 0;
              extern u32  psSleepCnt;
              extern u32  psAwakeCnt;
              extern u32  psNotInSleepMode; 
              #endif
  72          #ifdef POWERSAVE
              u32 goldntb10;
              u32 goldntb2;
              bool hiberClkOffSetFlag = FALSE;
              u32 tmpPsBpIntCnt = 0;     
              u32 EarlyWBPnotEven = 0;
              u32 EarlyWBPnotMOD = 0;
              u8  bpCntPSP = 0;
              extern u32 bcnStartInt;
              extern u32 bcnStartIntExitSleep;
              extern u8 psDebug;
              extern u32 EarlyBpNotMod;
              extern u32 notEQpsp;
              #endif
  86          #ifdef LOG_FLASH
              u32 lastITime = 0xFFFF;
              u32 lastBtime = 0xFFFF;
              #endif
  90          #ifdef LLP_POWERSAVE
              extern u32 bcnStartInt;
              extern u32 bcnStartIntandInPS;
              #ifdef PS_RESYNC
              u8 resyncFlag = FALSE;
              #endif
              extern u8 psDebug;
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 3   

              #endif
  98          #ifdef SW_RECOVERY
  99          extern void Monitor_Hang();
 100          #endif
 101          #ifdef SENSOR_DRIVER
              u32 postBPCnt;  //[YM] for sensor monitor usage
              #endif
 104          u8 discBcnTxCnt = 0;
 105          /* external interrupt handler control block */
 106          u8 gpio_int = 0;
 107          static sIsm    Ism;
 108          #ifdef LOG_FLASH
              
               u32 STM_GetTick();
              #endif
 112          /* TODO: need to check the hardware spec */
 113          
 114          void ISM_EnableCpuIrq(u8 irq)
 115          {
 116   1          if (irq >= CPU_INT_IRQ_ALL)
 117   1              return;
 118   1      
 119   1          //Ism.cpuIntMask.reg |= (1L << irq);
 120   1          switch(irq)
 121   1          {
 122   2              case CPU_INT_IRQ_TIME0:
 123   2                  Ism.cpuIntMask.s.timer0    = 1;
 124   2                  break;
 125   2              case CPU_INT_IRQ_WATCHDOG:
 126   2                  Ism.cpuIntMask.s.watchdog  = 1;
 127   2                  break;
 128   2              case CPU_INT_IRQ_UART:
 129   2                  Ism.cpuIntMask.s.uart0     = 1;
 130   2                  break;
 131   2              case CPU_INT_IRQ_PIO:
 132   2                  Ism.cpuIntMask.s.pio       = 1;
 133   2                  break;
 134   2              case CPU_INT_IRQ_BTN:
 135   2                  Ism.cpuIntMask.s.btn       = 1;
 136   2                  break;
 137   2              case CPU_INT_IRQ_LCD:
 138   2                  Ism.cpuIntMask.s.lcd       = 1;
 139   2                  break;
 140   2              case CPU_INT_IRQ_DMA0:
 141   2                  Ism.cpuIntMask.s.dma0      = 1;
 142   2                  break;
 143   2              case CPU_INT_IRQ_DMA1:
 144   2                  Ism.cpuIntMask.s.dma1      = 1;
 145   2                  break;
 146   2              case CPU_INT_IRQ_UART_LITE:
 147   2                  Ism.cpuIntMask.s.uartLite  = 1;
 148   2                  break;
 149   2              case CPU_INT_IRQ_EXT0:
 150   2                  Ism.cpuIntMask.s.ext0      = 1;
 151   2                  break;
 152   2              case CPU_INT_IRQ_EXT1:
 153   2                  Ism.cpuIntMask.s.ext1      = 1;
 154   2                  break;
 155   2              case CPU_INT_IRQ_GLOBAL_EN:
 156   2                  Ism.cpuIntMask.s.globalIntEna = 1;
 157   2                  break;
 158   2              default:
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 4   

 159   2                  return;
 160   2          }
 161   1          WriteU32Reg(INTIRQ_8051_REG, Ism.cpuIntMask.reg);
 162   1      }
 163          
 164          
 165          void ISM_DisableCpuIrq(u8 irq)
 166          {
 167   1          if (irq >= CPU_INT_IRQ_ALL)
 168   1              return;
 169   1      
 170   1          //Ism.cpuIntMask.reg &= ~(1L << irq);
 171   1          switch(irq)
 172   1          {
 173   2              case CPU_INT_IRQ_TIME0:
 174   2                  Ism.cpuIntMask.s.timer0    = 0;
 175   2                  break;
 176   2              case CPU_INT_IRQ_WATCHDOG:
 177   2                  Ism.cpuIntMask.s.watchdog  = 0;
 178   2                  break;
 179   2              case CPU_INT_IRQ_UART:
 180   2                  Ism.cpuIntMask.s.uart0     = 0;
 181   2                  break;
 182   2              case CPU_INT_IRQ_PIO:
 183   2                  Ism.cpuIntMask.s.pio       = 0;
 184   2                  break;
 185   2              case CPU_INT_IRQ_BTN:
 186   2                  Ism.cpuIntMask.s.btn       = 0;
 187   2                  break;
 188   2              case CPU_INT_IRQ_LCD:
 189   2                  Ism.cpuIntMask.s.lcd       = 0;
 190   2                  break;
 191   2              case CPU_INT_IRQ_DMA0:
 192   2                  Ism.cpuIntMask.s.dma0      = 0;
 193   2                  break;
 194   2              case CPU_INT_IRQ_DMA1:
 195   2                  Ism.cpuIntMask.s.dma1      = 0;
 196   2                  break;
 197   2              case CPU_INT_IRQ_UART_LITE:
 198   2                  Ism.cpuIntMask.s.uartLite  = 0;
 199   2                  break;
 200   2              case CPU_INT_IRQ_EXT0:
 201   2                  Ism.cpuIntMask.s.ext0      = 0;
 202   2                  break;
 203   2              case CPU_INT_IRQ_EXT1:
 204   2                  Ism.cpuIntMask.s.ext1      = 0;
 205   2                  break;
 206   2              case CPU_INT_IRQ_GLOBAL_EN:
 207   2                  Ism.cpuIntMask.s.globalIntEna = 0;
 208   2                  break;
 209   2              default:
 210   2                  return;
 211   2          }
 212   1          WriteU32Reg(INTIRQ_8051_REG, Ism.cpuIntMask.reg);
 213   1      }
 214          
 215          
 216          
 217          
 218          
 219          void ISM_EnableMacIrq(u8 irq)
 220          {
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 5   

 221   1          if (irq > MAC_INT_IRQ_ALL)
 222   1              return;
 223   1      
 224   1          if (irq == MAC_INT_IRQ_ALL)
 225   1          {
 226   2              /* enable all */
 227   2              // 3. Enable MAC Interrupts - routed through External Int 0
 228   2              Ism.macIntMask.reg   = 0;
 229   2              //intMacEnable.reg |= CPU_INTERRUPT_ALLINTSMASK;
 230   2              Ism.macIntMask.s.ethFreeCP      = 1;
 231   2              Ism.macIntMask.s.hpgpBP         = 1;
 232   2              Ism.macIntMask.s.cpuTxQNonEmpty = 1;
 233   2              Ism.macIntMask.s.plcBcn3Sent    = 1;
 234   2              Ism.macIntMask.s.plcBcnRx       = 1;
 235   2      //        Ism.macIntMask.s.hpgpBPSta      = 1;
 236   2              Ism.macIntMask.s.plcMedStatInt  = 1;
 237   2          }
 238   1          else if (irq < MAC_INT_IRQ_ALL)
 239   1          {
 240   2      //        Ism.macIntMask.reg |= (1L << irq);
 241   2              switch(irq)
 242   2              {
 243   3                  case MAC_INT_IRQ_PLC_MED_STAT:
 244   3                      Ism.macIntMask.s.plcMedStatInt  = 1;
 245   3                      break;
 246   3                  case MAC_INT_IRQ_HPGP_BP_STA:
 247   3      //                Ism.macIntMask.s.hpgpBPSta      = 1;
 248   3                      break;
 249   3      //            case MAC_INT_IRQ_ZIGBEE:
 250   3      //                Ism.macIntMask.s.zigbee         = 1;
 251   3      //                break;
 252   3                  case MAC_INT_IRQ_PLC_BCN_RX:
 253   3                      Ism.macIntMask.s.plcBcnRx       = 1;
 254   3                      break;
 255   3                  case MAC_INT_IRQ_PLC_BCN3_SENT:
 256   3                      Ism.macIntMask.s.plcBcn3Sent    = 1;
 257   3                      break;
 258   3                  case MAC_INT_IRQ_PLC_BCN2_SENT:
 259   3                      Ism.macIntMask.s.plcBcn2Sent    = 1;
 260   3                      break;
 261   3                  case MAC_INT_IRQ_PLC_FRAME_VALID:
 262   3                      Ism.macIntMask.s.plcFrmValid    = 1;
 263   3                      break;
 264   3                  case MAC_INT_IRQ_CPU_TXQ_NONEMPTY:
 265   3                      Ism.macIntMask.s.cpuTxQNonEmpty = 1;
 266   3                      break;
 267   3                  case MAC_INT_IRQ_PLC_BCN_TX:
 268   3                      Ism.macIntMask.s.hpgpBP         = 1;
 269   3                      break;
 270   3                  case MAC_INT_IRQ_NEW_ETH_SA:
 271   3                      Ism.macIntMask.s.newEtherSA     = 1;
 272   3                      break;
 273   3                  case MAC_INT_IRQ_HOST_SPI:
 274   3                      Ism.macIntMask.s.hostSpiInt     = 1;
 275   3                      break;
 276   3                  case MAC_INT_IRQ_ETH_FREE_CP:
 277   3                      Ism.macIntMask.s.ethFreeCP      = 1;
 278   3                      break;
 279   3                  default:
 280   3                     return;
 281   3              } 
 282   2          }
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 6   

 283   1              
 284   1          WriteU32Reg(CPU_INTENABLE_REG, Ism.macIntMask.reg);
 285   1      }
 286          
 287          
 288          void ISM_DisableMacIrq(u8 irq)
 289          {
 290   1          if (irq > MAC_INT_IRQ_ALL)
 291   1              return;
 292   1      
 293   1          if (irq == MAC_INT_IRQ_ALL)
 294   1          {
 295   2              /* disable all */
 296   2              Ism.macIntMask.reg   = 0;
 297   2          }
 298   1          else if (irq < MAC_INT_IRQ_ALL)
 299   1          {
 300   2      //        Ism.macIntMask.reg &= ~(1L << irq);
 301   2              switch(irq)
 302   2              {
 303   3                  case MAC_INT_IRQ_PLC_MED_STAT:
 304   3                      Ism.macIntMask.s.plcMedStatInt  = 0;
 305   3                      break;
 306   3                  case MAC_INT_IRQ_HPGP_BP_STA:
 307   3      //                Ism.macIntMask.s.hpgpBPSta      = 0;
 308   3                      break;
 309   3      //            case MAC_INT_IRQ_ZIGBEE:
 310   3      //                Ism.macIntMask.s.zigbee         = 0;
 311   3      //                break;
 312   3                  case MAC_INT_IRQ_PLC_BCN_RX:
 313   3                      Ism.macIntMask.s.plcBcnRx       = 0;
 314   3                      break;
 315   3                  case MAC_INT_IRQ_PLC_BCN3_SENT:
 316   3                      Ism.macIntMask.s.plcBcn3Sent    = 0;
 317   3                      break;
 318   3                  case MAC_INT_IRQ_PLC_BCN2_SENT:
 319   3                      Ism.macIntMask.s.plcBcn2Sent    = 0;
 320   3                      break;
 321   3                  case MAC_INT_IRQ_PLC_FRAME_VALID:
 322   3                      Ism.macIntMask.s.plcFrmValid    = 0;
 323   3                      break;
 324   3                  case MAC_INT_IRQ_CPU_TXQ_NONEMPTY:
 325   3                      Ism.macIntMask.s.cpuTxQNonEmpty = 0;
 326   3                      break;
 327   3                  case MAC_INT_IRQ_PLC_BCN_TX:
 328   3                      Ism.macIntMask.s.hpgpBP         = 0;
 329   3                      break;
 330   3                  case MAC_INT_IRQ_NEW_ETH_SA:
 331   3                      Ism.macIntMask.s.newEtherSA     = 0;
 332   3                      break;
 333   3                  case MAC_INT_IRQ_HOST_SPI:
 334   3                      Ism.macIntMask.s.hostSpiInt     = 0;
 335   3                      break;
 336   3                  case MAC_INT_IRQ_ETH_FREE_CP:
 337   3                      Ism.macIntMask.s.ethFreeCP      = 0;
 338   3                      break;
 339   3                  default:
 340   3                     return;
 341   3              } 
 342   2          }
 343   1              
 344   1          WriteU32Reg(CPU_INTENABLE_REG, Ism.macIntMask.reg);
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 7   

 345   1      }
 346          
 347          
 348          void ISM_EnableInterrupts()
 349          {
 350   1      #ifdef HAL_INT
                  u8051InterruptReg   int8051Enable;
              #ifdef P8051
                  /* Set the interrupts to Lowlevel-triggered */
                  IT0 = 0;                    
                  IT1 = 0;
              
                  /* enable the external interrupt */
                  EX1 = 1;
              #endif
                  ISM_EnableCpuIrq(CPU_INT_IRQ_EXT1);
              
                  /* enable the global interrupt */
                  int8051Enable.reg = 0;
                  int8051Enable.s.ext1 = 1;
                  int8051Enable.s.globalIntEna = 1;
                  WriteU32Reg(INTENA_8051_REG,int8051Enable.reg);
              #endif
 368   1      
 369   1      #ifdef P8051
 370   1          /* start interrupt */
 371   1          EA  = 1;                    
 372   1      #endif
 373   1      #ifdef UM
 374   1      #ifdef UART_HOST_INTF 
 375   1      {
 376   2        u8051InterruptReg int8051Enable;
 377   2        IT0 = 0;                    
 378   2          IT1 = 0;
 379   2          /* enable the external interrupt */
 380   2          EX1 = 1;
 381   2        EA  = 1;
 382   2        ISM_EnableCpuIrq(CPU_INT_IRQ_UART);
 383   2        int8051Enable.reg = 0;
 384   2         int8051Enable.s.uart0 = 1;
 385   2         int8051Enable.s.globalIntEna = 1;
 386   2         WriteU32Reg(INTENA_8051_REG,int8051Enable.reg);
 387   2      }
 388   1      #endif
 389   1      #endif
 390   1      }
 391                                     
 392          extern u32 gBPSTdelta;
 393          extern u8 gNegativeflag;
 394          extern u8 gPositiveflag;
 395          extern u8 firsttime;
 396          extern u32 goldbpst;
 397          extern u32 gavg;
 398          extern u8 zctrack;
 399          extern u8 zcFlag;
 400          extern u32 gbpst;
 401          extern u8 gRollOver;
 402          extern u32 zcCCONTBold;
 403          extern u32 gCCO_BTS;
 404          extern u32 gtimer2, gtimer1;
 405          extern u32 zcCCONTB_OLD;
 406          
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 8   

 407          #ifdef PROD_TEST
              u8  checkSPITxDone()
              {
                  uInterruptReg intStatus;
              
                   EA = 0;                             
                  // Read interrupt status. 
                  intStatus.reg = ReadU32Reg(CPU_INTSTATUS_REG);
              
                EA = 1;
                  // Write back the value to clear the status
              
                if(intStatus.s.spiTxDone)
                {
                  WriteU32Reg(CPU_INTSTATUS_REG, intStatus.s.spiTxDone);
              
                  /* SPI Int Handler */
                  hal_spi_tx_done_handler();
                }
                return 1;
              
              }
              #endif
 430          #ifdef STA_FUNC
 431          extern void LINKL_SendBcnLossInd(u8 type);
 432          #endif
 433          #ifdef HAL_INT_HDL
              /* external interrupt handler */
              void ISM_Ext1Isr(void) __INTERRUPT2__
              #else
 437          void ISM_PollInt(void) 
 438          #endif
 439          {
 440   1          //u32  intStatus;
 441   1      //    u32 delta, ntb1;
 442   1        
 443   1      #ifdef RTX51_TINY_OS
 444   1        
 445   1        u8 scheduleFrameTask = 0;
 446   1      #endif      
 447   1      
 448   1          uInterruptReg intStatus;
 449   1          uPlcMedInterruptReg PlcMedInterruptReg;
 450   1          u32           bankSelReg;
 451   1        //u32 dbc_pattern;
 452   1          u32 postBpstdiff;
 453   1          u32 ntb1;
 454   1      #ifdef LOG_FLASH
                  u32 currITime;
              #endif
 457   1      
 458   1      #ifdef UM
 459   1        sLinkLayer    *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 460   1        sStaInfo      *staInfo = LINKL_GetStaInfo(linkLayer);
 461   1      #endif
 462   1      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                sScb *scb;
                u8 loopCnt=0;
                u8 missBcnCnt = 0;
              
                  if (linkLayer->mode == LINKL_STA_MODE_CCO)
                {
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 9   

                  // this station is CCO
                  scb = staInfo->ccoScb;
                }
                else
                {
                  // this station is STA
                  scb = staInfo->staScb;
                }
              #endif
 478   1      
 479   1          gHalCB.extIntCnt++;
 480   1      #ifdef LOG_FLASH
                  currITime = STM_GetTick();
                  if((lastITime + 6) < currITime)
                  {
                      sTime t;
                      tickToTime(&t, lastITime);
                      logEvent(ISM_ERROR, ISM_ENTRY_ERROR, 0, &t, sizeof(sTime));
                  }
                  lastITime = currITime;
              #endif
 490   1           EA = 0;                             
 491   1          // Read interrupt status. 
 492   1          intStatus.reg = ReadU32Reg(CPU_INTSTATUS_REG);
 493   1      
 494   1          // Write back the value to clear the status
 495   1          WriteU32Reg(CPU_INTSTATUS_REG, intStatus.reg);
 496   1          PlcMedInterruptReg.reg = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
 497   1          //  WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, PlcMedInterruptReg.reg);
 498   1          
 499   1          // Save CP bank context
 500   1          bankSelReg = ReadU32Reg(CPU_PKTBUFBANKSEL_REG);
 501   1        EA = 1; // Enable Globle Interrupts //Kiran
 502   1          // Process/Dispatch interrupts.
 503   1      #ifdef HYBRII_802154
 504   1          //while(intStatus.reg)
 505   1          while(intStatus.reg || PlcMedInterruptReg.s.zcint ||  PlcMedInterruptReg.s.plcTxDoneint)
 506   1      #else
                  
              #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                  while(intStatus.s.hpgpBP ||intStatus.s.PosthpgpBP||intStatus.s.ethFreeCP||intStatus.s.eth_txfifoRdDn||
             -intStatus.s.spiRxDone||intStatus.s.spiTxDone||intStatus.s.newEtherSA||intStatus.s.cpuTxQNonEmpty||intStatus.s.plcBcn2Sen
             -t||intStatus.s.plcBcn3Sent||intStatus.s.plcBcnRx || PlcMedInterruptReg.s.zcint|| PlcMedInterruptReg.s.plcTxDoneint || Pl
             -cMedInterruptReg.s.earlywakeBP || PlcMedInterruptReg.s.bcnStart) 
              #else
                  //while(intStatus.s.hpgpBP ||intStatus.s.PosthpgpBP||intStatus.s.ethFreeCP||
                //    intStatus.s.eth_txfifoRdDn || intStatus.s.spiRxDone||intStatus.s.spiTxDone||intStatus.s.newEtherSA||
             -intStatus.s.cpuTxQNonEmpty||intStatus.s.plcBcn2Sent||intStatus.s.plcBcn3Sent||intStatus.s.plcBcnRx || PlcMedInterruptReg
             -.s.zcint ||  PlcMedInterruptReg.s.plcTxDoneint || PlcMedInterruptReg.s.DbcHoldInt || PlcMedInterruptReg.s.HP101Detect) 
                  while(intStatus.s.hpgpBP ||intStatus.s.PosthpgpBP||intStatus.s.ethFreeCP||
                    intStatus.s.eth_txfifoRdDn || intStatus.s.spiRxDone||intStatus.s.spiTxDone||intStatus.s.newEtherSA||
                    (intStatus.s.cpuTxQNonEmpty)||intStatus.s.plcBcn2Sent||intStatus.s.plcBcn3Sent|| 
                    (intStatus.s.plcBcnRx) || PlcMedInterruptReg.s.zcint || PlcMedInterruptReg.s.plcTxDoneint) 
              #endif
              #endif // HYBRII_802154
 519   1          {
 520   2           
 521   2      #ifdef  HYBRII_HPGP
 522   2      //        HHAL_ProcessPlcTxDone();
 523   2      #endif
 524   2      
 525   2        if (PlcMedInterruptReg.s.zcint)
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 10  

 526   2          gHpgpHalCB.zcInt++;
 527   2      
 528   2      #ifdef HYBRII_HPGP
 529   2           if(PlcMedInterruptReg.s.zcint && gHpgpHalCB.bcnInitDone
 530   2      #ifdef FREQ_DETECT    
 531   2             && (gHpgpHalCB.gFreqCB.freqDetected)
 532   2      #endif
 533   2         ) //after 33.33 ms
 534   2      
 535   2         {
 536   3                  //WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, PlcMedInterruptReg.reg);
 537   3      
 538   3             if(gHpgpHalCB.devMode == DEV_MODE_CCO)
 539   3            {
 540   4      
 541   4              //gHpgpHalCB.c1++;
 542   4              doSynchronization();
 543   4      
 544   4            }
 545   3      
 546   3            //[YM]
 547   3                 //printf("\n Call doSynchronization()- zc\n");
 548   3                 //gHpgpHalCB.bPerAvgInitDone = 1;
 549   3           }
 550   2      #ifdef FREQ_DETECT
 551   2          
 552   2          if((gHpgpHalCB.gFreqCB.freqDetected == FALSE)  && gHpgpHalCB.bcnInitDone)
 553   2          {
 554   3      
 555   3      #ifdef HPGP_HAL_TEST
                      if(PlcMedInterruptReg.s.zcint && (gHpgpHalCB.devMode == DEV_MODE_CCO))
              #else
 558   3             // if(PlcMedInterruptReg.s.zcint && (linkLayer->mode == LINKL_STA_MODE_CCO))
 559   3      
 560   3          if(PlcMedInterruptReg.s.zcint && (gHpgpHalCB.devMode == DEV_MODE_CCO))   // PCCO TODO
 561   3      #endif         
 562   3          /*Compiler warning suppression*/
 563   3          {
 564   4      
 565   4      //      gHpgpHalCB.c2++;
 566   4                  FREQDET_DetectFrequencyUsingZC();             
 567   4              }
 568   3          }
 569   2      #endif
 570   2      #if 1 //def AC_TO_DC
 571   2          if(PlcMedInterruptReg.s.zcint)
 572   2          {
 573   3              gHpgpHalCB.halStats.zc++;
 574   3          }
 575   2      #endif
 576   2      
 577   2      #endif //HYBRII_HPGP
 578   2        if (PlcMedInterruptReg.s.plcTxDoneint)
 579   2        {
 580   3      //#ifdef HYBRII_HPGP  
 581   3          datapath_handlePlcTxDone();
 582   3      
 583   3          //scheduleFrameTask = 1;
 584   3      
 585   3          //printf("td\n");
 586   3      
 587   3          WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_PLC_TXDONE));
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 11  

 588   3      
 589   3        }
 590   2        
 591   2          if(PlcMedInterruptReg.s.zcint)
 592   2          {
 593   3              WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_ZC)); 
 594   3          }
 595   2      #if 0
                  if (gHpgpHalCB.HP101Detection)
                  {
                     if(PlcMedInterruptReg.s.HP101Detect) 
                     {
                          WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_HP101DETECT)); 
                    printf("HP101 is detected\n");
                    // Set Global variables for HP101 and HP11 detection bit to 1, which shall be used in Tx VF field
                     }
                  }
              
                if (PlcMedInterruptReg.s.DbcHoldInt)
                {
                        WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_DBC_HOLD));
                    printf("DBC pattern is detected\n");
                    // Set Global variables for DBC detection bit to 1, which will be used for packet flow control
                    dbc_pattern = ReadU32Reg(PLC_DBC_PATTERN_REG);
                    printf("DBC Pattern REG = %bX\n", dbc_pattern);
                }
              #endif  
 615   2      #if 0   // For Sound packet process
                      // [YM] When Rx a sound packet, read RSSI value from RSSI FIFO and print it out for pass to a func
             -tion for further process
                      if(intStatus.s.plcMSoundRxInt)
                      {
                         //
                         HHAL_RxSoundIntHandler();
                      }
              #endif  
 623   2      
 624   2      #ifdef HYBRII_HPGP
 625   2              if(intStatus.s.plcBcnRx)
 626   2              {  
 627   3      #ifdef HPGP_HAL_TEST
                          //HHAL_BcnRxIntHandler();
                          HAL_beaconRxHandler(NULL);
              
              #else
 632   3                  //HAL_BcnRxIntHandler(Ism.macIntCb[MAC_INT_IRQ_PLC_BCN_RX].cookie);
 633   3                  HAL_beaconRxHandler(Ism.macIntCb[MAC_INT_IRQ_PLC_BCN_RX].cookie);
 634   3          //  scheduleFrameTask = 1;
 635   3      
 636   3      #endif
 637   3              }
 638   2      
 639   2              if(intStatus.s.hpgpBP )//|| intStatus.s.hpgpBPSta)
 640   2              {
 641   3      #ifdef LOG_FLASH
                          u32 currBtime;
              #endif
 644   3      #ifdef HPGP_HAL_TEST
                           HHAL_BPIntHandler();
               
              #else
 648   3      #ifdef CCO_FUNC
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 12  

 649   3      #ifdef LOG_FLASH
              
                           currBtime = STM_GetTick();
                           if((lastBtime + 10) < currBtime)
                           {
                               sTime t;
                               tickToTime(&t, lastBtime);
                               logEvent(ISM_ERROR, BCN_TX_INT_ERROR, 0, &t, sizeof(sTime));
                           }
                           lastBtime = currBtime;
              #endif
 660   3                   if (!LINKL_BcnUpdateActive())
 661   3                   {
 662   4                       //HHAL_BcnTxIntHandler();
 663   4                       HHAL_BPIntHandler();
 664   4                   }
 665   3      #endif  /* CCO_FUNC */
 666   3      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                    if (EarlyWakeBpIntFlag)
                    {
              /*
                      if (psDebug)
                        FM_Printf(FM_MMSG,"hpgp_Int: exit deep sleep. gHpgpHalCB.halStats.psBpIntCnt=%lu\n", gHpgpHalCB.halSt
             -ats.psBpIntCnt);
              */
                      psAwakeCnt++;
                      if (gHpgpHalCB.psInSleepMode == 0)
                        psNotInSleepMode++; 
                      PSM_exit_deep_sleep_PS();
                      EarlyWakeBpIntFlag = FALSE;
                    }
              #endif
 680   3       
 681   3      #endif //HPGP_HAL_TEST
 682   3       
 683   3            }
 684   2               if(intStatus.s.PosthpgpBP)
 685   2               {
 686   3      #ifdef SENSOR_DRIVER
                         // [YM] Add a counter for sensor monitor
                      postBPCnt++;           
              #endif             
 690   3                 // gavg = PLC_MAX_AC_BPLEN;
 691   3                   
 692   3                  ntb1 = rtocl(ReadU32Reg(PLC_NTB_REG));
 693   3                  postBpstdiff = (ntb1 - goldntb1) * 40;
 694   3                  goldntb1 = ntb1; 
 695   3                  //printf("\n diff = %lu",diff);
 696   3                  
 697   3                  if(zctrack)
 698   3      
 699   3                  {
 700   4                       // printf("\n gbpst =%lu", (gbpst*40));
 701   4                       // printf("\n ntb = %lu",  (rtocl(ReadU32Reg(PLC_NTB_REG)) * 40));
 702   4                        //printf("\n gavg = %lu",  (gavg * 40));
 703   4                      if(postBpstdiff > BPST_THRESHOLD) //this threshold should work for AC as well as DC
 704   4                      {
 705   5                          //printf("\n diff = %lu",diff);
 706   5                          gbpst =  rtocl(ReadU32Reg(PLC_ZCNTB_REG)) + MAC_PROCESSING_CLOCK;
 707   5                          gNegativeflag =0;
 708   5                          gBPSTdelta =0;
 709   5                          gPositiveflag =0;
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 13  

 710   5                      } 
 711   4      
 712   4                        gBPSTdelta = gBPSTdelta / 8;
 713   4                       if(gNegativeflag)
 714   4                       {
 715   5                          gbpst += gavg - gBPSTdelta ;
 716   5                          //gNegativeflag = 0;
 717   5                       }
 718   4                       else  if(gPositiveflag)
 719   4                       {
 720   5                           gbpst += gavg + gBPSTdelta ;
 721   5                           //gPositiveflag = 0;
 722   5                       }
 723   4                       else
 724   4                       {
 725   5                          gbpst += gavg; 
 726   5                       } 
 727   4      //                 WriteU32Reg(PLC_BPST_REG, ctorl(gbpst)); //  bug fix, let HW handle BPST (TRI)
 728   4                  }
 729   3                  if(((gHpgpHalCB.devMode == DEV_MODE_STA)
 730   3      #ifdef MCCO
 731   3              || (gHpgpHalCB.devMode == DEV_MODE_PCCO)
 732   3      #endif
 733   3              )&& gHpgpHalCB.syncComplete)
 734   3                  {
 735   4                      if(gHpgpHalCB.bcncnt == gHpgpHalCB.halStats.BcnRxIntCnt)
 736   4                      {
 737   5                         gHpgpHalCB.bcnmisscnt++; 
 738   5      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                        if (scb->psState == PSM_PS_STATE_ON)
                        {
                          missBcnCnt = scb->commAwd.numBp + MAX_MISS_BCN;
                                }
                        if (missBcnCnt < MAX_MISS_BCN)
                          missBcnCnt = MAX_MISS_BCN;
                         
                                 if(gHpgpHalCB.bcnmisscnt == missBcnCnt)          
              #else
 748   5                         if(gHpgpHalCB.bcnmisscnt == MAX_MISS_BCN)
 749   5      #endif
 750   5                         {
 751   6                 gHpgpHalCB.bcnmisscnt = 0;
 752   6      #if 1 //ef MPER                    
 753   6                         //printf("rs\n");
 754   6      #endif
 755   6      
 756   6                    gHpgpHalCB.syncComplete = 0;
 757   6      //            gHpgpHalCB.nwSelected = 0;
 758   6      #ifdef MCCO
 759   6                  if (gHpgpHalCB.devMode == DEV_MODE_PCCO)
 760   6                  {
 761   7                    gHpgpHalCB.bPerAvgInitDone = 0;
 762   7                  }
 763   6      #endif
 764   6      
 765   6      #ifdef UM       
 766   6      #ifdef MCCO
 767   6                  if (gHpgpHalCB.devMode == DEV_MODE_PCCO)
 768   6                  {
 769   7                    sCnsm*       cnsm = (sCnsm *)LINKL_GetCnsm(linkLayer);
 770   7      
 771   7                    cnsm->netScan = 1;
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 14  

 772   7                    cnsm->netSync = 0;
 773   7                  }
 774   6                  else
 775   6      #endif          
 776   6                  if (gHpgpHalCB.devMode == DEV_MODE_STA)   
 777   6                  {
 778   7                    sSnsm*       snsm = (sSnsm *)LINKL_GetSnsm(linkLayer);
 779   7                    snsm ->netScan = 1;
 780   7                    snsm ->netSync = 0;           
 781   7                  }
 782   6      #endif
 783   6      
 784   6                  HHAL_SetSWStatReqScanFlag(REG_FLAG_SET);
 785   6                 }
 786   5                      }
 787   4              //[YM] - should add else condition to clear bcnmisscnt if missing bcn is not conseqtive happened        
 788   4                      gHpgpHalCB.bcncnt = gHpgpHalCB.halStats.BcnRxIntCnt;
 789   4                  }
 790   3               } 
 791   2      #endif
 792   2      
 793   2      #ifdef ETH_BRDG_DEBUG
                      if(intStatus.s.ethFreeCP)
                  {
                    // this is the old ETH Tx Done interrupt. It's generated after HW
                    // finishes copying the pkt to ETH FIFO
                    //
                    oldNumEthTxDoneInts++;
                  }
              #endif
 802   2               
 803   2      #ifdef SW_RECOVERY
 804   2              if(intStatus.s.plcSMHangInt)
 805   2              {
 806   3            Monitor_Hang();       
 807   3              }
 808   2      #endif
 809   2      
 810   2              if(intStatus.s.eth_txfifoRdDn)
 811   2              {
 812   3      #ifdef HYBRII_ETH
                    // this is the new ETH Tx Done interrupt. It's generated after ETH
                    // is done with transmitting the pkt.
                          // Release ETH Tx Complete CPs
                          EHAL_ReleaseEthTxCPIntHandler();
              
                    //scheduleFrameTask = 1;
              
              
              #endif
 822   3              }
 823   2      #ifdef HYBRII_SPI
                      if(intStatus.s.spiRxDone)
                      {
                          /* SPI Int Handler */
                          hal_spi_rx_done_handler();
                      }
                      if(intStatus.s.spiTxDone)
                      {
                          /* SPI Int Handler */
                          hal_spi_tx_done_handler();
              
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 15  

                    //scheduleFrameTask = 1;
                       }
              #endif
 837   2      
 838   2      //[YM] comment out the hpgpBp bit checking, it wil cause Bp tx counter mismatch
 839   2      
 840   2              if(intStatus.s.newEtherSA)
 841   2              {
 842   3                  // Read the EtherSA and invoke
 843   3                  // callback function in Bridge module.
 844   3              }
 845   2      #if CPU_TXQ_POLL
              #else       
 847   2              if(intStatus.s.cpuTxQNonEmpty)
 848   2              {                  
 849   3      #ifdef HPGP_HAL_TEST
                          CHAL_CpuTxQNemptyIntHandler();
              #else
 852   3                  /* Frame Rx handler */
 853   3                  CHAL_FrameRxIntHandler(Ism.macIntCb[MAC_INT_IRQ_CPU_TXQ_NONEMPTY].cookie);
 854   3      #endif
 855   3            //scheduleFrameTask = 1;
 856   3              }
 857   2      #endif 
 858   2      #ifdef HYBRII_HPGP     
 859   2              if(intStatus.s.plcBcn2Sent)
 860   2              {
 861   3                  // Call Discovery beacon Sent Int Handler
 862   3              }
 863   2              if(intStatus.s.plcBcn3Sent)
 864   2              {
 865   3                  // Call Central beacon Sent Int Handler
 866   3                  HHAL_Bcn3SentIntHandler();
 867   3                 /*if(zctrack)
 868   3                  {
 869   3                      gbpst = gavg + gbpst + MAC_PROCESSING_CLOCK ;// + 0x1BAFF;//1365 is bpsto
 870   3                       WriteU32Reg(PLC_BPST_REG, ctorl(gbpst));
 871   3                  } */
 872   3              }   
 873   2                 
 874   2              
 875   2      #endif 
 876   2      #ifdef HYBRII_802154
 877   2              if (intStatus.s.zbPreBcnTxTime)
 878   2              {
 879   3                  hal_zb_pre_bc_tx_time_handler();
 880   3              }
 881   2      
 882   2              if (intStatus.s.zbBcnTxTime)
 883   2              {
 884   3                  hal_zb_bc_tx_time_handler();
 885   3              }
 886   2      
 887   2              if (intStatus.s.zbTxDone)
 888   2              {
 889   3                  hal_zb_tx_done_handler();
 890   3              }
 891   2              
 892   2              if (intStatus.s.zbBcnTxDone)
 893   2              {
 894   3                  hal_zb_bc_tx_done_hadler();
 895   3              }
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 16  

 896   2              //break;
 897   2      #endif
 898   2      
 899   2      #if 0   // For Sound packet process
                      // [YM] When Rx a sound packet, read RSSI value from RSSI FIFO and print it out for pass to a func
             -tion for further process
                      if(intStatus.s.plcMSoundRxInt)
                      {
                         //
                         HHAL_RxSoundIntHandler();
                      }
              #endif  
 907   2      
 908   2      //#ifdef HYBRII_HPGP
 909   2      #ifdef POWERSAVE
                 // The order of polling is important: must poll for bpStartInt before EarlyWakeBpInt
                   if(PlcMedInterruptReg.s.bcnStart)
                 {
                  //u8 modVal;
              
                  WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_BCNSTART));
              
                  bcnStartInt++;
                  bpCntPSP++;
                  gHpgpHalCB.halStats.psBpIntCnt++;
              
                      if(gHpgpHalCB.devMode == DEV_MODE_CCO)
                    {
                      scb->bpCnt++;
                    }
              
              #ifdef PS_DEBUG
                    if (psDebug)
                      FM_Printf(FM_MMSG,"HPGP_INT: gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%d, \n", 
                          gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt);
              #endif
                    if (scb)
                    {
                      if (scb->psState == PSM_PS_STATE_ON)
                      {
                        u8 awdCnt = 0;
              
              //          if (psDebug)
              //            printf("hpgpBP INT:  gHpgpHalCB.halStats.psBpIntCnt=%lu, EarlyWakeBcnCnt=%lu\n", gHpgpHalCB.halSta
             -ts.psBpIntCnt, EarlyWakeBcnCnt);
              //          if (scb->bpCnt == (EarlyWakeBcnCnt+2))  // should be only + 1, but + 1 doesn't work, why ?
                        if (scb->commAwd.awdTime & 0x80)
                        {
                          awdCnt = (scb->commAwd.awdTime & 0x0f);
                        }
                        if (EarlyWakeBcnCnt && (gHpgpHalCB.halStats.psBpIntCnt == (EarlyWakeBcnCnt + awdCnt + 1)))
                        {
                          // this is the BP right after the AWD BP
              #ifdef PS_DEBUG
                          if (psDebug)
                            FM_Printf(FM_MMSG, "HPGP_INT: After AWD, enter deep sleep. gHpgpHalCB.halStats.psBpIntCnt=%lu, scb-
             ->bpCnt=%d, numBp=%d,awdCnt=%bu\n", 
                                gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt,  scb->commAwd.numBp, awdCnt);
              #endif
                          EarlyWakeBcnCnt = 0;
                          PSM_enter_deep_sleep_PS();
              #if 0
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 17  

                          WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_HIBERCLKOFF));
                          hiberClkOffSetFlag = FALSE;
                          EarlyWakeBcnCnt = 0;
                              PlcMedInterruptReg.reg = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
                            if(PlcMedInterruptReg.s.hiberClkOff)
                            FM_Printf(FM_MMSG,"HPGP_INT: hiberClkOff is still ON after clearing it\n");
                          tmpPsBpIntCnt = gHpgpHalCB.halStats.psBpIntCnt;
              #endif
                        }
                        else
                        {
                          // only STA in PS mode and it's AWD should datapath_transmitDataPlc() be called
                          datapath_transmitDataPlc(1);
                        }
                      }
                      else if (scb->psState == PSM_PS_STATE_WAITING_ON)
                      {
                        sPsSchedule tmpCommAwd;
              
                        // this STA has been waiting for the right bp to start its AWD
              #ifdef PS_DEBUG
                        if (psDebug)
                          FM_Printf(FM_MMSG,"HPGP_INT: scb->psState=WAITING_ON. gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt
             -=%d, scb->commAwd.numBp=%d\n", 
                              gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt,  scb->commAwd.numBp);
              #endif
                        PSM_cvrtPss_Awd(scb->pss, &tmpCommAwd); // for now, store PSS in tmp place so datapath_transmitDataPl
             -c()
                                            // can still tx
                        if (!(scb->bpCnt % tmpCommAwd.numBp))
                        {
              #ifdef PS_DEBUG
                          if (psDebug)
                            FM_Printf(FM_MMSG,"HPGP_INT: Config PS HW for AWD. gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%
             -d, scb->commAwd.numBp=%d\n", 
                                gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt,  scb->commAwd.numBp);
              #endif
                          scb->psState = PSM_PS_STATE_ON;
                          gHpgpHalCB.halStats.psBpIntCnt = scb->bpCnt;  // sync with CCO's bpCnt
                          PSM_ConfigStaPsHW(scb->pss);  
                            PSM_SetStaPsHW(TRUE);
                          PSM_cvrtPss_Awd(scb->pss, &scb->commAwd); // convert PSS to usable format
                          FM_Printf(FM_MMSG, "STA Power Saving Mode is now ON\n");
                        }
                      }  
                    }
              /*
                  bcnStartInt++;
                  if (EarlyWakeBpIntFlag)
                  {
                    if (psDebug)
                      FM_Printf(FM_MMSG,"bcnStart_Int: exit deep sleep. gHpgpHalCB.halStats.psBpIntCnt=%lu\n", gHpgpHalCB.ha
             -lStats.psBpIntCnt);
                    PSM_exit_deep_sleep_PS();
                    EarlyWakeBpIntFlag = FALSE;
                    bcnStartIntExitSleep++;
                  }
              */
                }
              
                   if(PlcMedInterruptReg.s.earlywakeBP)
                 {
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 18  

                  u8 modVal;
                    sEvent *newEvent = NULL;
                  //u32 ntb;
              
                  earlywakeBPintCnt++;
              #ifdef PS_DEBUG
                  if (psDebug)
                    FM_Printf(FM_MMSG,"earlywakeBP_Int: exit deep sleep. gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%d 
             -\n", gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt);
              #endif
                  WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_EARLYWAKEUPBP));
              
                  if (gHpgpHalCB.devMode == DEV_MODE_CCO)
                  {
                    if ( !(scb->bpCnt % 2))
                    {
                      // bpCnt should be an odd # in this interrupt
                      // if it's even, it means that it's 1 more than it should be
                      // Need to change it to odd so STA can sync with CCO
                        scb->bpCnt--;
                      EarlyWBPnotEven++;
              #ifdef PS_DEBUG
                      if (psDebug)
                        FM_Printf(FM_MMSG,"EARLY WAKEUP INT, CCO: changed bpCnt to ODD, new scb->bpCnt=%d\n", scb->bpCnt);
              #endif
                    }
              
                    // take care of the case when EarlyWakeBP interrupt occurs too early (usually 2 bps earlier)
                    if (scb->commAwd.numBp)
                    {
                      modVal = (scb->bpCnt + 1) % scb->commAwd.numBp;
                      if (modVal != 0)
                      {
                        EarlyWBPnotMOD++;
              #ifdef PS_DEBUG
                      if (psDebug)
                          printf("CCO: NOT MOD with scb->commAwd.numBp=%d, gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%d, 
             -modVal=%bu\n", 
                              scb->commAwd.numBp, gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt, modVal);
              #endif
                          scb->bpCnt += scb->commAwd.numBp - modVal;
                      }
                    }
                    EarlyWakeBcnCnt = scb->bpCnt;
                  }
                  if (gHpgpHalCB.devMode == DEV_MODE_STA)
                  {
                    if (!(gHpgpHalCB.halStats.psBpIntCnt % 2))
                    {
                      // bpCnt should be an odd # in this interrupt
                      // if it's even, it means that it's 1 more than it should be
                      // Need to change it to odd
                        gHpgpHalCB.halStats.psBpIntCnt--;
                      EarlyWBPnotEven++;
              #ifdef PS_DEBUG
                      if (psDebug)
                        FM_Printf(FM_MMSG,"EARLY WAKEUP INT, STA: changed bpCnt to ODD, new gHpgpHalCB.halStats.psBpIntCnt=%l
             -u\n", gHpgpHalCB.halStats.psBpIntCnt);
              #endif
                    }
              
                    // take care of the case when EarlyWakeBP interrupt occurs too early (usually 2 bps earlier)
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 19  

                    if (scb->commAwd.numBp)
                    {
                      modVal = (gHpgpHalCB.halStats.psBpIntCnt + 1) % scb->commAwd.numBp;
                      if (modVal != 0)
                      {
                        EarlyWBPnotMOD++;
              #ifdef PS_DEBUG
                        if (psDebug)
                          printf("STAT: NOT MOD with scb->commAwd.numBp=%d, gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%d,
             - modVal=%bu\n", 
                              scb->commAwd.numBp, gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt, modVal);
              #endif
                          gHpgpHalCB.halStats.psBpIntCnt += scb->commAwd.numBp - modVal;
                      }
                    }
                    EarlyWakeBcnCnt = gHpgpHalCB.halStats.psBpIntCnt;
                  }
              #ifdef PS_DEBUG
                  if (psDebug)
                    FM_Printf(FM_MMSG,"EARLY WAKEUP INT: final: EarlyWakeBcnCnt=%lu, gHpgpHalCB.halStats.psBpIntCnt=%lu, sc
             -b->bpCnt=%d\n", 
                        EarlyWakeBcnCnt, gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt);
              #endif
                  EarlyWakeBpIntFlag = TRUE;
                  // now exit deep_sleep mode
              //    PSM_exit_deep_sleep_PS();
                }
              
              #ifdef POWERSAVE_NO 
                   if(PlcMedInterruptReg.s.hiberClkOff)
                 {
                  if (scb && (scb->psState == PSM_PS_STATE_ON))
                  {
                    if (!hiberClkOffSetFlag &&  (gHpgpHalCB.halStats.psBpIntCnt > tmpPsBpIntCnt)) // HW problem: HiberClkOf
             -f goes HI too fast, so wait for next BP to do this
                    {
              #ifdef PS_DEBUG
                      if (psDebug)
                            FM_Printf(FM_MMSG,"hiberClkOff int. is HI. Enter deep sleep. gHpgpHalCB.halStats.psBpIntCnt=%lu
             -, scb->bpCnt=%d\n", gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt);
              #endif
                      hiberClkOffSetFlag = TRUE;
                      PSM_enter_deep_sleep_PS();
                    }
                  }
                   }
                 else
                 {
                  if (scb && (scb->psState == PSM_PS_STATE_ON))
                  {
              #ifdef PS_DEBUG
                    if (psDebug)
                          FM_Printf(FM_MMSG,"hiberClkOff int. is LO. gHpgpHalCB.halStats.psBpIntCnt=%lu, scb->bpCnt=%d\n",
             - gHpgpHalCB.halStats.psBpIntCnt, scb->bpCnt, gHpgpHalCB);
              #endif
                    
                  }
                 }
              #endif
              #endif //POWERSAVE
1127   2      
1128   2      #ifdef LLP_POWERSAVE
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 20  

                 // The order of polling is important: must poll for bpStartInt before EarlyWakeBpInt
                   if(PlcMedInterruptReg.s.bcnStart)
                 {
                  u8 modVal;
                  u32 bpst=0;
                  static u32 oldBpst=0;
              
                  WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_BCNSTART));
                  bcnStartInt++;
                  bpst = (rtocl(ReadU32Reg(PLC_CurBPST_REG))*40)/1000000;
              #ifdef PS_DEBUG
              
                  if (psDebug)
                    printf("bcn_Start: bpst=%lu, oldB=%lu\n",  bpst,  oldBpst);
              #endif
                   oldBpst =  bpst;
                  if (scb)
                  {
                    if (scb->psState == PSM_PS_STATE_ON)
                    {
                      u8 awdCnt = 0;
              
                      scb->bpCnt++;
                      scb->bpCnt &= 0xfff;  // limit to 12 bits
              
              #ifdef PS_RESYNC
                      if (resyncFlag == TRUE)
                      {
                        resyncFlag = FALSE;
              #ifdef PS_DEBUG
                          FM_Printf(FM_USER, "3) Resync STA PS Mode: scb->bpCnt = %u\n", scb->bpCnt);
              #endif
              //          PSM_ForcePsOff(staInfo->staScb) ;
                        PSM_enable_PS(scb, scb->pss, scb->bpCnt, linkLayer->mode);      // enable PS
                        }
              #endif
                      if (scb->commAwd.awdTime & 0x80)
                      {
                        awdCnt = (scb->commAwd.awdTime & 0x0f);
                      }
                      bcnStartIntandInPS++;
                      if (EarlyWakeBcnCnt)
                      {
                        if (scb->bpCnt == (EarlyWakeBcnCnt + awdCnt + 1))
                        {
                          // this is the BP right after the AWD BP, ie. start the sleep period
              #ifdef PS_DEBUG
                          if (psDebug)
                            FM_Printf(FM_USER, "BCN_START_INT: enter deep sleep, ,awdCnt=%bu, scb->bpCnt=%u\n", awdCnt, scb->bp
             -Cnt); 
              #endif
                          EarlyWakeBcnCnt = 0;
                          psSleepCnt++;
                          PSM_enter_deep_sleep_PS();
                        }
                        else
                        {
                          // still within the Awake period, try to Tx data
              #ifdef PS_DEBUG
                          if (psDebug)
                            FM_Printf(FM_USER, "BCN_START_INT: call datapath_transmitDataPlc(), EarlyWakeBcnCnt=%lu, awdCnt=%bu
             -, scb->bpCnt=%u\n", EarlyWakeBcnCnt, awdCnt, scb->bpCnt); 
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 21  

              #endif
                          datapath_transmitDataPlc(1);
                        }
                       }
                     }
                   }
                 }
              
                   if(PlcMedInterruptReg.s.earlywakeBP)
                 {
                  u8 modVal;
                    sEvent *newEvent = NULL;
                  u32 ntb;
              
                  // clear the interrupt
                  WriteU32Reg(PLC_MEDIUMINTSTATUS_REG, ctorl(INT_STATUS_EARLYWAKEUPBP));
              
              #ifdef PS_DEBUG
                  if (psDebug)
                    printf("EarlyWakeupBP: entered: scb->bpCnt=%u, earlywakeBPintCnt=%lu, bcnStartInt=%lu\n", scb->bpCnt, e
             -arlywakeBPintCnt, bcnStartInt); 
              #endif
                  // the below case applied to both CCO and STA
                  if (scb->psState == PSM_PS_STATE_ON)
                  {
                    // at Early Wakeup BP interrupt, the bcnCnt should be 
                    // multiple of (scb->commAwd.numBp-1)
                    modVal = (scb->bpCnt + 1) % scb->commAwd.numBp;
                    if (modVal != 0)
                    {
              #ifdef PS_DEBUG
                      if (psDebug)
                        printf("EarlyWakeupBP: : NOT MOD with scb->commAwd.numBp=%d, scb->bpCnt=%u, modVal=%bu\n", 
                            scb->commAwd.numBp, scb->bpCnt, modVal);
              #endif
                        scb->bpCnt += scb->commAwd.numBp - modVal;
                    }
              
                    earlywakeBPintCnt++;
                    if (earlywakeBPintCnt > 2)
                    {
                      // there's a bug in HW whereas when the GV board first boots up,
                      // it triggers earlyWakeupBp interrupt, so we disregard the 1st
                      // interrupt. And when we first enable PS in HW, the # of sleep bps
                      // are not correct, therefor the 1st earlyWakeBP int is also not reliable
              #ifdef PS_DEBUG
              
                      if (psDebug)
                        printf("EarlyWakeupBP: : set flag to TRUE, earlywakeBPintCnt=%lu\n", earlywakeBPintCnt);
              #endif
                      EarlyWakeBpIntFlag = TRUE;
                      EarlyWakeBcnCnt = scb->bpCnt;
                    }
                  }
                }
              #endif //LLP_POWERSAVE
1244   2      //#endif //HYBRII_HPGP
1245   2              EA = 0;
1246   2              // Read interrupt status.
1247   2              intStatus.reg = ReadU32Reg(CPU_INTSTATUS_REG);
1248   2              // Write back the value to clear the status immediately
1249   2              WriteU32Reg(CPU_INTSTATUS_REG, intStatus.reg);
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 22  

1250   2              PlcMedInterruptReg.reg = ReadU32Reg(PLC_MEDIUMINTSTATUS_REG);
1251   2          //if (intStatus.s.hpgpBP ||intStatus.s.PosthpgpBP||intStatus.s.ethFreeCP||intStatus.s.spiRxDone||intStat
             -us.s.spiTxDone||intStatus.s.newEtherSA||intStatus.s.cpuTxQNonEmpty||intStatus.s.plcBcn2Sent||intStatus.s.plcBcn3Sent||in
             -tStatus.s.plcBcnRx )
1252   2            // printf(" intStatus.reg = %lx\n", intStatus.reg);
1253   2              EA = 1;
1254   2      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                  loopCnt++;
              #endif
1257   2      
1258   2          }
1259   1      
1260   1      
1261   1        
1262   1      #ifdef RTX51_TINY_OS
1263   1      
1264   1        if (scheduleFrameTask )
1265   1        {
1266   2      
1267   2          //FM_Printf(FM_USER,"s\n");
1268   2          os_set_ready(HYBRII_TASK_ID_FRAME);
1269   2      
1270   2        }
1271   1      
1272   1          
1273   1      #endif  
1274   1          // Restore cp bank context
1275   1      #ifndef HYBRII_FPGA
1276   1      #ifdef  HYBRII_HPGP
1277   1      //    HHAL_ProcessPlcTxDone();
1278   1        
1279   1      #endif
1280   1      #endif
1281   1          
1282   1          WriteU32Reg(CPU_PKTBUFBANKSEL_REG, bankSelReg);
1283   1      #ifdef HYBRII_HPGP
1284   1          hal_hpgp_mac_monitoring();    
1285   1      #endif
1286   1      
1287   1          return;
1288   1      
1289   1      
1290   1      }
1291          
1292          #ifndef HAL_INT
1293          void ISM_EnableIntPolling()
1294          {
1295   1      #ifndef RTX51_TINY_OS
                  SCHED_Sched(&Ism.task);
              #endif
1298   1      }
1299          #endif
1300          
1301          eStatus ISM_Init(void)
1302          {
1303   1          memset(&Ism, 0, sizeof(sIsm));
1304   1      #ifndef HAL_INT
1305   1      #ifdef RTX51_TINY_OS
1306   1          //os_create_task(HYBRII_TASK_ID_ISM_POLL);
1307   1      #else
                  SCHED_InitTask(&Ism.task, HYBRII_TASK_ID_ISM_POLL, "ISM",
                                 HPGP_TASK_PRI_ISM, ISM_PollInt, &Ism);
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 23  

              #endif
1311   1      #endif
1312   1          return STATUS_SUCCESS;
1313   1      }
1314          
1315          eStatus ISM_RegisterIntHandler( eMacIntIrq intIrq,
1316                                           void (*intHdlr)(void XDATA *cookie),
1317                                           void* cookie)
1318          {
1319   1          intHdlr = intHdlr;
1320   1      
1321   1          if(intIrq < MAC_INT_IRQ_ALL)
1322   1          {
1323   2      #ifdef CALLBACK
                      Ism.macIntCb[intIrq].intHandler = intHdlr;
              #endif
1326   2              Ism.macIntCb[intIrq].cookie = cookie;
1327   2              return STATUS_SUCCESS;
1328   2          }
1329   1          else
1330   1          {
1331   2              return STATUS_FAILURE;
1332   2          }
1333   1      }
1334          
1335          
1336          
1337          void ISM_UnregisterIntrHandler( eMacIntIrq intIrq)
1338          {
1339   1          if(intIrq < MAC_INT_IRQ_ALL)
1340   1          {
1341   2              Ism.macIntCb[intIrq].intHandler = NULL;
1342   2              Ism.macIntCb[intIrq].cookie = NULL;
1343   2          }
1344   1      }
1345          
1346          /*
1347          #ifdef RTX51_TINY_OS
1348          extern void mac_hal_irq_handler(void);
1349          void ISM_ExtInterruptPoll (void) _task_ HYBRII_TASK_ID_ISM_POLL
1350          {
1351              while (1) {
1352          #ifdef HYBRII_HPGP
1353                  ISM_PollInt();
1354          #else
1355                  // FIXME - To be removed
1356                  mac_hal_irq_handler();
1357          #endif
1358                  os_switch_task();
1359              }
1360          }
1361          #endif
1362          */
1363          
1364          /** =========================================================
1365           *
1366           * Edit History
1367           *
1368           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/common/ism.c,v $
1369           *
1370           * $Log: ism.c,v $
1371           * Revision 1.60  2015/01/02 14:55:35  kiran
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 24  

1372           * 1) Timer Leak fixed while freeing SCB fixed
1373           * 2) Software broadcast supported for LG
1374           * 3) UART Loopback supported for LG
1375           * 4) Keep Alive feature to ageout defunctional STA
1376           * 5) Improved flash API's for NO Host Solution
1377           * 6) Imporved PLC Hang recovery mechanism
1378           * 7) Reduced nested call tree of common path functions
1379           * 8) Code optimization and cleanup (unused arguments, unused local variables)
1380           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
1381           * 10) Use of memory specific pointers instead of generic pointers
1382           *
1383           * Revision 1.59  2014/12/23 09:01:33  ranjan
1384           * Fixed Zigbee LMAC projects
1385           *
1386           * Revision 1.58  2014/12/09 07:09:08  ranjan
1387           * - multicco feature under MCCO flag
1388           *
1389           * Revision 1.57  2014/11/11 14:52:56  ranjan
1390           * 1.New Folder Architecture espically in /components
1391           * 2.Modular arrangment of functionality in new files
1392           *    anticipating the need for exposing them as FW App
1393           *    development modules
1394           * 3.Other improvisation in code and .h files
1395           *
1396           * Revision 1.56  2014/11/06 18:28:25  ranjan
1397           * -disabling recovery_monitor
1398           * -removing scheduleframetask for interupt stability
1399           *
1400           * Revision 1.55  2014/11/06 14:46:15  prashant
1401           * Plc rx frame stuck issue fix
1402           *
1403           * Revision 1.54  2014/10/29 22:29:09  yiming
1404           * add some comments to code
1405           *
1406           * Revision 1.53  2014/10/28 16:27:42  kiran
1407           * 1) Software recovery using Watchdog Timer
1408           * 2) Hardware recovery monitor and policies
1409           * 3) Timer Polling in Control Task and Frame task for better accuracy
1410           * 4) Common memory optimized by reducing prints
1411           * 5) Discovered netlist corruption fixed
1412           * 6) VCO fix in HHAL_AFEInit()
1413           * 7) Idata optimized by removing floating point operation
1414           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
1415           * 9) Beacon processing protected from interrupts
1416           * 10) Corrupted Beacons are dropped
1417           * 11) Some unused arguments removed to improve code size
1418           *
1419           * Revision 1.52  2014/10/15 10:42:51  ranjan
1420           * small fixes in um
1421           *
1422           * Revision 1.51  2014/10/13 10:23:57  prashant
1423           * LG-Uart corruption issue fix
1424           *
1425           * Revision 1.50  2014/09/30 21:39:43  tri
1426           * Added LLP PS
1427           *
1428           * Revision 1.49  2014/09/25 10:57:41  prashant
1429           * 1. GPIO API swapping issue fixed.
1430           * 2. Supported 1 to 512 frame length for uart.
1431           * 3. list.h file cleanup (code deleted).
1432           * 4. Supporting minirobo for mgmt frames.
1433           *
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 25  

1434           * Revision 1.48  2014/09/05 09:28:18  ranjan
1435           * 1. uppermac cco-sta switching feature fix
1436           * 2. general stability fixes for many station associtions
1437           * 3. changed mgmt memory pool for many STA support
1438           *
1439           * Revision 1.47  2014/08/25 07:37:34  kiran
1440           * 1) RSSI & LQI support
1441           * 2) Fixed Sync related issues
1442           * 3) Fixed timer 0 timing drift for SDK
1443           * 4) MMSG & Error Logging in Flash
1444           *
1445           * Revision 1.46  2014/07/30 12:26:25  kiran
1446           * 1) Software Recovery for CCo
1447           * 2) User appointed CCo support in SDK
1448           * 3) Association process performance fixes
1449           * 4) SSN related fixes
1450           *
1451           * Revision 1.45  2014/07/22 21:04:25  tri
1452           * Fixed compiler error
1453           *
1454           * Revision 1.44  2014/07/22 10:03:52  kiran
1455           * 1) SDK Supports Power Save
1456           * 2) Uart_Driver.c cleanup
1457           * 3) SDK app memory pool optimization
1458           * 4) Prints from STM.c are commented
1459           * 5) Print messages are trimmed as common no memory left in common
1460           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
1461           *
1462           * Revision 1.43  2014/07/16 10:47:40  kiran
1463           * 1) Updated SDK
1464           * 2) Fixed Diag test in SDK
1465           * 3) Ethernet and SPI interfaces removed from SDK as common memory is less
1466           * 4) GPIO access API's added in SDK
1467           * 5) GV701x chip reset command supported
1468           * 6) Start network and Join network supported in SDK (Forced CCo and STA)
1469           * 7) Some bug fixed in SDK (CP free, p app command issue etc.)
1470           *
1471           * Revision 1.42  2014/07/11 10:23:37  kiran
1472           * power save changes
1473           *
1474           * Revision 1.41  2014/06/19 17:13:19  ranjan
1475           * -uppermac fixes for lvnet and reset command for cco and sta mode
1476           * -backup cco working
1477           *
1478           * Revision 1.40  2014/06/17 20:35:23  varsha
1479           * freq detect code for hal test and umac prj is under flag compilation.
1480           *
1481           * Revision 1.39  2014/06/11 15:09:43  tri
1482           * took out debug printf
1483           *
1484           * Revision 1.38  2014/06/05 10:26:07  prashant
1485           * Host Interface selection isue fix, Ac sync issue fix
1486           *
1487           * Revision 1.37  2014/05/28 10:58:58  prashant
1488           * SDK folder structure changes, Uart changes, removed htm (UI) task
1489           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
1490           *
1491           * Revision 1.36  2014/05/21 15:57:51  yiming
1492           * temporary uncheck DBC and HP101 checking
1493           *
1494           * Revision 1.35  2014/05/15 19:30:43  varsha
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 26  

1495           * FREQ_DETECT code is added
1496           *
1497           * Revision 1.34  2014/05/13 20:28:18  varsha
1498           * This file added for sW recovery machenism
1499           *
1500           * Revision 1.33  2014/05/12 08:09:57  prashant
1501           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
1502           *
1503           * Revision 1.32  2014/04/29 21:29:28  yiming
1504           * disable print message for Mitsumi (MPER)
1505           *
1506           * Revision 1.31  2014/04/25 21:16:51  tri
1507           * PS
1508           *
1509           * Revision 1.30  2014/04/24 21:50:00  yiming
1510           * Working Code for Mitsumi
1511           *
1512           * Revision 1.29  2014/04/23 23:21:11  tri
1513           * fix compiler error
1514           *
1515           * Revision 1.28  2014/04/23 23:09:10  tri
1516           * more PS
1517           *
1518           * Revision 1.27  2014/04/21 20:04:23  tri
1519           * more PS
1520           *
1521           * Revision 1.26  2014/04/21 03:10:59  tri
1522           * more PS
1523           *
1524           * Revision 1.25  2014/04/20 19:47:12  tri
1525           * more PS
1526           *
1527           * Revision 1.24  2014/04/20 05:06:24  tri
1528           * compiler error
1529           *
1530           * Revision 1.23  2014/04/20 05:04:57  tri
1531           * more PS
1532           *
1533           * Revision 1.22  2014/04/20 04:55:19  tri
1534           * more PS
1535           *
1536           * Revision 1.21  2014/04/15 23:07:21  tri
1537           * more PS
1538           *
1539           * Revision 1.20  2014/04/15 19:52:20  yiming
1540           * Merge new ASIC setting, Add throughput improvement code, add M_PER code
1541           *
1542           * Revision 1.19  2014/04/09 21:11:58  yiming
1543           * fix compile error
1544           *
1545           * Revision 1.18  2014/04/09 21:04:23  tri
1546           * more PS
1547           *
1548           * Revision 1.17  2014/03/27 23:51:48  tri
1549           * more PS
1550           *
1551           * Revision 1.16  2014/03/26 00:11:50  yiming
1552           * Add DBC register definition
1553           *
1554           * Revision 1.15  2014/03/25 17:01:07  son
1555           * Hybrii B ASIC bring up
1556           *
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 27  

1557           * Revision 1.14  2014/03/19 00:13:46  tri
1558           * PS
1559           *
1560           * Revision 1.13  2014/03/15 17:24:06  tri
1561           * Power Save deep sleep
1562           *
1563           * Revision 1.12  2014/03/12 19:51:45  tri
1564           * added code for ETH_BRDG_DEBUG
1565           *
1566           * Revision 1.11  2014/03/10 05:58:10  ranjan
1567           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
1568           *
1569           * Revision 1.10  2014/02/27 10:42:47  prashant
1570           * Routing code added
1571           *
1572           * Revision 1.9  2014/02/26 22:56:06  tri
1573           * more PS code
1574           *
1575           * Revision 1.8  2014/02/19 20:30:21  son
1576           * Replace calling CHAL_Ext1Isr with ISM_PollInt
1577           *
1578           * Revision 1.7  2014/02/19 10:22:40  ranjan
1579           * - common sync for hal_tst and upper mac project
1580           * - ism.c is MAC interrupt handler for hhal_tst and upper mac.
1581           *    chal_ext1isr function   is removed
1582           * - verified : lower mac sync, upper mac sync data traffic.
1583           *
1584           * Revision 1.6  2014/02/14 21:09:35  varsha
1585           * I have added work around in posthpgpBP interrupt because we were missing polling in three device commun
             -ication.
1586           * With this fix AC,DC, uppermac and Lower MAc sync is working fine.
1587           *
1588           * Varsha.
1589           *
1590           * Revision 1.5  2014/02/12 11:45:16  prashant
1591           * Performance improvement fixes
1592           *
1593           * Revision 1.4  2014/02/07 22:45:05  yiming
1594           * add HP101 and HP11 detection code
1595           *
1596           * Revision 1.3  2014/01/28 17:53:46  tri
1597           * Added Power Save code
1598           *
1599           * Revision 1.2  2014/01/10 17:02:18  yiming
1600           * check in Rajan 1/8/2014 code release
1601           *
1602           * Revision 1.14  2014/01/08 10:53:53  ranjan
1603           * Changes for LM OS support.
1604           * New Datapath FrameTask
1605           * LM and UM  datapath, feature verified.
1606           *
1607           * known issues : performance numbers needs revisit
1608           *
1609           * review : pending.
1610           *
1611           * Revision 1.13  2013/10/25 13:08:16  prashant
1612           * ism.c fix for zigbee, Sniffer support for lower MAC
1613           *
1614           * Revision 1.12  2013/10/21 18:59:51  son
1615           * Fixed compilation issue for zigbee project
1616           *
1617           * Revision 1.11  2013/10/16 07:43:37  prashant
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 28  

1618           * Hybrii B Upper Mac compiling issues and QCA fix, added default eks code
1619           *
1620           * Revision 1.10  2013/09/20 14:19:36  yiming
1621           * merge Varsha SEP 16 code to Hybrii_B CVS
1622           *
1623           * Revision 1.9  2013/09/17 22:08:46  yiming
1624           * merge Hybrii_A ism.c to Hybrii_B CVS
1625           *
1626           * Revision 1.8  2013/09/17 22:00:03  yiming
1627           * fixed the compile error on 0916 sync code merge, remove older code and hpgpBPSta bit setting
1628           *
1629           * Revision 1.7  2013/09/16 22:29:38  yiming
1630           * Merge 0916 sync code
1631           *
1632           * Revision 1.6  2013/09/13 19:39:07  yiming
1633           * Merge Varsha 0911_2013 Beacon Sync code
1634           *
1635           * Revision 1.5  2013/09/04 15:49:18  yiming
1636           * comment out old line of code
1637           *
1638           * Revision 1.4  2013/09/04 14:43:30  yiming
1639           * New changes for Hybrii_A code merge
1640           *
1641           * Revision 1.3  2013/06/04 20:29:05  yiming
1642           * Merge 0603_2013 Hybrii A Code to Hybrii_B Test Code
1643           *
1644           * Revision 1.2  2013/01/24 00:13:46  yiming
1645           * Use 01-23-2013 Hybrii-A code as first Hybrii-B code base
1646           *
1647           * Revision 1.24  2013/01/22 12:41:38  prashant
1648           * Fixing build issues
1649           *
1650           * Revision 1.23  2013/01/17 16:06:03  ranjan
1651           * datapath stability fixes
1652           *
1653           * Revision 1.22  2013/01/15 12:26:11  ranjan
1654           * a)fixed issues in swQ for plc->host intf datapath and
1655           *    swQ for host -> plc datapath
1656           *
1657           * Revision 1.21  2013/01/04 16:11:22  prashant
1658           * SPI to PLC bridgeing added, Queue added for SPI and Ethernet
1659           *
1660           * Revision 1.20  2012/12/14 11:06:57  ranjan
1661           * queue added for eth to plc datapath
1662           * removed mgmt tx polling
1663           *
1664           * Revision 1.19  2012/11/13 22:39:43  son
1665           * Added Reset and RX reable primitives
1666           *
1667           * Revision 1.18  2012/10/11 06:21:00  ranjan
1668           * ChangeLog:
1669           * 1. Added HPGP_MAC_SAP to support linux host data and command path.
1670           *     define HPGP_MAC_SAP, NMA needs to be added in project.
1671           *
1672           * 2. Added 'p ping' command in htm.c . Feature is under AUTO_PING macro.
1673           *
1674           * 3. Extended  'p key' command to include PPEK support.
1675           *
1676           * verified :
1677           *   1. Datapath ping works overnite after association,auth
1678           *   2. HAL TEST project is intact
1679           *
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 29  

1680           * Revision 1.17  2012/09/08 04:01:43  son
1681           * Integrated SPI, Zigbee into common interrupt service function
1682           *
1683           * Revision 1.16  2012/07/19 21:46:07  son
1684           * Prepared files for zigbee integration
1685           *
1686           * Revision 1.15  2012/07/18 22:02:11  son
1687           * Changed ISM Polling task name
1688           *
1689           * Revision 1.14  2012/07/14 04:07:58  kripa
1690           * Reverting the change to ISM Poll task temporarily, to avoid a unknown crash.
1691           * Committed on the Free edition of March Hare Software CVSNT Client.
1692           * Upgrade to CVS Suite for more features and support:
1693           * http://march-hare.com/cvsnt/
1694           *
1695           * Revision 1.13  2012/07/12 22:05:55  son
1696           * Moved ISM Polling to ISM Task.
1697           * UI is now part of init task
1698           *
1699           * Revision 1.12  2012/07/04 19:08:36  kripa
1700           * Calling PnedingTxProc funciton from interrupt polling routine.
1701           * Committed on the Free edition of March Hare Software CVSNT Client.
1702           * Upgrade to CVS Suite for more features and support:
1703           * http://march-hare.com/cvsnt/
1704           *
1705           * Revision 1.11  2012/06/20 17:29:13  kripa
1706           * Adding Bcn3SentIntHandler()
1707           * Committed on the Free edition of March Hare Software CVSNT Client.
1708           * Upgrade to CVS Suite for more features and support:
1709           * http://march-hare.com/cvsnt/
1710           *
1711           * Revision 1.10  2012/06/13 06:24:31  yuanhua
1712           * add code for tx bcn interrupt handler integration and data structures for region entry schedule. But th
             -ey are not in execution yet.
1713           *
1714           * Revision 1.9  2012/06/07 06:10:29  yuanhua
1715           * (1) free CPs if frame tx fails (2) add compiler flag HAL_INT_HDL to differentiate the interrupt and int
             -errupt handler. (3) enable all interrupts during the system initialization.
1716           *
1717           * Revision 1.8  2012/06/05 22:37:11  son
1718           * UART console does not get initialized due to task ID changed
1719           *
1720           * Revision 1.7  2012/06/05 07:25:58  yuanhua
1721           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
1722           *
1723           * Revision 1.6  2012/06/04 23:09:18  son
1724           * Timer Handler to be called from RTX51 OS
1725           *
1726           * Revision 1.5  2012/05/19 22:22:16  yuanhua
1727           * added bcn Tx/Rx non-callback option for the ISM.
1728           *
1729           * Revision 1.4  2012/05/12 04:11:46  yuanhua
1730           * (1) added list.h (2) changed the hal tx for the hw MAC implementation.
1731           *
1732           * Revision 1.3  2012/04/19 16:46:30  yuanhua
1733           * fixed some C51 compiler errors for the integration.
1734           *
1735           * Revision 1.2  2012/04/13 06:15:10  yuanhua
1736           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
1737           *
1738           * Revision 1.1  2011/07/03 05:58:49  jie
C51 COMPILER V9.53.0.0   ISM                                                               11/04/2015 20:09:46 PAGE 30  

1739           * Initial check in
1740           *
1741           * Revision 1.1  2011/05/06 18:31:47  kripa
1742           * Adding common utils and isr files for Greenchip firmware.
1743           *
1744           * Revision 1.1  2011/04/08 21:41:00  yuanhua
1745           * Framework
1746           *
1747           *
1748           * =========================================================*/
1749          
1750          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2247    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    230      41
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
