C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NSM_CCO
OBJECT MODULE PLACED IN .\obj\nsm_cco.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\firmware\hpgp\src\link\nsm_cco.c LARGE OBJECTADVANCED OPTIMI
                    -ZE(9,SIZE) BROWSE INTVECTOR(0X2100) INCDIR(..\..\..\..\firmware\common\datapath;..\..\..\..\firmware\common\include;..\.
                    -.\..\..\firmware\hal;..\..\..\..\firmware\hpgp\src\crypto;..\..\..\..\firmware\hpgp\src\ctrl;..\..\..\..\firmware\hpgp\s
                    -rc\hal;..\..\..\..\firmware\hpgp\src\link;..\..\..\..\firmware\hpgp\src\mux;..\..\..\..\firmware\hpgp\src\nma;..\..\..\.
                    -.\firmware\hpgp\src\route;..\..\..\..\firmware\hpgp\src\test;..\..\..\..\firmware\project\hal\src;..\..\..\..\firmware\z
                    -igbee;..\..\..\..\components\aps\inc;..\..\..\..\components\utilities\datatype\inc;..\..\..\..\components\utilities\even
                    -t\inc;..\..\..\..\components\utilities\linklist\inc;..\..\..\..\components\utilities\timer\inc;..\..\..\..\components\hp
                    -gp\inc;..\..\..\..\firmware\common;..\..\..\..\firmware\hpgp;..\..\..\..\firmware\hpgp\src;..\..\..\..\firmware\app_supp
                    -ort;..\..\..\..\firmware\HybriiB_configuration_rw\src;..\..\..\..\components\drivers\gpio\inc;..\..\..\..\components\dri
                    -vers\hpgp\inc;..\..\..\..\components\drivers\nwk\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\component
                    -s;..\..\..\..\components\osal\inc;..\..\..\..\components\nma\hpgp\inc;..\..\..\..\components\nma\ieee802154\inc;..\..\..
                    -\..\components\nma;..\..\..\..\components\utilities\event\inc;..\..\..\..\components\hpgp\inc;..\..\..\..\components\dri
                    -vers\flash\inc;..\..\..\..\components\ieee802154\inc;..\..\..\..\components\drivers\uart\inc;..\..\..\..\components\util
                    -ities;..\..\..\..\components\drivers\hpgp\inc;..\..\..\..\components\drivers\ieee802154\inc;..\..\..\..\components\drive
                    -rs\nwk\inc;..\..\..\..\components\utilities\debug\inc;..\..\..\..\sampleapp\inc;..\..\..\..\sampleapp\src;..\..\inc;..\.
                    -.\..\..\components\drivers\i2c\inc;..\..\..\..\components\drivers\gvspi\inc) NOAREGS DEFINE(inline,P8051,C51,HPGP_HAL,HY
                    -BRII_8051,HYBRII_HPGP,CCO_FUNC,STA_FUNC,HPGP_TEST,HPGP_DEBUG,RTX51_TINY_OS,HYBRII_ASIC,PLC_SW_SYNC,HPGP_MAC_SAP,NMA,NEW_
                    -SYNC,UM,HYBRII_B,Hybrii_B,HW_SPI_TX_CRC,HW_SPI_RX_CRC,B_ASICPLC,HYBRII_ASIC_A2,BB_CAL,_CRC_VERIFY_,BB_GAIN_TABLE,B2,FREQ
                    -_DETECT,HYBRII_B_AFE,_BC_SECURE_TEST_,FREQ_DETECT,BCN_ERR,NO_HOST,MCCO,KEEP_ALIVE,UART_RAW,UART_HOST_INTF,UART_GPIO_INTE
                    -RRUPT,MCCO,SW_RECOVERY,HYBRII_802154,DEBUG_DATAPATH,HPGP_DRIVER_APP,LRWPAN_DRIVER_APP,NWKSTARTUP_APP,ROUTE_APP,RTOPO_APP
                    -,REGISTER_APP,LLP_APP,BRIDGE,DEVICEINTF_APP,SMARTLIGHT_APP,LED_SMART_LIGHT,ROUTE_RECOVERY) PRINT(.\lst\nsm_cco.lst) TABS
                    -(2) OBJECT(.\obj\nsm_cco.obj)

line level    source

   1          /** ========================================================
   2           *
   3           * @file nsm.c
   4           * 
   5           *  @brief Network System Manager:
   6           *         CNSM: CCO Network System Manager
   7           *         SNSM: STA Network System Manager
   8           *
   9           *  Copyright (C) 2010-2011, Greenvity Communications, Inc.
  10           *  All Rights Reserved
  11           *  
  12           * =========================================================*/
  13          
  14          
  15          #include <string.h>
  16          #include <stdio.h>
  17          #include "papdef.h"
  18          #ifdef ROUTE
              #include "hpgp_route.h"
              #endif
  21          #include "linkl.h"
  22          #include "nsm.h"
  23          #include "nam.h"
  24          #include "muxl.h"
  25          #include "nma.h"
  26          #include "nma_fw.h"
  27          #include "hpgpapi.h"
  28          #include "hpgpconf.h"
  29          #include "fm.h"
  30          #include "ism.h"
  31          #include "hpgpevt.h"
  32          #include "mmsg.h"
  33          #include "timer.h"
  34          #include "stm.h"
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 2   

  35          #include "hal.h"
  36          #include "sys_common.h"
  37          #include "crm.h"
  38          #ifdef HPGP_HAL
  39          #include "hal_hpgp.h"
  40          #else
              #include "sdrv.h"
              #endif
  43          #ifndef CALLBACK
  44          #include "hpgpapi.h"
  45          #endif
  46          #include "hybrii_tasks.h"
  47          #include "event_fw.h"
  48          #include "hpgp_msgs.h"
  49          
  50          #ifndef UART_HOST_INTF
              //#define DISC_BCN
              #endif
  53          #define HPGP_TIME_BBT                  1000   //2 seconds
  54          
  55          #define HPGP_TIME_USAI                  1000   //1 seconds
  56          //#define HPGP_TIME_DISC_AGING            120000 // 2 minutes
  57          #define HPGP_TIME_DISC_AGING            15000 // test 
  58          #define HPGP_TIME_DISC_PERIOD_MAX       5000   //10 seconds - MaxDiscoverPeriod
  59          //#define HPGP_TIME_STA_AGING_CNT       5  //5* 10 seconds - MaxDiscoverPeriod
  60          #define HPGP_TIME_CCO_BBT_TIMER              1000
  61          #define HPGP_HO_COUNTDOWN_MAX           5   //5 beacon periods
  62          #define HPGP_HO_SWITCH_NONE             0   //no handover switch
  63          #define HPGP_HO_SWITCH_STA              1   //switch to the STA mdoe/role
  64          #define HPGP_HO_SWITCH_CCO              2   //switch to the CCO mdoe/role
  65          
  66          #define HPGP_TIME_BEACON_LOSS              200 // test 
  67          #define MAXSNID                        16
  68          
  69          #define HPGP_MCCO_SYNC_BCN_RSSI   125
  70          #define HPGP_MCCO_SYNC_BCN_CNT    100
  71          #define HPGP_MCCO_START_SYNC_BCN_CNT 10
  72          
  73          
  74          /* default regions (in unit of ALU) */
  75          #define HPGP_REGION_MIN_SHARED_CSMA    0x5DC  /* minimum shared CSMA */
  76                                                        /* 1500 usec */        
  77          #define HPGP_REGION_MIN_LOCAL_CSMA     0x5DC  /* minimum local CSMA  */
  78                                                        /* 1500 usec */             
  79          #define HPGP_REGION_MAX_BEACON         (8*HPGP_BEACON_SLOT_ATU)  
  80                                                        /* maximum beacon region */
  81                                                        /* 8 slots */             
  82          #define HPGP_GLID_LOCAL_CSMA           0xFF
  83          #define HPGP_GLID_SHARED_CSMA          0xFE
  84          #define HPGP_GLID_DISC_BEACON          0xFD
  85          #define HPGP_GLID_GPP                  0xFB
  86          #define MAXSNID                        16
  87          
  88          #ifdef SIMU
              #define HPGP_TIME_BCN_INTERVAL    4 //4 ms
              #endif
  91          
  92          //beacon source
  93          enum
  94          {
  95              BCN_SRC_CCO,  // central beacon from the CCo/proxy CCo in the same network
  96              BCN_SRC_DISC, // discovery beacon from the STA in the same network 
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 3   

  97              BCN_SRC_OTHER_CCO, //CCo or proxy CCo in other networks
  98              BCN_SRC_OTHER_DISC, //discovery beacon from other networks
  99              BCN_SRC_UNKNOWN,     //unknown
 100          };
 101          u16 CSMA_REGIONS_50Hz[HYBRII_MAXSMAREGION_CNT] = {0x30, 0xE7F ,0xFFF,0xFFF, 0xFFF, 0xFFF }; 
 102          u16 CSMA_REGIONS_60Hz[HYBRII_MAXSMAREGION_CNT] = {0x30, 0xBF4 ,0xFFF,0xFFF, 0xFFF, 0xFFF };
 103          
 104          u16 CSMA_REGIONS_50Hz_MN[HYBRII_MAXSMAREGION_CNT] = {0x40,0x80,0xc0,0x100,0xEAF,0xFFF};//Kiran
 105          u16 CSMA_REGIONS_60Hz_MN[HYBRII_MAXSMAREGION_CNT] = {0x40,0x80,0xC0,0x100,0xC04,0xFFF};//Kiran
 106          
 107          extern void LINKL_TimerHandler(u16 type, void *cookie);
 108          
 109          #ifdef ROUTE
              extern void ROUTE_prepareHoldList(sCrm *crm, sScb *scb);
              extern void ROUTE_preparteAndSendUnreachable(sScb *scb);
              extern eStatus ROUTE_sendRouteInfo(u16 mmType, sEvent *reqEvent);
              #endif
 114          #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
              extern u8 psDebug;
              #endif
 117          
 118          eStatus CNSM_BuildBeacon(sCnsm *cnsm, u8 bcnType);
 119          eStatus CNSM_TransmitBeacon(sCnsm *cnsm);
 120          eStatus CNSM_InitRegion(sCnsm *cnsm);
 121          u8 firstTimepCCo = 1;
 122          extern u8 BeHdrType[22];
 123          extern u8 BeLenMax[22];
 124          extern u8 syncThres;
 125          static void CNSM_ProcPassiveBcnHigh(sCnsm * cnsm,u8* bcn, u8 snid, u32 bts);
 126          
 127          #ifdef LLP_POWERSAVE
              extern u32 bcnStartInt;
              #endif
 130          
 131          void SCB_UpdateDiscStaList(sScb *scb, sDiscStaInfoRef *discStaInfoRef)
 132          {
 133   1          u8 i;
 134   1          u8 new, k;
 135   1        sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 136   1        sStaInfo *staInfo = &linkl->staInfo;
 137   1      
 138   1          //search through the discovered STA list 
 139   1          //always update the STA information whether or not it is new or old.
 140   1          new = 0;
 141   1          
 142   1          k = DISC_STA_LIST_MAX;
 143   1          for(i = 0; i < DISC_STA_LIST_MAX; i++)
 144   1          {
 145   2              if(staInfo->discStaInfo[i].valid == TRUE)
 146   2              {
 147   3                  if(memcmp(staInfo->discStaInfo[i].macAddr, discStaInfoRef->macAddr, 
 148   3                            MAC_ADDR_LEN) == 0)
 149   3                  {
 150   4                      //update
 151   4                      k = i;
 152   4                      new = 0;
 153   4                      break;
 154   4                  }
 155   3              } 
 156   2              else
 157   2              {
 158   3                  k = i;  
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 4   

 159   3                  new = 1;
 160   3              }
 161   2          }
 162   1          
 163   1          if(k < DISC_STA_LIST_MAX)
 164   1          {
 165   2              if(new == 1)
 166   2              {
 167   3                  //found a new discovered STA
 168   3                  scb->discUpdate = 1;
 169   3                  staInfo->discStaInfo[k].valid = TRUE;
 170   3                  memcpy(staInfo->discStaInfo[k].macAddr, discStaInfoRef->macAddr, MAC_ADDR_LEN);
 171   3                  staInfo->numDiscSta++;
 172   3              }         
 173   2      //        memcpy(scb->discStaInfo[k].nid, discStaInfoRef->nid, NID_LEN-1);
 174   2      //        scb->discStaInfo[k].nid[NID_LEN-1] = discStaInfoRef->nid[NID_LEN-1]&0x3F;
 175   2              staInfo->discStaInfo[k].tei = discStaInfoRef->tei;
 176   2              staInfo->discStaInfo[k].staCap.byte =  discStaInfoRef->discInfo->staCap.byte;
 177   2      
 178   2              staInfo->discStaInfo[k].sameNet = discStaInfoRef->sameNet;
 179   2      #ifdef MCCO
 180   2      
 181   2          staInfo->discStaInfo[k].slotId = discStaInfoRef->slotId;
 182   2          staInfo->discStaInfo[k].slotUsage = discStaInfoRef->slotUsage;
 183   2      
 184   2      #endif
 185   2      
 186   2              staInfo->discStaInfo[k].hit = 1;
 187   2          }
 188   1          else
 189   1          {
 190   2              FM_Printf(FM_WARN, "SNSM:Disc STA List is full\n");
 191   2          }
 192   1      }
 193          
 194          #if 0 //def MCCO
              
              void CNSM_UpdateAvlnList(sCnsm *cnsm, sAvlnInfoRef *avlnInfo)
              {
                sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                sStaInfo *staInfo = &linkl->staInfo;
              
                  u8 i;
                  u8 k;
                  //search through the AVLN list 
                  k = AVLN_LIST_MAX;
                  for(i = 0; i < AVLN_LIST_MAX; i++)
                  {
                      if(cnsm->avlnInfo[i].valid == TRUE)
                      {
                          if((memcmp(cnsm->avlnInfo[i].nid, avlnInfo->nid, NID_LEN-1) == 0) &&
                             ((cnsm->avlnInfo[i].nid[NID_LEN-1]&NID_EXTRA_BIT_MASK) == (avlnInfo->nid[NID_LEN-1]&NID_EXT
             -RA_BIT_MASK)))
                          {
                            u8 weightAvg;
                              //found the existing AVLN
                              cnsm->avlnInfo[i].hit = 1;
                      
                      weightAvg = ((cnsm->avlnInfo[i].rssi *80)/100) + (( avlnInfo->rssi* 20)/100);
                      
                      cnsm->avlnInfo[i].rssi = weightAvg;
                        
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 5   

                      cnsm->avlnInfo[i].lqi = avlnInfo->lqi;
              
                      snsm->avlnInfo[i].bcnRxCnt++;
                      
                              return;
                          }            
                      }
                      else
                      {
                          k = i;  
                      }
                  }
                  
                  if(k < AVLN_LIST_MAX)
                  {
                      //found a new AVLN
                      cnsm->avlnInfo[k].valid = TRUE;
                      memcpy(cnsm->avlnInfo[k].nid, avlnInfo->nid, NID_LEN-1);
                      cnsm->avlnInfo[k].nid[NID_LEN-1] = avlnInfo->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK;
                      cnsm->avlnInfo[k].hit = 1;
                      cnsm->avlnInfo[k].snid = avlnInfo->snid;
                  cnsm->avlnInfo[k].tei = avlnInfo->tei;    
                
                  cnsm->avlnInfo[k].rssi = avlnInfo->rssi;
                  cnsm->avlnInfo[k].lqi = avlnInfo->lqi;
                  cnsm->avlnInfo[k].slotId = avlnInfo->slotId;//Kiran
              
                  cnsm->avlnInfo[k].slotUsage = avlnInfo->slotUsage;
                    
                  staInfo->slotUsage |= BIT(avlnInfo->slotId);
                  
                  printf("\nMulti NW: Slot ID AVLN List : %bu , slotUsage %bu \n",
                      avlnInfo->slotId, staInfo->slotUsage);//Kiran   
                  
                  FM_HexDump(FM_USER,"avn nid",avlnInfo->nid, NID_LEN);   
              
                      cnsm->numAvln++;
              
                  cnsm->bcnUpdate = 1;
              
                  }
                  else
                  {
                      FM_Printf(FM_WARN, "AVLN List full\n");
                  }
              }
              
              #endif
 268          
 269          sDiscNetInfo *SCB_GetDiscNetEntry(u8 *nid)
 270          {
 271   1          u8 i;
 272   1          u8 k;
 273   1        u8 new = 0;
 274   1        sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 275   1        sStaInfo *staInfo = &linkl->staInfo;
 276   1        
 277   1        /*Compiler warning suppression*/
 278   1        k = k;
 279   1        
 280   1        for(i = 0; i < DISC_NET_LIST_MAX; i++)
 281   1        {
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 6   

 282   2          if (!staInfo->discNetInfo[i].valid)
 283   2            continue;
 284   2          if((memcmp(staInfo->discNetInfo[i].nid, nid, NID_LEN-1) == 0) &&
 285   2              ((staInfo->discNetInfo[i].nid[NID_LEN-1]&NID_EXTRA_BIT_MASK) ==
 286   2               (nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)) )
 287   2          {
 288   3            return (&staInfo->discNetInfo[i]);
 289   3          }
 290   2        }
 291   1        return NULL;
 292   1      }
 293          void SCB_UpdateDiscNetList(sScb *scb, sDiscNetInfoRef *discNetInfoRef)
 294          {
 295   1          
 296   1          u8 i;
 297   1          u8 k;
 298   1        u8 new = 0;
 299   1        sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 300   1        sStaInfo *staInfo = &linkl->staInfo;
 301   1        
 302   1          k = DISC_NET_LIST_MAX;
 303   1          for(i = 0; i < DISC_NET_LIST_MAX; i++)
 304   1          {
 305   2              if(staInfo->discNetInfo[i].valid == TRUE)
 306   2              {
 307   3                  if( (memcmp(staInfo->discNetInfo[i].nid, discNetInfoRef->nid, NID_LEN-1) == 0) &&
 308   3                      ((staInfo->discNetInfo[i].nid[NID_LEN-1]&NID_EXTRA_BIT_MASK) ==
 309   3                       (discNetInfoRef->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)) )
 310   3                  {
 311   4                    u8 weightAvg;
 312   4                      //already in the list. no update
 313   4                      staInfo->discNetInfo[i].hit = 1;
 314   4      
 315   4            //  printf("hit\n");
 316   4              
 317   4              weightAvg = (((staInfo->discNetInfo[i].rssi  *80) + ( discNetInfoRef->rssi * 20))/100);
 318   4              
 319   4                staInfo->discNetInfo[i].rssi = weightAvg;
 320   4              
 321   4              staInfo->discNetInfo[i].lqi = discNetInfoRef->lqi;
 322   4              staInfo->discNetInfo[i].snid = discNetInfoRef->snid;
 323   4              memcpy(&staInfo->discNetInfo[i].vendor_ota, &discNetInfoRef->vendor_ota, sizeof(svendorOta));     
 324   4      
 325   4              staInfo->discNetInfo[i].bcnRxCnt++;
 326   4      #ifdef MCCO
 327   4                
 328   4              staInfo->slotUsage &= ~(BIT(staInfo->discNetInfo[i].slotId));
 329   4      
 330   4              staInfo->slotUsage  |= BIT(discNetInfoRef->slotId);
 331   4      
 332   4      #endif
 333   4      
 334   4                  
 335   4              new = 0;
 336   4                      return;
 337   4                  }
 338   3              }
 339   2              else
 340   2              {
 341   3                  k = i; 
 342   3            new = 1;
 343   3              }
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 7   

 344   2          }
 345   1          if(k < DISC_NET_LIST_MAX)
 346   1          {
 347   2            if(new == 1)
 348   2            {
 349   3                //new AVLN is found
 350   3                staInfo->numDiscNet++;
 351   3                memcpy(staInfo->discNetInfo[k].nid, discNetInfoRef->nid, NID_LEN-1);
 352   3                staInfo->discNetInfo[k].nid[NID_LEN-1] = discNetInfoRef->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK;
 353   3        //        memcpy(snsm->discNetInfo[k].bpsto, discNetInfoRef->bpsto, 3);
 354   3                staInfo->discNetInfo[k].netMode = discNetInfoRef->netMode;
 355   3                staInfo->discNetInfo[k].hybridMode = discNetInfoRef->hybridMode;
 356   3                staInfo->discNetInfo[k].numBcnSlots = discNetInfoRef->numBcnSlots;
 357   3      
 358   3            staInfo->discNetInfo[k].rssi =  discNetInfoRef->rssi;
 359   3            staInfo->discNetInfo[k].snid = discNetInfoRef->snid;
 360   3            memcpy(&staInfo->discNetInfo[k].vendor_ota, &discNetInfoRef->vendor_ota, sizeof(svendorOta));     
 361   3      #ifdef MCCO
 362   3                staInfo->discNetInfo[k].slotId = discNetInfoRef->slotId;
 363   3      
 364   3            staInfo->slotUsage  |= BIT(discNetInfoRef->slotId);
 365   3                  
 366   3                staInfo->discNetInfo[k].slotUsage = discNetInfoRef->slotUsage;
 367   3      #endif
 368   3                staInfo->discNetInfo[k].hit = 1;
 369   3                scb->discUpdate = 1;
 370   3                staInfo->discNetInfo[k].valid  = 1;
 371   3            staInfo->discNetInfo[k].bcnRxCnt = 1;
 372   3            }
 373   2          }
 374   1          else
 375   1          {
 376   2            #ifndef RELEASE 
 377   2                //FM_Printf(FM_WARN, "Disc NetList full\n");
 378   2          #endif
 379   2          }
 380   1      
 381   1      }
 382          
 383          void SCB_ClearAgeDiscLists()
 384          {
 385   1        u8 i;
 386   1      
 387   1        sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 388   1        sCrm      *crm = LINKL_GetCrm(linkl);
 389   1        sStaInfo *staInfo = &linkl->staInfo;
 390   1      
 391   1        /*Compiler warning suppression*/
 392   1        i = i;
 393   1        
 394   1        memset((u8*)&staInfo->discNetInfo, 0x00 ,   
 395   1            sizeof(sDiscNetInfo)* DISC_NET_LIST_MAX);
 396   1      
 397   1        staInfo->numDiscNet = 0;
 398   1      
 399   1      
 400   1      }
 401          void SCB_AgeDiscLists(sScb *scb)
 402          {
 403   1          u8 i;
 404   1          sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 405   1        sScb          *uscb = NULL;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 8   

 406   1        sCrm          *crm = LINKL_GetCrm(linkl);
 407   1        sStaInfo *staInfo = &linkl->staInfo;
 408   1      
 409   1          //scb = snsm->staInfo->staScb;
 410   1          for(i = 0; i < DISC_STA_LIST_MAX; i++)
 411   1          {
 412   2              if(staInfo->discStaInfo[i].valid == TRUE)
 413   2              {
 414   3                  if(staInfo->discStaInfo[i].hit == 1)
 415   3                  {
 416   4                      staInfo->discStaInfo[i].hit = 0;
 417   4                  }
 418   3                  else
 419   3                  {
 420   4      #ifndef RELEASE
 421   4      #ifdef P8051
 422   4                   FM_Printf(FM_MINFO, "SCB:age out disc entry(tei: %bu)\n",
 423   4                                        staInfo->discStaInfo[i].tei);
 424   4      #else
                    FM_Printf(FM_MINFO, "SCB:age out disc entry(tei: %d)\n",
                                    staInfo->discStaInfo[i].tei);
              #endif
 428   4      #endif
 429   4      #if 1   //[YM] temporary commnet ageout function
 430   4       //Send unreachable Ind
 431   4              uscb = CRM_GetScb(crm, staInfo->discStaInfo[i].tei);
 432   4      #if 0 //def POWERSAVE 
                      if (uscb->psState == PSM_PS_STATE_ON)
                      {
                        // distant STA is is PS mode
                                scb->discStaInfo[i].hit = 0; // ?? find a limit time before tearing down the connection
                      }
                      else
                      {
              #endif
 441   4      #ifdef ROUTE
              
              
                        ROUTE_preparteAndSendUnreachable(uscb);        
              #endif
 446   4      #if 0
                      {
                        sEvent *newEvent;
                        
                        //send the event to the SNAM to renew the TEI
                        newEvent = EVENT_Alloc(MAC_ADDR_LEN, 
                                     EVENT_HPGP_CTRL_HEADROOM);
                        if(newEvent != NULL)
                        {
                          sHpgpHdr *hpgpHdr;
                          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                          newEvent->eventHdr.type = EVENT_TYPE_STA_AGEOUT;
                          hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                          hpgpHdr->scb = (sScb*)uscb;
              
                          LINKL_SendEvent(linkl, newEvent);
                        }
                        
              
                      }
              
              #endif
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 9   

 468   4      
 469   4                      //remove the entry from the list
 470   4                      memset(&staInfo->discStaInfo[i], 0, sizeof(sDiscStaInfo));
 471   4                      scb->discUpdate = 1;
 472   4                      staInfo->numDiscSta--;
 473   4      #if 0 //def POWERSAVE 
                      }
              #endif
 476   4      
 477   4      #endif  //[YM]
 478   4                  }
 479   3              }
 480   2          }
 481   1      
 482   1          for(i = 0; i < DISC_NET_LIST_MAX; i++)
 483   1          {
 484   2              if(staInfo->discNetInfo[i].valid == TRUE)
 485   2              {
 486   3                
 487   3        //      printf("chck \n");
 488   3              
 489   3                  if(staInfo->discNetInfo[i].hit == 1)
 490   3                  {
 491   4                      staInfo->discNetInfo[i].hit = 0;
 492   4                  }
 493   3                  else
 494   3                  {
 495   4                      //remove the entry from the list
 496   4      #ifdef MCCO
 497   4                      
 498   4              staInfo->slotUsage &= ~(BIT(staInfo->discNetInfo[i].slotId));
 499   4      #endif
 500   4              
 501   4                      memset(&staInfo->discNetInfo[i], 0, sizeof(sDiscNetInfo));
 502   4                      scb->discUpdate = 1;
 503   4                      staInfo->numDiscNet--;
 504   4      
 505   4              if (linkl->mode == LINKL_STA_MODE_CCO)
 506   4              {
 507   5                //linkl->ccoNsm.bcnUpdate = 1;
 508   5              }       
 509   4                  }
 510   3              }
 511   2          }
 512   1      }
 513          
 514          #ifdef CCO_FUNC
 515          
 516          /* ========================== 
 517           * CCO  network system manager
 518           * ========================== */
 519          
 520          #ifdef MCCO
 521          
 522          void CNSM_SetCentralCCo()
 523          {
 524   1          sHaLayer *hal;    
 525   1        sLinkLayer    *linkLayer = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
 526   1        sCnsm         *cnsm  = &linkLayer->ccoNsm;
 527   1        
 528   1          hal = HOMEPLUG_GetHal();
 529   1        cnsm->isCentralCCo = 1;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 10  

 530   1        cnsm->vendorSpec.enable = TRUE;
 531   1        memcpy(cnsm->vendorSpec.ota.ouid, (u8*)hal->macAddr, OUID_LEN);   
 532   1        memcpy(cnsm->vendorSpec.ota.buf, (u8*)hal->macAddr, 
 533   1            MAC_ADDR_LEN);  
 534   1        cnsm->vendorSpec.ota.buf[MAC_ADDR_LEN] = 0x11;
 535   1        cnsm->vendorSpec.ota.buf[MAC_ADDR_LEN+1] = 0x11;
 536   1      }
 537          
 538          #endif
 539          
 540          eStatus CNSM_SendMgmtMsg(sCnsm *cnsm, 
 541                      u16 mmType,
 542                      u8 snid,
 543                      u8 dsttei, u8 *macAddr)
 544          {
 545   1          eStatus         status = STATUS_SUCCESS;
 546   1          sEvent      xdata   *newEvent = NULL;
 547   1          sHpgpHdr       *hpgpHdr = NULL;
 548   1        sStaInfo       *staInfo = cnsm->staInfo;
 549   1        
 550   1          //send the CC_DISCOVER_LIST.REQ 
 551   1          //to query the discovered sta/network list
 552   1          //for the topology table
 553   1          newEvent = EVENT_MgmtAlloc(HPGP_DATA_PAYLOAD_MIN, EVENT_HPGP_MSG_HEADROOM);
 554   1          if(newEvent == NULL)
 555   1          {
 556   2              FM_Printf(FM_ERROR, "EAF\n");
 557   2              return STATUS_FAILURE;
 558   2          }
 559   1          newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
 560   1          newEvent->eventHdr.type = mmType;
 561   1      //                        newEvent->eventHdr.tei = event->eventHdr.tei;
 562   1          hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
 563   1          hpgpHdr->tei = dsttei;
 564   1        hpgpHdr->snid = snid;
 565   1          hpgpHdr->macAddr = macAddr;
 566   1          /* TODO: based on the each station encryption status, set the EKS */
 567   1          
 568   1                             
 569   1          if (mmType == EVENT_TYPE_CC_DISCOVER_LIST_REQ)
 570   1          {
 571   2      #ifdef P8051
 572   2              FM_Printf(FM_MMSG, "CNSM:>>CC_DISC_LIST.REQ tei: %bu\n",
 573   2                                  hpgpHdr->tei);
 574   2      #else
                      FM_Printf(FM_MMSG, "CNSM:>>CC_DISC_LIST.REQ tei: %d\n",
                                          hpgpHdr->tei);
              #endif
 578   2      
 579   2          hpgpHdr->eks = staInfo->nekEks;
 580   2          }
 581   1        else
 582   1        if ((mmType == EVENT_TYPE_NN_INL_REQ) ||
 583   1          (mmType == EVENT_TYPE_NN_INL_CNF))
 584   1        {
 585   2          sNnINLReq *inlReq = (sNnINLReq*)newEvent->buffDesc.dataptr;
 586   2      
 587   2          hpgpHdr->eks = HPGP_EKS_NONE;
 588   2          
 589   2      //    hpgpHdr->mnbc = 1;
 590   2            
 591   2          if (mmType == EVENT_TYPE_NN_INL_REQ)
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 11  

 592   2          {
 593   3            FM_Printf(FM_MMSG, "CNSM:>>NN_INL_REQ(tei:%bu)snid:%bu\n",
 594   3                          hpgpHdr->tei, snid);
 595   3          }else
 596   2          if (mmType == EVENT_TYPE_NN_INL_CNF)    
 597   2          {
 598   3            FM_Printf(FM_MMSG, "CNSM:>>NN_INL_CNF(tei:%bu)snid:%bu\n",
 599   3                          hpgpHdr->tei, snid);
 600   3          }
 601   2         
 602   2          inlReq->numNw = 0;
 603   2          memcpy(inlReq->srcNid, staInfo->nid, sizeof(staInfo->nid));
 604   2          inlReq->srcSnid = staInfo->snid;
 605   2          inlReq->srcTei = staInfo->staScb->tei;
 606   2          inlReq->srcNumAuthSta = CRM_GetScbNum(cnsm->crm);     
 607   2      
 608   2          newEvent->buffDesc.datalen = sizeof(sNnINLReq); 
 609   2        }
 610   1        else  
 611   1        {
 612   2          newEvent->buffDesc.datalen = HPGP_DATA_PAYLOAD_MIN;
 613   2        }
 614   1          //transmit CM_UNASSOCIATED_STA_IND in the MNBC
 615   1          status = MUXL_TransmitMgmtMsg(newEvent);
 616   1          //the event is freed by MUXL if the TX is successful
 617   1          if(status == STATUS_FAILURE)
 618   1          {
 619   2              EVENT_Free(newEvent);
 620   2          }
 621   1          return status;
 622   1      }
 623          
 624          
 625          void CNSM_UpdateSched(sCnsm *cnsm, u8 schedInd, u8 pscd, u8 cscd)
 626          {
 627   1          u8 j, k;
 628   1          sCsmaRegion *region = cnsm->regionTable[schedInd].region;
 629   1          u8 regionNum =  cnsm->regionTable[schedInd].regionNum;
 630   1          sSai *sai = cnsm->saiTable[schedInd].sai;
 631   1          u16 endTime = 0;
 632   1          /* build a sai table based on the region */
 633   1          k = 0;
 634   1          j = 0;
 635   1          while((j< regionNum) && (k < HPGP_SESS_MAX))
 636   1          {
 637   2              /* we only schedule two types of regions: shared csma and local csma */
 638   2              if (region[j].regionType == REGION_TYPE_SHARED_CSMA)
 639   2              {
 640   3                  /* it is assumed that the contiguous regions should have
 641   3                   * different region type */
 642   3                  sai[k].stpf = 1;
 643   3                  sai[k].glid = HPGP_GLID_SHARED_CSMA;
 644   3                  sai[k].startTime = region[j].startTime;
 645   3                  sai[k].duration = region[j].endTime - region[j].startTime;
 646   3                  k++;
 647   3              }
 648   2              else if (region[j].regionType == REGION_TYPE_LOCAL_CSMA)
 649   2              {
 650   3                  /* it is assumed that the contiguous regions should have
 651   3                   * different region type */
 652   3                  sai[k].stpf = 1;
 653   3                  sai[k].glid = HPGP_GLID_LOCAL_CSMA;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 12  

 654   3                  sai[k].startTime = region[j].startTime;
 655   3                  sai[k].duration = region[j].endTime - region[j].startTime;
 656   3                  k++;
 657   3              }
 658   2              endTime = region[j].endTime;
 659   2              j++;
 660   2          }
 661   1          cnsm->saiTable[schedInd].saiNum = k;
 662   1          cnsm->saiTable[schedInd].pscd = pscd;
 663   1          cnsm->saiTable[schedInd].cscd = cscd;
 664   1      #if 0
              for (j=0; j<k; j++) {
              FM_Printf(FM_HINFO, "CNSM: sai %bu \n", j);
              FM_Printf(FM_HINFO, "stpf %bu, glid %bu, start: 0x%x, duration: 0x%x\n",
              sai[j].stpf, sai[j].glid, sai[j].startTime, sai[j].duration);
              }
              #endif
 671   1      }
 672          
 673          
 674          
 675          
 676          extern u8 gEthMacAddrBrdcast[];
 677          #if 1
 678          
 679          void CNSM_NcoDetected(sCnsm *cnsm, sRxDesc *rxdesc, u8* bcn)
 680          {
 681   1        sBcnHdr *bcnHdr;
 682   1          u8       nbe = 0;
 683   1        sBeHdr *beHdr;
 684   1        u8    macAddr[MAC_ADDR_LEN];
 685   1        u8    *dataptr; 
 686   1      
 687   1        bcnHdr = (sBcnHdr *)bcn;
 688   1                
 689   1        nbe = bcnHdr->nbe;
 690   1        dataptr = bcn + sizeof(sBcnHdr);
 691   1        beHdr = (sBeHdr *) dataptr;
 692   1      
 693   1      
 694   1        //(2) Process Beacon Management Information (BMI)
 695   1        //Note: According to the standard, the BENTRYs within the MBI shall 
 696   1        //be arranged in increasing order of their BEHDR values.
 697   1        while(nbe)
 698   1        { 
 699   2          dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
 700   2          switch (beHdr->beType)
 701   2          { case BEHDR_MAC_ADDR:
 702   3            {
 703   4              memcpy(macAddr, dataptr, 6);
 704   4              break;
 705   4            }
 706   3            default:
 707   3            {
 708   4            }
 709   3          }
 710   2          //move to the next BEHDR
 711   2          dataptr = dataptr + beHdr->beLen; 
 712   2          beHdr = (sBeHdr *) dataptr;
 713   2          nbe--;
 714   2        }
 715   1        
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 13  

 716   1        CNSM_SendMgmtMsg(cnsm, EVENT_TYPE_NN_INL_REQ, rxdesc->snid,
 717   1                bcnHdr->stei, gEthMacAddrBrdcast);
 718   1      
 719   1      }
 720          #endif
 721          
 722          //We split the beacon processing into two parts:
 723          //High priority: those requiring immdiate response
 724          //Low  priority: those tolerating the processing delay .
 725          
 726          u8 CNSM_ProcBcnLow(sCnsm *cnsm, sRxDesc *rxdesc, u8* bcn )
 727          {
 728   1          //eStatus         status = STATUS_FAILURE;
 729   1          sBcnHdr        *bcnHdr = NULL;
 730   1          sBeHdr         *beHdr = NULL;
 731   1        sLinkLayer     *linkLayer = cnsm->linkl;
 732   1          u8              nid7; 
 733   1          u8              bcnsrc = BCN_SRC_UNKNOWN; 
 734   1          u8              reqDiscList = 0;
 735   1          u8              nbe = 0;
 736   1          u8             *dataptr = 0;
 737   1          u8             *macAddr = NULL;
 738   1          sDiscInfoEntry *discInfoEntry = NULL;
 739   1          u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr); 
 740   1          sDiscStaInfoRef discStaInfoRef;
 741   1          sDiscNetInfoRef discNetInfoRef;
 742   1        u8 nid[7];
 743   1          //sBeHdr         *beRef[NELEMENT(] = NULL;
 744   1          //sEvent         *newEvent = NULL;
 745   1          //sHpgpHdr       *hpgpHdr = NULL;
 746   1          sScb           *scb = NULL; 
 747   1          sStaInfo       *staInfo = cnsm->staInfo;
 748   1      
 749   1          /*Compiler warning suppression*/
 750   1          discNetInfoRef = discNetInfoRef;
 751   1          
 752   1          //(1) process the beacon header
 753   1      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
 754   1          bcnHdr = (sBcnHdr *)bcn;
 755   1      
 756   1          nid7 = bcnHdr->nid[NID_LEN-1];
 757   1      
 758   1          bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
 759   1        memcpy(nid, staInfo->nid,NID_LEN);
 760   1          nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
 761   1      
 762   1          if((memcmp(nid, bcnHdr->nid, NID_LEN) == 0))
 763   1          {
 764   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 765   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 766   2              {
 767   3                  //it should not occur
 768   3                  FM_Printf(FM_MMSG|FM_LINFO, "CNSM:<<CENTRAL/PROXY BCN(L)\n");
 769   3                  bcnsrc = BCN_SRC_CCO;
 770   3      
 771   3                  
 772   3            CNSM_NcoDetected(cnsm, rxdesc, bcn);
 773   3        
 774   3            
 775   3                  return bcnsrc; 
 776   3              }
 777   2              else
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 14  

 778   2              {
 779   3      #ifdef P8051
 780   3                  FM_Printf(FM_HINFO, "CNSM:<<DISC BCN(L)tei:%bu\n", bcnHdr->stei);
 781   3      #else
                          FM_Printf(FM_HINFO, "CNSM:<<DISC BCN(L)tei:%d\n", bcnHdr->stei);
              #endif
 784   3                  bcnsrc = BCN_SRC_DISC;
 785   3      #ifdef LG_WAR
                          return bcnsrc;
              #endif
 788   3      
 789   3              }
 790   2          }
 791   1          else
 792   1          {
 793   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
 794   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
 795   2              {
 796   3            sDiscNetInfoRef discNetInfoRef;
 797   3            u8 *dataptr;
 798   3            u8 nbe;     
 799   3            sBeHdr *beHdr;
 800   3                
 801   3            
 802   3            u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);
 803   3            
 804   3      
 805   3            u8 rssi = bcn[PLC_BCNRX_LEN-4-lLen];
 806   3              
 807   3                  bcnsrc = BCN_SRC_OTHER_CCO;   
 808   3      
 809   3            
 810   3            nbe = bcnHdr->nbe;
 811   3            dataptr = bcn + sizeof(sBcnHdr);
 812   3            beHdr = (sBeHdr *) dataptr;
 813   3            discNetInfoRef.nid = bcnHdr->nid; 
 814   3            discNetInfoRef.hybridMode = bcnHdr->nid[NID_LEN]>>6;        
 815   3            discNetInfoRef.snid = rxdesc->snid;
 816   3              discNetInfoRef.rssi = rssi;
 817   3            discNetInfoRef.lqi = bcn[PLC_BCNRX_LEN-3-lLen];
 818   3            discNetInfoRef.netMode = bcnHdr->nm;
 819   3            discNetInfoRef.numBcnSlots = bcnHdr->numslots;
 820   3            discNetInfoRef.slotId = bcnHdr->slotid;
 821   3            discNetInfoRef.slotUsage= bcnHdr->slotusage;                                        
 822   3            
 823   3              while(nbe)
 824   3              {
 825   4                  dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
 826   4                  switch (beHdr->beType)
 827   4                  {            
 828   5                case BEHDR_VENDOR_SPEC:
 829   5                {                           
 830   6                  memcpy(&discNetInfoRef.vendor_ota, (u8*)dataptr, sizeof(svendorOta));
 831   6        //          discNetInfoRef.validVendorOta = 1;      
 832   6                }
 833   5                break;  
 834   5      
 835   5                default:
 836   5                break;
 837   5                  }
 838   4                  dataptr = dataptr +  beHdr->beLen; 
 839   4                  beHdr = (sBeHdr *) dataptr;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 15  

 840   4                  nbe--;        
 841   4              }     
 842   3            SCB_UpdateDiscNetList(cnsm->staInfo->ccoScb, &discNetInfoRef);
 843   3      
 844   3      #if 0 //def MCCO
                  if (!cnsm->isCentralCCo){
                  if (bcnHdr->slotid == cnsm->slotId)
              
                  {
                    sEvent *newEvent;
                    sDiscNetInfo *netInfo;
              
                    netInfo = SCB_GetDiscNetEntry(bcnHdr->nid);
                    if (netInfo)
                    {
                      if ((memcmp(staInfo->nid,bcnHdr->nid, NID_LEN-1) >= 0) &&
                        (netInfo->rssi > HPGP_MCCO_SYNC_BCN_RSSI) &&
                        (netInfo->bcnRxCnt > HPGP_MCCO_SYNC_BCN_CNT))
                      {
                        newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
                        if(newEvent)
                        {
                        newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                        newEvent->eventHdr.type = EVENT_TYPE_RESTART_IND;
              
                          
                          cnsm->slotId = 0;
              
                          CTRLL_ReceiveEvent(linkLayer->eventcookie, newEvent);
                        }
                        else
                        {
                        //FM_Printf(FM_ERROR, "CNAM_ProcEvent:Failed to Restart on Slot Detect \n");
                        }
                      }
                    }
              
                    return bcnsrc;
                  }         
                    
              
                  
                    if(!cnsm->multiCCo)
                    {
                        sDiscNetInfo *netInfo;
                      u8 i = 0;
              
                      if (cnsm->slotId > bcnHdr->slotid )
                      {
                          
                      netInfo = SCB_GetDiscNetEntry(bcnHdr->nid);
              
                      if (netInfo)
                      {
                        if ((netInfo->rssi > HPGP_MCCO_SYNC_BCN_RSSI) &&
                          (netInfo->bcnRxCnt > HPGP_MCCO_SYNC_BCN_CNT))
                        {              
                      
                          sEvent *newEvent;
                          //printf("Found BCCo \n");
                        
                        memset(cnsm->passiveNid, 0x00, NID_LEN);
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 16  

                        
                        gHpgpHalCB.passSnid = 0;                  
              
                    //    HHAL_SetDevMode(DEV_MODE_CCO,  gHpgpHalCB.lineMode);
              
                        HHAL_ClearPassSnid();
              
                        HHAL_SetSnid(staInfo->snid);
              
                        //    CNSM_InitRegion(cnsm);
              
                        LINKL_ClearBcnInit();
              
                        cnsm->netScan = 0;
                        cnsm->netSync = 0;
              
                        gHpgpHalCB.bPerAvgInitDone = 0;
                            
              //          gHpgpHalCB.gFreqCB.freqDetected = 0;
              
              
              
              
                          newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
                          if(newEvent)
                          {
                            newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
              
              
                            newEvent->eventHdr.type = EVENT_TYPE_RESTART_IND;
                                  
                              CNSM_Stop(cnsm);
              
                            CTRLL_ReceiveEvent(linkLayer->eventcookie, newEvent);
              
                          }
                          else
                          {
                            FM_Printf(FM_ERROR, "C:Err\n");
                          }
                        }
              
                      } 
                    }
              
                    }
                  }     
              
              #endif
 951   3            
 952   3                  
 953   3              }
 954   2              else
 955   2              {
 956   3                  bcnsrc = BCN_SRC_OTHER_DISC;
 957   3              }
 958   2          return bcnsrc; // In current implementation firmware knows regions of other CCo so no need to
 959   2          // process Bentry in central BCN of other CCo // Kiran
 960   2          }
 961   1      //    FM_Printf(FM_MINFO, "CNSM: classify CCo %d.\n", bcnsrc);
 962   1      
 963   1                              
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 17  

 964   1          nbe = bcnHdr->nbe;
 965   1          dataptr = bcn + sizeof(sBcnHdr);
 966   1          beHdr = (sBeHdr *) dataptr;
 967   1         
 968   1          //(2) Process Beacon Management Information (BMI)
 969   1          //Note: According to the standard, the BENTRYs within the MBI shall 
 970   1          //be arranged in increasing order of their BEHDR values.
 971   1          while(nbe)
 972   1          { 
 973   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
 974   2              switch (beHdr->beType)
 975   2              {
 976   3                  case BEHDR_REGIONS:
 977   3                  {
 978   4                      u8 nextSchedInd = (cnsm->currSchedInd + 1) & 0x1;
 979   4                      u8 j, k;
 980   4                      u8 regionNum = 0;
 981   4                      sRegionEntry *regionEntry = NULL;
 982   4                      sCsmaRegion *nextRegion = NULL, *currRegion = NULL;
 983   4                      u16 duration, endTime;
 984   4                      if(bcnsrc ==  BCN_SRC_DISC) 
 985   4                      {
 986   5                          break;
 987   5                      }
 988   4      
 989   4                      if (cnsm->updateSched) 
 990   4                      {
 991   5                          /* we are already in an updating process */
 992   5                          break;
 993   5                      }
 994   4       
 995   4                      currRegion = cnsm->regionTable[cnsm->currSchedInd].region;
 996   4                      /* save the region info in the next region */
 997   4                      nextRegion = cnsm->regionTable[nextSchedInd].region;
 998   4                      memset(nextRegion, 0, HPGP_REGION_MAX);
 999   4                      /* NR */
1000   4                      regionNum = *dataptr;
1001   4                      regionEntry  = (sRegionEntry *)(dataptr + 1);
1002   4                      endTime = 0;
1003   4                      j = 0;
1004   4                      k = 0;
1005   4                      /* regions */     
1006   4                      /* assume at present the regions entry will cover the entire 
1007   4                       * beacon period, including the beacon region, which will be 
1008   4                       * specified by a CCO in uncoordinated or coordinated mode.
1009   4                       * but not by a CCO in CSMA-only mode.
1010   4                       */
1011   4                      while((j < regionNum) && (k < HPGP_REGION_MAX))
1012   4                      {
1013   5                          nextRegion[k].startTime = endTime;
1014   5                          endTime = (regionEntry->endTimeHi << 8) |
1015   5                              regionEntry->endTimeLo;
1016   5                          duration = endTime - nextRegion[k].startTime;
1017   5                          if (regionEntry->regionType == REGION_TYPE_BEACON)
1018   5                          {
1019   6                               /* The beacon region should be the first region
1020   6                               * if it exists. 
1021   6                               */
1022   6                              nextRegion[k].regionType = REGION_TYPE_BEACON;
1023   6                              nextRegion[k].endTime = endTime;
1024   6                          }
1025   5                          else if (regionEntry->regionType == REGION_TYPE_SHARED_CSMA)
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 18  

1026   5                          {
1027   6                              /* the shared csma region is either the first or second
1028   6                               * region if the beacon region exists */
1029   6                              if (duration >= (HPGP_REGION_MIN_SHARED_CSMA + 
1030   6                                  HPGP_REGION_MIN_LOCAL_CSMA)) 
1031   6                              {
1032   7                                  /* since the shared csma is large enough, 
1033   7                                   * split it to two regions: 
1034   7                                   * shared csma region and local csma region */
1035   7                                  nextRegion[k].endTime = nextRegion[k].startTime + HPGP_REGION_MIN_SHARED_CSMA;
1036   7                                  nextRegion[k].regionType = REGION_TYPE_SHARED_CSMA;
1037   7                                  k++;
1038   7                                  nextRegion[k].startTime = nextRegion[k-1].startTime + HPGP_REGION_MIN_SHARED_C
             -SMA;
1039   7                                  nextRegion[k].endTime = nextRegion[k].startTime + (duration - HPGP_REGION_MIN_
             -SHARED_CSMA);
1040   7                                  nextRegion[k].regionType = REGION_TYPE_LOCAL_CSMA;
1041   7                              }
1042   6                              else
1043   6                              {
1044   7                                  nextRegion[k].regionType = REGION_TYPE_SHARED_CSMA;
1045   7                                  //nextRegion[k].endTime = nextRegion[k].startTime + duration;
1046   7                              }
1047   6                          }
1048   5                          else
1049   5                          {
1050   6                              /* to provide passive coordination to a CCO 
1051   6                               * in coordinated mode, specify a Stayout region 
1052   6                               * in all regions other than CSMA regions */
1053   6                              nextRegion[k].regionType = REGION_TYPE_STAYOUT;
1054   6                              nextRegion[k].endTime = nextRegion[k].startTime + duration;
1055   6                          }
1056   5                          k++;
1057   5                          j++;
1058   5                          regionEntry++;        
1059   5                      }
1060   4                      cnsm->regionTable[nextSchedInd].regionNum = k;
1061   4                      /* check if the recevied region is different 
1062   4                       * from the current region */
1063   4                      for (j=0; j< k; j++)
1064   4                      {
1065   5                          if ((nextRegion[j].regionType != currRegion[j].regionType) || 
1066   5                              (nextRegion[j].startTime != currRegion[j].startTime) || 
1067   5                              (nextRegion[j].endTime != currRegion[j].endTime) )
1068   5                          {
1069   6                              cnsm->updateSched = 1;
1070   6                              break;
1071   6                          }
1072   5                      }
1073   4                      if (cnsm->updateSched)
1074   4                      {
1075   5                          /* update the next sai table */
1076   5                          CNSM_UpdateSched(cnsm, nextSchedInd, 5, 4);
1077   5                      }
1078   4                      break;
1079   4                  }
1080   3                  case BEHDR_MAC_ADDR:
1081   3                  {
1082   4                      macAddr = dataptr;
1083   4                      break;
1084   4                  }
1085   3                  case BEHDR_DISCOVER:
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 19  

1086   3                  {
1087   4                      break;
1088   4                  }
1089   3                  case BEHDR_DISC_INFO:
1090   3                  {
1091   4                      discInfoEntry = (sDiscInfoEntry *)dataptr;
1092   4                      discStaInfoRef.discInfo = (sDiscInfoEntry *)dataptr;
1093   4                      if (macAddr)
1094   4                      {
1095   5                          discStaInfoRef.macAddr = macAddr;
1096   5                discStaInfoRef.tei = bcnHdr->stei;
1097   5      #ifdef MCCO
1098   5                discStaInfoRef.slotId = bcnHdr->slotid;
1099   5                discStaInfoRef.slotUsage = bcnHdr->slotusage;         
1100   5      #endif
1101   5      
1102   5                          discStaInfoRef.snid = rxdesc->snid;
1103   5                          if( bcnsrc == BCN_SRC_DISC)
1104   5                          {
1105   6                              discStaInfoRef.sameNet = 1;
1106   6                          }
1107   5                          else //am I interested in other discovery beacons here?
1108   5                          {
1109   6                              discStaInfoRef.sameNet = 0;
1110   6                          }
1111   5      
1112   5                          //update the discovred STA list
1113   5                          SCB_UpdateDiscStaList(cnsm->staInfo->ccoScb, &discStaInfoRef);
1114   5                          
1115   5      #ifdef ROUTE
                                  scb = CRM_GetScb(cnsm->crm, bcnHdr->stei);
                                  if(scb)
                                  {
                                      if(scb->lrtEntry.nTei != scb->tei)
                                      {
                                          scb->lrtEntry.nTei = scb->tei;
                                          scb->lrtEntry.rnh = 0;
                                      }
                                  }
              #endif
1126   5                      }
1127   4                      
1128   4                      scb = CRM_GetScb(cnsm->crm, bcnHdr->stei);
1129   4                      if( memcmp(macAddr, scb->macAddr, MAC_ADDR_LEN) )
1130   4                      {
1131   5      #ifndef RELEASE
1132   5                          FM_Printf(FM_WARN, "CNSM:TEI MAC not matched in Disc BCN\n");
1133   5      #endif
1134   5                          break;
1135   5                      }
1136   4                      if(scb)
1137   4                      {
1138   5                        sLinkLayer *linkl = (sLinkLayer*)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1139   5                
1140   5                          //update the discovery info for the sta
1141   5                          scb->staCap.byte = discInfoEntry->staCap.byte; 
1142   5                          scb->staStatus = discInfoEntry->staStatus; 
1143   5      
1144   5                          //scb->numDiscSta = discInfoEntry->numDiscSta; 
1145   5                          //scb->numDiscNet = discInfoEntry->numDiscNet;  
1146   5                          //scb = CRM_GetScb(cnsm->crm, bcnHdr->stei);
1147   5      
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 20  

1148   5                
1149   5                if(!linkl->ccoNam.backupCCoCfg.scb)
1150   5                  {
1151   6                    CNAM_SelectBackupCCo(&linkl->ccoNam, NULL);
1152   6                  }
1153   5                
1154   5                          if(discInfoEntry->staCap.fields.update)
1155   5                          {
1156   6                              reqDiscList = 1;
1157   6                              //send the CC_DISCOVER_LIST.REQ 
1158   6                              //to query the discovered sta/network list
1159   6                              //for the topology table
1160   6                              CNSM_SendMgmtMsg(cnsm, EVENT_TYPE_CC_DISCOVER_LIST_REQ,
1161   6                                               staInfo->snid, scb->tei, scb->macAddr);
1162   6      /*
1163   6                              newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 
1164   6                                                     EVENT_HPGP_MSG_HEADROOM);
1165   6                              if(newEvent == NULL)
1166   6                              {
1167   6                                  FM_Printf(FM_ERROR, "Cannot allocate an event.\n");
1168   6                                  break;
1169   6                              }
1170   6                              newEvent->eventHdr.eventClass = EVENT_CLASS_MSG;
1171   6                              newEvent->eventHdr.type = EVENT_TYPE_CC_DISCOVER_LIST_REQ;
1172   6      //                        newEvent->eventHdr.tei = event->eventHdr.tei;
1173   6                              hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
1174   6                              hpgpHdr->tei = bcnHdr->stei; 
1175   6                              hpgpHdr->macAddr = scb->macAddr;
1176   6                             
1177   6                    FM_Printf(FM_MMSG, "CNSM: >>> CC_DISCOVER_LIST.REQ (tei: %d).\n",
1178   6                                        hpgpHdr->tei);
1179   6                              //transmit CM_UNASSOCIATED_STA_IND in the MNBC
1180   6                              status = MUXL_TransmitMgmtMsg(newEvent);
1181   6                              //the event is freed by MUXL if the TX is successful
1182   6                              if(status == STATUS_FAILURE)
1183   6                              {
1184   6                                  EVENT_Free(newEvent);
1185   6                              }
1186   6      */
1187   6                          }
1188   5      
1189   5                      }
1190   4                      break;
1191   4                  }
1192   3                  case BEHDR_ENCRYP_KEY_CHANGE:
1193   3                  {
1194   4                      break;
1195   4                  }
1196   3                  case BEHDR_CCO_HANDOVER:
1197   3                  {
1198   4                      break;
1199   4                  }
1200   3                  case BEHDR_BCN_RELOC:
1201   3                  {
1202   4                      break;
1203   4                  }
1204   3                  case BEHDR_ACL_SYNC_CNTDOWN:
1205   3                  {
1206   4                      break;
1207   4                  }
1208   3                  case BEHDR_CHANGE_NUM_SLOTS:
1209   3                  {
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 21  

1210   4                      break;
1211   4                  }
1212   3                  case BEHDR_CHANGE_HM:
1213   3                  {
1214   4                      break;
1215   4                  }
1216   3                  case BEHDR_CHANGE_SNID:
1217   3                  {
1218   4                      break;
1219   4                  }
1220   3                  default:
1221   3                  {
1222   4                  }
1223   3              }
1224   2              //move to the next BEHDR
1225   2              dataptr = dataptr + beHdr->beLen; 
1226   2              beHdr = (sBeHdr *) dataptr;
1227   2              nbe--;
1228   2          }
1229   1      
1230   1      
1231   1          return bcnsrc; 
1232   1      }
1233          
1234          void CNSM_ProcBcnHigh(sCnsm *cnsm, u8* bcn, u32 bts )
1235          {
1236   1          sBcnHdr        *bcnHdr = NULL;
1237   1          sBeHdr         *beHdr = NULL;
1238   1          u8              nid7; 
1239   1          u8              bcnsrc = BCN_SRC_UNKNOWN; 
1240   1          u8              nbe = 0;
1241   1          u8             *dataptr = 0;
1242   1      
1243   1          sStaInfo       *staInfo = cnsm->staInfo;
1244   1        
1245   1          /*Compiler warning suppression*/
1246   1          bts = bts;
1247   1        
1248   1          //(1) process the beacon header
1249   1      //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
1250   1          bcnHdr = (sBcnHdr *)bcn;
1251   1      
1252   1          nid7 = bcnHdr->nid[NID_LEN-1];
1253   1      
1254   1          bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
1255   1      
1256   1          if((memcmp(staInfo->nid, bcnHdr->nid, NID_LEN) == 0))
1257   1          {
1258   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1259   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
1260   2              {
1261   3                  //it should not occur
1262   3      #ifdef NSM_CCO_PRINT      
                          FM_Printf(FM_MMSG|FM_LINFO, "CNSM:<<<CENTRAL/PROXY BCN(H)\n");
              #endif      
1265   3                  bcnsrc = BCN_SRC_CCO;
1266   3      #ifdef BCN_ERR
1267   3                  bpstoFound = TRUE;
1268   3      #endif
1269   3      
1270   3                  return; 
1271   3              }
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 22  

1272   2              else if(bcnHdr->bt == BEACON_TYPE_DISCOVER)
1273   2              {
1274   3      #ifdef P8051
1275   3                  FM_Printf(FM_HINFO, "CNSM:<<<DISC BCN(H)(tei:%bu)\n", bcnHdr->stei);
1276   3      #else
                          FM_Printf(FM_HINFO, "CNSM:<<<DISC BCN(H)(tei:%d)\n", bcnHdr->stei);
              #endif
1279   3                  bcnsrc = BCN_SRC_DISC;
1280   3      
1281   3      #ifdef LOG_FLASH
                          logEvent(DISC_BCN_LOG,0,0,&bcnHdr->stei,1);
              #endif
1284   3      
1285   3      #ifdef LG_WAR
                          return;
              #endif
1288   3                  
1289   3              }
1290   2          else
1291   2          {
1292   3          //  FM_Printf(FM_ERROR, "CNSM:<<Unknown BCN Rx\n");// Kiran: Remove after testing
1293   3            bcnsrc = BCN_SRC_UNKNOWN;
1294   3            return;
1295   3          }
1296   2          }
1297   1          else
1298   1          {
1299   2              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1300   2                  (bcnHdr->bt == BEACON_TYPE_PROXY))
1301   2              {
1302   3                  bcnsrc = BCN_SRC_OTHER_CCO;
1303   3              }
1304   2              else
1305   2              {
1306   3                  bcnsrc = BCN_SRC_OTHER_DISC;
1307   3              }
1308   2          }
1309   1      
1310   1          bcnHdr->nid[NID_LEN-1] = nid7;
1311   1      
1312   1                              
1313   1          nbe = bcnHdr->nbe;
1314   1          dataptr = bcn + sizeof(sBcnHdr);
1315   1          beHdr = (sBeHdr *) dataptr;
1316   1          
1317   1          //(2) Process Beacon Management Information (BMI)
1318   1          //Note: According to the standard, the BENTRYs within the MBI shall 
1319   1          //be arranged in increasing order of their BEHDR values.
1320   1          while(nbe)
1321   1          { 
1322   2              dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1323   2              switch (beHdr->beType)
1324   2              {
1325   3                  case BEHDR_NON_PERSISTENT_SCHED:
1326   3                  {
1327   4                      //copy 
1328   4                      break;
1329   4                  }
1330   3                  case BEHDR_PERSISTENT_SCHED:
1331   3                  {
1332   4                      break;
1333   4                  }
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 23  

1334   3                  case BEHDR_BPSTO:
1335   3                  {
1336   4                      //set it to MAC
1337   4      #ifdef BCN_ERR
1338   4                      bpstoFound = TRUE;
1339   4      #endif
1340   4      
1341   4                      break;
1342   4                  }
1343   3                  default:
1344   3                  {
1345   4                  }
1346   3              }
1347   2              //move to the next BEHDR
1348   2              dataptr = dataptr + beHdr->beLen; 
1349   2              beHdr = (sBeHdr *) dataptr;
1350   2              nbe--;
1351   2          }
1352   1      
1353   1      }
1354          
1355          void LINKL_CcoProcBcnHandler(void *cookie, sEvent *event, u32 bts)
1356          {
1357   1          sLinkLayer     *linkl = (sLinkLayer *)cookie;
1358   1          sCnsm          *cnsm = (sCnsm *)LINKL_GetCnsm(linkl);
1359   1      
1360   1          CNSM_ProcBcnHigh(cnsm, event->buffDesc.dataptr, bts);
1361   1      }
1362          
1363          #ifdef MCCO
1364          
1365          
1366          void LINKL_PassiveCcoProcBcnHandler(void *cookie, sEvent *event, u32 bts)
1367          {
1368   1          sLinkLayer     *linkl = (sLinkLayer *)cookie;
1369   1          sCnsm          *cnsm = (sCnsm *)LINKL_GetCnsm(linkl);
1370   1        sHpgpHdr     *hpgpHdr = NULL;
1371   1          
1372   1      
1373   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
1374   1      
1375   1          CNSM_ProcPassiveBcnHigh(cnsm, event->buffDesc.dataptr, hpgpHdr->snid, bts);
1376   1      }
1377          
1378          void CNSM_ProcPassiveBcnHigh(sCnsm * cnsm,u8* bcn, u8 snid, u32 bts)
1379          {
1380   1        sBcnHdr      *bcnHdr = NULL;
1381   1        sBeHdr       *beHdr = NULL;
1382   1        sBeHdr       *beHdrRef[NELEMENTS(BeHdrType)];
1383   1        u8        nid7; 
1384   1        u8        bcnsrc = BCN_SRC_UNKNOWN; 
1385   1        u8        nbe = 0;
1386   1        u8         *dataptr = 0;
1387   1        u8        i = 0;
1388   1        u8        j = 0;
1389   1        sStaInfo     *staInfo = NULL;
1390   1        sCsmaRegion    *region = NULL;
1391   1        u8        regionNum = 0;
1392   1        u16       endTime = 0;
1393   1        sRegionEntry   *regionEntry = NULL;
1394   1        sHpgpHalCB *hhalCb = HOMEPLUG_GetHal()->hhalCb;
1395   1          
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 24  

1396   1        staInfo = cnsm->staInfo;
1397   1      
1398   1        // FM_Printf(FM_HINFO, "cnsm: BeHdrType size = %d\n", NELEMENTS(BeHdrType));
1399   1        for(i = 0; i< NELEMENTS(BeHdrType); i++)
1400   1        {
1401   2          beHdrRef[i] = NULL;
1402   2        }
1403   1        //(1) process the beacon header
1404   1        //    bcnHdr = (sBcnHdr *) event->buffDesc.dataptr;
1405   1        bcnHdr = (sBcnHdr *)bcn;
1406   1      
1407   1        nid7 = bcnHdr->nid[NID_LEN-1];
1408   1      
1409   1          
1410   1      
1411   1        bcnHdr->nid[NID_LEN-1] &= NID_EXTRA_BIT_MASK;
1412   1      
1413   1        //FM_Printf(FM_HINFO, "cnsm_ProcBcnHigh\n");
1414   1      
1415   1        
1416   1        if((memcmp(cnsm->passiveNid, bcnHdr->nid, NID_LEN) == 0))
1417   1        {
1418   2          if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1419   2            (bcnHdr->bt == BEACON_TYPE_PROXY))
1420   2          {
1421   3      
1422   3            if (firstTimepCCo) {
1423   4      #ifndef RELEASE
1424   4              printf("got cco\n");
1425   4      #endif
1426   4              cnsm->netScan =  1;
1427   4              HAL_ScanNet(TRUE);
1428   4      
1429   4              firstTimepCCo = 0;
1430   4              }
1431   3      
1432   3            cnsm->noBcn = 0;
1433   3            bcnsrc = BCN_SRC_CCO;
1434   3          }
1435   2          else
1436   2          {
1437   3      
1438   3            bcnsrc = BCN_SRC_DISC;
1439   3      
1440   3          }
1441   2        }
1442   1        else
1443   1        {
1444   2            
1445   2      #ifdef BCN_ERR
1446   2            bpstoFound = TRUE;
1447   2      #endif
1448   2            
1449   2            return; // TODO TBD
1450   2          
1451   2        }
1452   1      
1453   1        bcnHdr->nid[NID_LEN-1] = nid7;
1454   1      
1455   1        if((bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1456   1           (bcnHdr->bt == BEACON_TYPE_DISCOVER))
1457   1        {   
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 25  

1458   2          
1459   2          hhalCb->bcnmisscnt = 0;
1460   2          gCCO_BTS = bts;
1461   2          hhalCb->bts = bts;
1462   2          hhalCb->bcnDetectFlag = 1;
1463   2        }
1464   1      
1465   1      
1466   1      
1467   1        /* see if the beacon region exists */
1468   1        region = cnsm->region;
1469   1        j = 0;
1470   1        if (bcnHdr->numslots)
1471   1        {
1472   2          /* need to include beacon region */
1473   2          region[j].startTime = 0;
1474   2          region[j].endTime = region[j].startTime + (bcnHdr->numslots * HPGP_BEACON_SLOT_ATU);
1475   2          region[j].regionType = REGION_TYPE_BEACON;
1476   2          region[j].rxOnly = 1;
1477   2          j++;
1478   2        }
1479   1                        
1480   1        nbe = bcnHdr->nbe;
1481   1        dataptr = bcn + sizeof(sBcnHdr);
1482   1        beHdr = (sBeHdr *) dataptr;
1483   1      
1484   1        //(2) Process Beacon Management Information (BMI)
1485   1        //Note: According to the standard, the BENTRYs within the MBI shall 
1486   1        //be arranged in increasing order of their BEHDR values.
1487   1      
1488   1        //FM_HexDump(FM_DATA|FM_MINFO, "Rx Bcn:",
1489   1        //           bcn, PLC_BCNRX_LEN);
1490   1        while(nbe)
1491   1        { 
1492   2        dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
1493   2        switch (beHdr->beType)
1494   2        {
1495   3          #if 0
                    case BEHDR_NON_PERSISTENT_SCHED:
                    {
                        beHdrRef[BEHDR_NON_PERSISTENT_SCHED] = beHdr;
                //                bcnRef.nonPersSchedEntry = beHdr;
              
                        break;
                    }
                    case BEHDR_PERSISTENT_SCHED:
                    {
                        sSaiWithSt    *saiwst = NULL;
                        sSaiWithoutSt *saiwost = NULL;
                        u8            *ptr = NULL;
                        u8 ns = 0; 
                        u8 scd = 0;
                        u8 stpf = 0;
                        u16 et = 0;
                        u16 st = 0;
                        u8 cscd;
                        static u8 changeSch = 1;
                        
                        beHdrRef[BEHDR_PERSISTENT_SCHED] = beHdr;
                //                bcnRef.persSchedEntry = beHdr;
              
                        /* schedule count down */
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 26  

                        scd = *dataptr;
                        /* At present, interested in the current schedule only, 
                         * and ignore the preview schedule */ 
                        if (scd & 0x7) 
                        {
                            /* it is a preview schedule */
                            break; 
                        }
                        cscd = ((scd >> 3) & 0x7);
                        
                        if(changeSch == 1)
                        {
                                
                            /* now it is a current schedule */
                            /* NS */
                            ns = *(dataptr + 1);
                            ptr = dataptr + 2;
                            endTime = 0;
                      i = 0;
                            while((j < HPGP_REGION_MAX) && (i < ns))
                            {
                                stpf = *ptr;
                                if (stpf & 0x1) 
                                {
                                    saiwst = (sSaiWithSt *)ptr;
                                    endTime =  (saiwst->etHi << 4) | saiwst->etLo; 
                                    if ( (saiwst->glid == (HPGP_GLID_GPP & 0x7F)) ||
                                         (saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
                                         (saiwst->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
                                    {
                                        st = (saiwst->stHi << 8) | saiwst->stLo;
                                        if(et != st)
                                        {
                                            region[j].startTime =  0;//et;
                                            region[j].endTime = st;
                                            region[j].hybridMd  = 1;
                              region[j].rxOnly = 1;
                                            region[j].regionType = REGION_TYPE_STAYOUT;
              
                                        }
                                        et = endTime;
                                        j++;
                                        region[j].startTime =  0;//st;
                                        region[j].endTime = endTime;// - region[j].startTime;
                                        
                            if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) || 
                                (saiwst->glid == (HPGP_GLID_GPP & 0x7F))) 
                            {
                                region[j].hybridMd  = 1;
                              region[j].rxOnly = 0;
                              region[j].regionType = REGION_TYPE_SHARED_CSMA;
                            }
                            else
                            {
                                region[j].regionType = REGION_TYPE_LOCAL_CSMA;
                                            region[j].hybridMd = 1;
                                            region[j].rxOnly = 0;
                            }                            
                                        j++;
                                    }
                                    ptr += sizeof(sSaiWithSt);
                                }
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 27  

                                else 
                                {
                                    saiwost = (sSaiWithoutSt *)ptr;
                                    if ( (saiwost->glid == (HPGP_GLID_GPP & 0x7F)) ||
                                         (saiwost->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
                                         (saiwost->glid == (HPGP_GLID_LOCAL_CSMA & 0x7F))) 
                                    {
                                        region[j].startTime =  0;//endTime;
                                        endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
                                        region[j].endTime = endTime;// - region[j].startTime;
                            if ((saiwst->glid == (HPGP_GLID_SHARED_CSMA & 0x7F)) ||
                                (saiwost->glid == (HPGP_GLID_GPP & 0x7F))) 
                            {
                                region[j].hybridMd = 1;
                              region[j].rxOnly = 0;
                                    region[j].regionType = REGION_TYPE_SHARED_CSMA;
                            }
                            else
                            {
                                region[j].regionType = REGION_TYPE_LOCAL_CSMA;
                                            region[j].hybridMd = 1;
                                            region[j].rxOnly = 0;
                            }
                                        et = endTime;
                                        j++;
                                    }
                                    else
                                    {
                                        endTime =  (saiwost->etHi << 8) | saiwost->etLo; 
                                        et = endTime;
                                    }
                                    ptr += sizeof(sSaiWithoutSt);
                                }
                                i++;
                            }
                      for (;j < HPGP_REGION_MAX;j++)
                      {
                                region[j].startTime  = 0;//endTime;
                                region[j].rxOnly  = 1;
                                region[j].endTime   = 0xFFF;
                                region[j].hybridMd   = 1;  
                          region[j].regionType = REGION_TYPE_STAYOUT;
                                cnsm->regionNum = j + 1;
                            }
                      //else
                            {
                                cnsm->regionNum = HPGP_REGION_MAX;
                            }
                            //cnsm->regionNum = HPGP_REGION_MAX;
                //#ifdef HPGP_HAL
              //              HHAL_SetCsmaRegions(cnsm->region, cnsm->regionNum);
                            changeSch = 0;
              
                //#endif
                      //      for (j=0; j<cnsm->regionNum; j++) {
                      //          FM_Printf(FM_USER, "cnsm: region %bu, start: 0x%x, endTime: 0x%x rxOnly: %bu\n", 
                      //              j, cnsm->region[j].startTime, cnsm->region[j].endTime, cnsm->region[j].rxOnly);
                      //      }
                        }
                  //      printf("cscd : %bu \n", cscd);
              
                        if(cscd == 0 || cscd == 1) // if we loss bcn (cscd = 0) still it will modify sch
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 28  

                        {
                            changeSch = 1;
                            
                        }
                        break;
                    }
                    case BEHDR_REGIONS:
                    {
                        beHdrRef[BEHDR_REGIONS] = beHdr;
                        //bcnRef.regionEntry = beHdr;
                       // setCSMA_onCCO1();
                        break;
                    }
              
                  #endif
1659   3            case BEHDR_BPSTO:
1660   3            {
1661   4                
1662   4      #ifdef BCN_ERR
1663   4                bpstoFound = TRUE;
1664   4      #endif
1665   4      
1666   4      #ifdef HPGP_HAL
1667   4                /* TODO: perform sync with the any net
1668   4                 * during the network discovery 
1669   4                 */
1670   4                /* set it to MAC */
1671   4            // Process other bcn also to sync network
1672   4              //if((bcnsrc == BCN_SRC_CCO) || (bcnsrc == BCN_SRC_OTHER_CCO))
1673   4              if( (bcnHdr->bt == BEACON_TYPE_CENTRAL)||
1674   4                    (bcnHdr->bt == BEACON_TYPE_PROXY))
1675   4                {
1676   5      
1677   5                    memcpy(cnsm->bpsto, dataptr, 3);
1678   5                    if ( HHAL_SyncNet(cnsm->bpsto) == STATUS_SUCCESS 
1679   5                      && !cnsm->netSync )
1680   5                    {
1681   6                        /* stop scan if it is my network */
1682   6                        //HAL_ScanNet(FALSE);
1683   6                cnsm->netScan =  0;
1684   6      
1685   6                HAL_ScanNet(FALSE);
1686   6      
1687   6                        
1688   6                        cnsm->netSync = TRUE; 
1689   6      #ifndef RELEASE                       
1690   6                        FM_Printf(FM_USER, "cnsm:Setting netSync %bu\n", &cnsm->bpsto[0]);
1691   6      #endif
1692   6      
1693   6                        
1694   6      
1695   6                    }
1696   5                
1697   5                    /*FIXME: Host App should select the network , during scanning.
1698   5                                     Selection could be based on Lqi/Rssi 
1699   5                                     Temporarily the selection is done here */        
1700   5                    if(cnsm->netScan && !hhalCb->nwSelected)
1701   5                    {
1702   6              // TODO FIX THIS
1703   6              
1704   6                        if ((hhalCb->nwSelectedSnid == 0)  || 
1705   6                            (hhalCb->nwSelectedSnid == snid))
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 29  

1706   6                        {
1707   7                            if(hhalCb->halStats.RxGoodBcnCnt >= 
1708   7                      HPGP_MCCO_SYNC_BCN_CNT ) 
1709   7                            {               
1710   8      //                        staInfo->pSnid = snid;
1711   8                                HHAL_SetSnid(snid);
1712   8                                FM_Printf(FM_MINFO, "cnsm:Setting STA Snid %bu\n", snid);                        
             -     
1713   8                            }
1714   7                        }
1715   6                    }
1716   5                    
1717   5      
1718   5                }
1719   4      #endif
1720   4                
1721   4                break;
1722   4            }
1723   3      #if 0   
                    case BEHDR_CCO_HANDOVER:
                    {
                        //FM_Printf(FM_HINFO, "cnsm: CCO HO (H).\n");
                        beHdrRef[BEHDR_CCO_HANDOVER] = beHdr;
                        break;
                    }
                    case BEHDR_BCN_RELOC:
                    {
                        beHdrRef[BEHDR_BCN_RELOC] = beHdr;
                        break;
                    }
                    case BEHDR_CHANGE_NUM_SLOTS:
                    {
                        beHdrRef[BEHDR_CHANGE_NUM_SLOTS] = beHdr;
                        break;
                    }
                    case BEHDR_CHANGE_SNID:
                    {
                        beHdrRef[BEHDR_CHANGE_SNID] = beHdr;
                        break;
                    }
                    case BEHDR_MAC_ADDR:
                    {
              #if 0       
                        u8 *macAddr;
                        macAddr = dataptr;
                        if( (bcnsrc == BCN_SRC_CCO)&& staInfo->ccoScb != NULL &&
                            (memcmp(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN)) )
                        {                    
                            memcpy(staInfo->ccoScb->macAddr, macAddr, MAC_ADDR_LEN);
                        }
              #endif               
                        break;
                    }
              #endif
1759   3      
1760   3            default:
1761   3            {
1762   4            }
1763   3        }
1764   2        //move to the next BEHDR
1765   2        dataptr = dataptr + beHdr->beLen; 
1766   2        beHdr = (sBeHdr *) dataptr;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 30  

1767   2        nbe--;
1768   2        }
1769   1      
1770   1      
1771   1      
1772   1      }
1773          
1774          #endif
1775          #ifdef HOM
              void CNSM_PerformAutoCcoSelection(sCnsm *cnsm)
              {
                  sScb        *scbIter = NULL;
                  sScb        *scb = NULL;
                  sEvent      *newEvent = NULL;
                  u8          ccoCap = 0;
                  u8          staCap = 0;
                  sHpgpHdr   *hpgpHdr = NULL;
              //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                  sLinkLayer *linkl = cnsm->linkl;
                  sStaInfo   *staInfo = LINKL_GetStaInfo(linkl);
                  
              
                  ccoCap = staInfo->ccoScb->staCap.fields.ccoCap;
                  //FM_Printf(FM_ERROR, "CNSM: CCO Cap: %d.\n", ccoCap);
                  
                  scbIter = CRM_GetNextScb(cnsm->crm, scbIter);
                  while(scbIter)
                  {
                     staCap = scbIter->staCap.fields.ccoCap;
                     //FM_Printf(FM_ERROR, "CNSM: TEI: %bu. CCo Cap: %bu.\n", scbIter->tei, staCap); 
              //        if(ccoCap < scbIter->staCap.fields.ccoCap) 
                      if(ccoCap < staCap) 
                      {
                         
                           ccoCap = staCap;
              //           ccoCap = scbIter->staCap.fields.ccoCap;  
                         scb = scbIter;
                      }
                      scbIter = CRM_GetNextScb(cnsm->crm, scbIter);
                  }
              
                  if(scb)
                  {
                      //send an indication
                      newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, EVENT_HPGP_CTRL_HEADROOM);
                      if(newEvent == NULL)
                      {
                          FM_Printf(FM_ERROR, "EAF\n");
                          return ;
                      }
                      newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
                      newEvent->eventHdr.type = EVENT_TYPE_CCO_SELECT_IND;
              
                      hpgpHdr = (sHpgpHdr *)newEvent->buffDesc.buff;
                      hpgpHdr->scb = scb;
              //FM_Printf(FM_ERROR, "CNSM: send a cco selected ind.\n"); 
                      //LINKL_SendEvent(linkl, newEvent);
                      SLIST_Put(&linkl->intEventQueue, &newEvent->link);
                  }
                  return;
              }
              #endif
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 31  

1829          #ifdef MCCO
1830          #define CSMA_SLOT_ID 4 // Kiran
1831          #endif
1832          
1833          eStatus CNSM_InitRegion(sCnsm *cnsm)
1834          {
1835   1          sCsmaRegion *region = NULL;
1836   1          u16 *pRegion;
1837   1      #ifdef MCCO 
1838   1        u8 region_index; //Kiran
1839   1      #endif  
1840   1          /* initial regsions */
1841   1          cnsm->currSchedInd = 0;
1842   1          region = cnsm->regionTable[0].region;
1843   1          memset(region, 0, HPGP_REGION_MAX);
1844   1          if(gHpgpHalCB.lineFreq == FREQUENCY_50HZ)
1845   1          {
1846   2      #ifdef MCCO    
1847   2              pRegion = &CSMA_REGIONS_50Hz_MN[0];
1848   2      #else
                  pRegion = &CSMA_REGIONS_50Hz[0];
              #endif
1851   2          }
1852   1          else
1853   1          {
1854   2      #ifdef MCCO    
1855   2              pRegion = &CSMA_REGIONS_60Hz_MN[0];
1856   2      #else
                  pRegion = &CSMA_REGIONS_60Hz[0];
              #endif
1859   2          }
1860   1      
1861   1      #if 1
1862   1        
1863   1      #ifdef MCCO
1864   1        //printf("config slot id %bu\n",cnsm->slotId);
1865   1      
1866   1          for(region_index = 0; region_index < HYBRII_MAXSMAREGION_CNT; region_index++ )
1867   1        {
1868   2          region[region_index].startTime = ((region_index == 0) ? 0x00:pRegion[region_index-1]);
1869   2          region[region_index].endTime = pRegion[region_index];
1870   2          
1871   2          if(cnsm->slotId == region_index)
1872   2          {
1873   3            region[region_index].regionType = REGION_TYPE_BEACON; //REGION_TYPE_SHARED_CSMA;
1874   3            region[region_index].rxOnly = 0;
1875   3          }
1876   2          else if(region_index == CSMA_SLOT_ID)
1877   2          {
1878   3            region[region_index].regionType = REGION_TYPE_LOCAL_CSMA;
1879   3            region[region_index].rxOnly = 0;
1880   3          }
1881   2          else
1882   2          {
1883   3            region[region_index].regionType = REGION_TYPE_STAYOUT;
1884   3            region[region_index].rxOnly = 1;
1885   3          }
1886   2          
1887   2            region[region_index].hybridMd  = 1;
1888   2        }
1889   1      #else
                region[0].startTime = 0x0;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 32  

                      region[0].endTime = pRegion[0];
                      region[0].regionType = REGION_TYPE_BEACON; //REGION_TYPE_SHARED_CSMA;
                      region[0].rxOnly = 0;
                      region[0].hybridMd  = 1;
                      region[1].startTime = pRegion[0];
                      region[1].endTime  = pRegion[1];
                      region[1].rxOnly  = 0;
                      region[1].regionType = REGION_TYPE_LOCAL_CSMA;
                      region[1].hybridMd   = 1;        
                      
                      region[2].startTime = pRegion[1];
                      region[2].endTime  = pRegion[2];
                      region[2].rxOnly  = 1;
                      region[2].regionType = REGION_TYPE_STAYOUT;
                      region[2].hybridMd   = 1;
                      region[3].startTime = pRegion[2];
                      region[3].endTime  = pRegion[3];
                      region[3].rxOnly  = 1;
                      region[3].regionType = REGION_TYPE_STAYOUT;
                      region[3].hybridMd   = 1;
                      region[4].startTime = pRegion[3];
                      region[4].endTime  = pRegion[4];
                      region[4].rxOnly  = 1;
                      region[4].regionType = REGION_TYPE_STAYOUT;
                      region[4].hybridMd   = 1;
                      region[5].startTime = pRegion[4];
                      region[5].endTime  = pRegion[5];
                      region[5].rxOnly  = 1;
                      region[5].regionType = REGION_TYPE_STAYOUT;
                      region[5].hybridMd   = 1;
              #endif
1922   1      #if 0
                  else
                  {
                      region[0].endTime = 0xCA;// 0x2FF; /* in ATU  ( usec) */
                      region[0].regionType = REGION_TYPE_BEACON; //REGION_TYPE_SHARED_CSMA;
                      region[0].rxOnly = 0;
                      region[0].hybridMd  = 1;
                      region[1].startTime = 0xCA;
                      region[1].endTime  = 0xAF0;
                      region[1].rxOnly  = 0;
                      region[1].regionType = REGION_TYPE_LOCAL_CSMA;
                      region[1].hybridMd   = 1;
                      region[2].startTime = 0xAF0;
                      region[2].endTime  = endOfRegion;//0xD75;
                      region[2].rxOnly  = 1;
                      region[2].regionType = REGION_TYPE_STAYOUT;
                      region[2].hybridMd   = 1;
                      region[3].startTime = endOfRegion;//0xD75;
                      region[3].endTime  = endOfRegion;//0xD75;
                      region[3].rxOnly  = 1;
                      region[3].regionType = REGION_TYPE_STAYOUT;
                      region[3].hybridMd   = 1;
                      region[4].startTime = endOfRegion;//0xD75; /* 0x2FF + 0x6A1 */
                      region[4].endTime  = endOfRegion;//0xD75;
                      region[4].rxOnly  = 1;
                      region[4].regionType = REGION_TYPE_STAYOUT;
                      region[4].hybridMd   = 1;
                      region[5].startTime = endOfRegion;//0xD75; /* 0x2FF + 0x6A1 */
                      region[5].endTime  = endOfRegion;//0xD75;
                      region[5].rxOnly  = 1;
                      region[5].regionType = REGION_TYPE_STAYOUT;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 33  

                      region[5].hybridMd   = 1;
                  }
              #endif
1956   1          cnsm->regionTable[0].regionNum = 6;
1957   1      #else
                  region[0].endTime = 0xA00; /* in ATU */
                  region[0].regionType = REGION_TYPE_SHARED_CSMA;
                  cnsm->regionTable[0].regionNum = 1;
              #endif  
1962   1          CNSM_UpdateSched(cnsm, cnsm->currSchedInd, 0, 4);
1963   1          cnsm->updateSched = 0;
1964   1          HHAL_SetCsmaRegions(cnsm->regionTable[0].region, 
1965   1              cnsm->regionTable[0].regionNum);
1966   1        return STATUS_SUCCESS;
1967   1      }
1968          //Start CCo mode
1969          eStatus CNSM_Start(sCnsm *cnsm, u8 ccoType)
1970          {
1971   1          sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
1972   1          sEvent *event = NULL;
1973   1          u8 *pos = NULL;
1974   1          static u8 regionInitFlag = 1;
1975   1      
1976   1          /* Complier warning suppression */
1977   1          cnsm = cnsm;
1978   1          regionInitFlag = regionInitFlag;
1979   1        
1980   1      #if 0 //ndef MCCO
              
                  if(regionInitFlag == 1)
                  {
                      CNSM_InitRegion(cnsm);
                      regionInitFlag = 0;
                  }
              #endif  
1988   1      
1989   1          event = EVENT_Alloc(1, EVENT_HPGP_CTRL_HEADROOM);
1990   1          if(event == NULL)
1991   1          {
1992   2              FM_Printf(FM_ERROR, "EAF\n");
1993   2              return STATUS_FAILURE;
1994   2          }
1995   1          
1996   1          event->eventHdr.eventClass = EVENT_CLASS_CTRL;
1997   1          event->eventHdr.type = EVENT_TYPE_CNSM_START;
1998   1          pos = event->buffDesc.dataptr;
1999   1          *pos = ccoType; 
2000   1       
2001   1          event->buffDesc.datalen = 1;
2002   1      #ifdef NSM_CCO_PRINT  
                FM_Printf(FM_ERROR, "CNSM:Start(%bu)\n", ccoType);
              #endif  
2005   1          LINKL_SendEvent(linkl, event);
2006   1          return STATUS_SUCCESS;
2007   1      }
2008          
2009          extern u8 zctrack;
2010          
2011          void CNSM_PostStop(sCnsm *cnsm)
2012          {
2013   1      #ifdef MCCO
2014   1        cnsm->multiCCo = 0;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 34  

2015   1        cnsm->netSync = 0;
2016   1        cnsm->netScan = 0;  
2017   1      
2018   1        gHpgpHalCB.nwSelectedSnid = 0;
2019   1        gHpgpHalCB.bPerAvgInitDone = 0;
2020   1      
2021   1        gHpgpHalCB.nwSelected = 0;
2022   1      
2023   1        cnsm->staInfo->numDiscNet = 0;
2024   1      
2025   1      
2026   1      #ifdef FREQ_DETECT                
2027   1        gHpgpHalCB.gFreqCB.freqDetected = 0;
2028   1      #endif
2029   1      
2030   1        gHpgpHalCB.halStats.BcnSyncCnt = 0;
2031   1      
2032   1        gHpgpHalCB.syncComplete = 0;
2033   1        STM_StopTimer(cnsm->bbtTimer);   
2034   1        STM_StopTimer(cnsm->bcnLossTimer); 
2035   1      
2036   1      /// memset((u8*)&cnsm->avlnInfo, 0x00, sizeof(cnsm->avlnInfo));
2037   1      #endif
2038   1      
2039   1        zctrack = 0;
2040   1      
2041   1      }
2042          void CNSM_Stop(sCnsm *cnsm)
2043          {
2044   1          cnsm->hoCntDown = HPGP_HO_COUNTDOWN_MAX;
2045   1          cnsm->hoEnabled = 0;
2046   1          cnsm->hoReady = 0;
2047   1          cnsm->nctei = 0;
2048   1      
2049   1          cnsm->state = CNSM_STATE_INIT;
2050   1        
2051   1        
2052   1          STM_StopTimer(cnsm->discTimer);   
2053   1          STM_StopTimer(cnsm->discAgingTimer);   
2054   1      #ifdef SIMU
                  STM_StopTimer(cnsm->bcnTimer);   
              #else
2057   1          //disable the MAC HW to transmit the beacon
2058   1      #endif
2059   1      
2060   1        STM_StopTimer(cnsm->bbtTimer);
2061   1      
2062   1      
2063   1      }
2064          
2065          u8 CNSM_QueryAnyAlvn(sCnsm *cnsm)
2066          {
2067   1          if(cnsm->staInfo->numDiscNet)
2068   1          {
2069   2              return TRUE;
2070   2          }
2071   1          else
2072   1          {
2073   2              return FALSE;
2074   2          }
2075   1      }
2076          
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 35  

2077          
2078          #ifdef HOM
              void CNSM_EnableHo(sCnsm *cnsm, u8 enable)
              {
                  cnsm->hoEnabled = enable;
              }
              
              
              void CNSM_StartHo(sCnsm *cnsm, u8 nctei)
              {   
                  cnsm->hoReady = 1;
                  cnsm->nctei = nctei;
              }
              
              #endif
2092          void CNSM_UpdateDiscBcnSched(sCnsm *cnsm, sScb *scb)
2093          {
2094   1        /*Compiler warning suppression*/
2095   1        cnsm = cnsm;
2096   1        scb = scb;
2097   1        
2098   1        return;
2099   1        #if 0
                  if(cnsm->discScb == scb)
                  {
                      cnsm->discScb = CRM_GetNextScb(cnsm->crm, cnsm->discScb);
                  }
                #endif
2105   1      
2106   1      }
2107          
2108          #endif /* CCO_FUNC */
2109          
2110          #if 0
              //beacon entry header type
              u8 BeHdrType[] =
              {
                  BEHDR_NON_PERSISTENT_SCHED,    //0x00   //Non-Persistent Schedule
                  BEHDR_PERSISTENT_SCHED,        //0x01   //Current Persistent Schedule
                  BEHDR_PERSISTENT_SCHED,        //0x01   //Preview Persistent Schedule
                  BEHDR_REGIONS,                 //0x02   //region Schedule
                  BEHDR_MAC_ADDR,                //0x03   //MAC Address
                  BEHDR_DISCOVER,                //0x04   //Discover
                  BEHDR_DISC_INFO,               //0x05   //Discovered Info
                  BEHDR_BPSTO,                   //0x06   //Beacon Period Start Time Offset
                  BEHDR_ENCRYP_KEY_CHANGE,       //0x07   //Encryption Key Change
                  BEHDR_CCO_HANDOVER,            //0x08   //CCo Handover
                  BEHDR_BCN_RELOC,               //0x09   //Beacon Relocation
                  BEHDR_ACL_SYNC_CNTDOWN,        //0x0A   //AC Line Sync Countdown
                  BEHDR_CHANGE_NUM_SLOTS,        //0x0B   //Change NumSlots
                  BEHDR_CHANGE_HM,               //0x0C   //Change Hybrid Mode
                  BEHDR_CHANGE_SNID,             //0x0D   //Change SNID
                  BEHDR_RSN_INFO,                //0x0E   //RSN Info Element
                  BEHDR_ISP,                     //0x0F   //ISP BENTRY
                  BEHDR_EXT_BAND_STAY_OUT,       //0x10   //Extended Band Stay Out
                  BEHDR_AG_ASSIGN,               //0x11   //AG Assignment
                  BEHDR_EXT_CARR_SUPPORT,        //0x12   //Extended Carriers Support
                  BEHDR_PWR_SAVE,                //0x13   //Power Save BENTRY
                  BEHDR_VENDOR_SPEC,             //0xFF   //Vendor Specific
              };
              
              //Maximum size allowed for each entry corresponding to BeHdrType[]
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 36  

              u8 BeLenMax[] =
              {
                  sizeof(sBcnHdr) + 2 + 16,     //non-persistent: 4 SAIs (4 octets per SAI)
                  sizeof(sBcnHdr) + 2 + 16,     //current persistent: 4 SAIs (4 octets per SAI)
                  sizeof(sBcnHdr) + 2 + 16,     //preview persistent: 4 SAIs (4 octets per SAI)
                  sizeof(sBcnHdr) + 1 + 8,      //region: 4 regions
                  sizeof(sBcnHdr) + MAC_ADDR_LEN,  //MAC Address
                  sizeof(sBcnHdr) + 1,             //Discover
                  sizeof(sBcnHdr) + sizeof(sDiscInfoEntry),   //Discovered Info
                  sizeof(sBcnHdr) + 3,            //Beacon Period Start Time Offset
                  sizeof(sBcnHdr) + sizeof(sEncrypKeyChangeEntry),  //Encryption Key Change
                  sizeof(sBcnHdr) + sizeof(sCcoHoEntry),      //CCo Handover
                  sizeof(sBcnHdr) + sizeof(sBcnRelocEntry),   //Beacon Relocation
                  sizeof(sBcnHdr) + sizeof(sAclSyncCntDownEntry),  //AC Line Sync Countdown
                  sizeof(sBcnHdr) + sizeof(sChangeNumSlotsEntry),  //Change NumSlots
                  sizeof(sBcnHdr) + sizeof(sChangeHmEntry),        //Change Hybrid Mode
                  sizeof(sBcnHdr) + sizeof(sChangeSnidEntry),      //Change SNID
                  0,                             //RSN Info Element
                  0,                             //ISP BENTRY
                  0,                             //Extended Band Stay Out
                  0,                             //AG Assignment
                  0,                             //Extended Carriers Support
                  sizeof(sBcnHdr) + 12,          //Power Save BENTRY: 8 stations
                  0,                             //Vendor Specific
              };
              #else
2165          extern u8 BeHdrType[];
2166          extern u8 BeLenMax[];
2167          #endif
2168          
2169          
2170          #ifdef CCO_FUNC
2171          
2172          eStatus CNSM_BcnUpdateActive(sCnsm *cnsm)
2173          {
2174   1      
2175   1          return (cnsm->bcnUpdateProgress);
2176   1          
2177   1      }
2178          eStatus CNSM_BuildBeacon(sCnsm *cnsm, u8 bcnType)
2179          {
2180   1          sBcnHdr        *bcnHdr = NULL;
2181   1          sBeHdr         *beHdr = NULL;
2182   1          u8              bcnLen = 0;
2183   1          u8              beLen = 0;
2184   1          u8             *dataptr = NULL;
2185   1      //    u8             *nbe = NULL; //number of beacon entries
2186   1          u8              offset = 0; 
2187   1          u8              i;
2188   1          u8              done = 0;
2189   1          sDiscInfoEntry *discInfoEntry = NULL;
2190   1          sCcoHoEntry    *ccoHo = NULL;
2191   1          sRegionEntry   *regionEntry = NULL;
2192   1          u16             endTime = 0;
2193   1          u8              schedInd = cnsm->currSchedInd;
2194   1      //    sLinkLayer     *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2195   1          sLinkLayer     *linkl = cnsm->linkl;
2196   1          sStaInfo       *staInfo = LINKL_GetStaInfo(linkl);
2197   1      
2198   1      #ifdef NSM_CCO_PRINT
                  FM_Printf(FM_LINFO, "CNSM:Build a BCN payload\n");
              #endif
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 37  

2201   1          memset(cnsm->bcnBuff, 0, BEACON_BUFF_LEN);
2202   1      
2203   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
2206   1          offset = sizeof(sFrmCtrlBlk);
2207   1      #endif
2208   1          /* build a beacon payload */
2209   1          bcnHdr = (sBcnHdr *)(cnsm->bcnBuff + offset);
2210   1      
2211   1          //build beacon header
2212   1          memcpy(bcnHdr->nid, staInfo->nid, NID_LEN);
2213   1          bcnHdr->nid[NID_LEN-1] = (bcnHdr->nid[NID_LEN-1]&NID_EXTRA_BIT_MASK)|(staInfo->hm <<6);
2214   1          bcnHdr->stei = staInfo->ccoScb->tei;
2215   1          bcnHdr->bt = bcnType;
2216   1          bcnHdr->ncnr = 0;
2217   1          bcnHdr->npsm = 0;
2218   1          bcnHdr->numslots = 0;
2219   1      
2220   1          bcnHdr->ccocap = staInfo->ccoScb->staCap.fields.ccoCap;
2221   1      #ifdef MCCO
2222   1        if(bcnType == BEACON_TYPE_CENTRAL)
2223   1        {
2224   2          bcnHdr->slotid = cnsm->slotId;
2225   2      
2226   2          bcnHdr->slotusage = staInfo->slotUsage;
2227   2            
2228   2        }
2229   1      #endif  
2230   1          if ( (bcnType == BEACON_TYPE_CENTRAL)&&
2231   1               (cnsm->hoEnabled))
2232   1          {
2233   2              bcnHdr->hoip = 1;
2234   2          }
2235   1          else
2236   1          {
2237   2              bcnHdr->hoip = 0;
2238   2          }
2239   1               
2240   1      
2241   1          bcnLen = sizeof(sBcnHdr);    //13 bytes, including nbe
2242   1      
2243   1      //    nbe = (u8 *)bcnHdr + sizeof(sBcnHdr);
2244   1          dataptr = (u8 *)bcnHdr + sizeof(sBcnHdr);
2245   1          //prepare the Beacon entries  
2246   1      //    dataptr = nbe;
2247   1      //    dataptr++;
2248   1      //    bcnLen += 1;                 //1 byte 
2249   1      
2250   1         
2251   1          i = 0;
2252   1          done = 0;
2253   1          beHdr = (sBeHdr *)dataptr;
2254   1          bcnHdr->nbe = 0;
2255   1          while((!done) && ((offset + bcnLen + BeLenMax[i]) <= BEACON_PAYLOAD_SIZE))
2256   1          {
2257   2              beLen = 0;
2258   2              switch(BeHdrType[i])
2259   2              {
2260   3                  case BEHDR_NON_PERSISTENT_SCHED:
2261   3                  {
2262   4                      //build non-persistent schedule entry
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 38  

2263   4                      beHdr->beType = BEHDR_NON_PERSISTENT_SCHED;
2264   4                      //dataptr += sizeof(sBeHdr); 
2265   4                      break;
2266   4                  }
2267   3                  case BEHDR_PERSISTENT_SCHED:
2268   3                  {
2269   4                      /* this case may run twice: */
2270   4                      /* one for current schedule, the other for the future */
2271   4                     
2272   4                      u8 j;
2273   4                      sSaiWithSt    *saiwst = NULL;
2274   4                      sSaiWithoutSt *saiwost = NULL;
2275   4                      u8            *ptr = NULL;
2276   4                      sSai          *sai = NULL;
2277   4                      u8            saiNum;
2278   4                      u8            scd;
2279   4                      
2280   4                      /* build a persistent schedule entry */
2281   4                      beHdr->beType = BEHDR_PERSISTENT_SCHED;
2282   4                      /* schedule count down */
2283   4                      if (schedInd == cnsm->currSchedInd)
2284   4                      {
2285   5                          /* the first persistent schedule 
2286   5                           * for the current schedule */
2287   5                          if (cnsm->updateSched)
2288   5                          {
2289   6                              /* CSCD counts down */
2290   6                              cnsm->saiTable[schedInd].cscd--;
2291   6                          }
2292   5                      } 
2293   4                      else if (cnsm->updateSched)
2294   4                      {
2295   5                          /* the second persistent schedule 
2296   5                           * for the future/preview schedule */
2297   5                          if (cnsm->saiTable[schedInd].pscd == 0)
2298   5                          {
2299   6                              /* switch to the preview scheduler */
2300   6                              cnsm->currSchedInd = (cnsm->currSchedInd +1)&0x1;
2301   6                              schedInd = cnsm->currSchedInd;
2302   6                              cnsm->updateSched = 0;
2303   6      #ifdef HPGP_HAL
2304   6           //           HHAL_SetCsmaRegions(cnsm->regionTable[schedInd].regoin, 
2305   6           //               cnsm->regionTable[schedInd].regionNum);
2306   6      #endif
2307   6                          }
2308   5                          else
2309   5                          {
2310   6                              /* PSCD counts down */
2311   6                              cnsm->saiTable[schedInd].pscd--;
2312   6                          }
2313   5                      }
2314   4                      
2315   4                      cnsm->saiTable[schedInd].cscd = 0; // test
2316   4                      if ((schedInd == cnsm->currSchedInd) || (cnsm->updateSched))
2317   4                      {
2318   5                          sai = cnsm->saiTable[schedInd].sai;
2319   5                          saiNum = cnsm->saiTable[schedInd].saiNum;
2320   5                          scd = cnsm->saiTable[schedInd].pscd |   
2321   5                                (cnsm->saiTable[schedInd].cscd << 3);
2322   5                          dataptr += sizeof(sBeHdr); 
2323   5                          *dataptr = scd;
2324   5                          /* NS */
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 39  

2325   5                          *(dataptr + 1)= saiNum & 0x3F;
2326   5                          ptr = dataptr + 2;
2327   5                          beLen = 2;
2328   5                          endTime = 0;
2329   5                          for (j=0; j< saiNum; j++)
2330   5                          {
2331   6                              if (sai[j].stpf)
2332   6                              {
2333   7                                  saiwst = (sSaiWithSt *)ptr;
2334   7                                  saiwst->stpf = 1;
2335   7                                  saiwst->glid = sai[j].glid;
2336   7                                  saiwst->stLo = (sai[j].startTime) & 0xFF;
2337   7                                  saiwst->stHi = (sai[j].startTime >> 8) & 0xF;
2338   7                                  endTime = sai[j].startTime + sai[j].duration;
2339   7                                  saiwst->etLo = endTime & 0xF;
2340   7                                  saiwst->etHi = (endTime >> 4) & 0xFF;
2341   7                                  ptr += sizeof(sSaiWithSt);
2342   7                                  beLen += sizeof(sSaiWithSt);
2343   7                              }
2344   6                              else
2345   6                              {
2346   7                                  saiwost = (sSaiWithoutSt *)ptr;
2347   7                                  saiwost->stpf = 0;
2348   7                                  saiwost->glid = sai[j].glid;
2349   7                                  endTime += sai[j].duration;
2350   7                                  saiwost->etLo = endTime & 0xFF;
2351   7                                  saiwost->etHi = (endTime >> 8) & 0xF;
2352   7                                  ptr += sizeof(sSaiWithoutSt);
2353   7                                  beLen += sizeof(sSaiWithoutSt);
2354   7                              } 
2355   6                          }
2356   5                          schedInd = (schedInd + 1) & 0x1;
2357   5                      }                
2358   4      //FM_HexDump(FM_DATA, "CNSM sched entry:", dataptr, beLen);
2359   4                      break;
2360   4                  }
2361   3                  case BEHDR_REGIONS:
2362   3                  {     
2363   4                      u8 j;
2364   4                      u8 regionNum;
2365   4                      sCsmaRegion *region;
2366   4                      /* build region entry */
2367   4                      beHdr->beType = BEHDR_REGIONS;
2368   4                      dataptr += sizeof(sBeHdr); 
2369   4                      /* schedule regions */
2370   4                      schedInd = cnsm->currSchedInd;
2371   4                      region = cnsm->regionTable[schedInd].region;
2372   4                      regionNum = cnsm->regionTable[schedInd].regionNum;
2373   4      
2374   4                      /* NR */
2375   4                      *dataptr = regionNum;
2376   4                      beLen = 1;
2377   4              regionEntry = (sRegionEntry *)(dataptr + 1);
2378   4              /* regions */
2379   4              endTime = region[0].startTime;
2380   4              for (j=0; j< regionNum; j++)
2381   4              {
2382   5                  endTime = region[j].endTime;
2383   5                  //regionEntry->endTimeHi = (endTime >> 8)&0xF;
2384   5                //regionEntry->endTimeLo = endTime & 0xFF;
2385   5                regionEntry->endTimeLo =  (u8) endTime & 0xF;
2386   5                  regionEntry->endTimeHi = (u8) (endTime >> 4 ) & 0xFF;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 40  

2387   5                regionEntry->regionType = region[j].regionType;
2388   5                regionEntry++;
2389   5                beLen += sizeof(sRegionEntry);          
2390   5              }
2391   4      //FM_HexDump(FM_DATA, "CNSM region entry:", dataptr, beLen);        
2392   4                      break;
2393   4                  }
2394   3                  case BEHDR_MAC_ADDR:
2395   3                  {
2396   4      //               if(bcnType == BEACON_TYPE_DISCOVER)
2397   4                    if(cnsm->txDiscBcn)
2398   4                     {
2399   5                          beHdr->beType = BEHDR_MAC_ADDR;
2400   5                          dataptr += sizeof(sBeHdr); 
2401   5                          memcpy(dataptr, staInfo->ccoScb->macAddr, MAC_ADDR_LEN);
2402   5                          beLen = MAC_ADDR_LEN;
2403   5                     } 
2404   4      
2405   4                      break;
2406   4                  }
2407   3                  case BEHDR_DISCOVER:
2408   3                  {
2409   4                      if(cnsm->schedDiscBcn)
2410   4                      {
2411   5                          //schedule the discover beacon
2412   5                          //get the TEI of associated STA
2413   5                          cnsm->discScb = CRM_GetNextScb(cnsm->crm, cnsm->discScb);
2414   5                          if( cnsm->discScb != NULL)
2415   5                          {
2416   6                          
2417   6                              if( (cnsm->discScb->tei != staInfo->ccoScb->tei) &&
2418   6                                  (cnsm->discScb->namState == STA_NAM_STATE_CONN) )
2419   6                              {
2420   7      #ifndef RELEASE
2421   7      #ifdef P8051
2422   7                    FM_Printf(FM_HINFO, "CNSM:Sched disc bcn tei:%bu\n", 
2423   7                                     cnsm->discScb->tei);
2424   7      #else
                            FM_Printf(FM_HINFO, "CNSM:Sched disc bcn tei:%d\n", 
                                             cnsm->discScb->tei);
              #endif
2428   7      #endif
2429   7                                  beHdr->beType = BEHDR_DISCOVER;
2430   7                                  dataptr += sizeof(sBeHdr); 
2431   7                                  *dataptr = cnsm->discScb->tei;
2432   7                                  beLen = 1;
2433   7                              }
2434   6                              cnsm->bcnUpdate = 1;
2435   6                          }
2436   5                          else
2437   5                          {
2438   6                              //all STAs have scheduled so far
2439   6                              cnsm->schedDiscBcn = 0;
2440   6                              cnsm->bcnUpdate = 1;
2441   6                          }
2442   5                      }
2443   4                      break;
2444   4                  }
2445   3                  case BEHDR_DISC_INFO:
2446   3                  {
2447   4      //               if(bcnType == BEACON_TYPE_DISCOVER)
2448   4                     if(cnsm->txDiscBcn)
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 41  

2449   4                     {
2450   5                          cnsm->txDiscBcn--;
2451   5                          beHdr->beType = BEHDR_DISC_INFO;
2452   5                          dataptr += sizeof(sBeHdr); 
2453   5                          discInfoEntry = (sDiscInfoEntry *)dataptr;
2454   5                          discInfoEntry->staCap.byte = staInfo->ccoScb->staCap.byte;
2455   5      
2456   5                          discInfoEntry->numDiscSta = staInfo->numDiscSta; 
2457   5                          discInfoEntry->numDiscNet = staInfo->numDiscNet; 
2458   5      
2459   5                          discInfoEntry->staStatus.byte = staInfo->ccoScb->staStatus.byte; 
2460   5                          beLen = sizeof(sDiscInfoEntry);
2461   5                     }
2462   4                      break;
2463   4                  }
2464   3                  case BEHDR_BPSTO:
2465   3                  {
2466   4                      /* build bpsto entry */
2467   4                      beHdr->beType = BEHDR_BPSTO;
2468   4                      dataptr += sizeof(sBeHdr); 
2469   4                      beLen = 3;
2470   4      //                         cnsm->bpstoOffset = bcnLen + sizeof(sBeHdr);
2471   4                      cnsm->bpstoOffset = ((u8 *)beHdr  + sizeof(sBeHdr)) -  ((u8 *)cnsm->bcnBuff );
2472   4                      break;
2473   4                  }
2474   3                  case BEHDR_ENCRYP_KEY_CHANGE:
2475   3                  {
2476   4                      //build encrption key change entry
2477   4                      //beHdr->beType = BEHDR_ENCRYP_KEY_CHANGE;
2478   4                      //dataptr += sizeof(sBeHdr); 
2479   4      
2480   4                      break;
2481   4                  }
2482   3                  case BEHDR_CCO_HANDOVER:
2483   3                  {
2484   4                      //build cco handover entry
2485   4                      if ( (bcnType == BEACON_TYPE_CENTRAL)&&
2486   4                           (cnsm->hoReady))
2487   4                      {
2488   5                          beHdr->beType = BEHDR_CCO_HANDOVER;
2489   5                          dataptr += sizeof(sBeHdr); 
2490   5                          ccoHo = (sCcoHoEntry *)dataptr;
2491   5                          ccoHo->hcd = cnsm->hoCntDown;
2492   5                          ccoHo->nctei = cnsm->nctei; //TODO
2493   5                          beLen = sizeof(sCcoHoEntry);
2494   5           
2495   5                      }
2496   4                      break;
2497   4                  }
2498   3                  case BEHDR_BCN_RELOC:
2499   3                  {
2500   4                      //build beacon relocation entry
2501   4                      //beHdr->beType = BEHDR_BCN_RELOC;
2502   4                      //dataptr += sizeof(sBeHdr); 
2503   4      
2504   4                      break;
2505   4                  }
2506   3                  case BEHDR_ACL_SYNC_CNTDOWN:
2507   3                  {
2508   4                      //build AC line sync countdown entry
2509   4                      //beHdr->beType = BEHDR_ACL_SYNC_CNTDOWN;
2510   4                      //dataptr += sizeof(sBeHdr); 
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 42  

2511   4      
2512   4                      break;
2513   4                  }
2514   3                  case BEHDR_CHANGE_NUM_SLOTS:
2515   3                  {
2516   4                      //build change number of slots entry
2517   4                      //beHdr->beType = BEHDR_CHANGE_NUM_SLOTS;
2518   4                      //dataptr += sizeof(sBeHdr); 
2519   4      
2520   4                      break;
2521   4                  }
2522   3                  case BEHDR_CHANGE_HM:
2523   3                  {
2524   4                      //build change hybrid mode entry
2525   4                      //beHdr->beType = BEHDR_CHANGE_HM;
2526   4                      //dataptr += sizeof(sBeHdr); 
2527   4      
2528   4                      break;
2529   4                  }
2530   3                  case BEHDR_CHANGE_SNID:
2531   3                  {
2532   4                      //build change snid entry
2533   4                      //beHdr->beType = BEHDR_CHANGE_SNID;
2534   4                      //dataptr += sizeof(sBeHdr); 
2535   4      
2536   4                      break;
2537   4                  }
2538   3                  case BEHDR_PWR_SAVE:
2539   3                  {
2540   4      #if defined(POWERSAVE) || defined(LLP_POWERSAVE)
                      sPowerSaveEntry *pPsBentry ;
                      sHaLayer *hal;
              
                              beHdr->beType = BEHDR_PWR_SAVE;
                              dataptr += sizeof(sBeHdr);
                      pPsBentry = (sPowerSaveEntry *) dataptr;
              
                      hal = (sHaLayer *) HOMEPLUG_GetHal();
                             // cnsm->bcnUpdate = cnsm->bcnUpdate & 0xFD;
                        if (hal->hhalCb->psAvln == FALSE)
                      {
                        // if AVLN PS is disabled, set Stop PS flag to TRUE, no need to set anything else
                        // if there are HPAV1.1 stations in AVLN, set HPAV11 to TRUE
                        pPsBentry->spsf = TRUE;
                          pPsBentry->tpss = 0xf;
                        if (hal->hhalCb->psHPAV11 == TRUE)
                        {
                          pPsBentry->av11pf = TRUE;
                        }
              
                        beLen = sizeof(sPowerSaveEntry);
                      }
                      else
                      {
                          sLinkLayer    *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
                          sStaInfo      *staInfo = LINKL_GetStaInfo(linkl);
                          sScb          *scb = NULL;
                        sStations   *psStation;
                        u16       tmpBpCnt;
              
              
                          tmpBpCnt = staInfo->ccoScb->bpCnt+2;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 43  

                          pPsBentry->bpCnt_Lo = tmpBpCnt & 0xff;    // use only 12 bits
                          pPsBentry->bpCnt_Hi = (tmpBpCnt & 0xf00) >> 8;
                          pPsBentry->av11pf = FALSE;
                          pPsBentry->tpss = staInfo->ccoScb->pss;
                          pPsBentry->pssi = staInfo->ccoScb->pssi;
                        beLen = sizeof(sPowerSaveEntry);
              #ifdef POWERSAVE
                                psStation = (sStations *) (dataptr + beLen);
                        // go through all STAs in AVLN
              //printf("CRM_GetscbNum()=%bu\n", CRM_GetScbNum(cnsm->crm));
                                  scb = CRM_GetNextScb(cnsm->crm, scb);
                          while(scb)
                          {
                          if (scb->psState == PSM_PS_STATE_ON)
                          {
                            psStation->tei = scb->tei;
                            psStation->pss = scb->pss;
                            ++psStation;
                            beLen += sizeof(sStations);
              //              printf("add PS bentry from tei %bu, pss %bu\n", scb->tei, scb->pss);
                          }
                                    scb = CRM_GetNextScb(cnsm->crm, scb);
                        }
              #endif
                      }
              #ifdef PS_DEBUG
                      if (psDebug)
                        printf("CNSM_BuildBeacon:scb->bpCnt=%d\n", staInfo->ccoScb->bpCnt);
              #endif
              /*
                        if (psDebug)
                        {
                          u8 i;
                          u8 *tmpp = dataptr;
              
                          for (i=0;i<beLen;i++)
                            printf("0x%bx ", tmpp[i]);
                          printf("\n"); 
                        }
              */
                              break;
              #endif
2615   4                  }
2616   3          
2617   3                  case BEHDR_VENDOR_SPEC:         
2618   3                  {       
2619   4              if(cnsm->vendorSpec.enable == TRUE)
2620   4              {         
2621   5                  beHdr->beType = BEHDR_VENDOR_SPEC;
2622   5                  dataptr += sizeof(sBeHdr); 
2623   5                
2624   5                          memcpy((u8*)dataptr, (u8*)&cnsm->vendorSpec.ota, sizeof(svendorOta));
2625   5                //FM_HexDump(FM_ERROR,"\nVload:",dataptr, VENDOR_SPEC_FIELD_LEN);
2626   5                  beLen = sizeof(svendorOta);
2627   5              } 
2628   4            
2629   4                      done = 1;
2630   4                      break;
2631   4                  }
2632   3                  default:
2633   3                  {
2634   4                      //do not build the entry in the beacon
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 44  

2635   4                  }
2636   3              }
2637   2              //add the non-zero entry 
2638   2              if( beLen != 0)
2639   2              { 
2640   3      //            beHdr->beLen = beLen + sizeof(sBcnHdr); 
2641   3                  beHdr->beLen = beLen; 
2642   3                  bcnLen += sizeof(sBeHdr) + beHdr->beLen;
2643   3                  dataptr += beLen;
2644   3                  beHdr = (sBeHdr *)dataptr;
2645   3                  beLen = 0;
2646   3      //            *nbe = *nbe+1;
2647   3                  bcnHdr->nbe++;
2648   3              }
2649   2              i++;
2650   2          }
2651   1          cnsm->bcnLen = bcnLen;
2652   1      
2653   1        //FM_HexDump(FM_ERROR,"\nBcnload:",cnsm->bcnBuff, BEACON_BUFF_LEN); 
2654   1          return STATUS_SUCCESS;
2655   1      }
2656               
2657          eStatus CNSM_TransmitBeacon(sCnsm *cnsm)
2658          {
2659   1          sTxDesc    txinfo;
2660   1          sBuffDesc  buffDesc;
2661   1          u8         offset = 0;
2662   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2663   1          sLinkLayer *linkl = cnsm->linkl;
2664   1          sStaInfo   *staInfo = LINKL_GetStaInfo(linkl);
2665   1      
2666   1      #ifdef SIMU
                  offset = sizeof(sFrmCtrlBlk) + sizeof(sTxDesc);
              #else
2669   1          offset = sizeof(sFrmCtrlBlk);
2670   1      #endif
2671   1      
2672   1          //transmit the beacon 
2673   1          txinfo.dtei = 0xFF;
2674   1          txinfo.stei = staInfo->ccoScb->tei;
2675   1          txinfo.frameType = BEACON_TYPE_CENTRAL;
2676   1          txinfo.snid = staInfo->snid;
2677   1        
2678   1          //prepare tx control information
2679   1          buffDesc.buff = cnsm->bcnBuff;
2680   1          buffDesc.bufflen = BEACON_BUFF_LEN;
2681   1          buffDesc.dataptr = cnsm->bcnBuff + offset;
2682   1          buffDesc.datalen = BEACON_PAYLOAD_SIZE;
2683   1      
2684   1      //  FM_HexDump(FM_DATA, "CNSM beacon:", buffDesc.dataptr, buffDesc.datalen);
2685   1      
2686   1          HAL_TransmitBeacon(HOMEPLUG_GetHal(), &txinfo, &buffDesc, cnsm->bpstoOffset);
2687   1      
2688   1              
2689   1          return STATUS_SUCCESS;    
2690   1      
2691   1      }
2692          
2693          
2694          //beacon transmission in the interrupt context
2695          void LINKL_BcnTxHandler(void* cookie)
2696          {
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 45  

2697   1          sCnsm      *cnsm = NULL;
2698   1          sEvent     *event = NULL;
2699   1          eStatus     status = STATUS_SUCCESS;
2700   1          sScb       *scb = NULL;
2701   1          sScb       *nextscb = NULL;
2702   1          sLinkLayer *linkl = (sLinkLayer *)cookie;
2703   1          sStaInfo   *staInfo = LINKL_GetStaInfo(linkl);
2704   1      
2705   1          cnsm = &linkl->ccoNsm;
2706   1          //build central beacon
2707   1          status = CNSM_BuildBeacon(cnsm, BEACON_TYPE_CENTRAL);
2708   1          if(status == STATUS_SUCCESS)
2709   1          {
2710   2              CNSM_TransmitBeacon(cnsm);
2711   2          }
2712   1      
2713   1          if(cnsm->hoCntDown == 0)
2714   1          {
2715   2      
2716   2              FM_Printf(FM_HINFO, "CNSM: HO switch(ASSOC STA)\n");
2717   2              //send event CCO_HO_IND to the ctrl       
2718   2              event = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
2719   2              if(event == NULL)
2720   2              {
2721   3                  FM_Printf(FM_ERROR, "EAF\n");
2722   3                  return ;
2723   3              }
2724   2      
2725   2              //Handover: switch to the STA mode/role
2726   2              //still keep the SCBs in CRM for TEI MAP, 
2727   2              //but free the tei timer for all SCBs
2728   2              staInfo->staScb = staInfo->ccoScb;
2729   2              scb = CRM_GetNextScb(cnsm->crm, scb);
2730   2              while(scb)
2731   2              {
2732   3                  STM_StopTimer(scb->teiTimer);
2733   3                  STM_FreeTimer(scb->teiTimer);
2734   3                  scb->teiTimer = STM_TIMER_INVALID_ID;
2735   3                  if (scb->tei == cnsm->nctei)
2736   3                  {
2737   4                      staInfo->ccoScb = scb;
2738   4                  }
2739   3                  nextscb = CRM_GetNextScb(cnsm->crm, scb);
2740   3                  scb = nextscb;
2741   3              }
2742   2      
2743   2              if( staInfo->ccoScb == NULL)
2744   2              {
2745   3                  //never happen
2746   3                  FM_Printf(FM_ERROR, "CNSM:can't find cco scb\n");
2747   3              }
2748   2              CNSM_Stop(cnsm);
2749   2      
2750   2              event->eventHdr.eventClass = EVENT_CLASS_CTRL;
2751   2              event->eventHdr.type = EVENT_TYPE_CCO_HO_IND;
2752   2              //deliver the event to the upper layer
2753   2      #ifdef CALLBACK
                      linkl->deliverEvent(linkl->eventcookie, event);
              #else
2756   2              CTRLL_ReceiveEvent(linkl->eventcookie, event);
2757   2      #endif
2758   2          }
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 46  

2759   1          else
2760   1          {
2761   2              if(cnsm->hoReady)
2762   2              {
2763   3                  cnsm->hoCntDown--;
2764   3                  FM_Printf(FM_MINFO, "CNSM:HO cntdown(%d)\n", cnsm->hoCntDown);
2765   3              }
2766   2      #ifdef SIMU
                      STM_StartTimer(cnsm->bcnTimer, HPGP_TIME_BCN_INTERVAL);   
              #endif
2769   2          }
2770   1      }
2771          
2772          #ifdef SIMU
              void LINKL_BcnTimerHandler(u16 type, void* cookie)
              {
              //    sEvent *event = NULL;
                  sLinkLayer * linkl = (sLinkLayer *)cookie;
                  //sCnsm* cnsm =  LINKL_GetCnsm(linkl);
              
                  LINKL_BcnTxHandler(linkl);
                   
              }
              #endif
2783          
2784          
2785          void CNSM_ProcEvent(sCnsm *cnsm, sEvent *event)
2786          {
2787   1          sEvent            *newEvent = NULL;
2788   1          sHpgpHdr          *hpgpHdr = NULL;
2789   1          sScb              *staScb = NULL;
2790   1          sCcDiscStaInfo    *ccDiscStaInfo = NULL;
2791   1          sCcDiscNetInfo    *ccDiscNetInfo = NULL;
2792   1          sRxDesc           rxdesc;
2793   1          u8                 num;
2794   1          u8                *dataptr = NULL;
2795   1          u8                *bcn = NULL;
2796   1          u8                 i, ccoType;
2797   1         
2798   1      //    sLinkLayer *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
2799   1          sLinkLayer *linkl = cnsm->linkl;
2800   1          sStaInfo   *staInfo = LINKL_GetStaInfo(linkl);
2801   1      #ifdef ROUTE
                  sCrm              *crm = LINKL_GetCrm(linkl);
                  u32 ntb;
              #endif
2805   1          hpgpHdr = (sHpgpHdr *)event->buffDesc.buff;
2806   1          switch(cnsm->state)
2807   1          { 
2808   2              case CNSM_STATE_INIT:
2809   2              {
2810   3                  if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) && 
2811   3                      (event->eventHdr.type == EVENT_TYPE_CNSM_START) )
2812   3                  {
2813   4                      dataptr = event->buffDesc.dataptr;
2814   4                      ccoType = *dataptr;  
2815   4      
2816   4              syncThres =  ((staInfo->macAddr[5] * 4 ) % 5);
2817   4                      
2818   4      
2819   4              cnsm->noBcn = 0;
2820   4              cnsm->multiCCo = 0;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 47  

2821   4              
2822   4              staInfo->slotUsage = 0;
2823   4              staInfo->snid =  staInfo->nid[NID_LEN-1] ;
2824   4                
2825   4                      if(ccoType == LINKL_CCO_TYPE_UNASSOC)
2826   4                      {                
2827   5                cnsm->ccoNotification = 1;    
2828   5                      }
2829   4                      else if(ccoType == LINKL_CCO_TYPE_HO)
2830   4              {
2831   5                cnsm->ccoNotification = 0;
2832   5                cnsm->txDiscBcn = 10;
2833   5                cnsm->bcnUpdate = 1;
2834   5      
2835   5                          /* Send CC_DISCOVER_LIST.REQ to each STA mainly due to handover */
2836   5                          staScb = CRM_GetNextScb(cnsm->crm, staScb);
2837   5                          while(staScb)
2838   5                          {
2839   6                              if(staScb->tei != cnsm->staInfo->ccoScb->tei)
2840   6                              {
2841   7                                  CNSM_SendMgmtMsg(cnsm, EVENT_TYPE_CC_DISCOVER_LIST_REQ,
2842   7                                            staInfo->snid,
2843   7                                            staScb->tei, 
2844   7                                            staScb->macAddr);
2845   7                              }
2846   6            
2847   6                              staScb = CRM_GetNextScb(cnsm->crm, staScb);
2848   6                          }
2849   5                      }
2850   4                      else
2851   4                      {
2852   5                  /* CNSM starts first time as Associated CCo */
2853   5                          cnsm->ccoNotification = 0;
2854   5                      }
2855   4                      cnsm->discScb = NULL;
2856   4      #ifdef HPGP_HAL
2857   4                     ISM_EnableMacIrq(MAC_INT_IRQ_PLC_BCN_TX);
2858   4      #endif
2859   4      
2860   4      #ifdef AKM  
              
                       AKM_Start(&linkl->akm, LINKL_STA_MODE_CCO, AKM_NEW_NEK);
              #else
2864   4              if (ccoType != LINKL_CCO_TYPE_HO)
2865   4              {
2866   5                LINKL_SetHpgpNetworkKey(linkl);
2867   5      
2868   5              }
2869   4      
2870   4      
2871   4      #endif
2872   4      #ifndef MCCO
              
              
              
              #ifdef DISC_BCN
                              STM_StartTimer(cnsm->discTimer, HPGP_TIME_DISC_PERIOD_MAX);
              #endif
                              STM_StartTimer(cnsm->discAgingTimer, HPGP_TIME_DISC_AGING);
              #ifdef NSM_CCO_PRINT        
              #ifdef P8051   
              FM_Printf(FM_ERROR, "CNSM:Start disc timer(tid: %bu)\n", cnsm->discTimer);
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 48  

              FM_Printf(FM_ERROR, "CNSM:Start disc aging timer(tid: %bu)\n", 
                       cnsm->discAgingTimer);
              #else
              FM_Printf(FM_ERROR, "CNSM: Start disc timer(tid: %d)\n", cnsm->discTimer);
              FM_Printf(FM_ERROR, "CNSM: Start disc aging timer(tid: %d)\n", 
                       cnsm->discAgingTimer);
              #endif
              #endif
                  
              #ifdef SIMU
              FM_Printf(FM_ERROR, "CNSM:Start beacon timer(tid: %d)\n", cnsm->bcnTimer);
                              STM_StartTimer(cnsm->bcnTimer, HPGP_TIME_BCN_INTERVAL);   
              #else
                  //enable the MAC HW to transmit the beacon
              
              #endif
              
              #if 1 //def AC_TO_DC
                         // start AcToDc timer
                         if(gHpgpHalCB.lineMode == LINE_MODE_AC)
                         {
                           
                           gHpgpHalCB.halStats.zc = 0;
                           STM_StartTimer(cnsm->acDcTimer,AC_TO_DC_TIME);
                         }
                                     
              #endif
              
              
                              cnsm->state = CNSM_STATE_READY;
              
                      HHAL_SetSnid(staInfo->snid);
                      
                      HHAL_SetDevMode(DEV_MODE_CCO,  gHpgpHalCB.lineMode);
              
                      CNSM_InitRegion(cnsm);
              
                      LINKL_SetBcnInit();
              
                              CNSM_BuildBeacon(cnsm, BEACON_TYPE_CENTRAL);
              
                              CNSM_TransmitBeacon(cnsm);
              
              #else
2927   4              SCB_ClearAgeDiscLists();
2928   4              STM_StartTimer(cnsm->bbtTimer, (syncThres*1000) + 
2929   4                              staInfo->macAddr[5] + 500);
2930   4      #endif
2931   4                      
2932   4                  }
2933   3      
2934   3      #ifdef MCCO     
2935   3            else if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) && 
2936   3                      (event->eventHdr.type == EVENT_TYPE_TIMER_CCO_BBT_IND) )
2937   3            {
2938   4              u8 i = 0;
2939   4              u8 j = 0;
2940   4              u8 cco_slot[AVLN_LIST_MAX+1];
2941   4      
2942   4            //noAvln = SNSM_GetNoAvln();
2943   4            //printf("AVLN No. %bu\n",noAvln);//Kiran
2944   4      
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 49  

2945   4              memset((u8*)&cco_slot, 0x00, AVLN_LIST_MAX+1);
2946   4            
2947   4      #if 1 //def AC_TO_DC
2948   4              // start AcToDc timer
2949   4              if(gHpgpHalCB.lineMode == LINE_MODE_AC)
2950   4              {
2951   5                gHpgpHalCB.halStats.zc = 0;
2952   5                STM_StopTimer(cnsm->acDcTimer);
2953   5                STM_StartTimer(cnsm->acDcTimer,AC_TO_DC_TIME);
2954   5              }
2955   4      
2956   4      #endif
2957   4      #if 0
                      if (0)//!cnsm->isCentralCCo)
                      {
              
                        u8 *nidPtr;
                        
                        // CCo can fetch slotId visible through Discovery
                        // beacon as well
              
                        cnsm->nwMinSlotId = 0xFF;
                        memset(cnsm->passiveNid, 0x00, NID_LEN);
              
                        //printf("cnsm avlnNum %bu\n",cnsm->numAvln);
              
                //        FM_HexDump(FM_USER,"avlb", (u8*)&cnsm->avlnInfo, sizeof(cnsm->avlnInfo));
                        for(i = 0; i < DISC_NET_LIST_MAX; i++)
                        {
                          cco_slot[staInfo->discNetInfo[i].slotId] = 1;         
              
              //            printf("slot %bu\n", staInfo->discNetInfo[i].slotId);           
                          //printf("snid %bu\n", staInfo->discNetInfo[i].snid);           
                            
                            //}
                            
                          if((staInfo->discNetInfo[i].valid == TRUE) &&
                             (staInfo->discNetInfo[i].rssi > HPGP_MCCO_SYNC_BCN_RSSI) &&
                             (staInfo->discNetInfo[i].bcnRxCnt > 
                                HPGP_MCCO_START_SYNC_BCN_CNT))
                          { 
                          //  cnsm->multiCCo = 1;
                    
                            if((staInfo->discNetInfo[i].slotId) < (cnsm->nwMinSlotId))
                            {
                              {
                                
                                    
                                cnsm->nwMinSlotId = staInfo->discNetInfo[i].slotId;
                                nidPtr = &staInfo->discNetInfo[i].nid;
              
                                gHpgpHalCB.snid  = staInfo->discNetInfo[i].snid;
                                
                              //  printf("minslot %bu\n", cnsm->nwMinSlotId);
                                //printf("Snid %bu\n",gHpgpHalCB.snid );
              
                              }
                              
                            }
                          }
              
              #if 0
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 50  

                          if (staInfo->discNetInfo[i].valid == TRUE)              
                          {
              
                            u8 slotUsage;
                            cco_slot[staInfo->discNetInfo[i].slotId] = 1;
              
                            staInfo->slotUsage |= BIT(staInfo->discNetInfo[i].slotId);              
              
              
                            slotUsage = staInfo->discNetInfo[i].slotUsage;
              
                            if (slotUsage >= 8)
                            {
                            slotUsage -= 8;
                            cco_slot[3] = 1;
                            }
              
                            if (slotUsage >= 4)
                            {
                            slotUsage -= 4;
                            cco_slot[2] = 1;
                            }
                            if (slotUsage >= 2)
                            {
                            slotUsage -= 2;
                            cco_slot[1] = 1;
                            } 
                            if (slotUsage >= 1)
                            {
                            slotUsage -= 1;
                            cco_slot[0] = 1;
                            }
              
              
              
              
              
                            }
              #endif
                        }
                        if (cnsm->multiCCo)
                        {
                          memcpy(cnsm->passiveNid, nidPtr, NID_LEN);
              
                          cnsm->passiveNid[NID_LEN - 1] &= NID_EXTRA_BIT_MASK;
                          
                          FM_HexDump(FM_USER, "nid of peer", cnsm->passiveNid, NID_LEN);
                          printf("slot of peer %bu\n", cnsm->nwMinSlotId);      
              
                          
                            #if 0
                          if (cnsm->slotId)
                          {           
                                    
                            staInfo->slotUsage |= BIT(cnsm->slotId);
                            cco_slot[cnsm->slotId] = 0;                       
                            cnsm->slotId = 0;
                          }
                            #endif
              
                        }
                          
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 51  

                            for(i = 0; i < AVLN_LIST_MAX; i++)
                          {
                            if(cco_slot[i] == 0)
                            {
                              cnsm->slotId = i;         
              
                            printf("selected slotid %bu\n", cnsm->slotId);
                            break;
                          }
              
                                
                            
                            
                        }
                            
              
              
                        if (i == AVLN_LIST_MAX)
                        {
                          printf("NO SLOT AVAILABLE \n");
              
                          break;
                  
                        }
                        
                      
              
                      }else
              #endif        
3098   4              {
3099   5                  cnsm->slotId = 0;           
3100   5      
3101   5              }
3102   4      
3103   4      #if 0       
                      for(j=1; j<MAXSNID; j++)
                      {
                        for(i=0; i< AVLN_LIST_MAX; i++)
                        {
                            if((staInfo->discNetInfo[i].valid) &&
                            (staInfo->discNetInfo[i].snid == j))
                            {
                                break;
                            }
                        }
                        if(i == AVLN_LIST_MAX)
                        {                
                            staInfo->snid = j; 
                          //printf("fixsnid %bu\n", j);
                            break;
                        }
                      }
              #endif        
3122   4      
3123   4      #ifndef RELEASE
3124   4              printf("Cco snid %bu\n", staInfo->snid);
3125   4              
3126   4              printf("Cco slot %bu\n", cnsm->slotId);
3127   4      #endif
3128   4              if (cnsm->multiCCo)
3129   4              {
3130   5                HHAL_SetDevMode(DEV_MODE_PCCO,  gHpgpHalCB.lineMode);       
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 52  

3131   5                HHAL_SetNWSnid(staInfo->snid);          
3132   5                
3133   5                HHAL_SetSnid(gHpgpHalCB.snid);
3134   5              }
3135   4              else
3136   4              {
3137   5                HHAL_SetDevMode(DEV_MODE_CCO,  gHpgpHalCB.lineMode);
3138   5                
3139   5                
3140   5                HHAL_SetSnid(staInfo->snid);
3141   5      
3142   5              }
3143   4      
3144   4              CNSM_InitRegion(cnsm);
3145   4      
3146   4      #ifdef DISC_BCN
                      STM_StartTimer(cnsm->discTimer, HPGP_TIME_DISC_PERIOD_MAX);
              #endif
3149   4              STM_StartTimer(cnsm->discAgingTimer, HPGP_TIME_DISC_AGING);
3150   4      #ifdef NSM_CCO_PRINT        
              #ifdef P8051   
                      FM_Printf(FM_ERROR, "CNSM:Start disc timer(tid: %bu)\n", cnsm->discTimer);
                      FM_Printf(FM_ERROR, "CNSM:Start disc aging timer(tid: %bu)\n", 
                      cnsm->discAgingTimer);
              #else
                      FM_Printf(FM_ERROR, "CNSM: Start disc timer(tid: %d)\n", cnsm->discTimer);
                      FM_Printf(FM_ERROR, "CNSM: Start disc aging timer(tid: %d)\n", 
                      cnsm->discAgingTimer);
              #endif
              #endif
3161   4      
3162   4      #ifdef SIMU
                      FM_Printf(FM_ERROR, "CNSM:Start beacon timer(tid: %d)\n", cnsm->bcnTimer);
                      STM_StartTimer(cnsm->bcnTimer, HPGP_TIME_BCN_INTERVAL);   
              #else
3166   4              //enable the MAC HW to transmit the beacon
3167   4      #ifdef HPGP_HAL
3168   4              ISM_EnableMacIrq(MAC_INT_IRQ_PLC_BCN_TX);
3169   4      #endif
3170   4      
3171   4      #endif
3172   4              cnsm->state = CNSM_STATE_READY;
3173   4      
3174   4              LINKL_SetBcnInit();
3175   4              
3176   4              CNSM_BuildBeacon(cnsm, BEACON_TYPE_CENTRAL);
3177   4      
3178   4              CNSM_TransmitBeacon(cnsm);
3179   4      
3180   4      #ifdef AKM
                      if (ccoType != LINKL_CCO_TYPE_HO)
                        AKM_Start(&linkl->akm, LINKL_STA_MODE_CCO, AKM_NEW_NEK);
              #endif        
3184   4      #ifdef MCCO
3185   4              if (cnsm->multiCCo)         
3186   4                STM_StartTimer(cnsm->bcnLossTimer, HPGP_TIME_BEACON_LOSS);
3187   4      #endif
3188   4      
3189   4      
3190   4            }
3191   3            else if( (event->eventHdr.eventClass == EVENT_CLASS_CTRL) && 
3192   3                        (event->eventHdr.type == EVENT_TYPE_CC_BCN_IND) )
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 53  

3193   3            {   
3194   4            sDiscNetInfoRef discNetInfoRef;
3195   4            u8 nbe;     
3196   4            sBeHdr *beHdr;
3197   4            u8 *bcn = event->buffDesc.dataptr;      
3198   4            sBcnHdr *bcnHdr =  (sBcnHdr*)bcn;
3199   4            u8 *dataptr = bcn + sizeof(sBcnHdr);      
3200   4            u16 lLen = sizeof(sFrmCtrlBlk) + sizeof(sHybriiRxBcnHdr);
3201   4            
3202   4            u8 rssi = bcn[PLC_BCNRX_LEN-4-lLen];
3203   4              
3204   4      
3205   4            
3206   4            if (bcnHdr->bt != BEACON_TYPE_CENTRAL)
3207   4            {
3208   5            
3209   5              break;
3210   5            
3211   5            }
3212   4            
3213   4            nbe = bcnHdr->nbe;
3214   4      
3215   4            beHdr = (sBeHdr *) dataptr;
3216   4      
3217   4              while(nbe)
3218   4              {
3219   5                  dataptr += sizeof(sBeHdr); //move to the start of BEENTRY 
3220   5                  switch (beHdr->beType)
3221   5                  {            
3222   6                case BEHDR_VENDOR_SPEC:
3223   6                {
3224   7      #if 1        
3225   7                  discNetInfoRef.nid = bcnHdr->nid; 
3226   7                  discNetInfoRef.hybridMode = bcnHdr->nid[NID_LEN]>>6;        
3227   7                  discNetInfoRef.snid = hpgpHdr->snid;
3228   7                  
3229   7                  discNetInfoRef.rssi = bcn[PLC_BCNRX_LEN-4-lLen]; 
3230   7                  discNetInfoRef.lqi = bcn[PLC_BCNRX_LEN-3-lLen];
3231   7                  discNetInfoRef.netMode = bcnHdr->nm;
3232   7                  discNetInfoRef.numBcnSlots = bcnHdr->numslots;
3233   7                  discNetInfoRef.slotId = bcnHdr->slotid;
3234   7                  discNetInfoRef.slotUsage= bcnHdr->slotusage;                                        
3235   7                  memcpy(&discNetInfoRef.vendor_ota, (u8*)dataptr, sizeof(svendorOta));
3236   7                  
3237   7       #endif     
3238   7                }
3239   6                break;  
3240   6      
3241   6                default:
3242   6                break;
3243   6                  }
3244   5                  dataptr = dataptr +  beHdr->beLen; 
3245   5                  beHdr = (sBeHdr *) dataptr;
3246   5                  nbe--;        
3247   5              }     
3248   4            SCB_UpdateDiscNetList(cnsm->staInfo->ccoScb, &discNetInfoRef); 
3249   4          }
3250   3      #endif                
3251   3                  break;
3252   3              }
3253   2              case CNSM_STATE_READY:
3254   2              {
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 54  

3255   3                  if(event->eventHdr.eventClass == EVENT_CLASS_MSG)
3256   3                  {
3257   4                      switch(event->eventHdr.type)
3258   4                      {
3259   5                        case EVENT_TYPE_CM_UNASSOC_STA_IND:
3260   5                {
3261   6            //      FM_Printf(FM_MMSG, "CNSM:<<<UNASSOC STA IND(tei:%bu)\n",
3262   6                //                        hpgpHdr->tei);
3263   6      
3264   6                  break;
3265   6      
3266   6                      }
3267   5                        case EVENT_TYPE_NN_INL_REQ:
3268   5                        case EVENT_TYPE_NN_INL_CNF:
3269   5                {
3270   6                  sNnINLReq * inlReq = (sNnINLReq*)event->buffDesc.dataptr;
3271   6                  u8 numSta = CRM_GetScbNum(cnsm->crm);
3272   6      #if 0
              
                          if (event->eventHdr.type == EVENT_TYPE_NN_INL_REQ)
                          FM_Printf(FM_MMSG, "CNSM:<<<NN_INL_REQ(tei:%bu)\n",
                                                hpgpHdr->tei);
                          else
                          FM_Printf(FM_MMSG, "CNSM:<<<NN_INL_CNF(tei:%bu)\n",
                                                hpgpHdr->tei);
              #endif                         
3281   6                  if (numSta == inlReq->srcNumAuthSta)
3282   6                  {             
3283   7                    //FM_HexDump(FM_ERROR,"m1", staInfo->macAddr, 6);
3284   7                    //FM_HexDump(FM_ERROR,"m2", hpgpHdr->macAddr, 6);
3285   7                    
3286   7                    if (memcmp(staInfo->macAddr, hpgpHdr->macAddr, 6) < 0)
3287   7                    {
3288   8                      
3289   8                      newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
3290   8                      if(newEvent != NULL)
3291   8                      {
3292   9                        //printf("e %bu\n", EVENT_TYPE_NCO_IND);
3293   9                        newEvent->eventHdr.type = EVENT_TYPE_NCO_IND;
3294   9                        CTRLL_ReceiveEvent(NULL, newEvent);
3295   9                      }
3296   8                    }
3297   7                    
3298   7                  }
3299   6                  else
3300   6                  if (numSta <= inlReq->srcNumAuthSta)
3301   6                  {
3302   7                      newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
3303   7                      if(newEvent != NULL)
3304   7                      {
3305   8                        newEvent->eventHdr.type = EVENT_TYPE_NCO_IND;
3306   8                        CTRLL_ReceiveEvent(NULL, newEvent);
3307   8                      }
3308   7                  }
3309   6      
3310   6      
3311   6                  if (event->eventHdr.type == EVENT_TYPE_NN_INL_REQ)
3312   6                  {
3313   7                      
3314   7                    CNSM_SendMgmtMsg(cnsm, EVENT_TYPE_NN_INL_CNF,
3315   7                            inlReq->srcSnid,
3316   7                            inlReq->srcTei, hpgpHdr->macAddr);
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 55  

3317   7                  }
3318   6                            
3319   6            
3320   6                  break;
3321   6      
3322   6                }
3323   5      
3324   5      
3325   5                case EVENT_TYPE_CC_DISCOVER_LIST_CNF:
3326   5                          {
3327   6      #ifdef P8051
3328   6                              FM_Printf(FM_MMSG, "CNSM:<<CC_DISC_LIST.CNF(tei:%bu)\n",
3329   6                                      hpgpHdr->tei);
3330   6      #else
                                      FM_Printf(FM_MMSG, "CNSM:<<CC_DISC_LIST.CNF(tei:%d)\n",
                                              hpgpHdr->tei);
              #endif
3334   6                              staScb = hpgpHdr->scb;
3335   6                              if(staScb == NULL)
3336   6                              {
3337   7                                  FM_Printf(FM_ERROR, "CNSM:no scb\n");
3338   7                                  break;
3339   7                              }
3340   6      #if 0           
                                      /* reset the discovered sta/net lists in the scb */
                                      for (i = 0; i < DISC_STA_LIST_MAX; i ++)
                                      {
                                          staScb->discStaInfo[i].valid = 0;
                                      }
              
                                      for (i = 0; i < DISC_NET_LIST_MAX; i ++)
                                      {
                                          staScb->discNetInfo[i].valid = 0;
                                      }
              #endif            
3352   6                          staInfo->numDiscSta = 0;        
3353   6                              staInfo->numDiscNet = 0;
3354   6      
3355   6                              //update the discovered sta/net lists in the scb
3356   6                              //i.e. update the topology table
3357   6                              dataptr = event->buffDesc.dataptr;
3358   6                              num = *dataptr;   //number of stations
3359   6      #if 0                
                                      if(num > DISC_STA_LIST_MAX)
                                      {
                                          FM_Printf(FM_ERROR, "CNSM: less resource for discovered sta list in SCB\n");
                                      } 
              #endif            
3365   6                              dataptr++;
3366   6                              i = 0; 
3367   6      #if 0           
                                      while(num)
                                      {
                                          ccDiscStaInfo = (sCcDiscStaInfo *)dataptr; 
                                          if(i < DISC_STA_LIST_MAX)
                                          {
                                              staScb->discStaInfo[i].valid = 1;
                                              staScb->discStaInfo[i].hit = 1;
                                              memcpy(staScb->discStaInfo[i].macAddr,  
                                                  ccDiscStaInfo->macAddr, MAC_ADDR_LEN);
                                              staScb->discStaInfo[i].tei = ccDiscStaInfo->tei;
                                              staScb->discStaInfo[i].sameNet = ccDiscStaInfo->sameNet;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 56  

                                              staScb->discStaInfo[i].snid = ccDiscStaInfo->snid;
              
                                              staScb->discStaInfo[i].staCap.byte = ccDiscStaInfo->staCap.byte;
              
              //                                staScb->discStaInfo[i].sigLevel = ccDiscStaInfo->sigLevel;
              //                                staScb->discStaInfo[i].avgBle= ccDiscStaInfo->avgBle;
                                          }
                                          else
                                          {
              FM_Printf(FM_WARN, "CNSM: size of Rx discover sta list exceeds the max\n");
                                              break;
                                          }
                                          dataptr += sizeof(sCcDiscStaInfo); 
                                          i++;
                                          num--;
                                      }
                                      staScb->numDiscSta = i;
              
              #else
3398   6                            staInfo->numDiscSta = num;
3399   6      #endif
3400   6                              num = *dataptr;   //number of net
3401   6      #if 0                        
                                      if(num > DISC_NET_LIST_MAX)
                                      {
                                          FM_Printf(FM_ERROR, "CNSM: less resource for discovered net list in SCB\n");
                                      } 
              #endif
3407   6                              dataptr++;
3408   6                              i = 0; 
3409   6      #if 0           
                                      while(num)
                                      {
                                          ccDiscNetInfo = (sCcDiscNetInfo *)dataptr; 
                                          if(i < DISC_NET_LIST_MAX)
                                          {
                                              staScb->discNetInfo[i].valid = 1;
                                              staScb->discNetInfo[i].hit = 1;
                                              memcpy(staScb->discNetInfo[i].nid,  
                                                  ccDiscNetInfo->nid, NID_LEN);
                                              staScb->discNetInfo[i].snid = ccDiscNetInfo->snid;
                                              staScb->discNetInfo[i].hybridMode = ccDiscNetInfo->hybridMode;
                                              staScb->discNetInfo[i].numBcnSlots= ccDiscNetInfo->numBcnSlots;
                                              staScb->discNetInfo[i].coordStatus= ccDiscNetInfo->coordStatus;
                                              staScb->discNetInfo[i].offset= ccDiscNetInfo->offset;
                                          }
                                          else
                                          {
                              FM_Printf(FM_WARN, "CNSM:Rx disc exceeds\n");
                                              break;
                                          }
                                          dataptr += sizeof(sCcDiscNetInfo); 
                                          i++;
                                          num--;
                                      }
                                      staScb->numDiscNet = i;
              #else
3436   6                  staInfo->numDiscNet = num;
3437   6      #endif
3438   6                              break;
3439   6                         }
3440   5      #ifdef UKE           
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 57  

                                 case EVENT_TYPE_CM_SC_JOIN_REQ: //UKE
                                 {
                                      FM_Printf(FM_MMSG, "CNSM:<<CM_SC_JOIN.REQ\n");
                                       
                                     if(staInfo->secMode == SEC_MODE_SC_ADD)
                                     {
                                         FM_Printf(FM_MMSG, "SNSM:<<CM_SC_JOIN.REQ\n");
                                       
                                         LINKL_SendMgmtMsg(cnsm->staInfo, EVENT_TYPE_CM_SC_JOIN_CNF,
                                                      ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
              
                                         CNAM_EnableAssocNotification(&linkl->ccoNam,
                                                              ((sHpgpHdr*)(event->buffDesc.buff))->macAddr);
                                             
                                     }
                                         
                                     
                                     break;
                                  } 
              #endif  
3461   5                          
3462   5      #ifdef ROUTE      
                                  case EVENT_TYPE_CM_ROUTE_INFO_REQ:
                                  {
                                      FM_Printf(FM_MMSG, "ROUTE:<<<ROUTE_INFO.REQ(tei:%bu)\n",
                                             hpgpHdr->tei);
                                      ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_CNF, event);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_CNF:
                                  {
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_ROUTE_INFO_IND:
                                  {
                                      ROUTE_procRouteInfo((sRouteInfo *)&event->buffDesc.dataptr[1], event->buffDesc.dat
             -aptr[0], hpgpHdr->tei);
                                      break;
                                  }
                                  case EVENT_TYPE_CM_UNREACHABLE_IND:
                                  {
                                      u32 *unreachableNtb = event->buffDesc.dataptr;
                                      ROUTE_procUnreachableInd(&event->buffDesc.dataptr[5], event->buffDesc.dataptr[4], 
                                          hpgpHdr->tei, (u32)*event->buffDesc.dataptr);
                                      //Start HD_Duration timer using diff between unreachableNtb and current ntb
                                      break;
                                  }
              #endif
3489   5                         default:
3490   5                         {
3491   6                         }
3492   5                     }
3493   4                 }
3494   3                 else //control events
3495   3                 {
3496   4                     switch(event->eventHdr.type)
3497   4                     {
3498   5                         case EVENT_TYPE_CNSM_START: 
3499   5                         {
3500   6      #ifdef ROUTE
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 58  

                                      dataptr = event->buffDesc.dataptr;
                                      ccoType = *dataptr;  
                                      if(ccoType == LINKL_CCO_TYPE_ASSOC)
                                      {
                                          if(cnsm->staInfo->identifyCaps.routingCap == TRUE)
                                          {
                                              ROUTE_startUpdateTimer();
                                          }
                                      }
              #endif
3511   6                break;
3512   6                         }
3513   5                         case EVENT_TYPE_CC_BCN_IND:
3514   5                         {
3515   6                             rxdesc.snid = hpgpHdr->snid;  
3516   6                             bcn = event->buffDesc.dataptr;
3517   6      
3518   6                             if( (CNSM_ProcBcnLow(cnsm, &rxdesc, bcn) == BCN_SRC_OTHER_CCO)
3519   6                                 &&(cnsm->ccoNotification))
3520   6                             {
3521   7                                 newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
3522   7                                 if(newEvent == NULL)
3523   7                                 {
3524   8                                     FM_Printf(FM_ERROR, "EAF\n");
3525   8                                     return ;
3526   8                                 }
3527   7                                 cnsm->ccoNotification = 0; //reset
3528   7                                 newEvent->eventHdr.type = EVENT_TYPE_NET_DISC_IND;
3529   7                                 //deliver the event to the upper layer
3530   7      #ifdef CALLBACK
                                         linkl->deliverEvent(linkl->eventcookie, newEvent);
              #else
3533   7                                 CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
3534   7      #endif
3535   7                             }
3536   6                             break;
3537   6                         }
3538   5                         case EVENT_TYPE_TIMER_DISC_IND: 
3539   5                         {
3540   6                             //perform the auto-CCo selection if the cco is not an
3541   6                             //user-appointed CCo
3542   6                             if(!staInfo->ccoScb->staStatus.fields.apptCcoStatus)
3543   6                             {
3544   7                                // rajan  CNSM_PerformAutoCcoSelection(cnsm);
3545   7                             }
3546   6      
3547   6      /*
3548   6                      //check alive STA. It may not be needed, as the TEI lease
3549   6                      //timer provide the same funcation
3550   6                      scbIter = CRM_GetNextScb(cnsm->crm, scbIter);
3551   6                      while(scbIter)
3552   6                      {
3553   6                          if( scbIter->aliveCnt++ > HPGP_TIME_STA_AGING_CNT)
3554   6                          {
3555   6                              //STA is dead, silently remove the STA
3556   6                              
3557   6                          }
3558   6                          scbIter = CRM_GetNextScb(cnam->crm, scbIter);
3559   6                      }
3560   6      */
3561   6      
3562   6                             //NOTE: transmit the discover info in the central beacon 
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 59  

3563   6                             //instead of scheduling the beacon transmission for CCO itself
3564   6                      
3565   6      #ifdef NSM_CCO_PRINT
                                     FM_Printf(FM_HINFO, "CNSM:Add disc info in bcn\n");
              #endif             
3568   6                             cnsm->txDiscBcn = 1;
3569   6                             cnsm->bcnUpdate = 1;
3570   6      /*
3571   6                      status = CNSM_BuildBeacon(cnsm, BEACON_TYPE_DISCOVER);
3572   6                      if(status == STATUS_SUCCESS)
3573   6                      {
3574   6                          CNSM_TransmitBeacon(cnsm);
3575   6                      }
3576   6      */
3577   6      
3578   6                             //start to schedule the discover beacon
3579   6                             //assume that the CCO could schedule all discover beacons
3580   6                             //in MaxDiscoverPeriod
3581   6                             cnsm->schedDiscBcn = 1;
3582   6      
3583   6                             //restart the discovery timer
3584   6                            STM_StartTimer(cnsm->discTimer, HPGP_TIME_DISC_PERIOD_MAX);   
3585   6       
3586   6                             break;
3587   6                         }
3588   5                         case EVENT_TYPE_TIMER_DISC_AGING_IND:
3589   5                         {
3590   6      #ifdef DISC_BCN
                                     SCB_AgeDiscLists(cnsm->staInfo->ccoScb);
              #endif
3593   6                             STM_StartTimer(cnsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
3594   6      
3595   6                             break;
3596   6                         }   
3597   5      #ifdef MCCO
3598   5                   case EVENT_TYPE_TIMER_BEACON_LOSS_IND:
3599   5                {
3600   6                  
3601   6                  if (cnsm->multiCCo)
3602   6                  {
3603   7                    cnsm->noBcn++;                              
3604   7      
3605   7                    if(cnsm->noBcn >= MAX_NO_BEACON_PASSIVE_CCO)
3606   7                    {
3607   8                        //printf("EVENT_TYPE_TIMER_BEACON_LOSS_IND\n");
3608   8                        //CNSM_SwitchToCCoMode(cnsm, DEV_MODE_CCO);
3609   8      
3610   8                      
3611   8                        cnsm->multiCCo = 0;               
3612   8                      
3613   8                        memset(cnsm->passiveNid, 0x00, NID_LEN);
3614   8                        gHpgpHalCB.passSnid = 0;                  
3615   8                        
3616   8                        HHAL_SetDevMode(DEV_MODE_CCO,  gHpgpHalCB.lineMode);
3617   8                      
3618   8                        HHAL_ClearPassSnid();
3619   8                      
3620   8                        HHAL_SetSnid(staInfo->snid);
3621   8                      
3622   8                        LINKL_ClearBcnInit();
3623   8                      
3624   8                        cnsm->netScan = 0;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 60  

3625   8                        cnsm->netSync = 0;
3626   8                        
3627   8                        gHpgpHalCB.bPerAvgInitDone = 0;
3628   8      #ifdef FREQ_DETECT                
3629   8                        gHpgpHalCB.gFreqCB.freqDetected = 0;
3630   8      #endif
3631   8      
3632   8                      {
3633   9                        newEvent = EVENT_Alloc(EVENT_DEFAULT_SIZE, 0);
3634   9                        if(newEvent)
3635   9                        {
3636  10                          newEvent->eventHdr.eventClass = EVENT_CLASS_CTRL;
3637  10      
3638  10                          
3639  10                          newEvent->eventHdr.type = EVENT_TYPE_RESTART_IND;
3640  10                                
3641  10      
3642  10                          CTRLL_ReceiveEvent(linkl->eventcookie, newEvent);
3643  10                          
3644  10                        }
3645   9                        else
3646   9                        {
3647  10                          FM_Printf(FM_ERROR, "CNAM_ProcEvent:EEAF\n");
3648  10                        }
3649   9                      }
3650   8      
3651   8                      // flush AVLN LIst
3652   8      
3653   8                    }
3654   7                    else
3655   7                    STM_StartTimer(cnsm->bcnLossTimer, HPGP_TIME_BEACON_LOSS);
3656   7      
3657   7                  }
3658   6                  
3659   6                  break;
3660   6                }            
3661   5      #endif           
3662   5      #ifdef ROUTE
                                 case EVENT_TYPE_ROUTE_UPDATE_TIMEOUT:
                                 {
                                     ROUTE_sendRouteInfo(EVENT_TYPE_CM_ROUTE_INFO_IND, NULL);
                                     ROUTE_startUpdateTimer();
                                     break;
                                 }
                                 case EVENT_TYPE_ROUTE_HD_DURATION_TIMEOUT:
                                 {
                                     ROUTE_procHdDurationTimeout();
                                     break;
                                 }
              #endif
3675   5      #if 1 //def AC_TO_DC
3676   5                         case EVENT_TYPE_TIMER_AC_DC_IND:
3677   5                         {
3678   6                             
3679   6                             if(gHpgpHalCB.halStats.zc < 2)
3680   6                             {
3681   7                                // switch to DC
3682   7                                sLinkLayer  *linkl = (sLinkLayer *)HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);    
3683   7                                //FM_Printf(FM_USER,"AC DC Tm\n");
3684   7                                //LINKL_SetLineMode(linkl, LINE_MODE_DC);    
3685   7                                gHpgpHalCB.lineMode = LINE_MODE_DC;
3686   7      
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 61  

3687   7      //               FM_Printf(FM_USER,"AC DC Tm\n");
3688   7      
3689   7                                HHAL_SetDevMode(DEV_MODE_CCO, LINE_MODE_DC);
3690   7      //#ifdef FREQ_DETECT                                        
3691   7                              //  FREQDET_FreqSetting(gHpgpHalCB.lineFreq);
3692   7      //#endif
3693   7                             }
3694   6                             break;
3695   6                         }         
3696   5      #endif
3697   5                         default:
3698   5                         {
3699   6                         }
3700   5                     }
3701   4                 }
3702   3                 break;
3703   3              }
3704   2              default:
3705   2              {
3706   3              }
3707   2          }
3708   1      }
3709          
3710          
3711          
3712          eStatus CNSM_Init(sCnsm *cnsm, sLinkLayer *linkl)
3713          {
3714   1          //sLinkLayer *linkLayer = HPGPCTRL_GetLayer(HP_LAYER_TYPE_LINK);
3715   1          cnsm->linkl = linkl;
3716   1          
3717   1          cnsm->state = CNSM_STATE_INIT;
3718   1      #ifdef CALLBACK
                  cnsm->discTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                        EVENT_TYPE_TIMER_DISC_IND, linkl);
              #else
3722   1          cnsm->discTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3723   1                                EVENT_TYPE_TIMER_DISC_IND, linkl);
3724   1      #endif
3725   1      
3726   1          if(cnsm->discTimer == STM_TIMER_INVALID_ID)
3727   1          {
3728   2              return STATUS_FAILURE;
3729   2          }
3730   1      
3731   1      #ifdef MCCO
3732   1        cnsm->bcnLossTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3733   1                          EVENT_TYPE_TIMER_BEACON_LOSS_IND, linkl);
3734   1      
3735   1          if(cnsm->bcnLossTimer == STM_TIMER_INVALID_ID)
3736   1          {
3737   2          //printf("bcnLossTimerfailured\n");
3738   2          
3739   2              return STATUS_FAILURE;
3740   2          }
3741   1        cnsm->bbtTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3742   1                           EVENT_TYPE_TIMER_CCO_BBT_IND, linkl);
3743   1      
3744   1        if(cnsm->bcnLossTimer == STM_TIMER_INVALID_ID)
3745   1        {
3746   2          //printf("bbt timer failured\n");
3747   2          
3748   2          return STATUS_FAILURE;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 62  

3749   2        }
3750   1      #endif
3751   1      #if 1 //def AC_TO_DC
3752   1      #ifdef CALLBACK
                          cnsm->acDcTimer = STM_AllocTimer(LINKL_TimerHandler, 
                                                     EVENT_TYPE_TIMER_AC_DC_IND, linkl);
              #else
3756   1                  cnsm->acDcTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3757   1                                             EVENT_TYPE_TIMER_AC_DC_IND, linkl);
3758   1      #endif
3759   1                  if(cnsm->acDcTimer == STM_TIMER_INVALID_ID)
3760   1                  {
3761   2                      return STATUS_FAILURE;
3762   2                  }
3763   1      #endif
3764   1      
3765   1      #ifdef NSM_CCO_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "CNSM:disc timer id:%bu\n", cnsm->discTimer);
              #else
              FM_Printf(FM_ERROR, "CNSM:disc timer id:%d\n", cnsm->discTimer);
              #endif
              #endif
3772   1      
3773   1      #ifdef CALLBACK
                  cnsm->discAgingTimer = STM_AllocTimer(LINKL_TimerHandler,
                                             EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
              #else
3777   1          cnsm->discAgingTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
3778   1                                     EVENT_TYPE_TIMER_DISC_AGING_IND, linkl);
3779   1      #endif
3780   1          if(cnsm->discAgingTimer == STM_TIMER_INVALID_ID)
3781   1          {
3782   2              return STATUS_FAILURE;
3783   2          }
3784   1      #ifdef NSM_CCO_PRINT  
              #ifdef P8051
              FM_Printf(FM_ERROR, "CNSM:disc aging timer id:%bu\n", cnsm->discAgingTimer);
              #else
              FM_Printf(FM_ERROR, "CNSM:disc aging timer id:%d\n", cnsm->discAgingTimer);
              #endif
              #endif
3791   1      
3792   1      #ifdef SIMU
                  //simulate the beacon tx interrup for beacon interval
              #ifdef CALLBACK
                  cnsm->bcnTimer = STM_AllocTimer(LINKL_BcnTimerHandler, 
                                       EVENT_TYPE_TIMER_BCN_TX_IND, linkl);
              #else
                  cnsm->bcnTimer = STM_AllocTimer(HP_LAYER_TYPE_LINK,
                                       EVENT_TYPE_TIMER_BCN_TX_IND, linkl);
              #endif
              #ifdef NSM_CCO_PRINT
              FM_Printf(FM_ERROR, "CNSM:BCN timer id: %d\n", cnsm->bcnTimer);
              #endif
              #endif
3805   1      
3806   1          ISM_RegisterIntHandler(MAC_INT_IRQ_PLC_BCN_TX, LINKL_BcnTxHandler, linkl);
3807   1      
3808   1          cnsm->state = CNSM_STATE_INIT;
3809   1      
3810   1          cnsm->staInfo = LINKL_GetStaInfo(linkl);
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 63  

3811   1      //    cnsm->ccoInfo = LINKL_GetCcoInfo(linkLayer);
3812   1          cnsm->crm = LINKL_GetCrm(linkl);
3813   1          cnsm->discScb = NULL;
3814   1          cnsm->hoEnabled = 0;
3815   1          cnsm->hoReady = 0;
3816   1          cnsm->nctei = 0;
3817   1          cnsm->ccoNotification = 0;
3818   1          cnsm->schedDiscBcn = 0;
3819   1          cnsm->bcnUpdate = 0;
3820   1          cnsm->bcnUpdateProgress =0;
3821   1          cnsm->txDiscBcn = 0;
3822   1          cnsm->stopSnam = 0;
3823   1          cnsm->hoCntDown = HPGP_HO_COUNTDOWN_MAX;
3824   1          /* initial regsions */
3825   1          /* minimum CSMA regsion */
3826   1      
3827   1          
3828   1          CNSM_InitRegion(cnsm);
3829   1              
3830   1      
3831   1      
3832   1          return STATUS_SUCCESS;
3833   1      }
3834          #endif /* CCO_FUNC */
3835          
3836          //
3837          #if 0
              void SNSM_Start(sSns
              {
                  switch(staType)
                  {
                      case LINKL_STA_TYPE_UNASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          snsm->enableCcoSelection = 1;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_NETDISC:
                      {
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
                          //select PhyClk
              
                          STM_StartTimer(snsm->usttTimer, HPGP_TIME_USAI);   
                          STM_StartTimer(snsm->discAgingTimer, HPGP_TIME_DISC_AGING);   
                          snsm->state = SNSM_STATE_NET_DISC;
                          break;
                      }
                      case LINKL_STA_TYPE_ASSOC:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 1;
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 64  

                          snsm->state = SNSM_STATE_CONN;
                          break;
                      }
                      case LINKL_STA_TYPE_CONN:
                      {
                          //NOTE: better to send an start event, 
                          //instead of setting the state here
                          STM_StopTimer(snsm->usttTimer);   
                          snsm->enableCcoSelection = 0;
                          snsm->enableCcoDetection = 0;
                          snsm->state = SNSM_STATE_CONN;
                      }
                      default:
                      {
                      }
                  }
              }
              #endif
3891          
3892          
3893          /*
3894          void SNSM_StartConn(sSnsm *snsm)
3895          {
3896              STM_StopTimer(snsm->usttTimer);   
3897              snsm->state = SNSM_STATE_CONN;
3898          }
3899          
3900          
3901          void SNSM_LeaveConn(sSnsm *snsm)
3902          {
3903              snsm->state = SNSM_STATE_INIT;
3904          }
3905          */
3906          
3907          
3908          /** =========================================================
3909           *
3910           * Edit History
3911           *
3912           * $Source: /home/cvsrepo/Hybrii_B_OSFW_Dev/firmware/hpgp/src/link/nsm_cco.c,v $
3913           *
3914           * $Log: nsm_cco.c,v $
3915           * Revision 1.42  2015/01/02 14:55:36  kiran
3916           * 1) Timer Leak fixed while freeing SCB fixed
3917           * 2) Software broadcast supported for LG
3918           * 3) UART Loopback supported for LG
3919           * 4) Keep Alive feature to ageout defunctional STA
3920           * 5) Improved flash API's for NO Host Solution
3921           * 6) Imporved PLC Hang recovery mechanism
3922           * 7) Reduced nested call tree of common path functions
3923           * 8) Code optimization and cleanup (unused arguments, unused local variables)
3924           * 9) Work around for UART hardware interrupt issues (unintended interrupts and no interrupts)
3925           * 10) Use of memory specific pointers instead of generic pointers
3926           *
3927           * Revision 1.41  2014/12/30 05:34:15  ranjan
3928           * -multicco fix
3929           *
3930           * Revision 1.40  2014/12/23 09:01:33  ranjan
3931           * Fixed Zigbee LMAC projects
3932           *
3933           * Revision 1.39  2014/12/22 07:05:49  ranjan
3934           * -MCCO:increased per slot to 650us
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 65  

3935           *
3936           * Revision 1.38  2014/12/09 07:09:08  ranjan
3937           * - multicco feature under MCCO flag
3938           *
3939           * Revision 1.37  2014/11/17 06:52:32  prashant
3940           * SPI fix, All devices become unassoc CCO issue fix
3941           *
3942           * Revision 1.36  2014/11/11 14:52:58  ranjan
3943           * 1.New Folder Architecture espically in /components
3944           * 2.Modular arrangment of functionality in new files
3945           *    anticipating the need for exposing them as FW App
3946           *    development modules
3947           * 3.Other improvisation in code and .h files
3948           *
3949           * Revision 1.35  2014/10/28 16:27:43  kiran
3950           * 1) Software recovery using Watchdog Timer
3951           * 2) Hardware recovery monitor and policies
3952           * 3) Timer Polling in Control Task and Frame task for better accuracy
3953           * 4) Common memory optimized by reducing prints
3954           * 5) Discovered netlist corruption fixed
3955           * 6) VCO fix in HHAL_AFEInit()
3956           * 7) Idata optimized by removing floating point operation
3957           * 8) Fixed EVENT_TYPE_CC_BCN_IND false indication during association @ CCO
3958           * 9) Beacon processing protected from interrupts
3959           * 10) Corrupted Beacons are dropped
3960           * 11) Some unused arguments removed to improve code size
3961           *
3962           * Revision 1.34  2014/10/13 10:23:57  prashant
3963           * LG-Uart corruption issue fix
3964           *
3965           * Revision 1.33  2014/09/30 21:45:15  tri
3966           * Added LLP PS
3967           *
3968           * Revision 1.32  2014/09/05 09:28:18  ranjan
3969           * 1. uppermac cco-sta switching feature fix
3970           * 2. general stability fixes for many station associtions
3971           * 3. changed mgmt memory pool for many STA support
3972           *
3973           * Revision 1.31  2014/08/25 07:37:34  kiran
3974           * 1) RSSI & LQI support
3975           * 2) Fixed Sync related issues
3976           * 3) Fixed timer 0 timing drift for SDK
3977           * 4) MMSG & Error Logging in Flash
3978           *
3979           * Revision 1.30  2014/08/05 13:12:55  kiran
3980           * Fixed CP loss issue with UART Host & Peripheral interface
3981           *
3982           * Revision 1.29  2014/07/22 10:03:52  kiran
3983           * 1) SDK Supports Power Save
3984           * 2) Uart_Driver.c cleanup
3985           * 3) SDK app memory pool optimization
3986           * 4) Prints from STM.c are commented
3987           * 5) Print messages are trimmed as common no memory left in common
3988           * 6) Prins related to Power save and some other modules are in compilation flags. To enable module specif
             -ic prints please refer respective module
3989           *
3990           * Revision 1.28  2014/07/16 10:47:40  kiran
3991           * 1) Updated SDK
3992           * 2) Fixed Diag test in SDK
3993           * 3) Ethernet and SPI interfaces removed from SDK as common memory is less
3994           * 4) GPIO access API's added in SDK
3995           * 5) GV701x chip reset command supported
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 66  

3996           * 6) Start network and Join network supported in SDK (Forced CCo and STA)
3997           * 7) Some bug fixed in SDK (CP free, p app command issue etc.)
3998           *
3999           * Revision 1.27  2014/07/11 10:23:37  kiran
4000           * power save changes
4001           *
4002           * Revision 1.26  2014/07/10 11:42:45  prashant
4003           * power save commands added
4004           *
4005           * Revision 1.25  2014/07/05 09:16:27  prashant
4006           * 100 Devices support- only association tested, memory adjustments
4007           *
4008           * Revision 1.24  2014/06/19 17:13:19  ranjan
4009           * -uppermac fixes for lvnet and reset command for cco and sta mode
4010           * -backup cco working
4011           *
4012           * Revision 1.23  2014/06/19 07:16:02  prashant
4013           * Region fix, frequency setting fix
4014           *
4015           * Revision 1.22  2014/06/13 14:55:11  ranjan
4016           * -fixing memory issue due to previous checkin
4017           *
4018           * Revision 1.21  2014/06/12 13:15:44  ranjan
4019           * -separated bcn,mgmt,um event pools
4020           * -fixed datapath issue due to previous checkin
4021           * -work in progress. neighbour cco detection
4022           *
4023           * Revision 1.20  2014/06/11 15:08:28  tri
4024           * took out debug printf
4025           *
4026           * Revision 1.19  2014/06/11 13:17:47  kiran
4027           * UART as host interface and peripheral interface supported.
4028           *
4029           * Revision 1.18  2014/06/05 10:26:07  prashant
4030           * Host Interface selection isue fix, Ac sync issue fix
4031           *
4032           * Revision 1.17  2014/06/05 08:38:41  ranjan
4033           * -flash function enabled for uppermac
4034           * - commit command after any change would flash systemprofiles
4035           * - verfied upper mac
4036           *
4037           * Revision 1.16  2014/05/28 10:58:59  prashant
4038           * SDK folder structure changes, Uart changes, removed htm (UI) task
4039           * Varified - UM, LM - iperf (UDP/TCP), overnight test pass
4040           *
4041           * Revision 1.15  2014/05/21 23:02:09  tri
4042           * more PS
4043           *
4044           * Revision 1.14  2014/05/20 05:57:45  prashant
4045           * persistent schedule code updated
4046           *
4047           * Revision 1.13  2014/05/13 20:05:46  tri
4048           * more PS
4049           *
4050           * Revision 1.12  2014/05/12 08:09:57  prashant
4051           * Route fix, STA sync issue with AV CCO and handling discover bcn issue fix
4052           *
4053           * Revision 1.11  2014/04/24 21:51:07  yiming
4054           * Working Code for Mitsumi
4055           *
4056           * Revision 1.10  2014/04/09 21:10:07  tri
4057           * more PS
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 67  

4058           *
4059           * Revision 1.9  2014/03/20 23:20:46  tri
4060           * more PS
4061           *
4062           * Revision 1.8  2014/03/12 09:41:22  ranjan
4063           * 1. added ageout event to cco cnam,backupcco ageout handling
4064           * 2.  fix linking issue in zb_lx51_asic due to backup cco checkin
4065           *
4066           * Revision 1.7  2014/03/10 05:58:10  ranjan
4067           * 1. added HomePlug BackupCCo feature. verified C&I test.(passed.) (bug 176)
4068           *
4069           * Revision 1.6  2014/02/27 10:42:47  prashant
4070           * Routing code added
4071           *
4072           * Revision 1.5  2014/02/26 23:16:02  tri
4073           * more PS code
4074           *
4075           * Revision 1.4  2014/02/19 10:22:41  ranjan
4076           * - common sync for hal_tst and upper mac project
4077           * - ism.c is MAC interrupt handler for hhal_tst and upper mac.
4078           *    chal_ext1isr function   is removed
4079           * - verified : lower mac sync, upper mac sync data traffic.
4080           *
4081           * Revision 1.3  2014/01/28 17:45:15  tri
4082           * Added Power Save code
4083           *
4084           * Revision 1.2  2014/01/10 17:17:53  yiming
4085           * check in Rajan 1/8/2014 code release
4086           *
4087           * Revision 1.5  2014/01/08 10:53:54  ranjan
4088           * Changes for LM OS support.
4089           * New Datapath FrameTask
4090           * LM and UM  datapath, feature verified.
4091           *
4092           * known issues : performance numbers needs revisit
4093           *
4094           * review : pending.
4095           *
4096           * Revision 1.4  2013/09/04 14:51:01  yiming
4097           * New changes for Hybrii_A code merge
4098           *
4099           * Revision 1.7  2013/07/12 08:56:36  ranjan
4100           * -UKE Push Button Security Feature.
4101           * Verified : DirectEntry Security Works.Datapath Works.
4102           *                 command SetSecMode for UKE works.
4103           * Added against bug-160
4104           *
4105           * Revision 1.6  2013/04/17 13:00:59  ranjan
4106           * Added FW ready event, Removed hybrii header from datapath, Modified hybrii header
4107           *  formate
4108           *
4109           * Revision 1.5  2013/03/26 12:07:26  ranjan
4110           * -added  host sw reset command
4111           * - fixed issue in bcn update
4112           *
4113           * Revision 1.4  2013/03/22 12:21:49  prashant
4114           * default FM_MASK and FM_Printf modified for USER INFO
4115           *
4116           * Revision 1.3  2013/03/14 11:49:18  ranjan
4117           * 1.handled cases  for CCo toSTA switch and  viceversa
4118           * 2.UM uses bcntemplate
4119           *
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 68  

4120           * Revision 1.2  2013/02/15 12:53:57  prashant
4121           * ASSOC.REQ changes for DEVELO
4122           *
4123           * Revision 1.1  2012/09/05 00:13:08  mark
4124           * separate nsm.c into nsm_cco.c and nsm_sta.c,  reason is nsm.c can't be put into bank
4125           *
4126           * Revision 1.40  2012/08/25 15:12:01  yuanhua
4127           * correct the csma region setting in SNSM when a persistent schedule is received
4128           *
4129           * Revision 1.39  2012/08/25 05:49:15  yuanhua
4130           * fix a potential overwriting of region array in SNSM when receive a beacon.
4131           *
4132           * Revision 1.38  2012/08/24 04:40:12  yuanhua
4133           * set initial regions in CNSM for CCO
4134           *
4135           * Revision 1.37  2012/08/23 04:06:52  yuanhua
4136           * made a fix in SNSM for persistent schedule process
4137           *
4138           * Revision 1.36  2012/08/20 04:57:35  yuanhua
4139           * modify the region entry and add persistent schedule entry for beacon
4140           *
4141           * Revision 1.35  2012/08/03 04:03:23  kripa
4142           * *** empty log message ***
4143           *
4144           * Revision 1.34  2012/08/01 04:56:02  kripa
4145           * Fixed the variable reuse within BuildBeacon regions Bentry, that was causing bcn corruption.
4146           * Committed on the Free edition of March Hare Software CVSNT Client.
4147           * Upgrade to CVS Suite for more features and support:
4148           * http://march-hare.com/cvsnt/
4149           *
4150           * Revision 1.33  2012/07/31 14:53:34  kripa
4151           * Initilalizing snsm->hoSwitch = HPGP_HO_SWITCH_NONE ; it fixes a bug that causes STA to begin a Handover
             - process, soon afer initial sync.
4152           *
4153           * Revision 1.32  2012/07/30 04:37:55  yuanhua
4154           * fixed an issue that an event memory could be overwritten in the HAL when the HAL receives a mgmt messag
             -e.
4155           *
4156           * Revision 1.31  2012/07/15 17:31:07  yuanhua
4157           * (1)fixed a potential memory overwriting in MUXL (2)update prints for 8051.
4158           *
4159           * Revision 1.30  2012/07/12 05:47:34  kripa
4160           * Commenting out Disc Bcn dump, as this could interfere with sync.
4161           * Committed on the Free edition of March Hare Software CVSNT Client.
4162           * Upgrade to CVS Suite for more features and support:
4163           * http://march-hare.com/cvsnt/
4164           *
4165           * Revision 1.29  2012/07/08 18:42:20  yuanhua
4166           * (1)fixed some issues when ctrl layer changes its state from the UCC to ACC. (2) added a event CNSM_STAR
             -T.
4167           *
4168           * Revision 1.28  2012/06/30 19:53:58  kripa
4169           * Commenting out Schedule Bentrys enoding & parsing temporarily.
4170           * Committed on the Free edition of March Hare Software CVSNT Client.
4171           * Upgrade to CVS Suite for more features and support:
4172           * http://march-hare.com/cvsnt/
4173           *
4174           * Revision 1.27  2012/06/30 19:47:39  kripa
4175           * Commenting out Schedule Bentry encoding+parsing temporarily.
4176           * Committed on the Free edition of March Hare Software CVSNT Client.
4177           * Upgrade to CVS Suite for more features and support:
4178           * http://march-hare.com/cvsnt/
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 69  

4179           *
4180           * Revision 1.26  2012/06/29 03:05:31  kripa
4181           * Commenting out SetCsmaRegions() call temporarily until it has been tested.
4182           * Passing Linemode argument to setDevMode call.
4183           * Committed on the Free edition of March Hare Software CVSNT Client.
4184           * Upgrade to CVS Suite for more features and support:
4185           * http://march-hare.com/cvsnt/
4186           *
4187           * Revision 1.25  2012/06/27 04:28:18  yuanhua
4188           * added region entry in the beacon.
4189           *
4190           * Revision 1.24  2012/06/20 17:57:05  kripa
4191           * Multiple changes to fix bcn sync. May need review later.
4192           * Committed on the Free edition of March Hare Software CVSNT Client.
4193           * Upgrade to CVS Suite for more features and support:
4194           * http://march-hare.com/cvsnt/
4195           *
4196           * Revision 1.23  2012/06/15 04:35:21  yuanhua
4197           * add a STA type of passive unassoc STA. With this STA type, the device acts as a STA during the network 
             -discovery. It performs the network scan for beacons from the CCO, but does not transmit the UNASSOC_STA.IND and does not
             - involve in the CCO selection process. Thus, it joins the existing network.
4198           *
4199           * Revision 1.22  2012/06/14 06:51:50  yuanhua
4200           * still keep discovery aging timer to run after the CCO is found.
4201           *
4202           * Revision 1.21  2012/06/14 06:45:06  yuanhua
4203           * stop the periodic timers after the STA finds the CCo during the network discovery, as no need to transm
             -it an unassociated_sta.ind if the CCO is detected.
4204           *
4205           * Revision 1.20  2012/06/14 06:14:47  yuanhua
4206           * (1) remove the net scan when the device is set to the CCO mode(2) start the net scan when the CCO is fo
             -und, but the STA is not sync with CCO yet.
4207           *
4208           * Revision 1.19  2012/06/13 16:10:06  son
4209           * Commenting out ScanNet() call in Network Discovery state - so that unassocSta.Ind messages can be sent.
4210           * Committed on the Free edition of March Hare Software CVSNT Client.
4211           * Upgrade to CVS Suite for more features and support:
4212           * http://march-hare.com/cvsnt/
4213           *
4214           * Revision 1.18  2012/06/13 06:24:31  yuanhua
4215           * add code for tx bcn interrupt handler integration and data structures for region entry schedule. But th
             -ey are not in execution yet.
4216           *
4217           * Revision 1.17  2012/06/11 14:49:59  yuanhua
4218           * changed the HAL back to the STA mode after finding the CCo during the network discovery so that the CTR
             -LL issues an association request in the HAL STA mode.
4219           *
4220           * Revision 1.16  2012/06/11 06:29:01  yuanhua
4221           * changed HAL_SetBpsto to HAL_SyncNet.
4222           *
4223           * Revision 1.15  2012/06/08 05:50:57  yuanhua
4224           * added snid function.
4225           *
4226           * Revision 1.14  2012/06/05 22:37:12  son
4227           * UART console does not get initialized due to task ID changed
4228           *
4229           * Revision 1.13  2012/06/05 07:25:59  yuanhua
4230           * (1) add a scan call to the MAC during the network discovery. (2) add a tiny task in ISM for interrupt p
             -olling (3) modify the frame receiving integration. (4) modify the tiny task in STM.
4231           *
4232           * Revision 1.12  2012/06/04 23:34:02  son
4233           * Added RTX51 OS support
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 70  

4234           *
4235           * Revision 1.11  2012/05/19 20:32:17  yuanhua
4236           * added non-callback option for the protocol stack.
4237           *
4238           * Revision 1.10  2012/05/19 05:05:15  yuanhua
4239           * optimized the timer handlers in CTRL and LINK layers.
4240           *
4241           * Revision 1.9  2012/05/17 05:05:58  yuanhua
4242           * (1) added the option for timer w/o callback (2) added task id and name.
4243           *
4244           * Revision 1.8  2012/05/01 04:51:09  yuanhua
4245           * added compiler flags STA_FUNC and CCO_FUNC in link and ctrl layers.
4246           *
4247           * Revision 1.7  2012/05/01 00:18:47  son
4248           * Added _CCO_FUNC_ and _STA_FUNC_ compiler flags
4249           *
4250           * Revision 1.6  2012/04/30 04:05:57  yuanhua
4251           * (1) integrated the HAL mgmt Tx. (2) various updates
4252           *
4253           * Revision 1.5  2012/04/20 01:39:33  yuanhua
4254           * integrated uart module and added compiler flag NMA.
4255           *
4256           * Revision 1.4  2012/04/13 06:15:11  yuanhua
4257           * integrate the HPGP protocol stack with the HAL for the beacon TX/RX and mgmt msg RX.
4258           *
4259           * Revision 1.3  2012/03/11 17:02:25  yuanhua
4260           * (1) added NEK auth in AKM (2) added NMA (3) modified hpgp layer data structures (4) added Makefile for 
             -linux simulation
4261           *
4262           * Revision 1.2  2011/09/09 07:02:31  yuanhua
4263           * migrate the firmware code from the greenchip to the hybrii.
4264           *
4265           * Revision 1.12  2011/09/06 05:01:46  yuanhua
4266           * Made a fix such that the STA continues periodic TEI renew after CCo handover.
4267           *
4268           * Revision 1.11  2011/08/12 23:13:22  yuanhua
4269           * (1)Added Control Layer (2) Fixed bugs for user-selected CCo handover (3) Made changes to SNAM/CNAM and 
             -SNSM/CNSM for CCo handover switch (from CCo to STA, from STA to CCo, and from STA to STA but with different CCo) and pos
             -t CCo handover
4270           *
4271           * Revision 1.10  2011/08/09 22:45:44  yuanhua
4272           * changed to event structure, seperating HPGP-related events from the general event defination so that th
             -e general event could be used for other purposes than the HPGP.
4273           *
4274           * Revision 1.9  2011/08/08 22:05:41  yuanhua
4275           * user-selected CCo handover fix
4276           *
4277           * Revision 1.8  2011/08/05 17:06:29  yuanhua
4278           * (1) added an internal queue in Link Layer for communication btw modules within Link Layer (2) Fixed bug
             -s in CCo Handover. Now, CCo handover could be triggered by auto CCo selection, CCo handover messages work fine (3) Made 
             -some modifications in SHAL.
4279           *
4280           * Revision 1.7  2011/08/02 16:06:00  yuanhua
4281           * (1) Fixed a bug in STM (2) Made STA discovery work according to the standard, including aging timer. (3
             -) release the resource after the STA leave (4) STA will switch to the backup CCo if the CCo failure occurs (5) At this p
             -oint, the CCo could work with multiple STAs correctly, including CCo association/leave, TEI renew, TEI map updating, dis
             -covery beacon scheduling, discovery STA list updating ang aging, CCo failure, etc.
4282           *
4283           * Revision 1.6  2011/07/30 02:43:35  yuanhua
4284           * (1) Split the beacon process into two parts: one requiring an immdiate response, the other tolerating t
             -he delay (2) Changed the API btw the MUX and SHAL for packet reception (3) Fixed bugs in various modules. Now, multiple 
             -STAs could successfully associate/leave the CCo
C51 COMPILER V9.53.0.0   NSM_CCO                                                           11/04/2015 20:09:46 PAGE 71  

4285           *
4286           * Revision 1.5  2011/07/22 18:51:05  yuanhua
4287           * (1) added the hardware timer tick simulation (hts.h/hts.c) (2) Added semaphors for sync in simulation a
             -nd defined macro for critical section (3) Fixed some bugs in list.h and CRM (4) Modified and fixed bugs in SHAL (5) Chan
             -ged SNSM/CNSM and SNAM/CNAM for bug fix (6) Added debugging prints, and more.
4288           *
4289           * Revision 1.4  2011/07/16 17:11:23  yuanhua
4290           * (1)Implemented SHOM and CHOM modules, including handover procedure, SCB resource updating for HO (2) Up
             -date SNAM and CNAM modules to support uer-appointed CCo handover (3) Made the SCB resources to support the TEI MAP for t
             -he STA mode and management of associated STA resources (e.g. TEI) (4) Modified SNSM and CNSM to perform all types of han
             -dover switch (CCo handover to the new STA, STA taking over the CCo, STA switching to the new CCo)
4291           *
4292           * Revision 1.3  2011/07/08 22:23:48  yuanhua
4293           * (1) Implemented CNSM, including its state machine, beacon transmission and process, discover beacon sch
             -eduling, auto CCo selection, discover list, handover countdown, etc. (2) Updated SNSM, including discover list processin
             -g, triggering a switch to the new CCo, etc. (3) Updated CNAM and SNAM, adding the connection state in the SNAM, switch t
             -o the new CCo, etc. (4) Other updates
4294           *
4295           * Revision 1.2  2011/06/24 14:33:18  yuanhua
4296           * (1) Changed event structure (2) Implemented SNSM, including the state machines in network discovery and
             - connection states, becaon process, discover process, and handover detection (3) Integrated the HPGP and SHAL
4297           *
4298           * Revision 1.1  2011/05/28 06:31:19  kripa
4299           * Combining corresponding STA and CCo modules.
4300           *
4301           * Revision 1.1  2011/05/06 19:10:12  kripa
4302           * Adding link layer files to new source tree.
4303           *
4304           * Revision 1.3  2011/04/23 19:48:45  kripa
4305           * Fixing stm.h and event.h inclusion, using relative paths to avoid conflict with windows system header f
             -iles.
4306           *
4307           * Revision 1.2  2011/04/23 17:35:36  kripa
4308           * Used relative path for inclusion of stm.h, to avoid conflict with a system header file in VC.
4309           *
4310           * Revision 1.1  2011/04/08 21:42:45  yuanhua
4311           * Framework
4312           *
4313           *
4314           * =========================================================*/
4315          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16853    ----
   CONSTANT SIZE    =    558    ----
   XDATA SIZE       =     50     630
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
