/**
 * @file mac_associate.c
 *
 * Implements the functionality required for Association.
 *
 * $Id: mac_associate.c,v 1.4 2014/06/09 13:19:46 kiran Exp $
 *
 * Copyright (c) 2011, Greenvity Communication All rights reserved.
 *
 */

/* === Includes ============================================================= */

#include <string.h>
#include "papdef.h"
#include "return_val.h"
#include "bmm.h"
#include "qmm.h"
#include "mac_msgs.h"
#include "mac_hal.h"
#include "mac_const.h"
#include "mac_api.h"
#include "mac_data_structures.h"
#include "mac_internal.h"
#include "mac.h"
#include "mac_security.h"
#include "utils.h"
#include "timer.h"
#include "stm.h"

/* === Macros =============================================================== */

/* Payload length of association request frame. */
#define ASSOC_REQ_PAYLOAD_LEN           (2)

/* Payload length of association response frame. */
#define ASSOC_RESP_PAYLOAD_LEN          (4)

/* === Globals ============================================================== */

/* === Prototypes =========================================================== */


/* === Implementation ======================================================= */

/*
 *
 * This function creates and appends a MLME associate confirm message
 * into the  internal event queue.
 *
 * buf_ptr          - Buffer for sending MLME associate confirm message to NHLE
 * status           - Status of association
 * assoc_short_addr - Allocated short address
 */
void mac_gen_mlme_associate_conf (buffer_t *buf_p,
                                  uint8_t  status,
                                  uint16_t assoc_short_addr)
{
    /* Reuse the associate request buffer for associate confirm. */
    mlme_associate_conf_t *assoc_conf_p = (mlme_associate_conf_t *)
                                          BMM_BUFFER_POINTER(buf_p);

    assoc_conf_p->cmdcode = MLME_ASSOCIATE_CONFIRM;
    assoc_conf_p->status = status;
    assoc_conf_p->AssocShortAddress = assoc_short_addr;

    mlme_associate_conf(buf_p);
}

/*
 * Handle Poll Waiting timer while waiting for the association reponse frame
 *
 * callback_parameter Callback parameter
 */
void mac_assocresponsetime_cb (void *callback_parameter)
{
    uint16_t panid;
    /*
     * Association response is not received within time, hence generate
     * mlme association confirm with MAC_NO_DATA using the buffer stored in
     * mac_conf_buf_ptr.
     */
    mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
                                MAC_NO_DATA,
                                BROADCAST);

    /* Restore the mac poll state in case of association failure. */
    mac_poll_state = MAC_POLL_IDLE;

    /* Set the default parameters. */
    panid = macPANId_def;
    set_hal_pib_internal(macPANId, (void *)&panid);

    mac_pib_macCoordShortAddress = macCoordShortAddress_def;
    mac_pib_macCoordExtendedAddress.lo_u32 = 0;
    mac_pib_macCoordExtendedAddress.hi_u32 = 0;

    /* Set radio to sleep if allowed */
    mac_trx_sleep();

    callback_parameter = callback_parameter;
}

/**
 * The MLME associate request primitive is generated by the next higher layer
 * of an unassociated device and issued to its MAC to request an association
 * with a coordinator.
 *
 * buf_p Pointer to MLME association request parameters
 */
void mlme_associate_request (buffer_t *buf_p)
{
    mlme_associate_req_t mar;
    retval_t             status, status_2;
    uint8_t              frame_len = 0;
    uint8_t              *frame_ptr;
    uint8_t              *temp_frame_ptr;
    uint16_t             fcf = 0;
    uint16_t             bc_addr = BROADCAST;
    frame_info_t         *assoc_req_frame_p;
    bool                 encrypt = FALSE;
    wpan_addr_spec_t     dst_addr_spec;

    memcpy(&mar, BMM_BUFFER_POINTER(buf_p), sizeof(mlme_associate_req_t));

    /*
     * Store the buffer which was received from the NHLE as it will be reused
     * while sending MLME association confirmation to the NHLE.
     */
    mac_conf_buf_ptr = (uint8_t *)buf_p;

    if ((FCF_SHORT_ADDR != mar.CoordAddrMode) &&
        (FCF_LONG_ADDR != mar.CoordAddrMode)) {
        mac_gen_mlme_associate_conf(buf_p,
                                    MAC_INVALID_PARAMETER,
                                    INVALID_SHORT_ADDRESS);

        return;
    }
    
    dst_addr_spec.AddrMode = mar.CoordAddrMode;
            
    if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
        ADDR_COPY_DST_SRC_16(mac_pib_macCoordShortAddress,
                             mar.CoordAddress.short_address);
        dst_addr_spec.Addr.short_address = mar.CoordAddress.short_address;
    } else {
        dst_addr_spec.Addr.long_address =mar.CoordAddress.long_address;
        ADDR_COPY_DST_SRC_64(mac_pib_macCoordExtendedAddress,
                             mar.CoordAddress.long_address);
        /*
         * Since the coordinator used its extended address, we need to mark
         * this also in its short address.
         */
        mac_pib_macCoordShortAddress = MAC_NO_SHORT_ADDR_VALUE;
    }

    /* Set the PAN ID. */
    set_hal_pib_internal(macPANId, (void *)&mar.CoordPANId);

    mac_trx_wakeup();

    /* Build the Association Request command frame. */

    assoc_req_frame_p = (frame_info_t *)(BMM_BUFFER_POINTER(buf_p));

    assoc_req_frame_p->msg_type = ASSOCIATIONREQUEST;
    assoc_req_frame_p->buffer_header_p = buf_p;


    /* Get the payload pointer. */
    frame_ptr = temp_frame_ptr =
                (uint8_t *)assoc_req_frame_p +
                BUFFER_SIZE -
                ASSOC_REQ_PAYLOAD_LEN;

    /* Update the payload field. */
    *frame_ptr++ = ASSOCIATIONREQUEST;
    /* Build the capability info. */
    *frame_ptr = mar.CapabilityInformation;

    /* Get the payload pointer again to add the MHR. */
    frame_ptr = temp_frame_ptr;

    if (mar.Security.SecurityLevel > 0) {
        if (mac_pib_macSecurityEnabled == TRUE) {
            retval_t build_sec;

            build_sec = mac_build_aux_sec_header(&frame_ptr, &mar.Security,
                                                 &frame_len);
            if (MAC_SUCCESS != build_sec) {
                mac_gen_mlme_associate_conf(buf_p,
                                            MAC_SECURITY_ERROR,
                                            INVALID_SHORT_ADDRESS);
                /* Set radio to sleep if allowed */
                mac_trx_sleep();
                return; 
            }
            fcf = FCF_SECURITY_ENABLED | FCF_FRAME_VERSION_2006;
            encrypt = TRUE;
        } else {
            mac_gen_mlme_associate_conf(buf_p,
                                        MAC_UNSUPPORTED_SECURITY,
                                        INVALID_SHORT_ADDRESS);
            /* Set radio to sleep if allowed */
            mac_trx_sleep();
            return; 
        }
    }

    /* Update the length. */
    frame_len += ASSOC_REQ_PAYLOAD_LEN +
                 PAN_ID_LEN            +     // Destination PAN-Id
                 PAN_ID_LEN            +     // Source PAN-Id
                 EXT_ADDR_LEN          +     // long Source Address
                 SEQ_NUM_LEN           +     // Sequence number
                 FCF_LEN;             // FCF

    /* Source address */
    frame_ptr -= EXT_ADDR_LEN;
    mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);

    /* Source PAN-Id is broadcast PAN ID */
    frame_ptr -= PAN_ID_LEN;
    mac_utils_16_bit_to_byte_array(bc_addr, frame_ptr);

    /* Destination address */
    if (FCF_SHORT_ADDR == mar.CoordAddrMode) {
        frame_ptr -= SHORT_ADDR_LEN;
        frame_len += SHORT_ADDR_LEN;
        mac_utils_16_bit_to_byte_array(mac_pib_macCoordShortAddress, frame_ptr);

        fcf |= FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD)                  |
                                 FCF_SET_DEST_ADDR_MODE(FCF_SHORT_ADDR)  |
                                 FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
                                 FCF_ACK_REQUEST;
    } else {
        frame_ptr -= EXT_ADDR_LEN;
        frame_len += EXT_ADDR_LEN;
        mac_utils_64_bit_to_byte_array(mac_pib_macCoordExtendedAddress,
                                       frame_ptr);

        fcf |= FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD)                  |
                                 FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR)   |
                                 FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR) |
                                 FCF_ACK_REQUEST;
    }

    /* Destination PAN-Id */
    frame_ptr -= PAN_ID_LEN;
    mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);
    dst_addr_spec.PANId = hal_pib_PANId;

    /* Set DSN. */
    frame_ptr -= SEQ_NUM_LEN;
    *frame_ptr = mac_pib_macDSN++;


    /* Set the FCF. */
    frame_ptr -= FCF_LEN;
    mac_utils_16_bit_to_byte_array(fcf, frame_ptr);


    /* First element shall be length of PHY frame. */
    frame_ptr -= LENGTH_FIELD_LEN;
    *frame_ptr = frame_len;

    /* Finished building of frame. */
    assoc_req_frame_p->mpdu_p = frame_ptr;

    /* Set the channel page passed by the request. */
    status = set_hal_pib_internal(phyCurrentPage,
                                  (void *)&(mar.ChannelPage));

    /* Set the channel passed by the request. */
    status_2 = set_hal_pib_internal(phyCurrentChannel,
                                    (void *)&(mar.LogicalChannel));

    if ((MAC_SUCCESS == status) && (MAC_SUCCESS == status_2)) {
        tx_mode_t tx_mode;

        if (TRUE == encrypt) {
            status = mac_secure(&mar.Security, &dst_addr_spec);
            if (MAC_SUCCESS != status) {
                mac_gen_mlme_associate_conf(buf_p,
                                            MAC_SECURITY_ERROR,
                                            INVALID_SHORT_ADDRESS);
                /* Set radio to sleep if allowed */
                mac_trx_sleep();
                return; 
            }
        }
		/*
         * In Beacon network the association request frame is sent with
         * slotted CSMA-CA if the node is synced before assocaition.
         * In all other cases the frame is transmitted using unslotted
         * CSMA-CA.
         */


        if (MAC_SYNC_BEFORE_ASSOC == mac_sync_state) {
            tx_mode = CSMA_SLOTTED;
        } else {
            tx_mode = CSMA_UNSLOTTED;
        }

        status = mac_hal_tx_frame(assoc_req_frame_p, tx_mode, encrypt);

        if (MAC_SUCCESS == status) {
            MAC_BUSY();
        } else {
            mac_gen_mlme_associate_conf(buf_p,
                                        MAC_CHANNEL_ACCESS_FAILURE,
                                        INVALID_SHORT_ADDRESS);

            /* Set radio to sleep if allowed */
            mac_trx_sleep();
        }
    } else {
        mac_gen_mlme_associate_conf(buf_p,
                                    MAC_CHANNEL_ACCESS_FAILURE,
                                    INVALID_SHORT_ADDRESS);

        /* Set radio to sleep if allowed */
        mac_trx_sleep();
    }
}

/**
 *
 * This function will process a received association request command frame and
 * generates a MLME associate indication to the NHLE.
 *
 * assoc_req_p - pointer to the received association request frame
 */
void mac_process_associate_request (buffer_t *assoc_req_p)
{
    /* Use the frame reception buffer for association indication. */
    mlme_associate_ind_t *mai_p = (mlme_associate_ind_t *)
                                  BMM_BUFFER_POINTER(assoc_req_p);

    /*
     * If the coordinator has macAssociationPermit set to false, and receives an
     * association request command from a device, the command shall be ignored.
     */
    if (FALSE == mac_pib_macAssociationPermit) {
        bmm_buffer_free(assoc_req_p);
        return;
    }

    /* Build the MLME association indication parameters. */
    ADDR_COPY_DST_SRC_64(mai_p->DeviceAddress,
                         mac_parse_data.src_addr.long_address);
    mai_p->CapabilityInformation = 
                mac_parse_data.mac_payload_data.assoc_req_data.capability_info;
    mai_p->cmdcode = MLME_ASSOCIATE_INDICATION;

    mlme_associate_ind(assoc_req_p);
}

/**
 * Entry point from the stack for MLME associate response
 *
 * The MLME associate response primitive is used to initiate a response to a
 * MLME association indication primitive.
 *
 * buf_p - Pointer to association response parameters
 */
void mlme_associate_response (buffer_t *buf_p)
{
    uint8_t frame_len;
    uint8_t *frame_ptr;
    uint8_t *temp_frame_ptr;
    uint16_t fcf;
    frame_info_t *assoc_resp_frame_p;

    mlme_associate_resp_t mar;
    memcpy(&mar, BMM_BUFFER_POINTER(buf_p), sizeof(mlme_associate_resp_t));

    assoc_resp_frame_p = (frame_info_t *)BMM_BUFFER_POINTER(buf_p);

    /*
     * A MLME associate response can only be processed
     * in the MAC_PAN_COORD_STARTED or MAC_COORDINATOR state.
     */
    if ((MAC_PAN_COORD_STARTED != mac_state) &&
        (MAC_COORDINATOR != mac_state)) {
        bmm_buffer_free(buf_p);
        return;
    }


    /* Build the Association Response frame. */
    assoc_resp_frame_p->msg_type = ASSOCIATIONRESPONSE;


    /* Get the payload pointer. */
    frame_ptr = temp_frame_ptr =
                (uint8_t *)assoc_resp_frame_p +
                BUFFER_SIZE -
                ASSOC_RESP_PAYLOAD_LEN;

    /* Update the payload field. */
    *frame_ptr++ = ASSOCIATIONRESPONSE;

    /* Add the short address allocated for the device. */
    mac_utils_16_bit_to_byte_array(mar.AssocShortAddress, frame_ptr);
    frame_ptr += SHORT_ADDR_LEN;

    /* Build the association status. */
    *frame_ptr = mar.status;

    /* Get the payload pointer again to add the MHR. */
    frame_ptr = temp_frame_ptr;


    /* Update the length. */
    frame_len = ASSOC_RESP_PAYLOAD_LEN +
                PAN_ID_LEN             + // Destination PAN-Id
                EXT_ADDR_LEN           + // long Destination Address
                EXT_ADDR_LEN           + // long Source Address
                SEQ_NUM_LEN            +
                FCF_LEN;

    /* Source address */
    frame_ptr -= EXT_ADDR_LEN;
    mac_utils_64_bit_to_byte_array(hal_pib_IeeeAddress, frame_ptr);


    /* Build the Destination address. */
    frame_ptr -= EXT_ADDR_LEN;
    mac_utils_64_bit_to_byte_array(mar.DeviceAddress, frame_ptr);


    /* Build the Destination PAN ID. */
    frame_ptr -= PAN_ID_LEN;
    mac_utils_16_bit_to_byte_array(hal_pib_PANId, frame_ptr);


    /* Set DSN. */
    frame_ptr -= SEQ_NUM_LEN;
    *frame_ptr = mac_pib_macDSN++;


    /* Set the FCF. */
    /* Create the frame control field. */
    fcf = FCF_SET_FRAMETYPE(FCF_FRAMETYPE_MAC_CMD) |
          FCF_SET_DEST_ADDR_MODE(FCF_LONG_ADDR)    |
          FCF_SET_SOURCE_ADDR_MODE(FCF_LONG_ADDR)  |
          FCF_PAN_ID_COMPRESSION                   |
          FCF_ACK_REQUEST;
    frame_ptr -= FCF_LEN;
    mac_utils_16_bit_to_byte_array(fcf, frame_ptr);


    /* First element shall be length of PHY frame. */
    frame_ptr -= LENGTH_FIELD_LEN;
    *frame_ptr = frame_len;

    /* Finished building of frame. */
    assoc_resp_frame_p->mpdu_p = frame_ptr;

    /* Indirect transmission not ongoing yet. */
    assoc_resp_frame_p->indirect_in_transit = false;

    /* Append the association response into indirect queue. */
    if (FALSE == qmm_queue_append(&indirect_data_q, buf_p)) {
        /*
         * Indirect queue reached the maximum size allowed.
         * Send the comm status indication with MAC transaction overflow.
         */
        mac_mlme_comm_status(MAC_TRANSACTION_OVERFLOW, buf_p);

        return;
    }
    /*
     * If an FFD does have pending data,
     * the MAC persistence timer needs to be started.
     */
    assoc_resp_frame_p->persistence_time = 
                                       mac_pib_macTransactionPersistenceTime;
    mac_start_persistence_timer();
}

/**
 *
 * This function processes the received association response
 * command frame.
 *
 * assoc_resp_p - Pointer to  Association response
 */
void mac_process_associate_response (buffer_t *assoc_resp_p)
{
    uint16_t panid;
    uint16_t short_addr;
    uint8_t  status;

    status = mac_parse_data.mac_payload_data.assoc_response_data.assoc_status;

    /* Free the buffer received for association response frame. */
    bmm_buffer_free(assoc_resp_p);

    if (ASSOCIATION_SUCCESSFUL == status) {
        /* Set the short address received in association response frame. */
        set_hal_pib_internal(macShortAddress,
                             (void *)&(mac_parse_data.\
                             mac_payload_data.assoc_response_data.short_addr));

        short_addr = mac_parse_data.\
                     mac_payload_data.assoc_response_data.short_addr;

        ADDR_COPY_DST_SRC_64(mac_pib_macCoordExtendedAddress,
                             mac_parse_data.src_addr.long_address);

        /* Node is properly associated now */
        mac_state = MAC_ASSOCIATED;
        mac_poll_state = MAC_POLL_IDLE;

        if (MAC_SYNC_BEFORE_ASSOC == mac_sync_state) {
            mac_sync_state = MAC_SYNC_TRACKING_BEACON;
        }
    } else {
        /* Restore the default values. */
        mac_poll_state = MAC_POLL_IDLE;

        panid = macPANId_def;

        set_hal_pib_internal(macPANId, (void *)&panid);

        mac_pib_macCoordShortAddress = macCoordShortAddress_def;
        mac_pib_macCoordExtendedAddress.hi_u32 = 0;
        mac_pib_macCoordExtendedAddress.lo_u32 = 0;

        short_addr = INVALID_SHORT_ADDRESS;
    }

    /*
     * The MLME association request buffer is stored in mac_conf_buf_ptr,
     * which is reused to generate MLME association confirmation.
     */
    mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
                                status,
                                short_addr);

    /* Set radio to sleep if allowed */
    mac_trx_sleep();
}

/**
 * Handle T_Poll_Wait_Time timer after successful transmission of an
 * association request frame and before sending out the subsequent
 * data request frame.
 *
 * callback_parameter Callback parameter.
 */
void mac_response_wait_cb (void *callback_parameter)
{
    uint32_t response_time;
    bool     status;

    /*
     * IEEE 802.15.4-2006 page 154:
     *
     * If the data request command is being sent following the acknowledgment
     * to an association request command frame, the Destination Addressing Mode
     * subfield of the Frame Control field shall be set according to the
     * coordinator to which the data request command is directed.
     * If macCoordShortAddress is equal to 0xfffe, extended addressing
     * shall be used. Short addressing shall be used otherwise.
     * The Source Addressing Mode subfield shall be set to use
     * extended addressing.
     */
    /*
     * No explicit destination address attached, so use current values of
     * PIB attributes macCoordShortAddress or macCoordExtendedAddress.
     */
    status = mac_data_build_and_tx_data_req(false, true, 0, NULL, 0);

    if (!status) {
        /*
         * Data request could not be transmitted, hence association confirmation
         * is generated using the buffer stored in mac_conf_buf_ptr.
         */
        mac_gen_mlme_associate_conf((buffer_t *)mac_conf_buf_ptr,
                                    MAC_CHANNEL_ACCESS_FAILURE,
                                    INVALID_SHORT_ADDRESS);
        return;
    }

    response_time = 
        HAL_CONVERT_SYMBOLS_TO_US(mac_pib_macResponseWaitTime) / 1000;

    if (STATUS_SUCCESS != 
        STM_StartTimer(mac_asso_rsp_wait_timer, response_time)) {
        /* Timer could not be started. */
        mac_assocresponsetime_cb(NULL);
    }

    callback_parameter = callback_parameter;
}


